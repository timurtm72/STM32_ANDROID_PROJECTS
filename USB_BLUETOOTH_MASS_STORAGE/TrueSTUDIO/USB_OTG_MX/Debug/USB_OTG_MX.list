
D:\ALL_PROJECTS\BLUETOOTH_ANDROID_STM32\USB MASS STORAGE PROJ\USB_OTG_MX\TrueSTUDIO\USB_OTG_MX\Debug\USB_OTG_MX.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000068fc  08000188  08000188  00010188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000070c  08006a84  08006a84  00016a84  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08007190  08007190  00017190  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08007194  08007194  00017194  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000168  20000000  08007198  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  00020168  2**0
                  CONTENTS
  7 .bss          00001ac0  20000168  20000168  00020168  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  20001c28  20001c28  00020168  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020168  2**0
                  CONTENTS, READONLY
 10 .debug_line   00009321  00000000  00000000  00020198  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0001d789  00000000  00000000  000294b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00004cf8  00000000  00000000  00046c42  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00001090  00000000  00000000  0004b940  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001458  00000000  00000000  0004c9d0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f2ca  00000000  00000000  0004de28  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000058d6  00000000  00000000  0005d0f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007e  00000000  00000000  000629c8  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00002e80  00000000  00000000  00062a48  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	; (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b113      	cbz	r3, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2301      	movs	r3, #1
 800019c:	7023      	strb	r3, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	20000168 	.word	0x20000168
 80001a4:	00000000 	.word	0x00000000
 80001a8:	08006a6c 	.word	0x08006a6c

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b03      	ldr	r3, [pc, #12]	; (80001bc <frame_dummy+0x10>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4903      	ldr	r1, [pc, #12]	; (80001c0 <frame_dummy+0x14>)
 80001b4:	4803      	ldr	r0, [pc, #12]	; (80001c4 <frame_dummy+0x18>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	bd08      	pop	{r3, pc}
 80001bc:	00000000 	.word	0x00000000
 80001c0:	2000016c 	.word	0x2000016c
 80001c4:	08006a6c 	.word	0x08006a6c

080001c8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80001c8:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000200 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80001cc:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80001ce:	e003      	b.n	80001d8 <LoopCopyDataInit>

080001d0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80001d0:	4b0c      	ldr	r3, [pc, #48]	; (8000204 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80001d2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80001d4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80001d6:	3104      	adds	r1, #4

080001d8 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80001d8:	480b      	ldr	r0, [pc, #44]	; (8000208 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80001da:	4b0c      	ldr	r3, [pc, #48]	; (800020c <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80001dc:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80001de:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80001e0:	d3f6      	bcc.n	80001d0 <CopyDataInit>
  ldr  r2, =_sbss
 80001e2:	4a0b      	ldr	r2, [pc, #44]	; (8000210 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80001e4:	e002      	b.n	80001ec <LoopFillZerobss>

080001e6 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80001e6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80001e8:	f842 3b04 	str.w	r3, [r2], #4

080001ec <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80001ec:	4b09      	ldr	r3, [pc, #36]	; (8000214 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80001ee:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80001f0:	d3f9      	bcc.n	80001e6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80001f2:	f000 fc57 	bl	8000aa4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80001f6:	f006 fb1d 	bl	8006834 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80001fa:	f000 f8c9 	bl	8000390 <main>
  bx  lr    
 80001fe:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8000200:	20020000 	.word	0x20020000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8000204:	08007198 	.word	0x08007198
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8000208:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800020c:	20000168 	.word	0x20000168
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8000210:	20000168 	.word	0x20000168
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000214:	20001c28 	.word	0x20001c28

08000218 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000218:	e7fe      	b.n	8000218 <ADC_IRQHandler>
	...

0800021c <BSP_SD_Init>:
/**
  * @brief  Initializes the SD card device.
  * @retval SD status
  */
uint8_t BSP_SD_Init(void)
{
 800021c:	b507      	push	{r0, r1, r2, lr}
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @retval Returns if SD is detected or not
 */
uint8_t BSP_SD_IsDetected(void)
{
  __IO uint8_t status = SD_PRESENT;
 800021e:	2001      	movs	r0, #1
 8000220:	f88d 0007 	strb.w	r0, [sp, #7]

  /* USER CODE BEGIN 1 */
  /* user code can be inserted here */
  /* USER CODE END 1 */    	

  return status;
 8000224:	f89d 3007 	ldrb.w	r3, [sp, #7]
  */
uint8_t BSP_SD_Init(void)
{
  uint8_t sd_state = MSD_OK;
  /* Check if the SD card is plugged in the slot */
  if (BSP_SD_IsDetected() != SD_PRESENT)
 8000228:	4283      	cmp	r3, r0
 800022a:	d103      	bne.n	8000234 <BSP_SD_Init+0x18>
  {
    return MSD_ERROR;
  }
  /* HAL SD initialization */
  sd_state = HAL_SD_Init(&hsd, &SDCardInfo);
 800022c:	4903      	ldr	r1, [pc, #12]	; (800023c <BSP_SD_Init+0x20>)
 800022e:	4804      	ldr	r0, [pc, #16]	; (8000240 <BSP_SD_Init+0x24>)
 8000230:	f001 ffb4 	bl	800219c <HAL_SD_Init>
    }
  }
#endif
*/
  return sd_state;
}
 8000234:	b003      	add	sp, #12
 8000236:	f85d fb04 	ldr.w	pc, [sp], #4
 800023a:	bf00      	nop
 800023c:	200001f8 	.word	0x200001f8
 8000240:	20000250 	.word	0x20000250

08000244 <BSP_SD_ReadBlocks>:
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to read 
  * @retval SD status
  */
uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 8000244:	b507      	push	{r0, r1, r2, lr}
  uint8_t sd_state;
  if(HAL_SD_ReadBlocks(&hsd, pData, ReadAddr, BlockSize, NumOfBlocks) != SD_OK)
 8000246:	9905      	ldr	r1, [sp, #20]
 8000248:	9101      	str	r1, [sp, #4]
 800024a:	9904      	ldr	r1, [sp, #16]
 800024c:	9100      	str	r1, [sp, #0]
 800024e:	4601      	mov	r1, r0
 8000250:	4804      	ldr	r0, [pc, #16]	; (8000264 <BSP_SD_ReadBlocks+0x20>)
 8000252:	f002 f980 	bl	8002556 <HAL_SD_ReadBlocks>
  else
  {
    sd_state = MSD_OK;
  }
  return sd_state;  
}
 8000256:	3000      	adds	r0, #0
 8000258:	bf18      	it	ne
 800025a:	2001      	movne	r0, #1
 800025c:	b003      	add	sp, #12
 800025e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000262:	bf00      	nop
 8000264:	20000250 	.word	0x20000250

08000268 <BSP_SD_WriteBlocks>:
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to write
  * @retval SD status
  */
uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 8000268:	b507      	push	{r0, r1, r2, lr}
  uint8_t sd_state;
  if(HAL_SD_WriteBlocks(&hsd, pData, WriteAddr, BlockSize, NumOfBlocks) != SD_OK)  
 800026a:	9905      	ldr	r1, [sp, #20]
 800026c:	9101      	str	r1, [sp, #4]
 800026e:	9904      	ldr	r1, [sp, #16]
 8000270:	9100      	str	r1, [sp, #0]
 8000272:	4601      	mov	r1, r0
 8000274:	4804      	ldr	r0, [pc, #16]	; (8000288 <BSP_SD_WriteBlocks+0x20>)
 8000276:	f002 fa30 	bl	80026da <HAL_SD_WriteBlocks>
  else
  {
    sd_state = MSD_OK;
  }
  return sd_state;  
}
 800027a:	3000      	adds	r0, #0
 800027c:	bf18      	it	ne
 800027e:	2001      	movne	r0, #1
 8000280:	b003      	add	sp, #12
 8000282:	f85d fb04 	ldr.w	pc, [sp], #4
 8000286:	bf00      	nop
 8000288:	20000250 	.word	0x20000250

0800028c <BSP_SD_GetStatus>:
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  *            @arg  SD_TRANSFER_ERROR: Data transfer error 
  */
HAL_SD_TransferStateTypedef BSP_SD_GetStatus(void)
{
  return(HAL_SD_GetStatus(&hsd));
 800028c:	4801      	ldr	r0, [pc, #4]	; (8000294 <BSP_SD_GetStatus+0x8>)
 800028e:	f002 bbaa 	b.w	80029e6 <HAL_SD_GetStatus>
 8000292:	bf00      	nop
 8000294:	20000250 	.word	0x20000250

08000298 <BSP_SD_GetCardInfo>:
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  */
void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypedef* CardInfo)
{
  /* Get SD card Information */
  HAL_SD_Get_CardInfo(&hsd, CardInfo);
 8000298:	4601      	mov	r1, r0
 800029a:	4801      	ldr	r0, [pc, #4]	; (80002a0 <BSP_SD_GetCardInfo+0x8>)
 800029c:	f001 be3c 	b.w	8001f18 <HAL_SD_Get_CardInfo>
 80002a0:	20000250 	.word	0x20000250

080002a4 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
 80002a4:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SD_Path);
 80002a6:	4903      	ldr	r1, [pc, #12]	; (80002b4 <MX_FATFS_Init+0x10>)
 80002a8:	4803      	ldr	r0, [pc, #12]	; (80002b8 <MX_FATFS_Init+0x14>)
 80002aa:	f004 ff85 	bl	80051b8 <FATFS_LinkDriver>
 80002ae:	4b03      	ldr	r3, [pc, #12]	; (80002bc <MX_FATFS_Init+0x18>)
 80002b0:	7018      	strb	r0, [r3, #0]
 80002b2:	bd08      	pop	{r3, pc}
 80002b4:	200001ad 	.word	0x200001ad
 80002b8:	08007098 	.word	0x08007098
 80002bc:	200001ac 	.word	0x200001ac

080002c0 <get_fattime>:
DWORD get_fattime(void)
{
  /* USER CODE BEGIN get_fattime */
  return 0;
  /* USER CODE END get_fattime */  
}
 80002c0:	2000      	movs	r0, #0
 80002c2:	4770      	bx	lr

080002c4 <Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void Error_Handler(void)
{
 80002c4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN Error_Handler */
  /* User can add his own implementation to report the HAL error return state */
  while(1) 
  {
	  HAL_GPIO_TogglePin(GPIOD, LD4_Pin);
 80002c6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80002ca:	4804      	ldr	r0, [pc, #16]	; (80002dc <Error_Handler+0x18>)
 80002cc:	f000 fdca 	bl	8000e64 <HAL_GPIO_TogglePin>
	  HAL_Delay(500);
 80002d0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80002d4:	f000 fc48 	bl	8000b68 <HAL_Delay>
 80002d8:	e7f5      	b.n	80002c6 <Error_Handler+0x2>
 80002da:	bf00      	nop
 80002dc:	40020c00 	.word	0x40020c00

080002e0 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 80002e0:	b510      	push	{r4, lr}
 80002e2:	b094      	sub	sp, #80	; 0x50

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __HAL_RCC_PWR_CLK_ENABLE();
 80002e4:	4b28      	ldr	r3, [pc, #160]	; (8000388 <SystemClock_Config+0xa8>)
 80002e6:	2100      	movs	r1, #0
 80002e8:	9101      	str	r1, [sp, #4]
 80002ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80002ec:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80002f0:	641a      	str	r2, [r3, #64]	; 0x40
 80002f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80002f4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80002f8:	9301      	str	r3, [sp, #4]
 80002fa:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80002fc:	4b23      	ldr	r3, [pc, #140]	; (800038c <SystemClock_Config+0xac>)
 80002fe:	9102      	str	r1, [sp, #8]
 8000300:	681a      	ldr	r2, [r3, #0]
 8000302:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000306:	601a      	str	r2, [r3, #0]
 8000308:	681b      	ldr	r3, [r3, #0]
 800030a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800030e:	9302      	str	r3, [sp, #8]
 8000310:	9b02      	ldr	r3, [sp, #8]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000312:	2301      	movs	r3, #1
 8000314:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000316:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000318:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800031c:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLM = 8;
 800031e:	2308      	movs	r3, #8
 8000320:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 336;
 8000322:	f44f 73a8 	mov.w	r3, #336	; 0x150

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000326:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
 8000328:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800032a:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
 800032c:	2307      	movs	r3, #7

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800032e:	940e      	str	r4, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8000330:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 7;
 8000332:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000334:	f001 fa32 	bl	800179c <HAL_RCC_OscConfig>
 8000338:	b108      	cbz	r0, 800033e <SystemClock_Config+0x5e>
  {
    Error_Handler();
 800033a:	f7ff ffc3 	bl	80002c4 <Error_Handler>
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800033e:	230f      	movs	r3, #15
 8000340:	9303      	str	r3, [sp, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8000342:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000346:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8000348:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 800034a:	2105      	movs	r1, #5
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800034c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8000350:	a803      	add	r0, sp, #12
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000352:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000354:	9307      	str	r3, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8000356:	f001 fbc7 	bl	8001ae8 <HAL_RCC_ClockConfig>
 800035a:	4604      	mov	r4, r0
 800035c:	2800      	cmp	r0, #0
 800035e:	d1ec      	bne.n	800033a <SystemClock_Config+0x5a>
  {
    Error_Handler();
  }

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8000360:	f001 fc76 	bl	8001c50 <HAL_RCC_GetHCLKFreq>
 8000364:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000368:	fbb0 f0f3 	udiv	r0, r0, r3
 800036c:	f000 fc5c 	bl	8000c28 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8000370:	2004      	movs	r0, #4
 8000372:	f000 fc6f 	bl	8000c54 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8000376:	4622      	mov	r2, r4
 8000378:	4621      	mov	r1, r4
 800037a:	f04f 30ff 	mov.w	r0, #4294967295
 800037e:	f000 fc13 	bl	8000ba8 <HAL_NVIC_SetPriority>
}
 8000382:	b014      	add	sp, #80	; 0x50
 8000384:	bd10      	pop	{r4, pc}
 8000386:	bf00      	nop
 8000388:	40023800 	.word	0x40023800
 800038c:	40007000 	.word	0x40007000

08000390 <main>:
/* USER CODE BEGIN 0 */
/* USER CODE END 0 */

extern volatile uint8_t TxFlag;
int main(void)
{
 8000390:	b500      	push	{lr}
 8000392:	b08b      	sub	sp, #44	; 0x2c
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000394:	2400      	movs	r4, #0
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000396:	f000 fbbf 	bl	8000b18 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 800039a:	f7ff ffa1 	bl	80002e0 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800039e:	4b4c      	ldr	r3, [pc, #304]	; (80004d0 <main+0x140>)
 80003a0:	9400      	str	r4, [sp, #0]
 80003a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 80003a4:	484b      	ldr	r0, [pc, #300]	; (80004d4 <main+0x144>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80003a6:	f042 0204 	orr.w	r2, r2, #4
 80003aa:	631a      	str	r2, [r3, #48]	; 0x30
 80003ac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003ae:	f002 0204 	and.w	r2, r2, #4
 80003b2:	9200      	str	r2, [sp, #0]
 80003b4:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80003b6:	9401      	str	r4, [sp, #4]
 80003b8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003ba:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80003be:	631a      	str	r2, [r3, #48]	; 0x30
 80003c0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003c2:	f002 0280 	and.w	r2, r2, #128	; 0x80
 80003c6:	9201      	str	r2, [sp, #4]
 80003c8:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80003ca:	9402      	str	r4, [sp, #8]
 80003cc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003ce:	f042 0201 	orr.w	r2, r2, #1
 80003d2:	631a      	str	r2, [r3, #48]	; 0x30
 80003d4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003d6:	f002 0201 	and.w	r2, r2, #1
 80003da:	9202      	str	r2, [sp, #8]
 80003dc:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80003de:	9403      	str	r4, [sp, #12]
 80003e0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003e2:	f042 0202 	orr.w	r2, r2, #2
 80003e6:	631a      	str	r2, [r3, #48]	; 0x30
 80003e8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003ea:	f002 0202 	and.w	r2, r2, #2
 80003ee:	9203      	str	r2, [sp, #12]
 80003f0:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80003f2:	9404      	str	r4, [sp, #16]
 80003f4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003f6:	f042 0208 	orr.w	r2, r2, #8
 80003fa:	631a      	str	r2, [r3, #48]	; 0x30
 80003fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 80003fe:	2201      	movs	r2, #1
  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000400:	f003 0308 	and.w	r3, r3, #8

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 8000404:	4611      	mov	r1, r2
  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000406:	9304      	str	r3, [sp, #16]
 8000408:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 800040a:	f000 fd27 	bl	8000e5c <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin, GPIO_PIN_RESET);
 800040e:	4622      	mov	r2, r4
 8000410:	f44f 4170 	mov.w	r1, #61440	; 0xf000
 8000414:	4830      	ldr	r0, [pc, #192]	; (80004d8 <main+0x148>)
 8000416:	f000 fd21 	bl	8000e5c <HAL_GPIO_WritePin>

  /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 800041a:	2501      	movs	r5, #1
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 800041c:	a905      	add	r1, sp, #20
 800041e:	482d      	ldr	r0, [pc, #180]	; (80004d4 <main+0x144>)

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 8000420:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000422:	9506      	str	r5, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000424:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000426:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 8000428:	f000 fc38 	bl	8000c9c <HAL_GPIO_Init>

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 800042c:	4b2b      	ldr	r3, [pc, #172]	; (80004dc <main+0x14c>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 800042e:	482c      	ldr	r0, [pc, #176]	; (80004e0 <main+0x150>)
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 8000430:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8000432:	a905      	add	r1, sp, #20

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
 8000434:	2604      	movs	r6, #4
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
 8000436:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000438:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 800043a:	f000 fc2f 	bl	8000c9c <HAL_GPIO_Init>

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
 800043e:	a905      	add	r1, sp, #20
 8000440:	4828      	ldr	r0, [pc, #160]	; (80004e4 <main+0x154>)
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
 8000442:	9605      	str	r6, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000444:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000446:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
 8000448:	f000 fc28 	bl	8000c9c <HAL_GPIO_Init>
  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800044c:	4822      	ldr	r0, [pc, #136]	; (80004d8 <main+0x148>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800044e:	9506      	str	r5, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin;
 8000450:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8000454:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin;
 8000456:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000458:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800045a:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800045c:	f000 fc1e 	bl	8000c9c <HAL_GPIO_Init>

/* SDIO init function */
static void MX_SDIO_SD_Init(void)
{

  hsd.Instance = SDIO;
 8000460:	4b21      	ldr	r3, [pc, #132]	; (80004e8 <main+0x158>)
 8000462:	4a22      	ldr	r2, [pc, #136]	; (80004ec <main+0x15c>)
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  hsd.Init.ClockDiv = 4;
 8000464:	619e      	str	r6, [r3, #24]
/* SDIO init function */
static void MX_SDIO_SD_Init(void)
{

  hsd.Instance = SDIO;
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
 8000466:	e883 0014 	stmia.w	r3, {r2, r4}
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
 800046a:	609c      	str	r4, [r3, #8]
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
 800046c:	60dc      	str	r4, [r3, #12]
  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
 800046e:	611c      	str	r4, [r3, #16]
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 8000470:	615c      	str	r4, [r3, #20]
  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SDIO_SD_Init();
  MX_USB_DEVICE_Init();
 8000472:	f000 f931 	bl	80006d8 <MX_USB_DEVICE_Init>
  MX_FATFS_Init();
 8000476:	f7ff ff15 	bl	80002a4 <MX_FATFS_Init>

/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
 800047a:	481d      	ldr	r0, [pc, #116]	; (80004f0 <main+0x160>)
  huart2.Init.BaudRate = 115200;
 800047c:	4b1d      	ldr	r3, [pc, #116]	; (80004f4 <main+0x164>)
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800047e:	6084      	str	r4, [r0, #8]
/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
 8000480:	f44f 36e1 	mov.w	r6, #115200	; 0x1c200
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000484:	250c      	movs	r5, #12
/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
 8000486:	e880 0048 	stmia.w	r0, {r3, r6}
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
 800048a:	60c4      	str	r4, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 800048c:	6104      	str	r4, [r0, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 800048e:	6145      	str	r5, [r0, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000490:	6184      	str	r4, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8000492:	61c4      	str	r4, [r0, #28]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000494:	f002 fc30 	bl	8002cf8 <HAL_UART_Init>
 8000498:	b108      	cbz	r0, 800049e <main+0x10e>
  {
    Error_Handler();
 800049a:	f7ff ff13 	bl	80002c4 <Error_Handler>

/* USART3 init function */
static void MX_USART3_UART_Init(void)
{

  huart3.Instance = USART3;
 800049e:	4b16      	ldr	r3, [pc, #88]	; (80004f8 <main+0x168>)
 80004a0:	4a16      	ldr	r2, [pc, #88]	; (80004fc <main+0x16c>)
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 80004a2:	6098      	str	r0, [r3, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 80004a4:	60d8      	str	r0, [r3, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 80004a6:	6118      	str	r0, [r3, #16]
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80004a8:	6198      	str	r0, [r3, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 80004aa:	61d8      	str	r0, [r3, #28]
  if (HAL_UART_Init(&huart3) != HAL_OK)
 80004ac:	4618      	mov	r0, r3
/* USART3 init function */
static void MX_USART3_UART_Init(void)
{

  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
 80004ae:	e883 0044 	stmia.w	r3, {r2, r6}
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
 80004b2:	615d      	str	r5, [r3, #20]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
 80004b4:	f002 fc20 	bl	8002cf8 <HAL_UART_Init>
 80004b8:	2800      	cmp	r0, #0
 80004ba:	d1ee      	bne.n	800049a <main+0x10a>
  MX_SDIO_SD_Init();
  MX_USB_DEVICE_Init();
  MX_FATFS_Init();
  MX_USART2_UART_Init();
  MX_USART3_UART_Init();
  Disk_Init();
 80004bc:	f006 f80a 	bl	80064d4 <Disk_Init>
  InitStateMashine();
 80004c0:	f006 f9b2 	bl	8006828 <InitStateMashine>
  /* USER CODE BEGIN WHILE */
  //HAL_UART_Receive_IT(&huart3,&UART_Data,1);
  while (1)
  {
	//UART_RX();
	stateMashin();
 80004c4:	f006 f97a 	bl	80067bc <stateMashin>
	control_in_buf();
 80004c8:	f006 f92c 	bl	8006724 <control_in_buf>
 80004cc:	e7fa      	b.n	80004c4 <main+0x134>
 80004ce:	bf00      	nop
 80004d0:	40023800 	.word	0x40023800
 80004d4:	40020800 	.word	0x40020800
 80004d8:	40020c00 	.word	0x40020c00
 80004dc:	10120000 	.word	0x10120000
 80004e0:	40020000 	.word	0x40020000
 80004e4:	40020400 	.word	0x40020400
 80004e8:	20000250 	.word	0x20000250
 80004ec:	40012c00 	.word	0x40012c00
 80004f0:	200002b0 	.word	0x200002b0
 80004f4:	40004400 	.word	0x40004400
 80004f8:	200001b8 	.word	0x200001b8
 80004fc:	40004800 	.word	0x40004800

08000500 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000500:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 8000502:	2007      	movs	r0, #7
 8000504:	f000 fb3e 	bl	8000b84 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8000508:	2200      	movs	r2, #0
 800050a:	4611      	mov	r1, r2
 800050c:	f06f 000b 	mvn.w	r0, #11
 8000510:	f000 fb4a 	bl	8000ba8 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8000514:	2200      	movs	r2, #0
 8000516:	4611      	mov	r1, r2
 8000518:	f06f 000a 	mvn.w	r0, #10
 800051c:	f000 fb44 	bl	8000ba8 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 8000520:	2200      	movs	r2, #0
 8000522:	4611      	mov	r1, r2
 8000524:	f06f 0009 	mvn.w	r0, #9
 8000528:	f000 fb3e 	bl	8000ba8 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 800052c:	2200      	movs	r2, #0
 800052e:	4611      	mov	r1, r2
 8000530:	f06f 0004 	mvn.w	r0, #4
 8000534:	f000 fb38 	bl	8000ba8 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8000538:	2200      	movs	r2, #0
 800053a:	4611      	mov	r1, r2
 800053c:	f06f 0003 	mvn.w	r0, #3
 8000540:	f000 fb32 	bl	8000ba8 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8000544:	2200      	movs	r2, #0
 8000546:	4611      	mov	r1, r2
 8000548:	f06f 0001 	mvn.w	r0, #1
 800054c:	f000 fb2c 	bl	8000ba8 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 8, 0);
 8000550:	2200      	movs	r2, #0
 8000552:	2108      	movs	r1, #8
 8000554:	f04f 30ff 	mov.w	r0, #4294967295

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000558:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 8, 0);
 800055c:	f000 bb24 	b.w	8000ba8 <HAL_NVIC_SetPriority>

08000560 <HAL_SD_MspInit>:

  /* USER CODE END MspInit 1 */
}

void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 8000560:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hsd->Instance==SDIO)
 8000562:	6802      	ldr	r2, [r0, #0]
 8000564:	4b15      	ldr	r3, [pc, #84]	; (80005bc <HAL_SD_MspInit+0x5c>)
 8000566:	429a      	cmp	r2, r3

  /* USER CODE END MspInit 1 */
}

void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 8000568:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hsd->Instance==SDIO)
 800056a:	d125      	bne.n	80005b8 <HAL_SD_MspInit+0x58>
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */

  /* USER CODE END SDIO_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SDIO_CLK_ENABLE();
 800056c:	2300      	movs	r3, #0
 800056e:	9300      	str	r3, [sp, #0]
 8000570:	4b13      	ldr	r3, [pc, #76]	; (80005c0 <HAL_SD_MspInit+0x60>)
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000572:	4814      	ldr	r0, [pc, #80]	; (80005c4 <HAL_SD_MspInit+0x64>)
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */

  /* USER CODE END SDIO_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SDIO_CLK_ENABLE();
 8000574:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000576:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800057a:	645a      	str	r2, [r3, #68]	; 0x44
 800057c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800057e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8000582:	9300      	str	r3, [sp, #0]
 8000584:	9b00      	ldr	r3, [sp, #0]
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000586:	2702      	movs	r7, #2
    PC10     ------> SDIO_D2
    PC11     ------> SDIO_D3
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
 8000588:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800058c:	2601      	movs	r6, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800058e:	2503      	movs	r5, #3
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 8000590:	240c      	movs	r4, #12
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000592:	a901      	add	r1, sp, #4
    PC10     ------> SDIO_D2
    PC11     ------> SDIO_D3
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
 8000594:	9301      	str	r3, [sp, #4]
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000596:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000598:	9603      	str	r6, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800059a:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 800059c:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800059e:	f000 fb7d 	bl	8000c9c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80005a2:	2304      	movs	r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80005a4:	eb0d 0103 	add.w	r1, sp, r3
 80005a8:	4807      	ldr	r0, [pc, #28]	; (80005c8 <HAL_SD_MspInit+0x68>)
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80005aa:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80005ac:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80005ae:	9603      	str	r6, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80005b0:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 80005b2:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80005b4:	f000 fb72 	bl	8000c9c <HAL_GPIO_Init>
  /* USER CODE BEGIN SDIO_MspInit 1 */

  /* USER CODE END SDIO_MspInit 1 */
  }

}
 80005b8:	b007      	add	sp, #28
 80005ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80005bc:	40012c00 	.word	0x40012c00
 80005c0:	40023800 	.word	0x40023800
 80005c4:	40020800 	.word	0x40020800
 80005c8:	40020c00 	.word	0x40020c00

080005cc <HAL_UART_MspInit>:
  /* USER CODE END SDIO_MspDeInit 1 */

}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80005cc:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 80005ce:	4b2a      	ldr	r3, [pc, #168]	; (8000678 <HAL_UART_MspInit+0xac>)
 80005d0:	6804      	ldr	r4, [r0, #0]
 80005d2:	429c      	cmp	r4, r3
  /* USER CODE END SDIO_MspDeInit 1 */

}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80005d4:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 80005d6:	d121      	bne.n	800061c <HAL_UART_MspInit+0x50>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 80005d8:	f503 33fa 	add.w	r3, r3, #128000	; 0x1f400
 80005dc:	2400      	movs	r4, #0
 80005de:	9401      	str	r4, [sp, #4]
 80005e0:	6c19      	ldr	r1, [r3, #64]	; 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80005e2:	4826      	ldr	r0, [pc, #152]	; (800067c <HAL_UART_MspInit+0xb0>)
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 80005e4:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 80005e8:	6419      	str	r1, [r3, #64]	; 0x40
 80005ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80005ec:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80005f0:	9301      	str	r3, [sp, #4]
 80005f2:	9b01      	ldr	r3, [sp, #4]

    /**USART2 GPIO Configuration    
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 80005f4:	230c      	movs	r3, #12
 80005f6:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80005f8:	2302      	movs	r3, #2
 80005fa:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80005fc:	2301      	movs	r3, #1
 80005fe:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000600:	2303      	movs	r3, #3
 8000602:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000604:	a903      	add	r1, sp, #12
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8000606:	2307      	movs	r3, #7
 8000608:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800060a:	f000 fb47 	bl	8000c9c <HAL_GPIO_Init>

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USART2_IRQn, 8, 0);
 800060e:	2026      	movs	r0, #38	; 0x26
 8000610:	4622      	mov	r2, r4
 8000612:	2108      	movs	r1, #8
 8000614:	f000 fac8 	bl	8000ba8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 8000618:	2026      	movs	r0, #38	; 0x26
 800061a:	e028      	b.n	800066e <HAL_UART_MspInit+0xa2>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
  else if(huart->Instance==USART3)
 800061c:	4b18      	ldr	r3, [pc, #96]	; (8000680 <HAL_UART_MspInit+0xb4>)
 800061e:	429c      	cmp	r4, r3
 8000620:	d127      	bne.n	8000672 <HAL_UART_MspInit+0xa6>
  {
  /* USER CODE BEGIN USART3_MspInit 0 */

  /* USER CODE END USART3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();
 8000622:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
 8000626:	2500      	movs	r5, #0
 8000628:	9502      	str	r5, [sp, #8]
 800062a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800062c:	4815      	ldr	r0, [pc, #84]	; (8000684 <HAL_UART_MspInit+0xb8>)
  {
  /* USER CODE BEGIN USART3_MspInit 0 */

  /* USER CODE END USART3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();
 800062e:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8000632:	641a      	str	r2, [r3, #64]	; 0x40
 8000634:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000636:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800063a:	9302      	str	r3, [sp, #8]
 800063c:	9b02      	ldr	r3, [sp, #8]
  
    /**USART3 GPIO Configuration    
    PB10     ------> USART3_TX
    PB11     ------> USART3_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 800063e:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8000642:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000644:	2302      	movs	r3, #2
 8000646:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000648:	2303      	movs	r3, #3
    PB10     ------> USART3_TX
    PB11     ------> USART3_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800064a:	2601      	movs	r6, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800064c:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800064e:	a903      	add	r1, sp, #12
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8000650:	2307      	movs	r3, #7
 8000652:	9307      	str	r3, [sp, #28]
    PB10     ------> USART3_TX
    PB11     ------> USART3_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000654:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000656:	f000 fb21 	bl	8000c9c <HAL_GPIO_Init>
    USART3->CR1 |= USART_CR1_RXNEIE;
 800065a:	68e3      	ldr	r3, [r4, #12]
 800065c:	f043 0320 	orr.w	r3, r3, #32

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USART3_IRQn, 0, 1);
 8000660:	2027      	movs	r0, #39	; 0x27
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    USART3->CR1 |= USART_CR1_RXNEIE;
 8000662:	60e3      	str	r3, [r4, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USART3_IRQn, 0, 1);
 8000664:	4632      	mov	r2, r6
 8000666:	4629      	mov	r1, r5
 8000668:	f000 fa9e 	bl	8000ba8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_IRQn);
 800066c:	2027      	movs	r0, #39	; 0x27
 800066e:	f000 facf 	bl	8000c10 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 8000672:	b008      	add	sp, #32
 8000674:	bd70      	pop	{r4, r5, r6, pc}
 8000676:	bf00      	nop
 8000678:	40004400 	.word	0x40004400
 800067c:	40020000 	.word	0x40020000
 8000680:	40004800 	.word	0x40004800
 8000684:	40020400 	.word	0x40020400

08000688 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 8000688:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800068a:	f000 fa5f 	bl	8000b4c <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800068e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 8000692:	f000 baec 	b.w	8000c6e <HAL_SYSTICK_IRQHandler>
	...

08000698 <USART2_IRQHandler>:
void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 8000698:	4801      	ldr	r0, [pc, #4]	; (80006a0 <USART2_IRQHandler+0x8>)
 800069a:	f002 bb9b 	b.w	8002dd4 <HAL_UART_IRQHandler>
 800069e:	bf00      	nop
 80006a0:	200002b0 	.word	0x200002b0

080006a4 <USART3_IRQHandler>:
{
	/* USER CODE BEGIN USART3_IRQn 0 */

  /* USER CODE END USART3_IRQn 0 */
  //HAL_UART_IRQHandler(&huart3);
 if (USART3->SR & USART_SR_RXNE) {
 80006a4:	4b07      	ldr	r3, [pc, #28]	; (80006c4 <USART3_IRQHandler+0x20>)
 80006a6:	681a      	ldr	r2, [r3, #0]
 80006a8:	0692      	lsls	r2, r2, #26
 80006aa:	d509      	bpl.n	80006c0 <USART3_IRQHandler+0x1c>
	    // —брасываем флаг прерывани€
	    USART3->SR&=~USART_SR_RXNE;
 80006ac:	681a      	ldr	r2, [r3, #0]
 80006ae:	f022 0220 	bic.w	r2, r2, #32
 80006b2:	601a      	str	r2, [r3, #0]
	    UART_Data  = USART3->DR;
 80006b4:	685b      	ldr	r3, [r3, #4]
 80006b6:	4a04      	ldr	r2, [pc, #16]	; (80006c8 <USART3_IRQHandler+0x24>)
 80006b8:	b2db      	uxtb	r3, r3
 80006ba:	7013      	strb	r3, [r2, #0]
	readRXbuffer();
 80006bc:	f006 b81c 	b.w	80066f8 <readRXbuffer>
 80006c0:	4770      	bx	lr
 80006c2:	bf00      	nop
 80006c4:	40004800 	.word	0x40004800
 80006c8:	20001c01 	.word	0x20001c01

080006cc <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 80006cc:	4801      	ldr	r0, [pc, #4]	; (80006d4 <OTG_FS_IRQHandler+0x8>)
 80006ce:	f000 bc67 	b.w	8000fa0 <HAL_PCD_IRQHandler>
 80006d2:	bf00      	nop
 80006d4:	20000514 	.word	0x20000514

080006d8 <MX_USB_DEVICE_Init>:
/* USB Device Core handle declaration */
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
 80006d8:	b510      	push	{r4, lr}
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 80006da:	4c09      	ldr	r4, [pc, #36]	; (8000700 <MX_USB_DEVICE_Init+0x28>)
 80006dc:	4909      	ldr	r1, [pc, #36]	; (8000704 <MX_USB_DEVICE_Init+0x2c>)
 80006de:	2200      	movs	r2, #0
 80006e0:	4620      	mov	r0, r4
 80006e2:	f004 fddb 	bl	800529c <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_MSC);
 80006e6:	4908      	ldr	r1, [pc, #32]	; (8000708 <MX_USB_DEVICE_Init+0x30>)
 80006e8:	4620      	mov	r0, r4
 80006ea:	f004 fdec 	bl	80052c6 <USBD_RegisterClass>

  USBD_MSC_RegisterStorage(&hUsbDeviceFS, &USBD_Storage_Interface_fops_FS);
 80006ee:	4620      	mov	r0, r4
 80006f0:	4906      	ldr	r1, [pc, #24]	; (800070c <MX_USB_DEVICE_Init+0x34>)
 80006f2:	f005 f9d0 	bl	8005a96 <USBD_MSC_RegisterStorage>

  USBD_Start(&hUsbDeviceFS);
 80006f6:	4620      	mov	r0, r4

}
 80006f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_MSC);

  USBD_MSC_RegisterStorage(&hUsbDeviceFS, &USBD_Storage_Interface_fops_FS);

  USBD_Start(&hUsbDeviceFS);
 80006fc:	f004 bdea 	b.w	80052d4 <USBD_Start>
 8000700:	200002f0 	.word	0x200002f0
 8000704:	20000000 	.word	0x20000000
 8000708:	200000a8 	.word	0x200000a8
 800070c:	20000034 	.word	0x20000034

08000710 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8000710:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 8000712:	6803      	ldr	r3, [r0, #0]
 8000714:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8000718:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 800071a:	d139      	bne.n	8000790 <HAL_PCD_MspInit+0x80>
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = VBUS_FS_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800071c:	2400      	movs	r4, #0
    PA9     ------> USB_OTG_FS_VBUS
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = VBUS_FS_Pin;
 800071e:	f44f 7300 	mov.w	r3, #512	; 0x200
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
 8000722:	a901      	add	r1, sp, #4
 8000724:	481b      	ldr	r0, [pc, #108]	; (8000794 <HAL_PCD_MspInit+0x84>)
    PA9     ------> USB_OTG_FS_VBUS
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = VBUS_FS_Pin;
 8000726:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000728:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800072a:	9403      	str	r4, [sp, #12]
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
 800072c:	f000 fab6 	bl	8000c9c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8000730:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000734:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000736:	2602      	movs	r6, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000738:	2303      	movs	r3, #3
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 800073a:	250a      	movs	r5, #10
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800073c:	a901      	add	r1, sp, #4
 800073e:	4815      	ldr	r0, [pc, #84]	; (8000794 <HAL_PCD_MspInit+0x84>)
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000740:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000742:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000744:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8000746:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000748:	f000 faa8 	bl	8000c9c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = OTG_FS_DM_Pin|OTG_FS_DP_Pin;
 800074c:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000750:	a901      	add	r1, sp, #4
 8000752:	4810      	ldr	r0, [pc, #64]	; (8000794 <HAL_PCD_MspInit+0x84>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = OTG_FS_DM_Pin|OTG_FS_DP_Pin;
 8000754:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000756:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000758:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800075a:	9404      	str	r4, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 800075c:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800075e:	f000 fa9d 	bl	8000c9c <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8000762:	4b0d      	ldr	r3, [pc, #52]	; (8000798 <HAL_PCD_MspInit+0x88>)
 8000764:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000766:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800076a:	635a      	str	r2, [r3, #52]	; 0x34
 800076c:	9400      	str	r4, [sp, #0]
 800076e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000770:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000774:	645a      	str	r2, [r3, #68]	; 0x44
 8000776:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000778:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800077c:	9300      	str	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 6);
 800077e:	2043      	movs	r0, #67	; 0x43
 8000780:	2206      	movs	r2, #6
 8000782:	4621      	mov	r1, r4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8000784:	9b00      	ldr	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 6);
 8000786:	f000 fa0f 	bl	8000ba8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 800078a:	2043      	movs	r0, #67	; 0x43
 800078c:	f000 fa40 	bl	8000c10 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8000790:	b006      	add	sp, #24
 8000792:	bd70      	pop	{r4, r5, r6, pc}
 8000794:	40020000 	.word	0x40020000
 8000798:	40023800 	.word	0x40023800

0800079c <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 800079c:	f500 7161 	add.w	r1, r0, #900	; 0x384
 80007a0:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007a4:	f004 bdb9 	b.w	800531a <USBD_LL_SetupStage>

080007a8 <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 80007a8:	231c      	movs	r3, #28
 80007aa:	fb03 0301 	mla	r3, r3, r1, r0
 80007ae:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007b2:	f8d3 21e8 	ldr.w	r2, [r3, #488]	; 0x1e8
 80007b6:	f004 bddd 	b.w	8005374 <USBD_LL_DataOutStage>

080007ba <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 80007ba:	231c      	movs	r3, #28
 80007bc:	fb03 0301 	mla	r3, r3, r1, r0
 80007c0:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007c4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80007c6:	f004 be06 	b.w	80053d6 <USBD_LL_DataInStage>

080007ca <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF(hpcd->pData);
 80007ca:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007ce:	f004 be81 	b.w	80054d4 <USBD_LL_SOF>

080007d2 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 80007d2:	b510      	push	{r4, lr}
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  /*Set USB Current Speed*/
  switch (hpcd->Init.speed)
 80007d4:	68c1      	ldr	r1, [r0, #12]
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 80007d6:	4604      	mov	r4, r0
	
  default:
    speed = USBD_SPEED_FULL;    
    break;    
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
 80007d8:	3100      	adds	r1, #0
 80007da:	bf18      	it	ne
 80007dc:	2101      	movne	r1, #1
 80007de:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007e2:	f004 fe65 	bl	80054b0 <USBD_LL_SetSpeed>
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 80007e6:	f8d4 03b4 	ldr.w	r0, [r4, #948]	; 0x3b4
}
 80007ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    break;    
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 80007ee:	f004 be40 	b.w	8005472 <USBD_LL_Reset>
	...

080007f4 <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{  
 80007f4:	b510      	push	{r4, lr}
 80007f6:	4604      	mov	r4, r0
   /* Inform USB library that core enters in suspend Mode */
  USBD_LL_Suspend(hpcd->pData);
 80007f8:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007fc:	f004 fe5b 	bl	80054b6 <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8000800:	6822      	ldr	r2, [r4, #0]
 8000802:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 8000806:	f043 0301 	orr.w	r3, r3, #1
 800080a:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /*Enter in STOP mode */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 800080e:	6a23      	ldr	r3, [r4, #32]
 8000810:	b123      	cbz	r3, 800081c <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8000812:	4a03      	ldr	r2, [pc, #12]	; (8000820 <HAL_PCD_SuspendCallback+0x2c>)
 8000814:	6913      	ldr	r3, [r2, #16]
 8000816:	f043 0306 	orr.w	r3, r3, #6
 800081a:	6113      	str	r3, [r2, #16]
 800081c:	bd10      	pop	{r4, pc}
 800081e:	bf00      	nop
 8000820:	e000ed00 	.word	0xe000ed00

08000824 <HAL_PCD_ResumeCallback>:
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */
  USBD_LL_Resume(hpcd->pData);
 8000824:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000828:	f004 be4e 	b.w	80054c8 <USBD_LL_Resume>

0800082c <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
 800082c:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000830:	f004 be5e 	b.w	80054f0 <USBD_LL_IsoOUTIncomplete>

08000834 <HAL_PCD_ISOINIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
 8000834:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000838:	f004 be58 	b.w	80054ec <USBD_LL_IsoINIncomplete>

0800083c <HAL_PCD_ConnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevConnected(hpcd->pData);
 800083c:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000840:	f004 be58 	b.w	80054f4 <USBD_LL_DevConnected>

08000844 <HAL_PCD_DisconnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevDisconnected(hpcd->pData);
 8000844:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000848:	f004 be56 	b.w	80054f8 <USBD_LL_DevDisconnected>

0800084c <USBD_LL_Init>:
  * @brief  Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
 800084c:	b508      	push	{r3, lr}
  /* Init USB_IP */
  if (pdev->id == DEVICE_FS) {
 800084e:	7802      	ldrb	r2, [r0, #0]
 8000850:	bb42      	cbnz	r2, 80008a4 <USBD_LL_Init+0x58>
  /* Link The driver to the stack */	
  hpcd_USB_OTG_FS.pData = pdev;
 8000852:	4b15      	ldr	r3, [pc, #84]	; (80008a8 <USBD_LL_Init+0x5c>)
  pdev->pData = &hpcd_USB_OTG_FS; 
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8000854:	2104      	movs	r1, #4
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  /* Init USB_IP */
  if (pdev->id == DEVICE_FS) {
  /* Link The driver to the stack */	
  hpcd_USB_OTG_FS.pData = pdev;
 8000856:	f8c3 03b4 	str.w	r0, [r3, #948]	; 0x3b4
  pdev->pData = &hpcd_USB_OTG_FS; 
 800085a:	f8c0 3220 	str.w	r3, [r0, #544]	; 0x220
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 800085e:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 8000862:	e883 0003 	stmia.w	r3, {r0, r1}
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8000866:	2102      	movs	r1, #2
 8000868:	60d9      	str	r1, [r3, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 800086a:	6199      	str	r1, [r3, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 800086c:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 800086e:	2101      	movs	r1, #1
  pdev->pData = &hpcd_USB_OTG_FS; 
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8000870:	611a      	str	r2, [r3, #16]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8000872:	615a      	str	r2, [r3, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8000874:	61da      	str	r2, [r3, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8000876:	621a      	str	r2, [r3, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8000878:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 800087a:	62d9      	str	r1, [r3, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 800087c:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 800087e:	f000 faf5 	bl	8000e6c <HAL_PCD_Init>
 8000882:	b108      	cbz	r0, 8000888 <USBD_LL_Init+0x3c>
  {
    Error_Handler();
 8000884:	f7ff fd1e 	bl	80002c4 <Error_Handler>
  }

  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8000888:	2180      	movs	r1, #128	; 0x80
 800088a:	4807      	ldr	r0, [pc, #28]	; (80008a8 <USBD_LL_Init+0x5c>)
 800088c:	f000 ff81 	bl	8001792 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8000890:	2240      	movs	r2, #64	; 0x40
 8000892:	2100      	movs	r1, #0
 8000894:	4804      	ldr	r0, [pc, #16]	; (80008a8 <USBD_LL_Init+0x5c>)
 8000896:	f000 ff5b 	bl	8001750 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 800089a:	2280      	movs	r2, #128	; 0x80
 800089c:	2101      	movs	r1, #1
 800089e:	4802      	ldr	r0, [pc, #8]	; (80008a8 <USBD_LL_Init+0x5c>)
 80008a0:	f000 ff56 	bl	8001750 <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
}
 80008a4:	2000      	movs	r0, #0
 80008a6:	bd08      	pop	{r3, pc}
 80008a8:	20000514 	.word	0x20000514

080008ac <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 80008ac:	b508      	push	{r3, lr}
  HAL_PCD_Start(pdev->pData);
 80008ae:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008b2:	f000 fb47 	bl	8000f44 <HAL_PCD_Start>
  return USBD_OK; 
}
 80008b6:	2000      	movs	r0, #0
 80008b8:	bd08      	pop	{r3, pc}

080008ba <USBD_LL_Stop>:
  * @brief  Stops the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Stop (USBD_HandleTypeDef *pdev)
{
 80008ba:	b508      	push	{r3, lr}
  HAL_PCD_Stop(pdev->pData);
 80008bc:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008c0:	f000 fb55 	bl	8000f6e <HAL_PCD_Stop>
  return USBD_OK; 
}
 80008c4:	2000      	movs	r0, #0
 80008c6:	bd08      	pop	{r3, pc}

080008c8 <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
 80008c8:	b510      	push	{r4, lr}
 80008ca:	461c      	mov	r4, r3

  HAL_PCD_EP_Open(pdev->pData, 
 80008cc:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008d0:	4613      	mov	r3, r2
 80008d2:	4622      	mov	r2, r4
 80008d4:	f000 fe1a 	bl	800150c <HAL_PCD_EP_Open>
                  ep_addr, 
                  ep_mps, 
                  ep_type);
  
  return USBD_OK; 
}
 80008d8:	2000      	movs	r0, #0
 80008da:	bd10      	pop	{r4, pc}

080008dc <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 80008dc:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 80008de:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008e2:	f000 fe41 	bl	8001568 <HAL_PCD_EP_Close>
  return USBD_OK; 
}
 80008e6:	2000      	movs	r0, #0
 80008e8:	bd08      	pop	{r3, pc}

080008ea <USBD_LL_FlushEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_FlushEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 80008ea:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_Flush(pdev->pData, ep_addr);
 80008ec:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008f0:	f000 ff14 	bl	800171c <HAL_PCD_EP_Flush>
  return USBD_OK; 
}
 80008f4:	2000      	movs	r0, #0
 80008f6:	bd08      	pop	{r3, pc}

080008f8 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 80008f8:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 80008fa:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008fe:	f000 febc 	bl	800167a <HAL_PCD_EP_SetStall>
  return USBD_OK; 
}
 8000902:	2000      	movs	r0, #0
 8000904:	bd08      	pop	{r3, pc}

08000906 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8000906:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8000908:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800090c:	f000 fee1 	bl	80016d2 <HAL_PCD_EP_ClrStall>
  return USBD_OK; 
}
 8000910:	2000      	movs	r0, #0
 8000912:	bd08      	pop	{r3, pc}

08000914 <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
  
  if((ep_addr & 0x80) == 0x80)
 8000914:	f011 0f80 	tst.w	r1, #128	; 0x80
  * @param  ep_addr: Endpoint Number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
 8000918:	f8d0 2220 	ldr.w	r2, [r0, #544]	; 0x220
  
  if((ep_addr & 0x80) == 0x80)
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 800091c:	bf18      	it	ne
 800091e:	f001 037f 	andne.w	r3, r1, #127	; 0x7f
 8000922:	f04f 001c 	mov.w	r0, #28
 8000926:	bf15      	itete	ne
 8000928:	fb00 2103 	mlane	r1, r0, r3, r2
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 800092c:	fb00 2101 	mlaeq	r1, r0, r1, r2
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
  
  if((ep_addr & 0x80) == 0x80)
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8000930:	f891 003a 	ldrbne.w	r0, [r1, #58]	; 0x3a
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8000934:	f891 01de 	ldrbeq.w	r0, [r1, #478]	; 0x1de
  }
}
 8000938:	4770      	bx	lr

0800093a <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
 800093a:	b508      	push	{r3, lr}
  
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 800093c:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000940:	f000 fdd2 	bl	80014e8 <HAL_PCD_SetAddress>
  return USBD_OK; 
}
 8000944:	2000      	movs	r0, #0
 8000946:	bd08      	pop	{r3, pc}

08000948 <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
 8000948:	b508      	push	{r3, lr}

  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 800094a:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800094e:	f000 fe67 	bl	8001620 <HAL_PCD_EP_Transmit>
  return USBD_OK;   
}
 8000952:	2000      	movs	r0, #0
 8000954:	bd08      	pop	{r3, pc}

08000956 <USBD_LL_PrepareReceive>:
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,                                      
                                           uint8_t  *pbuf,
                                           uint16_t  size)
{
 8000956:	b508      	push	{r3, lr}

  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8000958:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800095c:	f000 fe27 	bl	80015ae <HAL_PCD_EP_Receive>
  return USBD_OK;   
}
 8000960:	2000      	movs	r0, #0
 8000962:	bd08      	pop	{r3, pc}

08000964 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr)  
{
 8000964:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
 8000966:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800096a:	f000 fe51 	bl	8001610 <HAL_PCD_EP_GetRxCount>
}
 800096e:	bd08      	pop	{r3, pc}

08000970 <USBD_FS_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_DeviceDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 8000970:	2312      	movs	r3, #18
 8000972:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 8000974:	4800      	ldr	r0, [pc, #0]	; (8000978 <USBD_FS_DeviceDescriptor+0x8>)
 8000976:	4770      	bx	lr
 8000978:	20000020 	.word	0x20000020

0800097c <USBD_FS_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_LangIDStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 800097c:	2304      	movs	r3, #4
 800097e:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8000980:	4800      	ldr	r0, [pc, #0]	; (8000984 <USBD_FS_LangIDStrDescriptor+0x8>)
 8000982:	4770      	bx	lr
 8000984:	2000001c 	.word	0x2000001c

08000988 <USBD_FS_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000988:	b510      	push	{r4, lr}
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 800098a:	4c04      	ldr	r4, [pc, #16]	; (800099c <USBD_FS_ManufacturerStrDescriptor+0x14>)
 800098c:	4804      	ldr	r0, [pc, #16]	; (80009a0 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 800098e:	460a      	mov	r2, r1
 8000990:	4621      	mov	r1, r4
 8000992:	f004 ff66 	bl	8005862 <USBD_GetString>
  return USBD_StrDesc;
}
 8000996:	4620      	mov	r0, r4
 8000998:	bd10      	pop	{r4, pc}
 800099a:	bf00      	nop
 800099c:	200008cc 	.word	0x200008cc
 80009a0:	08006a84 	.word	0x08006a84

080009a4 <USBD_FS_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ProductStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80009a4:	b510      	push	{r4, lr}
  if(speed == 0)
  {   
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 80009a6:	4c04      	ldr	r4, [pc, #16]	; (80009b8 <USBD_FS_ProductStrDescriptor+0x14>)
 80009a8:	4804      	ldr	r0, [pc, #16]	; (80009bc <USBD_FS_ProductStrDescriptor+0x18>)
 80009aa:	460a      	mov	r2, r1
 80009ac:	4621      	mov	r1, r4
 80009ae:	f004 ff58 	bl	8005862 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 80009b2:	4620      	mov	r0, r4
 80009b4:	bd10      	pop	{r4, pc}
 80009b6:	bf00      	nop
 80009b8:	200008cc 	.word	0x200008cc
 80009bc:	08006a97 	.word	0x08006a97

080009c0 <USBD_FS_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80009c0:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {    
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 80009c2:	4c04      	ldr	r4, [pc, #16]	; (80009d4 <USBD_FS_SerialStrDescriptor+0x14>)
 80009c4:	4804      	ldr	r0, [pc, #16]	; (80009d8 <USBD_FS_SerialStrDescriptor+0x18>)
 80009c6:	460a      	mov	r2, r1
 80009c8:	4621      	mov	r1, r4
 80009ca:	f004 ff4a 	bl	8005862 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 80009ce:	4620      	mov	r0, r4
 80009d0:	bd10      	pop	{r4, pc}
 80009d2:	bf00      	nop
 80009d4:	200008cc 	.word	0x200008cc
 80009d8:	08006aaa 	.word	0x08006aaa

080009dc <USBD_FS_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ConfigStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80009dc:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {  
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 80009de:	4c04      	ldr	r4, [pc, #16]	; (80009f0 <USBD_FS_ConfigStrDescriptor+0x14>)
 80009e0:	4804      	ldr	r0, [pc, #16]	; (80009f4 <USBD_FS_ConfigStrDescriptor+0x18>)
 80009e2:	460a      	mov	r2, r1
 80009e4:	4621      	mov	r1, r4
 80009e6:	f004 ff3c 	bl	8005862 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length); 
  }
  return USBD_StrDesc;  
}
 80009ea:	4620      	mov	r0, r4
 80009ec:	bd10      	pop	{r4, pc}
 80009ee:	bf00      	nop
 80009f0:	200008cc 	.word	0x200008cc
 80009f4:	08006ab7 	.word	0x08006ab7

080009f8 <USBD_FS_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_InterfaceStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80009f8:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80009fa:	4c04      	ldr	r4, [pc, #16]	; (8000a0c <USBD_FS_InterfaceStrDescriptor+0x14>)
 80009fc:	4804      	ldr	r0, [pc, #16]	; (8000a10 <USBD_FS_InterfaceStrDescriptor+0x18>)
 80009fe:	460a      	mov	r2, r1
 8000a00:	4621      	mov	r1, r4
 8000a02:	f004 ff2e 	bl	8005862 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;  
}
 8000a06:	4620      	mov	r0, r4
 8000a08:	bd10      	pop	{r4, pc}
 8000a0a:	bf00      	nop
 8000a0c:	200008cc 	.word	0x200008cc
 8000a10:	08006ac2 	.word	0x08006ac2

08000a14 <STORAGE_IsWriteProtected_FS>:
int8_t  STORAGE_IsWriteProtected_FS (uint8_t lun)
{
  /* USER CODE BEGIN 5 */ 
  return (USBD_OK);
  /* USER CODE END 5 */ 
}
 8000a14:	2000      	movs	r0, #0
 8000a16:	4770      	bx	lr

08000a18 <STORAGE_GetMaxLun_FS>:
int8_t STORAGE_GetMaxLun_FS (void)
{
  /* USER CODE BEGIN 8 */ 
  return (STORAGE_LUN_NBR - 1);
  /* USER CODE END 8 */ 
}
 8000a18:	2000      	movs	r0, #0
 8000a1a:	4770      	bx	lr

08000a1c <STORAGE_Write_FS>:
*******************************************************************************/
int8_t STORAGE_Write_FS (uint8_t lun, 
                         uint8_t *buf, 
                         uint32_t blk_addr,
                         uint16_t blk_len)
{
 8000a1c:	b513      	push	{r0, r1, r4, lr}
  /* USER CODE BEGIN 7 */ 
	 HAL_SD_WriteBlocks(&hsd, (uint32_t*)buf, (uint64_t)(blk_addr * BLOCK_SIZE), BLOCK_SIZE, blk_len);
 8000a1e:	2400      	movs	r4, #0
 8000a20:	9301      	str	r3, [sp, #4]
 8000a22:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a26:	9300      	str	r3, [sp, #0]
 8000a28:	0252      	lsls	r2, r2, #9
 8000a2a:	4623      	mov	r3, r4
 8000a2c:	4802      	ldr	r0, [pc, #8]	; (8000a38 <STORAGE_Write_FS+0x1c>)
 8000a2e:	f001 fe54 	bl	80026da <HAL_SD_WriteBlocks>
  return (USBD_OK);
  /* USER CODE END 7 */ 
}
 8000a32:	4620      	mov	r0, r4
 8000a34:	b002      	add	sp, #8
 8000a36:	bd10      	pop	{r4, pc}
 8000a38:	20000250 	.word	0x20000250

08000a3c <STORAGE_Read_FS>:
*******************************************************************************/
int8_t STORAGE_Read_FS (uint8_t lun, 
                        uint8_t *buf, 
                        uint32_t blk_addr,                       
                        uint16_t blk_len)
{
 8000a3c:	b513      	push	{r0, r1, r4, lr}
  /* USER CODE BEGIN 6 */ 
	 HAL_SD_ReadBlocks(&hsd, (uint32_t*)buf, (uint64_t)(blk_addr * BLOCK_SIZE), BLOCK_SIZE, blk_len);
 8000a3e:	2400      	movs	r4, #0
 8000a40:	9301      	str	r3, [sp, #4]
 8000a42:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a46:	9300      	str	r3, [sp, #0]
 8000a48:	0252      	lsls	r2, r2, #9
 8000a4a:	4623      	mov	r3, r4
 8000a4c:	4802      	ldr	r0, [pc, #8]	; (8000a58 <STORAGE_Read_FS+0x1c>)
 8000a4e:	f001 fd82 	bl	8002556 <HAL_SD_ReadBlocks>
  return (USBD_OK);
  /* USER CODE END 6 */ 
}
 8000a52:	4620      	mov	r0, r4
 8000a54:	b002      	add	sp, #8
 8000a56:	bd10      	pop	{r4, pc}
 8000a58:	20000250 	.word	0x20000250

08000a5c <STORAGE_IsReady_FS>:
* @brief  Checks whether the medium is ready.
  * @param  lun: Logical unit number
  * @retval Status (0: OK / -1: Error)
*******************************************************************************/
int8_t  STORAGE_IsReady_FS (uint8_t lun)
{
 8000a5c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN 4 */
	if(HAL_SD_GetCardStatus(&hsd,&SDCardInfo)==SD_TRANSFER_OK)
 8000a5e:	4902      	ldr	r1, [pc, #8]	; (8000a68 <STORAGE_IsReady_FS+0xc>)
 8000a60:	4802      	ldr	r0, [pc, #8]	; (8000a6c <STORAGE_IsReady_FS+0x10>)
 8000a62:	f001 ffe3 	bl	8002a2c <HAL_SD_GetCardStatus>
	{
      return (USBD_OK);
	}
  /* USER CODE END 4 */ 
}
 8000a66:	bd08      	pop	{r3, pc}
 8000a68:	200001f8 	.word	0x200001f8
 8000a6c:	20000250 	.word	0x20000250

08000a70 <STORAGE_GetCapacity_FS>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t STORAGE_GetCapacity_FS (uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
 8000a70:	b570      	push	{r4, r5, r6, lr}
  /* USER CODE BEGIN 3 */   
	HAL_SD_Get_CardInfo(&hsd, &SDCardInfo);
 8000a72:	4c09      	ldr	r4, [pc, #36]	; (8000a98 <STORAGE_GetCapacity_FS+0x28>)
 8000a74:	4809      	ldr	r0, [pc, #36]	; (8000a9c <STORAGE_GetCapacity_FS+0x2c>)
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t STORAGE_GetCapacity_FS (uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
 8000a76:	460e      	mov	r6, r1
  /* USER CODE BEGIN 3 */   
	HAL_SD_Get_CardInfo(&hsd, &SDCardInfo);
 8000a78:	4621      	mov	r1, r4
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t STORAGE_GetCapacity_FS (uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
 8000a7a:	4615      	mov	r5, r2
  /* USER CODE BEGIN 3 */   
	HAL_SD_Get_CardInfo(&hsd, &SDCardInfo);
 8000a7c:	f001 fa4c 	bl	8001f18 <HAL_SD_Get_CardInfo>
	  *block_num  = SDCardInfo.CardCapacity / BLOCK_SIZE;
 8000a80:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000a82:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8000a84:	0a5b      	lsrs	r3, r3, #9
 8000a86:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 8000a8a:	6033      	str	r3, [r6, #0]
	  *block_size = BLOCK_SIZE;
 8000a8c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a90:	802b      	strh	r3, [r5, #0]
  return (USBD_OK);
  /* USER CODE END 3 */ 
}
 8000a92:	2000      	movs	r0, #0
 8000a94:	bd70      	pop	{r4, r5, r6, pc}
 8000a96:	bf00      	nop
 8000a98:	200001f8 	.word	0x200001f8
 8000a9c:	20000250 	.word	0x20000250

08000aa0 <STORAGE_Init_FS>:
 8000aa0:	2000      	movs	r0, #0
 8000aa2:	4770      	bx	lr

08000aa4 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000aa4:	490f      	ldr	r1, [pc, #60]	; (8000ae4 <SystemInit+0x40>)
 8000aa6:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8000aaa:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000aae:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000ab2:	4b0d      	ldr	r3, [pc, #52]	; (8000ae8 <SystemInit+0x44>)
 8000ab4:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000ab6:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000ab8:	f042 0201 	orr.w	r2, r2, #1
 8000abc:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000abe:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000ac0:	681a      	ldr	r2, [r3, #0]
 8000ac2:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000ac6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000aca:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000acc:	4a07      	ldr	r2, [pc, #28]	; (8000aec <SystemInit+0x48>)
 8000ace:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000ad0:	681a      	ldr	r2, [r3, #0]
 8000ad2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000ad6:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000ad8:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000ada:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000ade:	608b      	str	r3, [r1, #8]
 8000ae0:	4770      	bx	lr
 8000ae2:	bf00      	nop
 8000ae4:	e000ed00 	.word	0xe000ed00
 8000ae8:	40023800 	.word	0x40023800
 8000aec:	24003010 	.word	0x24003010

08000af0 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000af0:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8000af2:	4b08      	ldr	r3, [pc, #32]	; (8000b14 <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000af4:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8000af6:	6818      	ldr	r0, [r3, #0]
 8000af8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000afc:	fbb0 f0f3 	udiv	r0, r0, r3
 8000b00:	f000 f892 	bl	8000c28 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8000b04:	2200      	movs	r2, #0
 8000b06:	4621      	mov	r1, r4
 8000b08:	f04f 30ff 	mov.w	r0, #4294967295
 8000b0c:	f000 f84c 	bl	8000ba8 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000b10:	2000      	movs	r0, #0
 8000b12:	bd10      	pop	{r4, pc}
 8000b14:	20000054 	.word	0x20000054

08000b18 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000b18:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8000b1a:	4b0b      	ldr	r3, [pc, #44]	; (8000b48 <HAL_Init+0x30>)
 8000b1c:	681a      	ldr	r2, [r3, #0]
 8000b1e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000b22:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 8000b24:	681a      	ldr	r2, [r3, #0]
 8000b26:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000b2a:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000b2c:	681a      	ldr	r2, [r3, #0]
 8000b2e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000b32:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000b34:	2003      	movs	r0, #3
 8000b36:	f000 f825 	bl	8000b84 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000b3a:	2000      	movs	r0, #0
 8000b3c:	f7ff ffd8 	bl	8000af0 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 8000b40:	f7ff fcde 	bl	8000500 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 8000b44:	2000      	movs	r0, #0
 8000b46:	bd08      	pop	{r3, pc}
 8000b48:	40023c00 	.word	0x40023c00

08000b4c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000b4c:	4a02      	ldr	r2, [pc, #8]	; (8000b58 <HAL_IncTick+0xc>)
 8000b4e:	6813      	ldr	r3, [r2, #0]
 8000b50:	3301      	adds	r3, #1
 8000b52:	6013      	str	r3, [r2, #0]
 8000b54:	4770      	bx	lr
 8000b56:	bf00      	nop
 8000b58:	20000acc 	.word	0x20000acc

08000b5c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000b5c:	4b01      	ldr	r3, [pc, #4]	; (8000b64 <HAL_GetTick+0x8>)
 8000b5e:	6818      	ldr	r0, [r3, #0]
}
 8000b60:	4770      	bx	lr
 8000b62:	bf00      	nop
 8000b64:	20000acc 	.word	0x20000acc

08000b68 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8000b68:	b513      	push	{r0, r1, r4, lr}
 8000b6a:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0U;
  tickstart = HAL_GetTick();
 8000b6c:	f7ff fff6 	bl	8000b5c <HAL_GetTick>
 8000b70:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8000b72:	f7ff fff3 	bl	8000b5c <HAL_GetTick>
 8000b76:	9b01      	ldr	r3, [sp, #4]
 8000b78:	1b00      	subs	r0, r0, r4
 8000b7a:	4298      	cmp	r0, r3
 8000b7c:	d3f9      	bcc.n	8000b72 <HAL_Delay+0xa>
  {
  }
}
 8000b7e:	b002      	add	sp, #8
 8000b80:	bd10      	pop	{r4, pc}
	...

08000b84 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000b84:	4a07      	ldr	r2, [pc, #28]	; (8000ba4 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000b86:	68d3      	ldr	r3, [r2, #12]
 8000b88:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000b8c:	041b      	lsls	r3, r3, #16
 8000b8e:	0c1b      	lsrs	r3, r3, #16
 8000b90:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000b94:	0200      	lsls	r0, r0, #8
 8000b96:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000b9a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8000b9e:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000ba0:	60d3      	str	r3, [r2, #12]
 8000ba2:	4770      	bx	lr
 8000ba4:	e000ed00 	.word	0xe000ed00

08000ba8 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000ba8:	4b17      	ldr	r3, [pc, #92]	; (8000c08 <HAL_NVIC_SetPriority+0x60>)
 8000baa:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000bac:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000bb0:	b530      	push	{r4, r5, lr}
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000bb2:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000bb6:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000bb8:	2c04      	cmp	r4, #4
 8000bba:	bf28      	it	cs
 8000bbc:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000bbe:	2d06      	cmp	r5, #6

  return (
 8000bc0:	f04f 0501 	mov.w	r5, #1
 8000bc4:	fa05 f404 	lsl.w	r4, r5, r4
 8000bc8:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000bcc:	bf8c      	ite	hi
 8000bce:	3b03      	subhi	r3, #3
 8000bd0:	2300      	movls	r3, #0

  return (
 8000bd2:	400c      	ands	r4, r1
 8000bd4:	409c      	lsls	r4, r3
 8000bd6:	fa05 f303 	lsl.w	r3, r5, r3
 8000bda:	3b01      	subs	r3, #1
 8000bdc:	401a      	ands	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000bde:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000be0:	ea42 0204 	orr.w	r2, r2, r4
 8000be4:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000be8:	bfaf      	iteee	ge
 8000bea:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bee:	f000 000f 	andlt.w	r0, r0, #15
 8000bf2:	4b06      	ldrlt	r3, [pc, #24]	; (8000c0c <HAL_NVIC_SetPriority+0x64>)
 8000bf4:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bf6:	bfa5      	ittet	ge
 8000bf8:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8000bfc:	b2d2      	uxtbge	r2, r2
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bfe:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000c00:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8000c04:	bd30      	pop	{r4, r5, pc}
 8000c06:	bf00      	nop
 8000c08:	e000ed00 	.word	0xe000ed00
 8000c0c:	e000ed14 	.word	0xe000ed14

08000c10 <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000c10:	0942      	lsrs	r2, r0, #5
 8000c12:	2301      	movs	r3, #1
 8000c14:	f000 001f 	and.w	r0, r0, #31
 8000c18:	fa03 f000 	lsl.w	r0, r3, r0
 8000c1c:	4b01      	ldr	r3, [pc, #4]	; (8000c24 <HAL_NVIC_EnableIRQ+0x14>)
 8000c1e:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8000c22:	4770      	bx	lr
 8000c24:	e000e100 	.word	0xe000e100

08000c28 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000c28:	3801      	subs	r0, #1
 8000c2a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000c2e:	d20a      	bcs.n	8000c46 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000c30:	4b06      	ldr	r3, [pc, #24]	; (8000c4c <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000c32:	4a07      	ldr	r2, [pc, #28]	; (8000c50 <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000c34:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000c36:	21f0      	movs	r1, #240	; 0xf0
 8000c38:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000c3c:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000c3e:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000c40:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000c42:	601a      	str	r2, [r3, #0]
 8000c44:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8000c46:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000c48:	4770      	bx	lr
 8000c4a:	bf00      	nop
 8000c4c:	e000e010 	.word	0xe000e010
 8000c50:	e000ed00 	.word	0xe000ed00

08000c54 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8000c54:	4b04      	ldr	r3, [pc, #16]	; (8000c68 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000c56:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000c58:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000c5a:	bf0c      	ite	eq
 8000c5c:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000c60:	f022 0204 	bicne.w	r2, r2, #4
 8000c64:	601a      	str	r2, [r3, #0]
 8000c66:	4770      	bx	lr
 8000c68:	e000e010 	.word	0xe000e010

08000c6c <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000c6c:	4770      	bx	lr

08000c6e <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8000c6e:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8000c70:	f7ff fffc 	bl	8000c6c <HAL_SYSTICK_Callback>
 8000c74:	bd08      	pop	{r3, pc}

08000c76 <HAL_DMA_Abort_IT>:
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8000c76:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8000c7a:	2b02      	cmp	r3, #2
 8000c7c:	d003      	beq.n	8000c86 <HAL_DMA_Abort_IT+0x10>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000c7e:	2380      	movs	r3, #128	; 0x80
 8000c80:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8000c82:	2001      	movs	r0, #1
 8000c84:	4770      	bx	lr
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8000c86:	6802      	ldr	r2, [r0, #0]
    return HAL_ERROR;
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 8000c88:	2305      	movs	r3, #5
 8000c8a:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8000c8e:	6813      	ldr	r3, [r2, #0]
 8000c90:	f023 0301 	bic.w	r3, r3, #1
 8000c94:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8000c96:	2000      	movs	r0, #0
}
 8000c98:	4770      	bx	lr
	...

08000c9c <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000c9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000ca0:	4f6a      	ldr	r7, [pc, #424]	; (8000e4c <HAL_GPIO_Init+0x1b0>)
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000ca2:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000ca4:	f8df c1ac 	ldr.w	ip, [pc, #428]	; 8000e54 <HAL_GPIO_Init+0x1b8>

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000ca8:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 8000e58 <HAL_GPIO_Init+0x1bc>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000cac:	b085      	sub	sp, #20
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000cae:	2200      	movs	r2, #0
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000cb0:	9301      	str	r3, [sp, #4]
 8000cb2:	46be      	mov	lr, r7

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8000cb4:	2401      	movs	r4, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8000cb6:	9b01      	ldr	r3, [sp, #4]

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8000cb8:	4094      	lsls	r4, r2
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8000cba:	ea34 0303 	bics.w	r3, r4, r3
 8000cbe:	f040 80bd 	bne.w	8000e3c <HAL_GPIO_Init+0x1a0>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000cc2:	684d      	ldr	r5, [r1, #4]
 8000cc4:	f025 0a10 	bic.w	sl, r5, #16
 8000cc8:	f1ba 0f02 	cmp.w	sl, #2
 8000ccc:	d114      	bne.n	8000cf8 <HAL_GPIO_Init+0x5c>
 8000cce:	ea4f 09d2 	mov.w	r9, r2, lsr #3
 8000cd2:	eb00 0989 	add.w	r9, r0, r9, lsl #2
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8000cd6:	f002 0b07 	and.w	fp, r2, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8000cda:	f8d9 6020 	ldr.w	r6, [r9, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8000cde:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8000ce2:	230f      	movs	r3, #15
 8000ce4:	fa03 f30b 	lsl.w	r3, r3, fp
 8000ce8:	ea26 0603 	bic.w	r6, r6, r3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 8000cec:	690b      	ldr	r3, [r1, #16]
 8000cee:	fa03 f30b 	lsl.w	r3, r3, fp
 8000cf2:	4333      	orrs	r3, r6
        GPIOx->AFR[position >> 3U] = temp;
 8000cf4:	f8c9 3020 	str.w	r3, [r9, #32]
 8000cf8:	ea4f 0b42 	mov.w	fp, r2, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000cfc:	f04f 0903 	mov.w	r9, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8000d00:	6803      	ldr	r3, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000d02:	fa09 f90b 	lsl.w	r9, r9, fp
 8000d06:	ea6f 0909 	mvn.w	r9, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000d0a:	f005 0603 	and.w	r6, r5, #3
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000d0e:	ea03 0309 	and.w	r3, r3, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000d12:	fa06 f60b 	lsl.w	r6, r6, fp
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000d16:	f10a 3aff 	add.w	sl, sl, #4294967295
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000d1a:	4333      	orrs	r3, r6
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000d1c:	f1ba 0f01 	cmp.w	sl, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;
 8000d20:	6003      	str	r3, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000d22:	d80f      	bhi.n	8000d44 <HAL_GPIO_Init+0xa8>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8000d24:	6883      	ldr	r3, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000d26:	68ce      	ldr	r6, [r1, #12]
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000d28:	ea09 0303 	and.w	r3, r9, r3
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000d2c:	fa06 f60b 	lsl.w	r6, r6, fp
 8000d30:	431e      	orrs	r6, r3
        GPIOx->OSPEEDR = temp;
 8000d32:	6086      	str	r6, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000d34:	6843      	ldr	r3, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000d36:	f3c5 1600 	ubfx	r6, r5, #4, #1
        temp |= (GPIO_Init->Speed << (position * 2U));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000d3a:	ea23 0304 	bic.w	r3, r3, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000d3e:	4096      	lsls	r6, r2
 8000d40:	4333      	orrs	r3, r6
        GPIOx->OTYPER = temp;
 8000d42:	6043      	str	r3, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000d44:	68c3      	ldr	r3, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8000d46:	ea09 0903 	and.w	r9, r9, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000d4a:	688b      	ldr	r3, [r1, #8]
 8000d4c:	fa03 f30b 	lsl.w	r3, r3, fp
 8000d50:	ea43 0309 	orr.w	r3, r3, r9
      GPIOx->PUPDR = temp;
 8000d54:	60c3      	str	r3, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000d56:	00eb      	lsls	r3, r5, #3
 8000d58:	d570      	bpl.n	8000e3c <HAL_GPIO_Init+0x1a0>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d5a:	2300      	movs	r3, #0
 8000d5c:	9303      	str	r3, [sp, #12]
 8000d5e:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000d62:	4b3b      	ldr	r3, [pc, #236]	; (8000e50 <HAL_GPIO_Init+0x1b4>)
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d64:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
 8000d68:	f8cc 6044 	str.w	r6, [ip, #68]	; 0x44
 8000d6c:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44
 8000d70:	f022 0903 	bic.w	r9, r2, #3
 8000d74:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
 8000d78:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8000d7c:	f509 399c 	add.w	r9, r9, #79872	; 0x13800
 8000d80:	9603      	str	r6, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8000d82:	f002 0a03 	and.w	sl, r2, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d86:	9e03      	ldr	r6, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8000d88:	f8d9 b008 	ldr.w	fp, [r9, #8]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8000d8c:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8000d90:	260f      	movs	r6, #15
 8000d92:	fa06 f60a 	lsl.w	r6, r6, sl
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000d96:	4298      	cmp	r0, r3
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8000d98:	ea2b 0606 	bic.w	r6, fp, r6
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000d9c:	d01c      	beq.n	8000dd8 <HAL_GPIO_Init+0x13c>
 8000d9e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000da2:	4298      	cmp	r0, r3
 8000da4:	d01a      	beq.n	8000ddc <HAL_GPIO_Init+0x140>
 8000da6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000daa:	4298      	cmp	r0, r3
 8000dac:	d018      	beq.n	8000de0 <HAL_GPIO_Init+0x144>
 8000dae:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000db2:	4298      	cmp	r0, r3
 8000db4:	d016      	beq.n	8000de4 <HAL_GPIO_Init+0x148>
 8000db6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000dba:	4298      	cmp	r0, r3
 8000dbc:	d014      	beq.n	8000de8 <HAL_GPIO_Init+0x14c>
 8000dbe:	4540      	cmp	r0, r8
 8000dc0:	d014      	beq.n	8000dec <HAL_GPIO_Init+0x150>
 8000dc2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8000dc6:	4298      	cmp	r0, r3
 8000dc8:	d012      	beq.n	8000df0 <HAL_GPIO_Init+0x154>
 8000dca:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000dce:	4298      	cmp	r0, r3
 8000dd0:	bf14      	ite	ne
 8000dd2:	2308      	movne	r3, #8
 8000dd4:	2307      	moveq	r3, #7
 8000dd6:	e00c      	b.n	8000df2 <HAL_GPIO_Init+0x156>
 8000dd8:	2300      	movs	r3, #0
 8000dda:	e00a      	b.n	8000df2 <HAL_GPIO_Init+0x156>
 8000ddc:	2301      	movs	r3, #1
 8000dde:	e008      	b.n	8000df2 <HAL_GPIO_Init+0x156>
 8000de0:	2302      	movs	r3, #2
 8000de2:	e006      	b.n	8000df2 <HAL_GPIO_Init+0x156>
 8000de4:	2303      	movs	r3, #3
 8000de6:	e004      	b.n	8000df2 <HAL_GPIO_Init+0x156>
 8000de8:	2304      	movs	r3, #4
 8000dea:	e002      	b.n	8000df2 <HAL_GPIO_Init+0x156>
 8000dec:	2305      	movs	r3, #5
 8000dee:	e000      	b.n	8000df2 <HAL_GPIO_Init+0x156>
 8000df0:	2306      	movs	r3, #6
 8000df2:	fa03 f30a 	lsl.w	r3, r3, sl
 8000df6:	4333      	orrs	r3, r6
        SYSCFG->EXTICR[position >> 2U] = temp;
 8000df8:	f8c9 3008 	str.w	r3, [r9, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000dfc:	683b      	ldr	r3, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 8000dfe:	43e6      	mvns	r6, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000e00:	f415 3f80 	tst.w	r5, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8000e04:	bf0c      	ite	eq
 8000e06:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8000e08:	4323      	orrne	r3, r4
        }
        EXTI->IMR = temp;
 8000e0a:	f8ce 3000 	str.w	r3, [lr]

        temp = EXTI->EMR;
 8000e0e:	f8de 3004 	ldr.w	r3, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000e12:	f415 3f00 	tst.w	r5, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 8000e16:	bf0c      	ite	eq
 8000e18:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8000e1a:	4323      	orrne	r3, r4
        }
        EXTI->EMR = temp;
 8000e1c:	607b      	str	r3, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000e1e:	68bb      	ldr	r3, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000e20:	f415 1f80 	tst.w	r5, #1048576	; 0x100000
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 8000e24:	bf0c      	ite	eq
 8000e26:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8000e28:	4323      	orrne	r3, r4
        }
        EXTI->RTSR = temp;
 8000e2a:	f8ce 3008 	str.w	r3, [lr, #8]

        temp = EXTI->FTSR;
 8000e2e:	f8de 300c 	ldr.w	r3, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000e32:	02ad      	lsls	r5, r5, #10
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 8000e34:	bf54      	ite	pl
 8000e36:	4033      	andpl	r3, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8000e38:	4323      	orrmi	r3, r4
        }
        EXTI->FTSR = temp;
 8000e3a:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000e3c:	3201      	adds	r2, #1
 8000e3e:	2a10      	cmp	r2, #16
 8000e40:	f47f af38 	bne.w	8000cb4 <HAL_GPIO_Init+0x18>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8000e44:	b005      	add	sp, #20
 8000e46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000e4a:	bf00      	nop
 8000e4c:	40013c00 	.word	0x40013c00
 8000e50:	40020000 	.word	0x40020000
 8000e54:	40023800 	.word	0x40023800
 8000e58:	40021400 	.word	0x40021400

08000e5c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000e5c:	b902      	cbnz	r2, 8000e60 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8000e5e:	0409      	lsls	r1, r1, #16
 8000e60:	6181      	str	r1, [r0, #24]
 8000e62:	4770      	bx	lr

08000e64 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8000e64:	6943      	ldr	r3, [r0, #20]
 8000e66:	4059      	eors	r1, r3
 8000e68:	6141      	str	r1, [r0, #20]
 8000e6a:	4770      	bx	lr

08000e6c <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8000e6c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8000e6e:	4606      	mov	r6, r0
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8000e70:	b08b      	sub	sp, #44	; 0x2c
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8000e72:	2800      	cmp	r0, #0
 8000e74:	d063      	beq.n	8000f3e <HAL_PCD_Init+0xd2>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8000e76:	2303      	movs	r3, #3
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8000e78:	4634      	mov	r4, r6
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8000e7a:	f880 3381 	strb.w	r3, [r0, #897]	; 0x381
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);
 8000e7e:	f7ff fc47 	bl	8000710 <HAL_PCD_MspInit>

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8000e82:	f854 0b10 	ldr.w	r0, [r4], #16
 8000e86:	f002 f8ea 	bl	800305e <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8000e8a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000e8c:	466d      	mov	r5, sp
 8000e8e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000e90:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000e92:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000e94:	e894 0003 	ldmia.w	r4, {r0, r1}
 8000e98:	e885 0003 	stmia.w	r5, {r0, r1}
 8000e9c:	1d37      	adds	r7, r6, #4
 8000e9e:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8000ea2:	6830      	ldr	r0, [r6, #0]
 8000ea4:	f002 f89f 	bl	8002fe6 <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8000ea8:	2100      	movs	r1, #0
 8000eaa:	6830      	ldr	r0, [r6, #0]
 8000eac:	f002 f8dd 	bl	800306a <USB_SetCurrentMode>
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000eb0:	2100      	movs	r1, #0
 8000eb2:	4633      	mov	r3, r6
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8000eb4:	4632      	mov	r2, r6
 8000eb6:	f106 0410 	add.w	r4, r6, #16
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8000eba:	2501      	movs	r5, #1
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000ebc:	4608      	mov	r0, r1
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
   hpcd->IN_ep[i].num = i;
 8000ebe:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000ec2:	87d1      	strh	r1, [r2, #62]	; 0x3e
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000ec4:	3101      	adds	r1, #1
 8000ec6:	290f      	cmp	r1, #15
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8000ec8:	f882 5039 	strb.w	r5, [r2, #57]	; 0x39
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000ecc:	f882 003b 	strb.w	r0, [r2, #59]	; 0x3b
   hpcd->IN_ep[i].maxpacket = 0U;
 8000ed0:	6410      	str	r0, [r2, #64]	; 0x40
   hpcd->IN_ep[i].xfer_buff = 0U;
 8000ed2:	6450      	str	r0, [r2, #68]	; 0x44
   hpcd->IN_ep[i].xfer_len = 0U;
 8000ed4:	64d0      	str	r0, [r2, #76]	; 0x4c
 8000ed6:	f102 021c 	add.w	r2, r2, #28
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000eda:	d1f0      	bne.n	8000ebe <HAL_PCD_Init+0x52>
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000edc:	2200      	movs	r2, #0
 8000ede:	f8d6 e000 	ldr.w	lr, [r6]
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
 8000ee2:	4611      	mov	r1, r2
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000ee4:	f102 0040 	add.w	r0, r2, #64	; 0x40
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
   hpcd->OUT_ep[i].num = i;
 8000ee8:	f883 21dc 	strb.w	r2, [r3, #476]	; 0x1dc
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000eec:	87da      	strh	r2, [r3, #62]	; 0x3e
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000eee:	eb0e 0080 	add.w	r0, lr, r0, lsl #2
   hpcd->IN_ep[i].maxpacket = 0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 8000ef2:	3201      	adds	r2, #1
 8000ef4:	2a0f      	cmp	r2, #15
 {
   hpcd->OUT_ep[i].is_in = 0U;
 8000ef6:	f883 11dd 	strb.w	r1, [r3, #477]	; 0x1dd
   hpcd->OUT_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8000efa:	f883 11df 	strb.w	r1, [r3, #479]	; 0x1df
   hpcd->OUT_ep[i].maxpacket = 0U;
 8000efe:	f8c3 11e4 	str.w	r1, [r3, #484]	; 0x1e4
   hpcd->OUT_ep[i].xfer_buff = 0U;
 8000f02:	f8c3 11e8 	str.w	r1, [r3, #488]	; 0x1e8
   hpcd->OUT_ep[i].xfer_len = 0U;
 8000f06:	f8c3 11f0 	str.w	r1, [r3, #496]	; 0x1f0
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000f0a:	6041      	str	r1, [r0, #4]
 8000f0c:	f103 031c 	add.w	r3, r3, #28
   hpcd->IN_ep[i].maxpacket = 0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 8000f10:	d1e8      	bne.n	8000ee4 <HAL_PCD_Init+0x78>
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 8000f12:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000f14:	466d      	mov	r5, sp
 8000f16:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000f18:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000f1a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000f1c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8000f20:	e885 0003 	stmia.w	r5, {r0, r1}
 8000f24:	4670      	mov	r0, lr
 8000f26:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8000f2a:	f002 f8b5 	bl	8003098 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 8000f2e:	2301      	movs	r3, #1
 8000f30:	f886 3381 	strb.w	r3, [r6, #897]	; 0x381
 {
   HAL_PCDEx_ActivateBCD(hpcd);
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 8000f34:	6830      	ldr	r0, [r6, #0]
 8000f36:	f002 fc7a 	bl	800382e <USB_DevDisconnect>
 return HAL_OK;
 8000f3a:	2000      	movs	r0, #0
 8000f3c:	e000      	b.n	8000f40 <HAL_PCD_Init+0xd4>
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
  {
    return HAL_ERROR;
 8000f3e:	2001      	movs	r0, #1
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 return HAL_OK;
}
 8000f40:	b00b      	add	sp, #44	; 0x2c
 8000f42:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000f44 <HAL_PCD_Start>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8000f44:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8000f48:	2b01      	cmp	r3, #1
  * @brief  Start The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
 8000f4a:	b510      	push	{r4, lr}
 8000f4c:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8000f4e:	d00c      	beq.n	8000f6a <HAL_PCD_Start+0x26>
 8000f50:	2301      	movs	r3, #1
 8000f52:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_DevConnect (hpcd->Instance);  
 8000f56:	6800      	ldr	r0, [r0, #0]
 8000f58:	f002 fc5d 	bl	8003816 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 8000f5c:	6820      	ldr	r0, [r4, #0]
 8000f5e:	f002 f878 	bl	8003052 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 8000f62:	2000      	movs	r0, #0
 8000f64:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8000f68:	bd10      	pop	{r4, pc}
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8000f6a:	2002      	movs	r0, #2
  USB_DevConnect (hpcd->Instance);  
  __HAL_PCD_ENABLE(hpcd);
  __HAL_UNLOCK(hpcd); 
  return HAL_OK;
}
 8000f6c:	bd10      	pop	{r4, pc}

08000f6e <HAL_PCD_Stop>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8000f6e:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8000f72:	2b01      	cmp	r3, #1
  * @brief  Stop The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
 8000f74:	b510      	push	{r4, lr}
 8000f76:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8000f78:	d00f      	beq.n	8000f9a <HAL_PCD_Stop+0x2c>
 8000f7a:	2301      	movs	r3, #1
 8000f7c:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  __HAL_PCD_DISABLE(hpcd);
 8000f80:	6800      	ldr	r0, [r0, #0]
 8000f82:	f002 f86c 	bl	800305e <USB_DisableGlobalInt>
  USB_StopDevice(hpcd->Instance);
 8000f86:	6820      	ldr	r0, [r4, #0]
 8000f88:	f002 fc14 	bl	80037b4 <USB_StopDevice>
  USB_DevDisconnect(hpcd->Instance);
 8000f8c:	6820      	ldr	r0, [r4, #0]
 8000f8e:	f002 fc4e 	bl	800382e <USB_DevDisconnect>
  __HAL_UNLOCK(hpcd); 
 8000f92:	2000      	movs	r0, #0
 8000f94:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
 8000f98:	bd10      	pop	{r4, pc}
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8000f9a:	2002      	movs	r0, #2
  __HAL_PCD_DISABLE(hpcd);
  USB_StopDevice(hpcd->Instance);
  USB_DevDisconnect(hpcd->Instance);
  __HAL_UNLOCK(hpcd); 
  return HAL_OK;
}
 8000f9c:	bd10      	pop	{r4, pc}
	...

08000fa0 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000fa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000fa4:	f8d0 a000 	ldr.w	sl, [r0]
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000fa8:	b087      	sub	sp, #28
 8000faa:	4604      	mov	r4, r0
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8000fac:	4650      	mov	r0, sl
 8000fae:	f002 fc78 	bl	80038a2 <USB_GetMode>
 8000fb2:	2800      	cmp	r0, #0
 8000fb4:	f040 8277 	bne.w	80014a6 <HAL_PCD_IRQHandler+0x506>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 8000fb8:	6820      	ldr	r0, [r4, #0]
 8000fba:	f002 fc44 	bl	8003846 <USB_ReadInterrupts>
 8000fbe:	2800      	cmp	r0, #0
 8000fc0:	f000 8271 	beq.w	80014a6 <HAL_PCD_IRQHandler+0x506>
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8000fc4:	6820      	ldr	r0, [r4, #0]
 8000fc6:	f002 fc3e 	bl	8003846 <USB_ReadInterrupts>
 8000fca:	0785      	lsls	r5, r0, #30
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000fcc:	bf48      	it	mi
 8000fce:	6822      	ldrmi	r2, [r4, #0]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8000fd0:	6820      	ldr	r0, [r4, #0]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000fd2:	bf42      	ittt	mi
 8000fd4:	6953      	ldrmi	r3, [r2, #20]
 8000fd6:	f003 0302 	andmi.w	r3, r3, #2
 8000fda:	6153      	strmi	r3, [r2, #20]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8000fdc:	f002 fc33 	bl	8003846 <USB_ReadInterrupts>
 8000fe0:	f410 2000 	ands.w	r0, r0, #524288	; 0x80000
 8000fe4:	d04a      	beq.n	800107c <HAL_PCD_IRQHandler+0xdc>
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8000fe6:	6820      	ldr	r0, [r4, #0]
 8000fe8:	f002 fc31 	bl	800384e <USB_ReadDevAllOutEpInterrupt>
 8000fec:	f50a 6630 	add.w	r6, sl, #2816	; 0xb00
 8000ff0:	4607      	mov	r7, r0
 8000ff2:	46a1      	mov	r9, r4
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0U;
 8000ff4:	2500      	movs	r5, #0
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
 8000ff6:	2f00      	cmp	r7, #0
 8000ff8:	d041      	beq.n	800107e <HAL_PCD_IRQHandler+0xde>
      {
        if (ep_intr & 0x1U)
 8000ffa:	07f8      	lsls	r0, r7, #31
 8000ffc:	d538      	bpl.n	8001070 <HAL_PCD_IRQHandler+0xd0>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8000ffe:	fa5f fb85 	uxtb.w	fp, r5
 8001002:	4659      	mov	r1, fp
 8001004:	6820      	ldr	r0, [r4, #0]
 8001006:	f002 fc32 	bl	800386e <USB_ReadDevOutEPInterrupt>
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 800100a:	f010 0f01 	tst.w	r0, #1
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U)
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 800100e:	4680      	mov	r8, r0
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8001010:	d021      	beq.n	8001056 <HAL_PCD_IRQHandler+0xb6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
            
            if(hpcd->Init.dma_enable == 1U)
 8001012:	6921      	ldr	r1, [r4, #16]
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8001014:	2301      	movs	r3, #1
            
            if(hpcd->Init.dma_enable == 1U)
 8001016:	4299      	cmp	r1, r3
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8001018:	60b3      	str	r3, [r6, #8]
            
            if(hpcd->Init.dma_enable == 1U)
 800101a:	d10c      	bne.n	8001036 <HAL_PCD_IRQHandler+0x96>
            {
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 800101c:	6931      	ldr	r1, [r6, #16]
 800101e:	f8d9 01e4 	ldr.w	r0, [r9, #484]	; 0x1e4
 8001022:	f3c1 0112 	ubfx	r1, r1, #0, #19
 8001026:	1a41      	subs	r1, r0, r1
 8001028:	f8c9 11f4 	str.w	r1, [r9, #500]	; 0x1f4
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 800102c:	f8d9 11e8 	ldr.w	r1, [r9, #488]	; 0x1e8
 8001030:	4408      	add	r0, r1
 8001032:	f8c9 01e8 	str.w	r0, [r9, #488]	; 0x1e8
            }
            
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
 8001036:	4659      	mov	r1, fp
 8001038:	4620      	mov	r0, r4
 800103a:	f7ff fbb5 	bl	80007a8 <HAL_PCD_DataOutStageCallback>
            if(hpcd->Init.dma_enable == 1U)
 800103e:	6921      	ldr	r1, [r4, #16]
 8001040:	2901      	cmp	r1, #1
 8001042:	d108      	bne.n	8001056 <HAL_PCD_IRQHandler+0xb6>
            {
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8001044:	b93d      	cbnz	r5, 8001056 <HAL_PCD_IRQHandler+0xb6>
 8001046:	f8d4 21f0 	ldr.w	r2, [r4, #496]	; 0x1f0
 800104a:	b922      	cbnz	r2, 8001056 <HAL_PCD_IRQHandler+0xb6>
              {
                 /* this is ZLP, so prepare EP0 for next setup */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800104c:	f504 7261 	add.w	r2, r4, #900	; 0x384
 8001050:	6820      	ldr	r0, [r4, #0]
 8001052:	f002 fc45 	bl	80038e0 <USB_EP0_OutStart>
              }              
            }
          }
          
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8001056:	f018 0f08 	tst.w	r8, #8
 800105a:	d004      	beq.n	8001066 <HAL_PCD_IRQHandler+0xc6>
          {
            /* Inform the upper layer that a setup packet is available */
            HAL_PCD_SetupStageCallback(hpcd);
 800105c:	4620      	mov	r0, r4
 800105e:	f7ff fb9d 	bl	800079c <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8001062:	2308      	movs	r3, #8
 8001064:	60b3      	str	r3, [r6, #8]
          }
          
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8001066:	f018 0f10 	tst.w	r8, #16
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800106a:	bf1c      	itt	ne
 800106c:	2310      	movne	r3, #16
 800106e:	60b3      	strne	r3, [r6, #8]
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
          }
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        }
        epnum++;
 8001070:	3501      	adds	r5, #1
        ep_intr >>= 1U;
 8001072:	087f      	lsrs	r7, r7, #1
 8001074:	3620      	adds	r6, #32
 8001076:	f109 091c 	add.w	r9, r9, #28
 800107a:	e7bc      	b.n	8000ff6 <HAL_PCD_IRQHandler+0x56>
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
  uint32_t i = 0U, ep_intr = 0U, epint = 0U, epnum = 0U;
 800107c:	4605      	mov	r5, r0
        epnum++;
        ep_intr >>= 1U;
      }
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 800107e:	6820      	ldr	r0, [r4, #0]
 8001080:	f002 fbe1 	bl	8003846 <USB_ReadInterrupts>
 8001084:	0341      	lsls	r1, r0, #13
 8001086:	f140 809b 	bpl.w	80011c0 <HAL_PCD_IRQHandler+0x220>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 800108a:	6820      	ldr	r0, [r4, #0]
 800108c:	f002 fbe7 	bl	800385e <USB_ReadDevAllInEpInterrupt>
 8001090:	4626      	mov	r6, r4
 8001092:	9003      	str	r0, [sp, #12]
 8001094:	f50a 6810 	add.w	r8, sl, #2304	; 0x900
      
      epnum = 0U;
 8001098:	2500      	movs	r5, #0
      
      while ( ep_intr )
 800109a:	9b03      	ldr	r3, [sp, #12]
 800109c:	2b00      	cmp	r3, #0
 800109e:	f000 808f 	beq.w	80011c0 <HAL_PCD_IRQHandler+0x220>
      {
        if (ep_intr & 0x1U) /* In ITR */
 80010a2:	9b03      	ldr	r3, [sp, #12]
 80010a4:	07da      	lsls	r2, r3, #31
 80010a6:	f140 8083 	bpl.w	80011b0 <HAL_PCD_IRQHandler+0x210>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 80010aa:	fa5f f985 	uxtb.w	r9, r5
 80010ae:	4649      	mov	r1, r9
 80010b0:	6820      	ldr	r0, [r4, #0]
 80010b2:	f002 fbe6 	bl	8003882 <USB_ReadDevInEPInterrupt>

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 80010b6:	07c3      	lsls	r3, r0, #31
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U) /* In ITR */
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 80010b8:	4607      	mov	r7, r0

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 80010ba:	d520      	bpl.n	80010fe <HAL_PCD_IRQHandler+0x15e>
          {
            fifoemptymsk = 0x1U << epnum;
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80010bc:	f8da 3834 	ldr.w	r3, [sl, #2100]	; 0x834
 80010c0:	2101      	movs	r1, #1
 80010c2:	40a9      	lsls	r1, r5
 80010c4:	ea23 0301 	bic.w	r3, r3, r1
 80010c8:	f8ca 3834 	str.w	r3, [sl, #2100]	; 0x834
            
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 80010cc:	2301      	movs	r3, #1
 80010ce:	f8c8 3008 	str.w	r3, [r8, #8]
            
            if (hpcd->Init.dma_enable == 1U)
 80010d2:	6923      	ldr	r3, [r4, #16]
 80010d4:	2b01      	cmp	r3, #1
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 80010d6:	bf01      	itttt	eq
 80010d8:	6c72      	ldreq	r2, [r6, #68]	; 0x44
 80010da:	6c33      	ldreq	r3, [r6, #64]	; 0x40
 80010dc:	189b      	addeq	r3, r3, r2
 80010de:	6473      	streq	r3, [r6, #68]	; 0x44
            }
                                      
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 80010e0:	4649      	mov	r1, r9
 80010e2:	4620      	mov	r0, r4
 80010e4:	f7ff fb69 	bl	80007ba <HAL_PCD_DataInStageCallback>

            if (hpcd->Init.dma_enable == 1U)
 80010e8:	6921      	ldr	r1, [r4, #16]
 80010ea:	2901      	cmp	r1, #1
 80010ec:	d107      	bne.n	80010fe <HAL_PCD_IRQHandler+0x15e>
            {
              /* this is ZLP, so prepare EP0 for next setup */
              if((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 80010ee:	b935      	cbnz	r5, 80010fe <HAL_PCD_IRQHandler+0x15e>
 80010f0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80010f2:	b923      	cbnz	r3, 80010fe <HAL_PCD_IRQHandler+0x15e>
              {
                /* prepare to rx more setup packets */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80010f4:	f504 7261 	add.w	r2, r4, #900	; 0x384
 80010f8:	6820      	ldr	r0, [r4, #0]
 80010fa:	f002 fbf1 	bl	80038e0 <USB_EP0_OutStart>
              }
            }           
          }
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 80010fe:	0738      	lsls	r0, r7, #28
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8001100:	bf44      	itt	mi
 8001102:	2308      	movmi	r3, #8
 8001104:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8001108:	06f9      	lsls	r1, r7, #27
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 800110a:	bf44      	itt	mi
 800110c:	2310      	movmi	r3, #16
 800110e:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8001112:	067a      	lsls	r2, r7, #25
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8001114:	bf44      	itt	mi
 8001116:	2340      	movmi	r3, #64	; 0x40
 8001118:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 800111c:	07bb      	lsls	r3, r7, #30
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 800111e:	bf44      	itt	mi
 8001120:	2302      	movmi	r3, #2
 8001122:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }       
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8001126:	063f      	lsls	r7, r7, #24
 8001128:	d542      	bpl.n	80011b0 <HAL_PCD_IRQHandler+0x210>
  * @param  epnum : endpoint number   
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 800112a:	6823      	ldr	r3, [r4, #0]
 800112c:	9304      	str	r3, [sp, #16]
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 800112e:	6d37      	ldr	r7, [r6, #80]	; 0x50
 8001130:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 8001132:	1bdb      	subs	r3, r3, r7
  
  if (len > ep->maxpacket)
 8001134:	6c37      	ldr	r7, [r6, #64]	; 0x40
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 8001136:	429f      	cmp	r7, r3
 8001138:	bf28      	it	cs
 800113a:	461f      	movcs	r7, r3
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 800113c:	9b04      	ldr	r3, [sp, #16]
 800113e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3U) / 4U;
 8001142:	f107 0b03 	add.w	fp, r7, #3
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8001146:	eb03 1345 	add.w	r3, r3, r5, lsl #5
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3U) / 4U;
 800114a:	ea4f 0b9b 	mov.w	fp, fp, lsr #2
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 800114e:	9305      	str	r3, [sp, #20]
 8001150:	9b05      	ldr	r3, [sp, #20]
 8001152:	699b      	ldr	r3, [r3, #24]
 8001154:	b29b      	uxth	r3, r3
 8001156:	455b      	cmp	r3, fp
 8001158:	d80c      	bhi.n	8001174 <HAL_PCD_IRQHandler+0x1d4>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
  }
  
  if(len <= 0U)
 800115a:	bb4f      	cbnz	r7, 80011b0 <HAL_PCD_IRQHandler+0x210>
  {
    fifoemptymsk = 0x1U << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800115c:	9b04      	ldr	r3, [sp, #16]
 800115e:	2201      	movs	r2, #1
 8001160:	f503 6900 	add.w	r9, r3, #2048	; 0x800
 8001164:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
 8001168:	40aa      	lsls	r2, r5
 800116a:	ea23 0302 	bic.w	r3, r3, r2
 800116e:	f8c9 3034 	str.w	r3, [r9, #52]	; 0x34
 8001172:	e01d      	b.n	80011b0 <HAL_PCD_IRQHandler+0x210>
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
          ep->xfer_count < ep->xfer_len &&
 8001174:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8001176:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8001178:	4293      	cmp	r3, r2
 800117a:	d9ee      	bls.n	800115a <HAL_PCD_IRQHandler+0x1ba>
          ep->xfer_count < ep->xfer_len &&
 800117c:	2b00      	cmp	r3, #0
 800117e:	d0ec      	beq.n	800115a <HAL_PCD_IRQHandler+0x1ba>
            ep->xfer_len != 0U)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
    
    if (len > ep->maxpacket)
 8001180:	6c37      	ldr	r7, [r6, #64]	; 0x40
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 8001182:	9804      	ldr	r0, [sp, #16]
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0U)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8001184:	1a9b      	subs	r3, r3, r2
 8001186:	429f      	cmp	r7, r3
 8001188:	bf28      	it	cs
 800118a:	461f      	movcs	r7, r3
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 800118c:	7c23      	ldrb	r3, [r4, #16]
 800118e:	9300      	str	r3, [sp, #0]
 8001190:	464a      	mov	r2, r9
 8001192:	b2bb      	uxth	r3, r7
 8001194:	6c71      	ldr	r1, [r6, #68]	; 0x44
 8001196:	f002 fa9b 	bl	80036d0 <USB_WritePacket>
    
    ep->xfer_buff  += len;
 800119a:	6c73      	ldr	r3, [r6, #68]	; 0x44
 800119c:	443b      	add	r3, r7
 800119e:	6473      	str	r3, [r6, #68]	; 0x44
    ep->xfer_count += len;
 80011a0:	6d33      	ldr	r3, [r6, #80]	; 0x50
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 80011a2:	f107 0b03 	add.w	fp, r7, #3
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 80011a6:	443b      	add	r3, r7
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 80011a8:	ea4f 0b9b 	mov.w	fp, fp, lsr #2
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 80011ac:	6533      	str	r3, [r6, #80]	; 0x50
 80011ae:	e7cf      	b.n	8001150 <HAL_PCD_IRQHandler+0x1b0>
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
        ep_intr >>= 1U;
 80011b0:	9b03      	ldr	r3, [sp, #12]
 80011b2:	085b      	lsrs	r3, r3, #1
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
 80011b4:	3501      	adds	r5, #1
        ep_intr >>= 1U;
 80011b6:	9303      	str	r3, [sp, #12]
 80011b8:	361c      	adds	r6, #28
 80011ba:	f108 0820 	add.w	r8, r8, #32
 80011be:	e76c      	b.n	800109a <HAL_PCD_IRQHandler+0xfa>
      }
    }
    
    /* Handle Resume Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80011c0:	6820      	ldr	r0, [r4, #0]
 80011c2:	f002 fb40 	bl	8003846 <USB_ReadInterrupts>
 80011c6:	2800      	cmp	r0, #0
 80011c8:	da0d      	bge.n	80011e6 <HAL_PCD_IRQHandler+0x246>
    {    
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80011ca:	f8da 3804 	ldr.w	r3, [sl, #2052]	; 0x804
 80011ce:	f023 0301 	bic.w	r3, r3, #1
 80011d2:	f8ca 3804 	str.w	r3, [sl, #2052]	; 0x804
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
      }
      else
#endif /* USB_OTG_GLPMCFG_LPMEN */
      {
        HAL_PCD_ResumeCallback(hpcd);
 80011d6:	4620      	mov	r0, r4
 80011d8:	f7ff fb24 	bl	8000824 <HAL_PCD_ResumeCallback>
      }
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 80011dc:	6822      	ldr	r2, [r4, #0]
 80011de:	6953      	ldr	r3, [r2, #20]
 80011e0:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80011e4:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Suspend Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80011e6:	6820      	ldr	r0, [r4, #0]
 80011e8:	f002 fb2d 	bl	8003846 <USB_ReadInterrupts>
 80011ec:	0506      	lsls	r6, r0, #20
 80011ee:	d50b      	bpl.n	8001208 <HAL_PCD_IRQHandler+0x268>
    {
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80011f0:	f8da 3808 	ldr.w	r3, [sl, #2056]	; 0x808
 80011f4:	07d8      	lsls	r0, r3, #31
 80011f6:	d502      	bpl.n	80011fe <HAL_PCD_IRQHandler+0x25e>
      {
        
        HAL_PCD_SuspendCallback(hpcd);
 80011f8:	4620      	mov	r0, r4
 80011fa:	f7ff fafb 	bl	80007f4 <HAL_PCD_SuspendCallback>
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80011fe:	6822      	ldr	r2, [r4, #0]
 8001200:	6953      	ldr	r3, [r2, #20]
 8001202:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001206:	6153      	str	r3, [r2, #20]
      }
    }
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8001208:	6820      	ldr	r0, [r4, #0]
 800120a:	f002 fb1c 	bl	8003846 <USB_ReadInterrupts>
 800120e:	04c1      	lsls	r1, r0, #19
 8001210:	d543      	bpl.n	800129a <HAL_PCD_IRQHandler+0x2fa>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 8001212:	f50a 6600 	add.w	r6, sl, #2048	; 0x800
 8001216:	6873      	ldr	r3, [r6, #4]
      USB_FlushTxFifo(hpcd->Instance , 0U);
 8001218:	6820      	ldr	r0, [r4, #0]
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 800121a:	f023 0301 	bic.w	r3, r3, #1
 800121e:	6073      	str	r3, [r6, #4]
      USB_FlushTxFifo(hpcd->Instance , 0U);
 8001220:	2100      	movs	r1, #0
 8001222:	f001 ffd3 	bl	80031cc <USB_FlushTxFifo>
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001226:	6860      	ldr	r0, [r4, #4]
 8001228:	f50a 6310 	add.w	r3, sl, #2304	; 0x900
 800122c:	2200      	movs	r2, #0
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 800122e:	21ff      	movs	r1, #255	; 0xff
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance , 0U);
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001230:	4282      	cmp	r2, r0
 8001232:	d005      	beq.n	8001240 <HAL_PCD_IRQHandler+0x2a0>
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 8001234:	6099      	str	r1, [r3, #8]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance , 0U);
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001236:	3201      	adds	r2, #1
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
        USBx_OUTEP(i)->DOEPINT = 0xFFU;
 8001238:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
 800123c:	3320      	adds	r3, #32
 800123e:	e7f7      	b.n	8001230 <HAL_PCD_IRQHandler+0x290>
      }
      USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8001240:	f04f 33ff 	mov.w	r3, #4294967295
 8001244:	61b3      	str	r3, [r6, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8001246:	69f3      	ldr	r3, [r6, #28]
 8001248:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 800124c:	61f3      	str	r3, [r6, #28]
      
      if(hpcd->Init.use_dedicated_ep1)
 800124e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001250:	b153      	cbz	r3, 8001268 <HAL_PCD_IRQHandler+0x2c8>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 8001252:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 8001256:	f043 030b 	orr.w	r3, r3, #11
 800125a:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 800125e:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8001260:	f043 030b 	orr.w	r3, r3, #11
 8001264:	6473      	str	r3, [r6, #68]	; 0x44
 8001266:	e007      	b.n	8001278 <HAL_PCD_IRQHandler+0x2d8>
      else
      {
#ifdef USB_OTG_DOEPINT_OTEPSPR
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM | USB_OTG_DOEPMSK_OTEPSPRM);
#else
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 8001268:	6973      	ldr	r3, [r6, #20]
 800126a:	f043 030b 	orr.w	r3, r3, #11
 800126e:	6173      	str	r3, [r6, #20]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8001270:	6933      	ldr	r3, [r6, #16]
 8001272:	f043 030b 	orr.w	r3, r3, #11
 8001276:	6133      	str	r3, [r6, #16]
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8001278:	f8da 3800 	ldr.w	r3, [sl, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 800127c:	7c21      	ldrb	r1, [r4, #16]
 800127e:	6820      	ldr	r0, [r4, #0]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8001280:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8001284:	f8ca 3800 	str.w	r3, [sl, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8001288:	f504 7261 	add.w	r2, r4, #900	; 0x384
 800128c:	f002 fb28 	bl	80038e0 <USB_EP0_OutStart>
        
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8001290:	6822      	ldr	r2, [r4, #0]
 8001292:	6953      	ldr	r3, [r2, #20]
 8001294:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001298:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Enumeration done Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 800129a:	6820      	ldr	r0, [r4, #0]
 800129c:	f002 fad3 	bl	8003846 <USB_ReadInterrupts>
 80012a0:	0482      	lsls	r2, r0, #18
 80012a2:	d57c      	bpl.n	800139e <HAL_PCD_IRQHandler+0x3fe>
    {
      USB_ActivateSetup(hpcd->Instance);
 80012a4:	6820      	ldr	r0, [r4, #0]
 80012a6:	f002 fb00 	bl	80038aa <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80012aa:	6820      	ldr	r0, [r4, #0]
 80012ac:	68c3      	ldr	r3, [r0, #12]
 80012ae:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 80012b2:	60c3      	str	r3, [r0, #12]
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 80012b4:	f001 ffb3 	bl	800321e <USB_GetDevSpeed>
 80012b8:	b948      	cbnz	r0, 80012ce <HAL_PCD_IRQHandler+0x32e>
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 80012ba:	6822      	ldr	r2, [r4, #0]
      USB_ActivateSetup(hpcd->Instance);
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 80012bc:	60e0      	str	r0, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 80012be:	f44f 7300 	mov.w	r3, #512	; 0x200
 80012c2:	6163      	str	r3, [r4, #20]
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 80012c4:	68d3      	ldr	r3, [r2, #12]
 80012c6:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 80012ca:	60d3      	str	r3, [r2, #12]
 80012cc:	e05f      	b.n	800138e <HAL_PCD_IRQHandler+0x3ee>
      }
      else
      {
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 80012ce:	2303      	movs	r3, #3
 80012d0:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 80012d2:	2340      	movs	r3, #64	; 0x40
 80012d4:	6163      	str	r3, [r4, #20]
        used by application. In the low AHB frequency range it is used to stretch enough the USB response 
        time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access 
        latency to the Data FIFO */
        
        /* Get hclk frequency value */
        hclk = HAL_RCC_GetHCLKFreq();
 80012d6:	f000 fcbb 	bl	8001c50 <HAL_RCC_GetHCLKFreq>
		
        if((hclk >= 14200000)&&(hclk < 15000000))
 80012da:	4b74      	ldr	r3, [pc, #464]	; (80014ac <HAL_PCD_IRQHandler+0x50c>)
 80012dc:	4a74      	ldr	r2, [pc, #464]	; (80014b0 <HAL_PCD_IRQHandler+0x510>)
 80012de:	4403      	add	r3, r0
 80012e0:	4293      	cmp	r3, r2
 80012e2:	6823      	ldr	r3, [r4, #0]
 80012e4:	d803      	bhi.n	80012ee <HAL_PCD_IRQHandler+0x34e>
        {
          /* hclk Clock Range between 14.2-15 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xF << 10) & USB_OTG_GUSBCFG_TRDT);
 80012e6:	68da      	ldr	r2, [r3, #12]
 80012e8:	f442 5270 	orr.w	r2, r2, #15360	; 0x3c00
 80012ec:	e04e      	b.n	800138c <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 15000000)&&(hclk < 16000000))
 80012ee:	4a71      	ldr	r2, [pc, #452]	; (80014b4 <HAL_PCD_IRQHandler+0x514>)
 80012f0:	4971      	ldr	r1, [pc, #452]	; (80014b8 <HAL_PCD_IRQHandler+0x518>)
 80012f2:	4402      	add	r2, r0
 80012f4:	428a      	cmp	r2, r1
 80012f6:	d803      	bhi.n	8001300 <HAL_PCD_IRQHandler+0x360>
        {
          /* hclk Clock Range between 15-16 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xE << 10) & USB_OTG_GUSBCFG_TRDT);
 80012f8:	68da      	ldr	r2, [r3, #12]
 80012fa:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 80012fe:	e045      	b.n	800138c <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 16000000)&&(hclk < 17200000))
 8001300:	f5a0 0274 	sub.w	r2, r0, #15990784	; 0xf40000
 8001304:	496d      	ldr	r1, [pc, #436]	; (80014bc <HAL_PCD_IRQHandler+0x51c>)
 8001306:	f5a2 5210 	sub.w	r2, r2, #9216	; 0x2400
 800130a:	428a      	cmp	r2, r1
 800130c:	d803      	bhi.n	8001316 <HAL_PCD_IRQHandler+0x376>
        {
          /* hclk Clock Range between 16-17.2 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xD << 10) & USB_OTG_GUSBCFG_TRDT);
 800130e:	68da      	ldr	r2, [r3, #12]
 8001310:	f442 5250 	orr.w	r2, r2, #13312	; 0x3400
 8001314:	e03a      	b.n	800138c <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 17200000)&&(hclk < 18500000))
 8001316:	f1a0 7283 	sub.w	r2, r0, #17170432	; 0x1060000
 800131a:	4969      	ldr	r1, [pc, #420]	; (80014c0 <HAL_PCD_IRQHandler+0x520>)
 800131c:	f5a2 42e7 	sub.w	r2, r2, #29568	; 0x7380
 8001320:	428a      	cmp	r2, r1
 8001322:	d803      	bhi.n	800132c <HAL_PCD_IRQHandler+0x38c>
        {
          /* hclk Clock Range between 17.2-18.5 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xC << 10) & USB_OTG_GUSBCFG_TRDT);
 8001324:	68da      	ldr	r2, [r3, #12]
 8001326:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
 800132a:	e02f      	b.n	800138c <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 18500000)&&(hclk < 20000000))
 800132c:	4a65      	ldr	r2, [pc, #404]	; (80014c4 <HAL_PCD_IRQHandler+0x524>)
 800132e:	4966      	ldr	r1, [pc, #408]	; (80014c8 <HAL_PCD_IRQHandler+0x528>)
 8001330:	4402      	add	r2, r0
 8001332:	428a      	cmp	r2, r1
 8001334:	d803      	bhi.n	800133e <HAL_PCD_IRQHandler+0x39e>
        {
          /* hclk Clock Range between 18.5-20 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xB << 10) & USB_OTG_GUSBCFG_TRDT);
 8001336:	68da      	ldr	r2, [r3, #12]
 8001338:	f442 5230 	orr.w	r2, r2, #11264	; 0x2c00
 800133c:	e026      	b.n	800138c <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 20000000)&&(hclk < 21800000))
 800133e:	4a63      	ldr	r2, [pc, #396]	; (80014cc <HAL_PCD_IRQHandler+0x52c>)
 8001340:	4963      	ldr	r1, [pc, #396]	; (80014d0 <HAL_PCD_IRQHandler+0x530>)
 8001342:	4402      	add	r2, r0
 8001344:	428a      	cmp	r2, r1
 8001346:	d803      	bhi.n	8001350 <HAL_PCD_IRQHandler+0x3b0>
        {
          /* hclk Clock Range between 20-21.8 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xA << 10) & USB_OTG_GUSBCFG_TRDT);
 8001348:	68da      	ldr	r2, [r3, #12]
 800134a:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
 800134e:	e01d      	b.n	800138c <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 21800000)&&(hclk < 24000000))
 8001350:	4a60      	ldr	r2, [pc, #384]	; (80014d4 <HAL_PCD_IRQHandler+0x534>)
 8001352:	4961      	ldr	r1, [pc, #388]	; (80014d8 <HAL_PCD_IRQHandler+0x538>)
 8001354:	4402      	add	r2, r0
 8001356:	428a      	cmp	r2, r1
 8001358:	d803      	bhi.n	8001362 <HAL_PCD_IRQHandler+0x3c2>
        {
          /* hclk Clock Range between 21.8-24 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9 << 10) & USB_OTG_GUSBCFG_TRDT);
 800135a:	68da      	ldr	r2, [r3, #12]
 800135c:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
 8001360:	e014      	b.n	800138c <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 24000000)&&(hclk < 27700000))
 8001362:	f1a0 72b7 	sub.w	r2, r0, #23986176	; 0x16e0000
 8001366:	495d      	ldr	r1, [pc, #372]	; (80014dc <HAL_PCD_IRQHandler+0x53c>)
 8001368:	f5a2 5258 	sub.w	r2, r2, #13824	; 0x3600
 800136c:	428a      	cmp	r2, r1
 800136e:	d803      	bhi.n	8001378 <HAL_PCD_IRQHandler+0x3d8>
        {
          /* hclk Clock Range between 24-27.7 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8 << 10) & USB_OTG_GUSBCFG_TRDT);
 8001370:	68da      	ldr	r2, [r3, #12]
 8001372:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001376:	e009      	b.n	800138c <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 27700000)&&(hclk < 32000000))
 8001378:	4a59      	ldr	r2, [pc, #356]	; (80014e0 <HAL_PCD_IRQHandler+0x540>)
 800137a:	495a      	ldr	r1, [pc, #360]	; (80014e4 <HAL_PCD_IRQHandler+0x544>)
 800137c:	4402      	add	r2, r0
 800137e:	428a      	cmp	r2, r1
        {
          /* hclk Clock Range between 27.7-32 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7 << 10) & USB_OTG_GUSBCFG_TRDT);
 8001380:	68da      	ldr	r2, [r3, #12]
 8001382:	bf94      	ite	ls
 8001384:	f442 52e0 	orrls.w	r2, r2, #7168	; 0x1c00
        }
        
        else /* if(hclk >= 32000000) */
        {
          /* hclk Clock Range between 32-180 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6 << 10) & USB_OTG_GUSBCFG_TRDT);
 8001388:	f442 52c0 	orrhi.w	r2, r2, #6144	; 0x1800
 800138c:	60da      	str	r2, [r3, #12]
        }  
      }
      
      HAL_PCD_ResetCallback(hpcd);
 800138e:	4620      	mov	r0, r4
 8001390:	f7ff fa1f 	bl	80007d2 <HAL_PCD_ResetCallback>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8001394:	6822      	ldr	r2, [r4, #0]
 8001396:	6953      	ldr	r3, [r2, #20]
 8001398:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800139c:	6153      	str	r3, [r2, #20]
    }

    /* Handle RxQLevel Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 800139e:	6820      	ldr	r0, [r4, #0]
 80013a0:	f002 fa51 	bl	8003846 <USB_ReadInterrupts>
 80013a4:	06c3      	lsls	r3, r0, #27
 80013a6:	d538      	bpl.n	800141a <HAL_PCD_IRQHandler+0x47a>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80013a8:	6822      	ldr	r2, [r4, #0]
 80013aa:	6993      	ldr	r3, [r2, #24]
 80013ac:	f023 0310 	bic.w	r3, r3, #16
 80013b0:	6193      	str	r3, [r2, #24]
      
      temp = USBx->GRXSTSP;
 80013b2:	f8da 6020 	ldr.w	r6, [sl, #32]
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 80013b6:	f3c6 4343 	ubfx	r3, r6, #17, #4
 80013ba:	2b02      	cmp	r3, #2
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
      
      temp = USBx->GRXSTSP;
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 80013bc:	f006 070f 	and.w	r7, r6, #15
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 80013c0:	d114      	bne.n	80013ec <HAL_PCD_IRQHandler+0x44c>
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 80013c2:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 80013c6:	4033      	ands	r3, r6
 80013c8:	b313      	cbz	r3, 8001410 <HAL_PCD_IRQHandler+0x470>
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
 80013ca:	231c      	movs	r3, #28
 80013cc:	fb03 4707 	mla	r7, r3, r7, r4
 80013d0:	f3c6 160a 	ubfx	r6, r6, #4, #11
 80013d4:	4632      	mov	r2, r6
 80013d6:	f8d7 11e8 	ldr.w	r1, [r7, #488]	; 0x1e8
 80013da:	4650      	mov	r0, sl
 80013dc:	f002 f98c 	bl	80036f8 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 80013e0:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 80013e4:	4433      	add	r3, r6
 80013e6:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
 80013ea:	e00c      	b.n	8001406 <HAL_PCD_IRQHandler+0x466>
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_SETUP_UPDT)
 80013ec:	2b06      	cmp	r3, #6
 80013ee:	d10f      	bne.n	8001410 <HAL_PCD_IRQHandler+0x470>
      {
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 80013f0:	2208      	movs	r2, #8
 80013f2:	f504 7161 	add.w	r1, r4, #900	; 0x384
 80013f6:	4650      	mov	r0, sl
 80013f8:	f002 f97e 	bl	80036f8 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 80013fc:	231c      	movs	r3, #28
 80013fe:	fb03 4707 	mla	r7, r3, r7, r4
 8001402:	f3c6 160a 	ubfx	r6, r6, #4, #11
 8001406:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 800140a:	441e      	add	r6, r3
 800140c:	f8c7 61f4 	str.w	r6, [r7, #500]	; 0x1f4
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8001410:	6822      	ldr	r2, [r4, #0]
 8001412:	6993      	ldr	r3, [r2, #24]
 8001414:	f043 0310 	orr.w	r3, r3, #16
 8001418:	6193      	str	r3, [r2, #24]
    }
    
    /* Handle SOF Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 800141a:	6820      	ldr	r0, [r4, #0]
 800141c:	f002 fa13 	bl	8003846 <USB_ReadInterrupts>
 8001420:	0707      	lsls	r7, r0, #28
 8001422:	d507      	bpl.n	8001434 <HAL_PCD_IRQHandler+0x494>
    {
      HAL_PCD_SOFCallback(hpcd);
 8001424:	4620      	mov	r0, r4
 8001426:	f7ff f9d0 	bl	80007ca <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 800142a:	6822      	ldr	r2, [r4, #0]
 800142c:	6953      	ldr	r3, [r2, #20]
 800142e:	f003 0308 	and.w	r3, r3, #8
 8001432:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Incomplete ISO IN Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8001434:	6820      	ldr	r0, [r4, #0]
 8001436:	f002 fa06 	bl	8003846 <USB_ReadInterrupts>
 800143a:	02c6      	lsls	r6, r0, #11
 800143c:	d508      	bpl.n	8001450 <HAL_PCD_IRQHandler+0x4b0>
    {
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 800143e:	b2e9      	uxtb	r1, r5
 8001440:	4620      	mov	r0, r4
 8001442:	f7ff f9f7 	bl	8000834 <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8001446:	6822      	ldr	r2, [r4, #0]
 8001448:	6953      	ldr	r3, [r2, #20]
 800144a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800144e:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Incomplete ISO OUT Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8001450:	6820      	ldr	r0, [r4, #0]
 8001452:	f002 f9f8 	bl	8003846 <USB_ReadInterrupts>
 8001456:	0280      	lsls	r0, r0, #10
 8001458:	d508      	bpl.n	800146c <HAL_PCD_IRQHandler+0x4cc>
    {
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 800145a:	b2e9      	uxtb	r1, r5
 800145c:	4620      	mov	r0, r4
 800145e:	f7ff f9e5 	bl	800082c <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8001462:	6822      	ldr	r2, [r4, #0]
 8001464:	6953      	ldr	r3, [r2, #20]
 8001466:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800146a:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Connection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 800146c:	6820      	ldr	r0, [r4, #0]
 800146e:	f002 f9ea 	bl	8003846 <USB_ReadInterrupts>
 8001472:	0041      	lsls	r1, r0, #1
 8001474:	d507      	bpl.n	8001486 <HAL_PCD_IRQHandler+0x4e6>
    {
      HAL_PCD_ConnectCallback(hpcd);
 8001476:	4620      	mov	r0, r4
 8001478:	f7ff f9e0 	bl	800083c <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 800147c:	6822      	ldr	r2, [r4, #0]
 800147e:	6953      	ldr	r3, [r2, #20]
 8001480:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8001484:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Disconnection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8001486:	6820      	ldr	r0, [r4, #0]
 8001488:	f002 f9dd 	bl	8003846 <USB_ReadInterrupts>
 800148c:	0742      	lsls	r2, r0, #29
 800148e:	d50a      	bpl.n	80014a6 <HAL_PCD_IRQHandler+0x506>
    {
      temp = hpcd->Instance->GOTGINT;
 8001490:	6823      	ldr	r3, [r4, #0]
 8001492:	685d      	ldr	r5, [r3, #4]
      
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8001494:	076b      	lsls	r3, r5, #29
 8001496:	d502      	bpl.n	800149e <HAL_PCD_IRQHandler+0x4fe>
      {
        HAL_PCD_DisconnectCallback(hpcd);
 8001498:	4620      	mov	r0, r4
 800149a:	f7ff f9d3 	bl	8000844 <HAL_PCD_DisconnectCallback>
      }
      hpcd->Instance->GOTGINT |= temp;
 800149e:	6822      	ldr	r2, [r4, #0]
 80014a0:	6853      	ldr	r3, [r2, #4]
 80014a2:	432b      	orrs	r3, r5
 80014a4:	6053      	str	r3, [r2, #4]
    }
  }
}
 80014a6:	b007      	add	sp, #28
 80014a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80014ac:	ff275340 	.word	0xff275340
 80014b0:	000c34ff 	.word	0x000c34ff
 80014b4:	ff1b1e40 	.word	0xff1b1e40
 80014b8:	000f423f 	.word	0x000f423f
 80014bc:	00124f7f 	.word	0x00124f7f
 80014c0:	0013d61f 	.word	0x0013d61f
 80014c4:	fee5b660 	.word	0xfee5b660
 80014c8:	0016e35f 	.word	0x0016e35f
 80014cc:	feced300 	.word	0xfeced300
 80014d0:	001b773f 	.word	0x001b773f
 80014d4:	feb35bc0 	.word	0xfeb35bc0
 80014d8:	002191bf 	.word	0x002191bf
 80014dc:	0038751f 	.word	0x0038751f
 80014e0:	fe5954e0 	.word	0xfe5954e0
 80014e4:	00419cdf 	.word	0x00419cdf

080014e8 <HAL_PCD_SetAddress>:
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd); 
 80014e8:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 80014ec:	2b01      	cmp	r3, #1
  * @param  hpcd: PCD handle
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 80014ee:	b510      	push	{r4, lr}
 80014f0:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80014f2:	d009      	beq.n	8001508 <HAL_PCD_SetAddress+0x20>
 80014f4:	2301      	movs	r3, #1
 80014f6:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_SetDevAddress(hpcd->Instance, address);
 80014fa:	6800      	ldr	r0, [r0, #0]
 80014fc:	f002 f97b 	bl	80037f6 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 8001500:	2000      	movs	r0, #0
 8001502:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8001506:	bd10      	pop	{r4, pc}
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd); 
 8001508:	2002      	movs	r0, #2
  USB_SetDevAddress(hpcd->Instance, address);
  __HAL_UNLOCK(hpcd);   
  return HAL_OK;
}
 800150a:	bd10      	pop	{r4, pc}

0800150c <HAL_PCD_EP_Open>:
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 800150c:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 800150e:	b24e      	sxtb	r6, r1
 8001510:	2e00      	cmp	r6, #0
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8001512:	4604      	mov	r4, r0
 8001514:	f04f 051c 	mov.w	r5, #28
 8001518:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 800151c:	bfb5      	itete	lt
 800151e:	fb05 4100 	mlalt	r1, r5, r0, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8001522:	fb05 4101 	mlage	r1, r5, r1, r4
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001526:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8001528:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  }
  ep->num   = ep_addr & 0x7FU;
 800152c:	b2c0      	uxtb	r0, r0
  
  ep->is_in = (0x80U & ep_addr) != 0U;
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
  if (ep->is_in)
 800152e:	2e00      	cmp	r6, #0
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8001530:	bfb8      	it	lt
 8001532:	80c8      	strhlt	r0, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK )
 8001534:	2b02      	cmp	r3, #2
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
 8001536:	70cb      	strb	r3, [r1, #3]
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8001538:	ea4f 75d6 	mov.w	r5, r6, lsr #31
    ep->tx_fifo_num = ep->num;
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
 800153c:	bf04      	itt	eq
 800153e:	2300      	moveq	r3, #0
 8001540:	710b      	strbeq	r3, [r1, #4]
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
 8001542:	7008      	strb	r0, [r1, #0]
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8001544:	704d      	strb	r5, [r1, #1]
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 8001546:	f894 3380 	ldrb.w	r3, [r4, #896]	; 0x380
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
  ep->maxpacket = ep_mps;
 800154a:	608a      	str	r2, [r1, #8]
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 800154c:	2b01      	cmp	r3, #1
 800154e:	d009      	beq.n	8001564 <HAL_PCD_EP_Open+0x58>
 8001550:	2301      	movs	r3, #1
 8001552:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  USB_ActivateEndpoint(hpcd->Instance , ep);
 8001556:	6820      	ldr	r0, [r4, #0]
 8001558:	f001 fe7c 	bl	8003254 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 800155c:	2000      	movs	r0, #0
 800155e:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return ret;
 8001562:	bd70      	pop	{r4, r5, r6, pc}
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 8001564:	2002      	movs	r0, #2
  USB_ActivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return ret;
}
 8001566:	bd70      	pop	{r4, r5, r6, pc}

08001568 <HAL_PCD_EP_Close>:
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 8001568:	b24b      	sxtb	r3, r1
 800156a:	2b00      	cmp	r3, #0
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
 800156c:	b510      	push	{r4, lr}
 800156e:	f04f 021c 	mov.w	r2, #28
 8001572:	4604      	mov	r4, r0
 8001574:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001578:	bfb5      	itete	lt
 800157a:	fb02 4100 	mlalt	r1, r2, r0, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 800157e:	fb02 4101 	mlage	r1, r2, r1, r4
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001582:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8001584:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8001588:	0fdb      	lsrs	r3, r3, #31
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
 800158a:	7008      	strb	r0, [r1, #0]
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 800158c:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 800158e:	f894 3380 	ldrb.w	r3, [r4, #896]	; 0x380
 8001592:	2b01      	cmp	r3, #1
 8001594:	d009      	beq.n	80015aa <HAL_PCD_EP_Close+0x42>
 8001596:	2301      	movs	r3, #1
 8001598:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 800159c:	6820      	ldr	r0, [r4, #0]
 800159e:	f001 fe9a 	bl	80032d6 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 80015a2:	2000      	movs	r0, #0
 80015a4:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 80015a8:	bd10      	pop	{r4, pc}
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
  
  __HAL_LOCK(hpcd); 
 80015aa:	2002      	movs	r0, #2
  USB_DeactivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return HAL_OK;
}
 80015ac:	bd10      	pop	{r4, pc}

080015ae <HAL_PCD_EP_Receive>:
  * @param  pBuf: pointer to the reception buffer   
  * @param  len: amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 80015ae:	b538      	push	{r3, r4, r5, lr}
 80015b0:	4604      	mov	r4, r0
 80015b2:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 80015b6:	201c      	movs	r0, #28
 80015b8:	fb00 4005 	mla	r0, r0, r5, r4
  ep->xfer_len = len;
 80015bc:	f8c0 31f0 	str.w	r3, [r0, #496]	; 0x1f0
  ep->xfer_count = 0U;
 80015c0:	2300      	movs	r3, #0
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 80015c2:	f8c0 21e8 	str.w	r2, [r0, #488]	; 0x1e8
  ep->xfer_len = len;
  ep->xfer_count = 0U;
 80015c6:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  ep->is_in = 0U;
 80015ca:	f880 31dd 	strb.w	r3, [r0, #477]	; 0x1dd
  ep->num = ep_addr & 0x7FU;
 80015ce:	f880 51dc 	strb.w	r5, [r0, #476]	; 0x1dc
  
  if (hpcd->Init.dma_enable == 1U)
 80015d2:	6923      	ldr	r3, [r4, #16]
 80015d4:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 80015d6:	bf08      	it	eq
 80015d8:	f8c0 21ec 	streq.w	r2, [r0, #492]	; 0x1ec
  }
  
  __HAL_LOCK(hpcd); 
 80015dc:	f894 2380 	ldrb.w	r2, [r4, #896]	; 0x380
 80015e0:	2a01      	cmp	r2, #1
 80015e2:	d013      	beq.n	800160c <HAL_PCD_EP_Receive+0x5e>
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80015e4:	211c      	movs	r1, #28
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 80015e6:	2201      	movs	r2, #1
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80015e8:	fb01 4105 	mla	r1, r1, r5, r4
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 80015ec:	f884 2380 	strb.w	r2, [r4, #896]	; 0x380
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80015f0:	f501 71ee 	add.w	r1, r1, #476	; 0x1dc
 80015f4:	b2da      	uxtb	r2, r3
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7FU) == 0U)
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80015f6:	6820      	ldr	r0, [r4, #0]
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7FU) == 0U)
 80015f8:	b915      	cbnz	r5, 8001600 <HAL_PCD_EP_Receive+0x52>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80015fa:	f001 ffbf 	bl	800357c <USB_EP0StartXfer>
 80015fe:	e001      	b.n	8001604 <HAL_PCD_EP_Receive+0x56>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001600:	f001 fea0 	bl	8003344 <USB_EPStartXfer>
  }
  __HAL_UNLOCK(hpcd); 
 8001604:	2000      	movs	r0, #0
 8001606:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  
  return HAL_OK;
 800160a:	bd38      	pop	{r3, r4, r5, pc}
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 800160c:	2002      	movs	r0, #2
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 800160e:	bd38      	pop	{r3, r4, r5, pc}

08001610 <HAL_PCD_EP_GetRxCount>:
  * @param  ep_addr: endpoint address
  * @retval Data Size
  */
uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  return hpcd->OUT_ep[ep_addr & 0x7FU].xfer_count;
 8001610:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8001614:	231c      	movs	r3, #28
 8001616:	fb03 0001 	mla	r0, r3, r1, r0
}
 800161a:	f8b0 01f4 	ldrh.w	r0, [r0, #500]	; 0x1f4
 800161e:	4770      	bx	lr

08001620 <HAL_PCD_EP_Transmit>:
  * @param  pBuf: pointer to the transmission buffer   
  * @param  len: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8001620:	b538      	push	{r3, r4, r5, lr}
 8001622:	4604      	mov	r4, r0
 8001624:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8001628:	201c      	movs	r0, #28
 800162a:	fb00 4005 	mla	r0, r0, r5, r4
  ep->xfer_len = len;
 800162e:	64c3      	str	r3, [r0, #76]	; 0x4c
  ep->xfer_count = 0U;
 8001630:	2300      	movs	r3, #0
 8001632:	6503      	str	r3, [r0, #80]	; 0x50
  ep->is_in = 1U;
 8001634:	2301      	movs	r3, #1
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8001636:	6442      	str	r2, [r0, #68]	; 0x44
  ep->xfer_len = len;
  ep->xfer_count = 0U;
  ep->is_in = 1U;
 8001638:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  ep->num = ep_addr & 0x7FU;
 800163c:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
  
  if (hpcd->Init.dma_enable == 1U)
 8001640:	6923      	ldr	r3, [r4, #16]
 8001642:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 8001644:	bf08      	it	eq
 8001646:	6482      	streq	r2, [r0, #72]	; 0x48
  }
  
  __HAL_LOCK(hpcd); 
 8001648:	f894 2380 	ldrb.w	r2, [r4, #896]	; 0x380
 800164c:	2a01      	cmp	r2, #1
 800164e:	d012      	beq.n	8001676 <HAL_PCD_EP_Transmit+0x56>
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001650:	211c      	movs	r1, #28
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8001652:	2201      	movs	r2, #1
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001654:	fb01 4105 	mla	r1, r1, r5, r4
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8001658:	f884 2380 	strb.w	r2, [r4, #896]	; 0x380
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 800165c:	3138      	adds	r1, #56	; 0x38
 800165e:	b2da      	uxtb	r2, r3
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7FU) == 0U)
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001660:	6820      	ldr	r0, [r4, #0]
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7FU) == 0U)
 8001662:	b915      	cbnz	r5, 800166a <HAL_PCD_EP_Transmit+0x4a>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001664:	f001 ff8a 	bl	800357c <USB_EP0StartXfer>
 8001668:	e001      	b.n	800166e <HAL_PCD_EP_Transmit+0x4e>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 800166a:	f001 fe6b 	bl	8003344 <USB_EPStartXfer>
  }
  
  __HAL_UNLOCK(hpcd);
 800166e:	2000      	movs	r0, #0
 8001670:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
     
  return HAL_OK;
 8001674:	bd38      	pop	{r3, r4, r5, pc}
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8001676:	2002      	movs	r0, #2
  }
  
  __HAL_UNLOCK(hpcd);
     
  return HAL_OK;
}
 8001678:	bd38      	pop	{r3, r4, r5, pc}

0800167a <HAL_PCD_EP_SetStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800167a:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 800167c:	b24b      	sxtb	r3, r1
 800167e:	2b00      	cmp	r3, #0
 8001680:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 8001684:	f04f 021c 	mov.w	r2, #28
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001688:	bfb5      	itete	lt
 800168a:	fb02 0105 	mlalt	r1, r2, r5, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800168e:	fb02 0101 	mlage	r1, r2, r1, r0
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001692:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8001694:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  }
  
  ep->is_stall = 1U;
 8001698:	2201      	movs	r2, #1
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 800169a:	0fdb      	lsrs	r3, r3, #31
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7FU;
 800169c:	b2ed      	uxtb	r5, r5
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1U;
 800169e:	708a      	strb	r2, [r1, #2]
  ep->num   = ep_addr & 0x7FU;
 80016a0:	700d      	strb	r5, [r1, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80016a2:	704b      	strb	r3, [r1, #1]
  
  
  __HAL_LOCK(hpcd); 
 80016a4:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 80016a8:	4293      	cmp	r3, r2
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 80016aa:	4604      	mov	r4, r0
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
  
  
  __HAL_LOCK(hpcd); 
 80016ac:	d00f      	beq.n	80016ce <HAL_PCD_EP_SetStall+0x54>
 80016ae:	f880 2380 	strb.w	r2, [r0, #896]	; 0x380
  USB_EPSetStall(hpcd->Instance , ep);
 80016b2:	6800      	ldr	r0, [r0, #0]
 80016b4:	f002 f82e 	bl	8003714 <USB_EPSetStall>
  if((ep_addr & 0x7FU) == 0U)
 80016b8:	b92d      	cbnz	r5, 80016c6 <HAL_PCD_EP_SetStall+0x4c>
  {
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 80016ba:	f504 7261 	add.w	r2, r4, #900	; 0x384
 80016be:	7c21      	ldrb	r1, [r4, #16]
 80016c0:	6820      	ldr	r0, [r4, #0]
 80016c2:	f002 f90d 	bl	80038e0 <USB_EP0_OutStart>
  }
  __HAL_UNLOCK(hpcd); 
 80016c6:	2000      	movs	r0, #0
 80016c8:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  
  return HAL_OK;
 80016cc:	bd38      	pop	{r3, r4, r5, pc}
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
  
  
  __HAL_LOCK(hpcd); 
 80016ce:	2002      	movs	r0, #2
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 80016d0:	bd38      	pop	{r3, r4, r5, pc}

080016d2 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 80016d2:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 80016d4:	b24b      	sxtb	r3, r1
 80016d6:	2b00      	cmp	r3, #0
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 80016d8:	4605      	mov	r5, r0
 80016da:	f04f 021c 	mov.w	r2, #28
 80016de:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 80016e2:	bfb5      	itete	lt
 80016e4:	fb02 5100 	mlalt	r1, r2, r0, r5
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 80016e8:	fb02 5101 	mlage	r1, r2, r1, r5
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 80016ec:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 80016ee:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  }
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80016f2:	0fdb      	lsrs	r3, r3, #31
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0U;
 80016f4:	2400      	movs	r4, #0
 80016f6:	708c      	strb	r4, [r1, #2]
  ep->num   = ep_addr & 0x7FU;
 80016f8:	7008      	strb	r0, [r1, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80016fa:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 80016fc:	f895 3380 	ldrb.w	r3, [r5, #896]	; 0x380
 8001700:	2b01      	cmp	r3, #1
 8001702:	d009      	beq.n	8001718 <HAL_PCD_EP_ClrStall+0x46>
 8001704:	2301      	movs	r3, #1
 8001706:	f885 3380 	strb.w	r3, [r5, #896]	; 0x380
  USB_EPClearStall(hpcd->Instance , ep);
 800170a:	6828      	ldr	r0, [r5, #0]
 800170c:	f002 f834 	bl	8003778 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 8001710:	f885 4380 	strb.w	r4, [r5, #896]	; 0x380
    
  return HAL_OK;
 8001714:	4620      	mov	r0, r4
 8001716:	bd38      	pop	{r3, r4, r5, pc}
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
  
  __HAL_LOCK(hpcd); 
 8001718:	2002      	movs	r0, #2
  USB_EPClearStall(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd); 
    
  return HAL_OK;
}
 800171a:	bd38      	pop	{r3, r4, r5, pc}

0800171c <HAL_PCD_EP_Flush>:
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  __HAL_LOCK(hpcd); 
 800171c:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8001720:	2b01      	cmp	r3, #1
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8001722:	b510      	push	{r4, lr}
 8001724:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8001726:	d011      	beq.n	800174c <HAL_PCD_EP_Flush+0x30>
 8001728:	2301      	movs	r3, #1
 800172a:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  
  if ((ep_addr & 0x80U) == 0x80U)
 800172e:	060b      	lsls	r3, r1, #24
 8001730:	d505      	bpl.n	800173e <HAL_PCD_EP_Flush+0x22>
  {
    USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7FU);
 8001732:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8001736:	6800      	ldr	r0, [r0, #0]
 8001738:	f001 fd48 	bl	80031cc <USB_FlushTxFifo>
 800173c:	e002      	b.n	8001744 <HAL_PCD_EP_Flush+0x28>
  }
  else
  {
    USB_FlushRxFifo(hpcd->Instance);
 800173e:	6800      	ldr	r0, [r0, #0]
 8001740:	f001 fd56 	bl	80031f0 <USB_FlushRxFifo>
  }
  
  __HAL_UNLOCK(hpcd); 
 8001744:	2000      	movs	r0, #0
 8001746:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
    
  return HAL_OK;
 800174a:	bd10      	pop	{r4, pc}
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  __HAL_LOCK(hpcd); 
 800174c:	2002      	movs	r0, #2
  }
  
  __HAL_UNLOCK(hpcd); 
    
  return HAL_OK;
}
 800174e:	bd10      	pop	{r4, pc}

08001750 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo: The number of Tx fifo
  * @param  size: Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8001750:	b570      	push	{r4, r5, r6, lr}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8001752:	6804      	ldr	r4, [r0, #0]
 8001754:	6a60      	ldr	r0, [r4, #36]	; 0x24
  
  if(fifo == 0U)
 8001756:	b919      	cbnz	r1, 8001760 <HAL_PCDEx_SetTxFiFo+0x10>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
 8001758:	ea40 4302 	orr.w	r3, r0, r2, lsl #16
 800175c:	62a3      	str	r3, [r4, #40]	; 0x28
 800175e:	e016      	b.n	800178e <HAL_PCDEx_SetTxFiFo+0x3e>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 8001760:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
 8001762:	2500      	movs	r5, #0
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 8001764:	eb00 4313 	add.w	r3, r0, r3, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8001768:	1e4e      	subs	r6, r1, #1
 800176a:	b2e8      	uxtb	r0, r5
 800176c:	4286      	cmp	r6, r0
 800176e:	f105 0501 	add.w	r5, r5, #1
 8001772:	d906      	bls.n	8001782 <HAL_PCDEx_SetTxFiFo+0x32>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16U);
 8001774:	3040      	adds	r0, #64	; 0x40
 8001776:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 800177a:	6840      	ldr	r0, [r0, #4]
 800177c:	eb03 4310 	add.w	r3, r3, r0, lsr #16
 8001780:	e7f3      	b.n	800176a <HAL_PCDEx_SetTxFiFo+0x1a>
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);        
 8001782:	313f      	adds	r1, #63	; 0x3f
 8001784:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 8001788:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800178c:	6063      	str	r3, [r4, #4]
  }
  
  return HAL_OK;
}
 800178e:	2000      	movs	r0, #0
 8001790:	bd70      	pop	{r4, r5, r6, pc}

08001792 <HAL_PCDEx_SetRxFiFo>:
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8001792:	6803      	ldr	r3, [r0, #0]
  
  return HAL_OK;
}
 8001794:	2000      	movs	r0, #0
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8001796:	6259      	str	r1, [r3, #36]	; 0x24
  
  return HAL_OK;
}
 8001798:	4770      	bx	lr
	...

0800179c <HAL_RCC_OscConfig>:
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800179c:	6803      	ldr	r3, [r0, #0]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800179e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80017a2:	4604      	mov	r4, r0
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80017a4:	07d8      	lsls	r0, r3, #31
 80017a6:	d403      	bmi.n	80017b0 <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80017a8:	6823      	ldr	r3, [r4, #0]
 80017aa:	0799      	lsls	r1, r3, #30
 80017ac:	d437      	bmi.n	800181e <HAL_RCC_OscConfig+0x82>
 80017ae:	e087      	b.n	80018c0 <HAL_RCC_OscConfig+0x124>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80017b0:	4ba7      	ldr	r3, [pc, #668]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
 80017b2:	689a      	ldr	r2, [r3, #8]
 80017b4:	f002 020c 	and.w	r2, r2, #12
 80017b8:	2a04      	cmp	r2, #4
 80017ba:	d007      	beq.n	80017cc <HAL_RCC_OscConfig+0x30>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80017bc:	689a      	ldr	r2, [r3, #8]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80017be:	f002 020c 	and.w	r2, r2, #12
 80017c2:	2a08      	cmp	r2, #8
 80017c4:	d10b      	bne.n	80017de <HAL_RCC_OscConfig+0x42>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80017c6:	685b      	ldr	r3, [r3, #4]
 80017c8:	025a      	lsls	r2, r3, #9
 80017ca:	d508      	bpl.n	80017de <HAL_RCC_OscConfig+0x42>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80017cc:	4ba0      	ldr	r3, [pc, #640]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
 80017ce:	681b      	ldr	r3, [r3, #0]
 80017d0:	039b      	lsls	r3, r3, #14
 80017d2:	d5e9      	bpl.n	80017a8 <HAL_RCC_OscConfig+0xc>
 80017d4:	6863      	ldr	r3, [r4, #4]
 80017d6:	2b00      	cmp	r3, #0
 80017d8:	d1e6      	bne.n	80017a8 <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
 80017da:	2001      	movs	r0, #1
 80017dc:	e134      	b.n	8001a48 <HAL_RCC_OscConfig+0x2ac>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80017de:	4b9d      	ldr	r3, [pc, #628]	; (8001a54 <HAL_RCC_OscConfig+0x2b8>)
 80017e0:	7922      	ldrb	r2, [r4, #4]
 80017e2:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 80017e4:	6863      	ldr	r3, [r4, #4]
 80017e6:	b16b      	cbz	r3, 8001804 <HAL_RCC_OscConfig+0x68>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80017e8:	f7ff f9b8 	bl	8000b5c <HAL_GetTick>
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80017ec:	4d98      	ldr	r5, [pc, #608]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80017ee:	4606      	mov	r6, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80017f0:	682b      	ldr	r3, [r5, #0]
 80017f2:	039f      	lsls	r7, r3, #14
 80017f4:	d4d8      	bmi.n	80017a8 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80017f6:	f7ff f9b1 	bl	8000b5c <HAL_GetTick>
 80017fa:	1b80      	subs	r0, r0, r6
 80017fc:	2864      	cmp	r0, #100	; 0x64
 80017fe:	d9f7      	bls.n	80017f0 <HAL_RCC_OscConfig+0x54>
          {
            return HAL_TIMEOUT;
 8001800:	2003      	movs	r0, #3
 8001802:	e121      	b.n	8001a48 <HAL_RCC_OscConfig+0x2ac>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001804:	f7ff f9aa 	bl	8000b5c <HAL_GetTick>

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001808:	4d91      	ldr	r5, [pc, #580]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800180a:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800180c:	682b      	ldr	r3, [r5, #0]
 800180e:	0398      	lsls	r0, r3, #14
 8001810:	d5ca      	bpl.n	80017a8 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001812:	f7ff f9a3 	bl	8000b5c <HAL_GetTick>
 8001816:	1b80      	subs	r0, r0, r6
 8001818:	2864      	cmp	r0, #100	; 0x64
 800181a:	d9f7      	bls.n	800180c <HAL_RCC_OscConfig+0x70>
 800181c:	e7f0      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800181e:	4b8c      	ldr	r3, [pc, #560]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
 8001820:	689a      	ldr	r2, [r3, #8]
 8001822:	f012 0f0c 	tst.w	r2, #12
 8001826:	d007      	beq.n	8001838 <HAL_RCC_OscConfig+0x9c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001828:	689a      	ldr	r2, [r3, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800182a:	f002 020c 	and.w	r2, r2, #12
 800182e:	2a08      	cmp	r2, #8
 8001830:	d117      	bne.n	8001862 <HAL_RCC_OscConfig+0xc6>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001832:	685b      	ldr	r3, [r3, #4]
 8001834:	0259      	lsls	r1, r3, #9
 8001836:	d414      	bmi.n	8001862 <HAL_RCC_OscConfig+0xc6>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001838:	4b85      	ldr	r3, [pc, #532]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
 800183a:	681a      	ldr	r2, [r3, #0]
 800183c:	0792      	lsls	r2, r2, #30
 800183e:	d502      	bpl.n	8001846 <HAL_RCC_OscConfig+0xaa>
 8001840:	68e2      	ldr	r2, [r4, #12]
 8001842:	2a01      	cmp	r2, #1
 8001844:	d1c9      	bne.n	80017da <HAL_RCC_OscConfig+0x3e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001846:	681a      	ldr	r2, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001848:	21f8      	movs	r1, #248	; 0xf8
 800184a:	fa91 f1a1 	rbit	r1, r1
 800184e:	6920      	ldr	r0, [r4, #16]
 8001850:	fab1 f181 	clz	r1, r1
 8001854:	fa00 f101 	lsl.w	r1, r0, r1
 8001858:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800185c:	430a      	orrs	r2, r1
 800185e:	601a      	str	r2, [r3, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001860:	e02e      	b.n	80018c0 <HAL_RCC_OscConfig+0x124>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8001862:	68e2      	ldr	r2, [r4, #12]
 8001864:	4b7c      	ldr	r3, [pc, #496]	; (8001a58 <HAL_RCC_OscConfig+0x2bc>)
 8001866:	b1ea      	cbz	r2, 80018a4 <HAL_RCC_OscConfig+0x108>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001868:	2201      	movs	r2, #1
 800186a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800186c:	f7ff f976 	bl	8000b5c <HAL_GetTick>

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001870:	4d77      	ldr	r5, [pc, #476]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001872:	4606      	mov	r6, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001874:	682b      	ldr	r3, [r5, #0]
 8001876:	4876      	ldr	r0, [pc, #472]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
 8001878:	079b      	lsls	r3, r3, #30
 800187a:	d405      	bmi.n	8001888 <HAL_RCC_OscConfig+0xec>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800187c:	f7ff f96e 	bl	8000b5c <HAL_GetTick>
 8001880:	1b80      	subs	r0, r0, r6
 8001882:	2802      	cmp	r0, #2
 8001884:	d9f6      	bls.n	8001874 <HAL_RCC_OscConfig+0xd8>
 8001886:	e7bb      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001888:	6803      	ldr	r3, [r0, #0]
 800188a:	22f8      	movs	r2, #248	; 0xf8
 800188c:	fa92 f2a2 	rbit	r2, r2
 8001890:	6921      	ldr	r1, [r4, #16]
 8001892:	fab2 f282 	clz	r2, r2
 8001896:	fa01 f202 	lsl.w	r2, r1, r2
 800189a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800189e:	4313      	orrs	r3, r2
 80018a0:	6003      	str	r3, [r0, #0]
 80018a2:	e00d      	b.n	80018c0 <HAL_RCC_OscConfig+0x124>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80018a4:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80018a6:	f7ff f959 	bl	8000b5c <HAL_GetTick>
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80018aa:	4d69      	ldr	r5, [pc, #420]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80018ac:	4606      	mov	r6, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80018ae:	682b      	ldr	r3, [r5, #0]
 80018b0:	079f      	lsls	r7, r3, #30
 80018b2:	d505      	bpl.n	80018c0 <HAL_RCC_OscConfig+0x124>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80018b4:	f7ff f952 	bl	8000b5c <HAL_GetTick>
 80018b8:	1b80      	subs	r0, r0, r6
 80018ba:	2802      	cmp	r0, #2
 80018bc:	d9f7      	bls.n	80018ae <HAL_RCC_OscConfig+0x112>
 80018be:	e79f      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80018c0:	6823      	ldr	r3, [r4, #0]
 80018c2:	071e      	lsls	r6, r3, #28
 80018c4:	d403      	bmi.n	80018ce <HAL_RCC_OscConfig+0x132>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80018c6:	6823      	ldr	r3, [r4, #0]
 80018c8:	075d      	lsls	r5, r3, #29
 80018ca:	d545      	bpl.n	8001958 <HAL_RCC_OscConfig+0x1bc>
 80018cc:	e01f      	b.n	800190e <HAL_RCC_OscConfig+0x172>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80018ce:	6962      	ldr	r2, [r4, #20]
 80018d0:	4b62      	ldr	r3, [pc, #392]	; (8001a5c <HAL_RCC_OscConfig+0x2c0>)
 80018d2:	b172      	cbz	r2, 80018f2 <HAL_RCC_OscConfig+0x156>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80018d4:	2201      	movs	r2, #1
 80018d6:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80018d8:	f7ff f940 	bl	8000b5c <HAL_GetTick>
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80018dc:	4d5c      	ldr	r5, [pc, #368]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80018de:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80018e0:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80018e2:	0798      	lsls	r0, r3, #30
 80018e4:	d4ef      	bmi.n	80018c6 <HAL_RCC_OscConfig+0x12a>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80018e6:	f7ff f939 	bl	8000b5c <HAL_GetTick>
 80018ea:	1b80      	subs	r0, r0, r6
 80018ec:	2802      	cmp	r0, #2
 80018ee:	d9f7      	bls.n	80018e0 <HAL_RCC_OscConfig+0x144>
 80018f0:	e786      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80018f2:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80018f4:	f7ff f932 	bl	8000b5c <HAL_GetTick>
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80018f8:	4d55      	ldr	r5, [pc, #340]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80018fa:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80018fc:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80018fe:	0799      	lsls	r1, r3, #30
 8001900:	d5e1      	bpl.n	80018c6 <HAL_RCC_OscConfig+0x12a>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001902:	f7ff f92b 	bl	8000b5c <HAL_GetTick>
 8001906:	1b80      	subs	r0, r0, r6
 8001908:	2802      	cmp	r0, #2
 800190a:	d9f7      	bls.n	80018fc <HAL_RCC_OscConfig+0x160>
 800190c:	e778      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800190e:	2300      	movs	r3, #0
 8001910:	9301      	str	r3, [sp, #4]
 8001912:	4b4f      	ldr	r3, [pc, #316]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8001914:	4d52      	ldr	r5, [pc, #328]	; (8001a60 <HAL_RCC_OscConfig+0x2c4>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8001916:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001918:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800191c:	641a      	str	r2, [r3, #64]	; 0x40
 800191e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001920:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001924:	9301      	str	r3, [sp, #4]
 8001926:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8001928:	682b      	ldr	r3, [r5, #0]
 800192a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800192e:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 8001930:	f7ff f914 	bl	8000b5c <HAL_GetTick>
 8001934:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8001936:	682b      	ldr	r3, [r5, #0]
 8001938:	05da      	lsls	r2, r3, #23
 800193a:	d510      	bpl.n	800195e <HAL_RCC_OscConfig+0x1c2>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800193c:	4b49      	ldr	r3, [pc, #292]	; (8001a64 <HAL_RCC_OscConfig+0x2c8>)
 800193e:	7a22      	ldrb	r2, [r4, #8]
 8001940:	701a      	strb	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8001942:	68a3      	ldr	r3, [r4, #8]
 8001944:	b1bb      	cbz	r3, 8001976 <HAL_RCC_OscConfig+0x1da>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001946:	f7ff f909 	bl	8000b5c <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800194a:	4d41      	ldr	r5, [pc, #260]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800194c:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800194e:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001952:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001954:	079b      	lsls	r3, r3, #30
 8001956:	d508      	bpl.n	800196a <HAL_RCC_OscConfig+0x1ce>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001958:	69a2      	ldr	r2, [r4, #24]
 800195a:	b9da      	cbnz	r2, 8001994 <HAL_RCC_OscConfig+0x1f8>
 800195c:	e059      	b.n	8001a12 <HAL_RCC_OscConfig+0x276>
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800195e:	f7ff f8fd 	bl	8000b5c <HAL_GetTick>
 8001962:	1b80      	subs	r0, r0, r6
 8001964:	2802      	cmp	r0, #2
 8001966:	d9e6      	bls.n	8001936 <HAL_RCC_OscConfig+0x19a>
 8001968:	e74a      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800196a:	f7ff f8f7 	bl	8000b5c <HAL_GetTick>
 800196e:	1b80      	subs	r0, r0, r6
 8001970:	42b8      	cmp	r0, r7
 8001972:	d9ee      	bls.n	8001952 <HAL_RCC_OscConfig+0x1b6>
 8001974:	e744      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001976:	f7ff f8f1 	bl	8000b5c <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800197a:	4d35      	ldr	r5, [pc, #212]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800197c:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800197e:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001982:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001984:	0798      	lsls	r0, r3, #30
 8001986:	d5e7      	bpl.n	8001958 <HAL_RCC_OscConfig+0x1bc>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001988:	f7ff f8e8 	bl	8000b5c <HAL_GetTick>
 800198c:	1b80      	subs	r0, r0, r6
 800198e:	42b8      	cmp	r0, r7
 8001990:	d9f7      	bls.n	8001982 <HAL_RCC_OscConfig+0x1e6>
 8001992:	e735      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001994:	4d2e      	ldr	r5, [pc, #184]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
 8001996:	68ab      	ldr	r3, [r5, #8]
 8001998:	f003 030c 	and.w	r3, r3, #12
 800199c:	2b08      	cmp	r3, #8
 800199e:	f43f af1c 	beq.w	80017da <HAL_RCC_OscConfig+0x3e>
 80019a2:	4e31      	ldr	r6, [pc, #196]	; (8001a68 <HAL_RCC_OscConfig+0x2cc>)
 80019a4:	2300      	movs	r3, #0
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80019a6:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80019a8:	6033      	str	r3, [r6, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80019aa:	d141      	bne.n	8001a30 <HAL_RCC_OscConfig+0x294>
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80019ac:	f7ff f8d6 	bl	8000b5c <HAL_GetTick>
 80019b0:	4680      	mov	r8, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80019b2:	682b      	ldr	r3, [r5, #0]
 80019b4:	4f26      	ldr	r7, [pc, #152]	; (8001a50 <HAL_RCC_OscConfig+0x2b4>)
 80019b6:	0199      	lsls	r1, r3, #6
 80019b8:	d42d      	bmi.n	8001a16 <HAL_RCC_OscConfig+0x27a>
 80019ba:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 80019be:	fa92 f2a2 	rbit	r2, r2
 80019c2:	f44f 3340 	mov.w	r3, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80019c6:	fab2 fe82 	clz	lr, r2
 80019ca:	fa93 f3a3 	rbit	r3, r3
 80019ce:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 80019d2:	fab3 f583 	clz	r5, r3
 80019d6:	fa92 f2a2 	rbit	r2, r2
 80019da:	69e0      	ldr	r0, [r4, #28]
 80019dc:	6a23      	ldr	r3, [r4, #32]
 80019de:	fab2 f182 	clz	r1, r2
 80019e2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80019e4:	4303      	orrs	r3, r0
 80019e6:	fa02 f20e 	lsl.w	r2, r2, lr
 80019ea:	ea43 0002 	orr.w	r0, r3, r2
 80019ee:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80019f0:	085a      	lsrs	r2, r3, #1
 80019f2:	3a01      	subs	r2, #1
 80019f4:	fa02 f305 	lsl.w	r3, r2, r5
 80019f8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80019fa:	4303      	orrs	r3, r0
 80019fc:	408a      	lsls	r2, r1
 80019fe:	4313      	orrs	r3, r2
 8001a00:	607b      	str	r3, [r7, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8001a02:	2301      	movs	r3, #1
 8001a04:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001a06:	f7ff f8a9 	bl	8000b5c <HAL_GetTick>
 8001a0a:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001a0c:	683b      	ldr	r3, [r7, #0]
 8001a0e:	019a      	lsls	r2, r3, #6
 8001a10:	d508      	bpl.n	8001a24 <HAL_RCC_OscConfig+0x288>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001a12:	2000      	movs	r0, #0
 8001a14:	e018      	b.n	8001a48 <HAL_RCC_OscConfig+0x2ac>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001a16:	f7ff f8a1 	bl	8000b5c <HAL_GetTick>
 8001a1a:	ebc8 0000 	rsb	r0, r8, r0
 8001a1e:	2802      	cmp	r0, #2
 8001a20:	d9c7      	bls.n	80019b2 <HAL_RCC_OscConfig+0x216>
 8001a22:	e6ed      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001a24:	f7ff f89a 	bl	8000b5c <HAL_GetTick>
 8001a28:	1b00      	subs	r0, r0, r4
 8001a2a:	2802      	cmp	r0, #2
 8001a2c:	d9ee      	bls.n	8001a0c <HAL_RCC_OscConfig+0x270>
 8001a2e:	e6e7      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001a30:	f7ff f894 	bl	8000b5c <HAL_GetTick>
 8001a34:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001a36:	682b      	ldr	r3, [r5, #0]
 8001a38:	019b      	lsls	r3, r3, #6
 8001a3a:	d5ea      	bpl.n	8001a12 <HAL_RCC_OscConfig+0x276>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001a3c:	f7ff f88e 	bl	8000b5c <HAL_GetTick>
 8001a40:	1b00      	subs	r0, r0, r4
 8001a42:	2802      	cmp	r0, #2
 8001a44:	d9f7      	bls.n	8001a36 <HAL_RCC_OscConfig+0x29a>
 8001a46:	e6db      	b.n	8001800 <HAL_RCC_OscConfig+0x64>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8001a48:	b002      	add	sp, #8
 8001a4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001a4e:	bf00      	nop
 8001a50:	40023800 	.word	0x40023800
 8001a54:	40023802 	.word	0x40023802
 8001a58:	42470000 	.word	0x42470000
 8001a5c:	42470e80 	.word	0x42470e80
 8001a60:	40007000 	.word	0x40007000
 8001a64:	40023870 	.word	0x40023870
 8001a68:	42470060 	.word	0x42470060

08001a6c <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001a6c:	491b      	ldr	r1, [pc, #108]	; (8001adc <HAL_RCC_GetSysClockFreq+0x70>)
 8001a6e:	688b      	ldr	r3, [r1, #8]
 8001a70:	f003 030c 	and.w	r3, r3, #12
 8001a74:	2b04      	cmp	r3, #4
 8001a76:	d02c      	beq.n	8001ad2 <HAL_RCC_GetSysClockFreq+0x66>
 8001a78:	2b08      	cmp	r3, #8
 8001a7a:	d12c      	bne.n	8001ad6 <HAL_RCC_GetSysClockFreq+0x6a>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001a7c:	6848      	ldr	r0, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001a7e:	684b      	ldr	r3, [r1, #4]
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001a80:	f000 003f 	and.w	r0, r0, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001a84:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001a88:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8001a8c:	684b      	ldr	r3, [r1, #4]
 8001a8e:	fa92 f2a2 	rbit	r2, r2
 8001a92:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8001a96:	fab2 f282 	clz	r2, r2
 8001a9a:	ea01 0103 	and.w	r1, r1, r3
 8001a9e:	fa21 f102 	lsr.w	r1, r1, r2
 8001aa2:	bf14      	ite	ne
 8001aa4:	4a0e      	ldrne	r2, [pc, #56]	; (8001ae0 <HAL_RCC_GetSysClockFreq+0x74>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8001aa6:	4a0f      	ldreq	r2, [pc, #60]	; (8001ae4 <HAL_RCC_GetSysClockFreq+0x78>)
 8001aa8:	fbb2 f0f0 	udiv	r0, r2, r0
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8001aac:	4a0b      	ldr	r2, [pc, #44]	; (8001adc <HAL_RCC_GetSysClockFreq+0x70>)
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8001aae:	fb00 f301 	mul.w	r3, r0, r1
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8001ab2:	6852      	ldr	r2, [r2, #4]
 8001ab4:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8001ab8:	fa90 f0a0 	rbit	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8001abc:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8001ac0:	fab0 f080 	clz	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8001ac4:	fa22 f000 	lsr.w	r0, r2, r0
 8001ac8:	3001      	adds	r0, #1
 8001aca:	0040      	lsls	r0, r0, #1
 8001acc:	fbb3 f0f0 	udiv	r0, r3, r0
 8001ad0:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8001ad2:	4803      	ldr	r0, [pc, #12]	; (8001ae0 <HAL_RCC_GetSysClockFreq+0x74>)
 8001ad4:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8001ad6:	4803      	ldr	r0, [pc, #12]	; (8001ae4 <HAL_RCC_GetSysClockFreq+0x78>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001ad8:	4770      	bx	lr
 8001ada:	bf00      	nop
 8001adc:	40023800 	.word	0x40023800
 8001ae0:	007a1200 	.word	0x007a1200
 8001ae4:	00f42400 	.word	0x00f42400

08001ae8 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001ae8:	4b55      	ldr	r3, [pc, #340]	; (8001c40 <HAL_RCC_ClockConfig+0x158>)
 8001aea:	681a      	ldr	r2, [r3, #0]
 8001aec:	f002 020f 	and.w	r2, r2, #15
 8001af0:	428a      	cmp	r2, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001af2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001af6:	4605      	mov	r5, r0
 8001af8:	460e      	mov	r6, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001afa:	d30a      	bcc.n	8001b12 <HAL_RCC_ClockConfig+0x2a>
      return HAL_ERROR;
    }
  }
 
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001afc:	6829      	ldr	r1, [r5, #0]
 8001afe:	0788      	lsls	r0, r1, #30
 8001b00:	d511      	bpl.n	8001b26 <HAL_RCC_ClockConfig+0x3e>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001b02:	4850      	ldr	r0, [pc, #320]	; (8001c44 <HAL_RCC_ClockConfig+0x15c>)
 8001b04:	6883      	ldr	r3, [r0, #8]
 8001b06:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001b0a:	68ab      	ldr	r3, [r5, #8]
 8001b0c:	4313      	orrs	r3, r2
 8001b0e:	6083      	str	r3, [r0, #8]
 8001b10:	e009      	b.n	8001b26 <HAL_RCC_ClockConfig+0x3e>
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001b12:	b2ca      	uxtb	r2, r1
 8001b14:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001b16:	681b      	ldr	r3, [r3, #0]
 8001b18:	f003 030f 	and.w	r3, r3, #15
 8001b1c:	4299      	cmp	r1, r3
 8001b1e:	d0ed      	beq.n	8001afc <HAL_RCC_ClockConfig+0x14>
    {
      return HAL_ERROR;
 8001b20:	2001      	movs	r0, #1
 8001b22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001b26:	07c9      	lsls	r1, r1, #31
 8001b28:	d406      	bmi.n	8001b38 <HAL_RCC_ClockConfig+0x50>
      }
    }
  }    
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8001b2a:	4b45      	ldr	r3, [pc, #276]	; (8001c40 <HAL_RCC_ClockConfig+0x158>)
 8001b2c:	681a      	ldr	r2, [r3, #0]
 8001b2e:	f002 020f 	and.w	r2, r2, #15
 8001b32:	4296      	cmp	r6, r2
 8001b34:	d351      	bcc.n	8001bda <HAL_RCC_ClockConfig+0xf2>
 8001b36:	e057      	b.n	8001be8 <HAL_RCC_ClockConfig+0x100>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001b38:	686b      	ldr	r3, [r5, #4]
 8001b3a:	4a42      	ldr	r2, [pc, #264]	; (8001c44 <HAL_RCC_ClockConfig+0x15c>)
 8001b3c:	2b01      	cmp	r3, #1
 8001b3e:	d103      	bne.n	8001b48 <HAL_RCC_ClockConfig+0x60>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001b40:	6812      	ldr	r2, [r2, #0]
 8001b42:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8001b46:	e008      	b.n	8001b5a <HAL_RCC_ClockConfig+0x72>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8001b48:	1e99      	subs	r1, r3, #2
 8001b4a:	2901      	cmp	r1, #1
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001b4c:	6812      	ldr	r2, [r2, #0]
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8001b4e:	d802      	bhi.n	8001b56 <HAL_RCC_ClockConfig+0x6e>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001b50:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8001b54:	e001      	b.n	8001b5a <HAL_RCC_ClockConfig+0x72>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001b56:	f012 0f02 	tst.w	r2, #2
 8001b5a:	d0e1      	beq.n	8001b20 <HAL_RCC_ClockConfig+0x38>
      {
        return HAL_ERROR;
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001b5c:	4c39      	ldr	r4, [pc, #228]	; (8001c44 <HAL_RCC_ClockConfig+0x15c>)
 8001b5e:	68a2      	ldr	r2, [r4, #8]
 8001b60:	f022 0203 	bic.w	r2, r2, #3
 8001b64:	4313      	orrs	r3, r2
 8001b66:	60a3      	str	r3, [r4, #8]
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001b68:	f7fe fff8 	bl	8000b5c <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001b6c:	686b      	ldr	r3, [r5, #4]
 8001b6e:	2b01      	cmp	r3, #1
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001b70:	4607      	mov	r7, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001b72:	f241 3888 	movw	r8, #5000	; 0x1388
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001b76:	d10c      	bne.n	8001b92 <HAL_RCC_ClockConfig+0xaa>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8001b78:	68a3      	ldr	r3, [r4, #8]
 8001b7a:	f003 030c 	and.w	r3, r3, #12
 8001b7e:	2b04      	cmp	r3, #4
 8001b80:	d0d3      	beq.n	8001b2a <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001b82:	f7fe ffeb 	bl	8000b5c <HAL_GetTick>
 8001b86:	1bc0      	subs	r0, r0, r7
 8001b88:	4540      	cmp	r0, r8
 8001b8a:	d9f5      	bls.n	8001b78 <HAL_RCC_ClockConfig+0x90>
        {
          return HAL_TIMEOUT;
 8001b8c:	2003      	movs	r0, #3
 8001b8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001b92:	2b02      	cmp	r3, #2
 8001b94:	d10a      	bne.n	8001bac <HAL_RCC_ClockConfig+0xc4>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001b96:	68a3      	ldr	r3, [r4, #8]
 8001b98:	f003 030c 	and.w	r3, r3, #12
 8001b9c:	2b08      	cmp	r3, #8
 8001b9e:	d0c4      	beq.n	8001b2a <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001ba0:	f7fe ffdc 	bl	8000b5c <HAL_GetTick>
 8001ba4:	1bc0      	subs	r0, r0, r7
 8001ba6:	4540      	cmp	r0, r8
 8001ba8:	d9f5      	bls.n	8001b96 <HAL_RCC_ClockConfig+0xae>
 8001baa:	e7ef      	b.n	8001b8c <HAL_RCC_ClockConfig+0xa4>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 8001bac:	2b03      	cmp	r3, #3
 8001bae:	d10f      	bne.n	8001bd0 <HAL_RCC_ClockConfig+0xe8>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 8001bb0:	68a3      	ldr	r3, [r4, #8]
 8001bb2:	f003 030c 	and.w	r3, r3, #12
 8001bb6:	2b0c      	cmp	r3, #12
 8001bb8:	d0b7      	beq.n	8001b2a <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001bba:	f7fe ffcf 	bl	8000b5c <HAL_GetTick>
 8001bbe:	1bc0      	subs	r0, r0, r7
 8001bc0:	4540      	cmp	r0, r8
 8001bc2:	d9f5      	bls.n	8001bb0 <HAL_RCC_ClockConfig+0xc8>
 8001bc4:	e7e2      	b.n	8001b8c <HAL_RCC_ClockConfig+0xa4>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001bc6:	f7fe ffc9 	bl	8000b5c <HAL_GetTick>
 8001bca:	1bc0      	subs	r0, r0, r7
 8001bcc:	4540      	cmp	r0, r8
 8001bce:	d8dd      	bhi.n	8001b8c <HAL_RCC_ClockConfig+0xa4>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8001bd0:	68a3      	ldr	r3, [r4, #8]
 8001bd2:	f013 0f0c 	tst.w	r3, #12
 8001bd6:	d1f6      	bne.n	8001bc6 <HAL_RCC_ClockConfig+0xde>
 8001bd8:	e7a7      	b.n	8001b2a <HAL_RCC_ClockConfig+0x42>
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  { 
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001bda:	b2f2      	uxtb	r2, r6
 8001bdc:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001bde:	681b      	ldr	r3, [r3, #0]
 8001be0:	f003 030f 	and.w	r3, r3, #15
 8001be4:	429e      	cmp	r6, r3
 8001be6:	d19b      	bne.n	8001b20 <HAL_RCC_ClockConfig+0x38>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001be8:	6829      	ldr	r1, [r5, #0]
 8001bea:	074a      	lsls	r2, r1, #29
 8001bec:	d506      	bpl.n	8001bfc <HAL_RCC_ClockConfig+0x114>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001bee:	4815      	ldr	r0, [pc, #84]	; (8001c44 <HAL_RCC_ClockConfig+0x15c>)
 8001bf0:	6883      	ldr	r3, [r0, #8]
 8001bf2:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8001bf6:	68eb      	ldr	r3, [r5, #12]
 8001bf8:	4313      	orrs	r3, r2
 8001bfa:	6083      	str	r3, [r0, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001bfc:	070b      	lsls	r3, r1, #28
 8001bfe:	d507      	bpl.n	8001c10 <HAL_RCC_ClockConfig+0x128>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001c00:	4a10      	ldr	r2, [pc, #64]	; (8001c44 <HAL_RCC_ClockConfig+0x15c>)
 8001c02:	6929      	ldr	r1, [r5, #16]
 8001c04:	6893      	ldr	r3, [r2, #8]
 8001c06:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001c0a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001c0e:	6093      	str	r3, [r2, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8001c10:	f7ff ff2c 	bl	8001a6c <HAL_RCC_GetSysClockFreq>
 8001c14:	4b0b      	ldr	r3, [pc, #44]	; (8001c44 <HAL_RCC_ClockConfig+0x15c>)
 8001c16:	22f0      	movs	r2, #240	; 0xf0
 8001c18:	689b      	ldr	r3, [r3, #8]
 8001c1a:	fa92 f2a2 	rbit	r2, r2
 8001c1e:	fab2 f282 	clz	r2, r2
 8001c22:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001c26:	40d3      	lsrs	r3, r2
 8001c28:	4a07      	ldr	r2, [pc, #28]	; (8001c48 <HAL_RCC_ClockConfig+0x160>)
 8001c2a:	5cd3      	ldrb	r3, [r2, r3]
 8001c2c:	40d8      	lsrs	r0, r3
 8001c2e:	4b07      	ldr	r3, [pc, #28]	; (8001c4c <HAL_RCC_ClockConfig+0x164>)
 8001c30:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8001c32:	2000      	movs	r0, #0
 8001c34:	f7fe ff5c 	bl	8000af0 <HAL_InitTick>
  
  return HAL_OK;
 8001c38:	2000      	movs	r0, #0
}
 8001c3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001c3e:	bf00      	nop
 8001c40:	40023c00 	.word	0x40023c00
 8001c44:	40023800 	.word	0x40023800
 8001c48:	08006af4 	.word	0x08006af4
 8001c4c:	20000054 	.word	0x20000054

08001c50 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8001c50:	4b01      	ldr	r3, [pc, #4]	; (8001c58 <HAL_RCC_GetHCLKFreq+0x8>)
 8001c52:	6818      	ldr	r0, [r3, #0]
 8001c54:	4770      	bx	lr
 8001c56:	bf00      	nop
 8001c58:	20000054 	.word	0x20000054

08001c5c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8001c5c:	4b08      	ldr	r3, [pc, #32]	; (8001c80 <HAL_RCC_GetPCLK1Freq+0x24>)
 8001c5e:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
 8001c62:	689b      	ldr	r3, [r3, #8]
 8001c64:	fa92 f2a2 	rbit	r2, r2
 8001c68:	fab2 f282 	clz	r2, r2
 8001c6c:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8001c70:	40d3      	lsrs	r3, r2
 8001c72:	4a04      	ldr	r2, [pc, #16]	; (8001c84 <HAL_RCC_GetPCLK1Freq+0x28>)
 8001c74:	5cd3      	ldrb	r3, [r2, r3]
 8001c76:	4a04      	ldr	r2, [pc, #16]	; (8001c88 <HAL_RCC_GetPCLK1Freq+0x2c>)
 8001c78:	6810      	ldr	r0, [r2, #0]
}
 8001c7a:	40d8      	lsrs	r0, r3
 8001c7c:	4770      	bx	lr
 8001c7e:	bf00      	nop
 8001c80:	40023800 	.word	0x40023800
 8001c84:	08006af4 	.word	0x08006af4
 8001c88:	20000054 	.word	0x20000054

08001c8c <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8001c8c:	4b08      	ldr	r3, [pc, #32]	; (8001cb0 <HAL_RCC_GetPCLK2Freq+0x24>)
 8001c8e:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 8001c92:	689b      	ldr	r3, [r3, #8]
 8001c94:	fa92 f2a2 	rbit	r2, r2
 8001c98:	fab2 f282 	clz	r2, r2
 8001c9c:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8001ca0:	40d3      	lsrs	r3, r2
 8001ca2:	4a04      	ldr	r2, [pc, #16]	; (8001cb4 <HAL_RCC_GetPCLK2Freq+0x28>)
 8001ca4:	5cd3      	ldrb	r3, [r2, r3]
 8001ca6:	4a04      	ldr	r2, [pc, #16]	; (8001cb8 <HAL_RCC_GetPCLK2Freq+0x2c>)
 8001ca8:	6810      	ldr	r0, [r2, #0]
} 
 8001caa:	40d8      	lsrs	r0, r3
 8001cac:	4770      	bx	lr
 8001cae:	bf00      	nop
 8001cb0:	40023800 	.word	0x40023800
 8001cb4:	08006af4 	.word	0x08006af4
 8001cb8:	20000054 	.word	0x20000054

08001cbc <SD_CmdResp2Error>:
  */
static HAL_SD_ErrorTypedef SD_CmdResp2Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8001cbc:	6803      	ldr	r3, [r0, #0]
 8001cbe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001cc0:	f012 0f45 	tst.w	r2, #69	; 0x45
 8001cc4:	d0fb      	beq.n	8001cbe <SD_CmdResp2Error+0x2>
  {
  }
    
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8001cc6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001cc8:	0752      	lsls	r2, r2, #29
 8001cca:	d503      	bpl.n	8001cd4 <SD_CmdResp2Error+0x18>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8001ccc:	2204      	movs	r2, #4
 8001cce:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8001cd0:	2003      	movs	r0, #3
 8001cd2:	4770      	bx	lr
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8001cd4:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8001cd6:	f010 0001 	ands.w	r0, r0, #1
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8001cda:	bf15      	itete	ne
 8001cdc:	2001      	movne	r0, #1
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001cde:	f240 52ff 	movweq	r2, #1535	; 0x5ff
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8001ce2:	6398      	strne	r0, [r3, #56]	; 0x38
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001ce4:	639a      	streq	r2, [r3, #56]	; 0x38
  
  return errorstate;
}
 8001ce6:	4770      	bx	lr

08001ce8 <SD_IsCardProgramming>:
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8001ce8:	b570      	push	{r4, r5, r6, lr}
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001cea:	6a43      	ldr	r3, [r0, #36]	; 0x24
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8001cec:	b086      	sub	sp, #24
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001cee:	041b      	lsls	r3, r3, #16
 8001cf0:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8001cf2:	230d      	movs	r3, #13
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8001cf4:	4605      	mov	r5, r0
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8001cf6:	9302      	str	r3, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001cf8:	2340      	movs	r3, #64	; 0x40
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
 8001cfa:	2200      	movs	r2, #0
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001cfc:	9303      	str	r3, [sp, #12]
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8001cfe:	460e      	mov	r6, r1
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001d00:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001d04:	a901      	add	r1, sp, #4
 8001d06:	6800      	ldr	r0, [r0, #0]
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
 8001d08:	9200      	str	r2, [sp, #0]
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001d0a:	9204      	str	r2, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001d0c:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001d0e:	f001 f934 	bl	8002f7a <SDIO_SendCommand>
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8001d12:	6828      	ldr	r0, [r5, #0]
 8001d14:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001d16:	f013 0f45 	tst.w	r3, #69	; 0x45
 8001d1a:	d0fb      	beq.n	8001d14 <SD_IsCardProgramming+0x2c>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8001d1c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001d1e:	075b      	lsls	r3, r3, #29
 8001d20:	d503      	bpl.n	8001d2a <SD_IsCardProgramming+0x42>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8001d22:	2304      	movs	r3, #4
 8001d24:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8001d26:	2003      	movs	r0, #3
 8001d28:	e07c      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8001d2a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001d2c:	f013 0401 	ands.w	r4, r3, #1
 8001d30:	d003      	beq.n	8001d3a <SD_IsCardProgramming+0x52>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8001d32:	2301      	movs	r3, #1
 8001d34:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8001d36:	4618      	mov	r0, r3
 8001d38:	e074      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  {
    /* No error flag set */
  }
  
  /* Check response received is of desired command */
  if((uint32_t)SDIO_GetCommandResponse(hsd->Instance) != SD_CMD_SEND_STATUS)
 8001d3a:	f001 f931 	bl	8002fa0 <SDIO_GetCommandResponse>
 8001d3e:	280d      	cmp	r0, #13
 8001d40:	d001      	beq.n	8001d46 <SD_IsCardProgramming+0x5e>
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 8001d42:	2010      	movs	r0, #16
 8001d44:	e06e      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001d46:	682b      	ldr	r3, [r5, #0]
 8001d48:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001d4c:	639a      	str	r2, [r3, #56]	; 0x38
  
  
  /* We have received response, retrieve it for analysis */
  responseR1 = SDIO_GetResponse(SDIO_RESP1);
 8001d4e:	4620      	mov	r0, r4
 8001d50:	f001 f92a 	bl	8002fa8 <SDIO_GetResponse>
 8001d54:	9000      	str	r0, [sp, #0]
  
  /* Find out card status */
  *pStatus = (uint8_t)((responseR1 >> 9U) & 0x0000000FU);
 8001d56:	9b00      	ldr	r3, [sp, #0]
  
  if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8001d58:	4833      	ldr	r0, [pc, #204]	; (8001e28 <SD_IsCardProgramming+0x140>)
  
  /* We have received response, retrieve it for analysis */
  responseR1 = SDIO_GetResponse(SDIO_RESP1);
  
  /* Find out card status */
  *pStatus = (uint8_t)((responseR1 >> 9U) & 0x0000000FU);
 8001d5a:	f3c3 2343 	ubfx	r3, r3, #9, #4
 8001d5e:	7033      	strb	r3, [r6, #0]
  
  if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8001d60:	9b00      	ldr	r3, [sp, #0]
 8001d62:	4018      	ands	r0, r3
 8001d64:	2800      	cmp	r0, #0
 8001d66:	d05d      	beq.n	8001e24 <SD_IsCardProgramming+0x13c>
  {
    return errorstate;
  }
  
  if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
 8001d68:	9b00      	ldr	r3, [sp, #0]
 8001d6a:	2b00      	cmp	r3, #0
 8001d6c:	db39      	blt.n	8001de2 <SD_IsCardProgramming+0xfa>
  {
    return(SD_ADDR_OUT_OF_RANGE);
  }
  
  if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
 8001d6e:	9b00      	ldr	r3, [sp, #0]
 8001d70:	005d      	lsls	r5, r3, #1
 8001d72:	d438      	bmi.n	8001de6 <SD_IsCardProgramming+0xfe>
  {
    return(SD_ADDR_MISALIGNED);
  }
  
  if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
 8001d74:	9b00      	ldr	r3, [sp, #0]
 8001d76:	009c      	lsls	r4, r3, #2
 8001d78:	d437      	bmi.n	8001dea <SD_IsCardProgramming+0x102>
  {
    return(SD_BLOCK_LEN_ERR);
  }
  
  if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
 8001d7a:	9b00      	ldr	r3, [sp, #0]
 8001d7c:	00d9      	lsls	r1, r3, #3
 8001d7e:	d436      	bmi.n	8001dee <SD_IsCardProgramming+0x106>
  {
    return(SD_ERASE_SEQ_ERR);
  }
  
  if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
 8001d80:	9b00      	ldr	r3, [sp, #0]
 8001d82:	011a      	lsls	r2, r3, #4
 8001d84:	d435      	bmi.n	8001df2 <SD_IsCardProgramming+0x10a>
  {
    return(SD_BAD_ERASE_PARAM);
  }
  
  if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
 8001d86:	9b00      	ldr	r3, [sp, #0]
 8001d88:	015b      	lsls	r3, r3, #5
 8001d8a:	d434      	bmi.n	8001df6 <SD_IsCardProgramming+0x10e>
  {
    return(SD_WRITE_PROT_VIOLATION);
  }
  
  if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
 8001d8c:	9b00      	ldr	r3, [sp, #0]
 8001d8e:	01de      	lsls	r6, r3, #7
 8001d90:	d433      	bmi.n	8001dfa <SD_IsCardProgramming+0x112>
  {
    return(SD_LOCK_UNLOCK_FAILED);
  }
  
  if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
 8001d92:	9b00      	ldr	r3, [sp, #0]
 8001d94:	021d      	lsls	r5, r3, #8
 8001d96:	d432      	bmi.n	8001dfe <SD_IsCardProgramming+0x116>
  {
    return(SD_COM_CRC_FAILED);
  }
  
  if((responseR1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
 8001d98:	9b00      	ldr	r3, [sp, #0]
 8001d9a:	025c      	lsls	r4, r3, #9
 8001d9c:	d4d1      	bmi.n	8001d42 <SD_IsCardProgramming+0x5a>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
 8001d9e:	9b00      	ldr	r3, [sp, #0]
 8001da0:	0299      	lsls	r1, r3, #10
 8001da2:	d42e      	bmi.n	8001e02 <SD_IsCardProgramming+0x11a>
  {
    return(SD_CARD_ECC_FAILED);
  }
  
  if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
 8001da4:	9b00      	ldr	r3, [sp, #0]
 8001da6:	02da      	lsls	r2, r3, #11
 8001da8:	d42d      	bmi.n	8001e06 <SD_IsCardProgramming+0x11e>
  {
    return(SD_CC_ERROR);
  }
  
  if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
 8001daa:	9b00      	ldr	r3, [sp, #0]
 8001dac:	031b      	lsls	r3, r3, #12
 8001dae:	d42c      	bmi.n	8001e0a <SD_IsCardProgramming+0x122>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
 8001db0:	9b00      	ldr	r3, [sp, #0]
 8001db2:	035e      	lsls	r6, r3, #13
 8001db4:	d42b      	bmi.n	8001e0e <SD_IsCardProgramming+0x126>
  {
    return(SD_STREAM_READ_UNDERRUN);
  }
  
  if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
 8001db6:	9b00      	ldr	r3, [sp, #0]
 8001db8:	039d      	lsls	r5, r3, #14
 8001dba:	d42a      	bmi.n	8001e12 <SD_IsCardProgramming+0x12a>
  {
    return(SD_STREAM_WRITE_OVERRUN);
  }
  
  if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
 8001dbc:	9b00      	ldr	r3, [sp, #0]
 8001dbe:	03dc      	lsls	r4, r3, #15
 8001dc0:	d429      	bmi.n	8001e16 <SD_IsCardProgramming+0x12e>
  {
    return(SD_CID_CSD_OVERWRITE);
  }
  
  if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
 8001dc2:	9b00      	ldr	r3, [sp, #0]
 8001dc4:	0419      	lsls	r1, r3, #16
 8001dc6:	d428      	bmi.n	8001e1a <SD_IsCardProgramming+0x132>
  {
    return(SD_WP_ERASE_SKIP);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
 8001dc8:	9b00      	ldr	r3, [sp, #0]
 8001dca:	045a      	lsls	r2, r3, #17
 8001dcc:	d427      	bmi.n	8001e1e <SD_IsCardProgramming+0x136>
  {
    return(SD_CARD_ECC_DISABLED);
  }
  
  if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
 8001dce:	9b00      	ldr	r3, [sp, #0]
 8001dd0:	049b      	lsls	r3, r3, #18
 8001dd2:	d426      	bmi.n	8001e22 <SD_IsCardProgramming+0x13a>
  {
    return(SD_ERASE_RESET);
  }
  
  if((responseR1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
 8001dd4:	9b00      	ldr	r3, [sp, #0]
  {
    return(SD_AKE_SEQ_ERROR);
 8001dd6:	f013 0f08 	tst.w	r3, #8
 8001dda:	bf0c      	ite	eq
 8001ddc:	2000      	moveq	r0, #0
 8001dde:	201a      	movne	r0, #26
 8001de0:	e020      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
    return errorstate;
  }
  
  if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
  {
    return(SD_ADDR_OUT_OF_RANGE);
 8001de2:	201c      	movs	r0, #28
 8001de4:	e01e      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
  {
    return(SD_ADDR_MISALIGNED);
 8001de6:	2009      	movs	r0, #9
 8001de8:	e01c      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
  {
    return(SD_BLOCK_LEN_ERR);
 8001dea:	200a      	movs	r0, #10
 8001dec:	e01a      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
  {
    return(SD_ERASE_SEQ_ERR);
 8001dee:	200b      	movs	r0, #11
 8001df0:	e018      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
  {
    return(SD_BAD_ERASE_PARAM);
 8001df2:	200c      	movs	r0, #12
 8001df4:	e016      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
  {
    return(SD_WRITE_PROT_VIOLATION);
 8001df6:	200d      	movs	r0, #13
 8001df8:	e014      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
  {
    return(SD_LOCK_UNLOCK_FAILED);
 8001dfa:	200e      	movs	r0, #14
 8001dfc:	e012      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8001dfe:	200f      	movs	r0, #15
 8001e00:	e010      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
    return(SD_ILLEGAL_CMD);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
  {
    return(SD_CARD_ECC_FAILED);
 8001e02:	2011      	movs	r0, #17
 8001e04:	e00e      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
  {
    return(SD_CC_ERROR);
 8001e06:	2012      	movs	r0, #18
 8001e08:	e00c      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8001e0a:	2013      	movs	r0, #19
 8001e0c:	e00a      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
  {
    return(SD_STREAM_READ_UNDERRUN);
 8001e0e:	2014      	movs	r0, #20
 8001e10:	e008      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
  {
    return(SD_STREAM_WRITE_OVERRUN);
 8001e12:	2015      	movs	r0, #21
 8001e14:	e006      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
  {
    return(SD_CID_CSD_OVERWRITE);
 8001e16:	2016      	movs	r0, #22
 8001e18:	e004      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
  {
    return(SD_WP_ERASE_SKIP);
 8001e1a:	2017      	movs	r0, #23
 8001e1c:	e002      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
  {
    return(SD_CARD_ECC_DISABLED);
 8001e1e:	2018      	movs	r0, #24
 8001e20:	e000      	b.n	8001e24 <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
  {
    return(SD_ERASE_RESET);
 8001e22:	2019      	movs	r0, #25
  {
    return(SD_AKE_SEQ_ERROR);
  }
  
  return errorstate;
}   
 8001e24:	b006      	add	sp, #24
 8001e26:	bd70      	pop	{r4, r5, r6, pc}
 8001e28:	fdffe008 	.word	0xfdffe008

08001e2c <SD_CmdResp1Error>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
{
 8001e2c:	b570      	push	{r4, r5, r6, lr}
 8001e2e:	4605      	mov	r5, r0
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8001e30:	6800      	ldr	r0, [r0, #0]
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
{
 8001e32:	460e      	mov	r6, r1
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8001e34:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001e36:	f013 0f45 	tst.w	r3, #69	; 0x45
 8001e3a:	d0fb      	beq.n	8001e34 <SD_CmdResp1Error+0x8>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8001e3c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001e3e:	075b      	lsls	r3, r3, #29
 8001e40:	d503      	bpl.n	8001e4a <SD_CmdResp1Error+0x1e>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8001e42:	2304      	movs	r3, #4
 8001e44:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8001e46:	2003      	movs	r0, #3
 8001e48:	bd70      	pop	{r4, r5, r6, pc}
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8001e4a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001e4c:	f013 0401 	ands.w	r4, r3, #1
 8001e50:	d002      	beq.n	8001e58 <SD_CmdResp1Error+0x2c>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8001e52:	2301      	movs	r3, #1
 8001e54:	6383      	str	r3, [r0, #56]	; 0x38
 8001e56:	e039      	b.n	8001ecc <SD_CmdResp1Error+0xa0>
    
    return errorstate;
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 8001e58:	f001 f8a2 	bl	8002fa0 <SDIO_GetCommandResponse>
 8001e5c:	42b0      	cmp	r0, r6
 8001e5e:	d001      	beq.n	8001e64 <SD_CmdResp1Error+0x38>
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 8001e60:	2010      	movs	r0, #16
 8001e62:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001e64:	682b      	ldr	r3, [r5, #0]
 8001e66:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001e6a:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 8001e6c:	4620      	mov	r0, r4
 8001e6e:	f001 f89b 	bl	8002fa8 <SDIO_GetResponse>
  
  if((response_r1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8001e72:	4b28      	ldr	r3, [pc, #160]	; (8001f14 <SD_CmdResp1Error+0xe8>)
 8001e74:	4003      	ands	r3, r0
 8001e76:	b34b      	cbz	r3, 8001ecc <SD_CmdResp1Error+0xa0>
  {
    return errorstate;
  }
  
  if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
 8001e78:	2800      	cmp	r0, #0
 8001e7a:	db29      	blt.n	8001ed0 <SD_CmdResp1Error+0xa4>
  {
    return(SD_ADDR_OUT_OF_RANGE);
  }
  
  if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
 8001e7c:	0045      	lsls	r5, r0, #1
 8001e7e:	d429      	bmi.n	8001ed4 <SD_CmdResp1Error+0xa8>
  {
    return(SD_ADDR_MISALIGNED);
  }
  
  if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
 8001e80:	0084      	lsls	r4, r0, #2
 8001e82:	d429      	bmi.n	8001ed8 <SD_CmdResp1Error+0xac>
  {
    return(SD_BLOCK_LEN_ERR);
  }
  
  if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
 8001e84:	00c1      	lsls	r1, r0, #3
 8001e86:	d429      	bmi.n	8001edc <SD_CmdResp1Error+0xb0>
  {
    return(SD_ERASE_SEQ_ERR);
  }
  
  if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
 8001e88:	0102      	lsls	r2, r0, #4
 8001e8a:	d429      	bmi.n	8001ee0 <SD_CmdResp1Error+0xb4>
  {
    return(SD_BAD_ERASE_PARAM);
  }
  
  if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
 8001e8c:	0143      	lsls	r3, r0, #5
 8001e8e:	d429      	bmi.n	8001ee4 <SD_CmdResp1Error+0xb8>
  {
    return(SD_WRITE_PROT_VIOLATION);
  }
  
  if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
 8001e90:	01c6      	lsls	r6, r0, #7
 8001e92:	d429      	bmi.n	8001ee8 <SD_CmdResp1Error+0xbc>
  {
    return(SD_LOCK_UNLOCK_FAILED);
  }
  
  if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
 8001e94:	0205      	lsls	r5, r0, #8
 8001e96:	d429      	bmi.n	8001eec <SD_CmdResp1Error+0xc0>
  {
    return(SD_COM_CRC_FAILED);
  }
  
  if((response_r1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
 8001e98:	0244      	lsls	r4, r0, #9
 8001e9a:	d4e1      	bmi.n	8001e60 <SD_CmdResp1Error+0x34>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
 8001e9c:	0281      	lsls	r1, r0, #10
 8001e9e:	d427      	bmi.n	8001ef0 <SD_CmdResp1Error+0xc4>
  {
    return(SD_CARD_ECC_FAILED);
  }
  
  if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
 8001ea0:	02c2      	lsls	r2, r0, #11
 8001ea2:	d427      	bmi.n	8001ef4 <SD_CmdResp1Error+0xc8>
  {
    return(SD_CC_ERROR);
  }
  
  if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
 8001ea4:	0303      	lsls	r3, r0, #12
 8001ea6:	d427      	bmi.n	8001ef8 <SD_CmdResp1Error+0xcc>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
 8001ea8:	0346      	lsls	r6, r0, #13
 8001eaa:	d427      	bmi.n	8001efc <SD_CmdResp1Error+0xd0>
  {
    return(SD_STREAM_READ_UNDERRUN);
  }
  
  if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
 8001eac:	0385      	lsls	r5, r0, #14
 8001eae:	d427      	bmi.n	8001f00 <SD_CmdResp1Error+0xd4>
  {
    return(SD_STREAM_WRITE_OVERRUN);
  }
  
  if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
 8001eb0:	03c4      	lsls	r4, r0, #15
 8001eb2:	d427      	bmi.n	8001f04 <SD_CmdResp1Error+0xd8>
  {
    return(SD_CID_CSD_OVERWRITE);
  }
  
  if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
 8001eb4:	0401      	lsls	r1, r0, #16
 8001eb6:	d427      	bmi.n	8001f08 <SD_CmdResp1Error+0xdc>
  {
    return(SD_WP_ERASE_SKIP);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
 8001eb8:	0442      	lsls	r2, r0, #17
 8001eba:	d427      	bmi.n	8001f0c <SD_CmdResp1Error+0xe0>
  {
    return(SD_CARD_ECC_DISABLED);
  }
  
  if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
 8001ebc:	0483      	lsls	r3, r0, #18
 8001ebe:	d427      	bmi.n	8001f10 <SD_CmdResp1Error+0xe4>
    return(SD_ERASE_RESET);
  }
  
  if((response_r1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
  {
    return(SD_AKE_SEQ_ERROR);
 8001ec0:	f010 0f08 	tst.w	r0, #8
 8001ec4:	bf0c      	ite	eq
 8001ec6:	2000      	moveq	r0, #0
 8001ec8:	201a      	movne	r0, #26
 8001eca:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  return errorstate;
 8001ecc:	4618      	mov	r0, r3
 8001ece:	bd70      	pop	{r4, r5, r6, pc}
    return errorstate;
  }
  
  if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
  {
    return(SD_ADDR_OUT_OF_RANGE);
 8001ed0:	201c      	movs	r0, #28
 8001ed2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
  {
    return(SD_ADDR_MISALIGNED);
 8001ed4:	2009      	movs	r0, #9
 8001ed6:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
  {
    return(SD_BLOCK_LEN_ERR);
 8001ed8:	200a      	movs	r0, #10
 8001eda:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
  {
    return(SD_ERASE_SEQ_ERR);
 8001edc:	200b      	movs	r0, #11
 8001ede:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
  {
    return(SD_BAD_ERASE_PARAM);
 8001ee0:	200c      	movs	r0, #12
 8001ee2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
  {
    return(SD_WRITE_PROT_VIOLATION);
 8001ee4:	200d      	movs	r0, #13
 8001ee6:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
  {
    return(SD_LOCK_UNLOCK_FAILED);
 8001ee8:	200e      	movs	r0, #14
 8001eea:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8001eec:	200f      	movs	r0, #15
 8001eee:	bd70      	pop	{r4, r5, r6, pc}
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
  {
    return(SD_CARD_ECC_FAILED);
 8001ef0:	2011      	movs	r0, #17
 8001ef2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
  {
    return(SD_CC_ERROR);
 8001ef4:	2012      	movs	r0, #18
 8001ef6:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8001ef8:	2013      	movs	r0, #19
 8001efa:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
  {
    return(SD_STREAM_READ_UNDERRUN);
 8001efc:	2014      	movs	r0, #20
 8001efe:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
  {
    return(SD_STREAM_WRITE_OVERRUN);
 8001f00:	2015      	movs	r0, #21
 8001f02:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
  {
    return(SD_CID_CSD_OVERWRITE);
 8001f04:	2016      	movs	r0, #22
 8001f06:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
  {
    return(SD_WP_ERASE_SKIP);
 8001f08:	2017      	movs	r0, #23
 8001f0a:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
  {
    return(SD_CARD_ECC_DISABLED);
 8001f0c:	2018      	movs	r0, #24
 8001f0e:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
  {
    return(SD_ERASE_RESET);
 8001f10:	2019      	movs	r0, #25
  {
    return(SD_AKE_SEQ_ERROR);
  }
  
  return errorstate;
}
 8001f12:	bd70      	pop	{r4, r5, r6, pc}
 8001f14:	fdffe008 	.word	0xfdffe008

08001f18 <HAL_SD_Get_CardInfo>:
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t tmp = 0U;
  
  pCardInfo->CardType = (uint8_t)(hsd->CardType);
 8001f18:	6a02      	ldr	r2, [r0, #32]
 8001f1a:	f881 2056 	strb.w	r2, [r1, #86]	; 0x56
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
 8001f1e:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001f20:	f8a1 2054 	strh.w	r2, [r1, #84]	; 0x54
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
 8001f24:	6a82      	ldr	r2, [r0, #40]	; 0x28
  * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
  *         contains all SD cardinformation  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
 8001f26:	4603      	mov	r3, r0
  pCardInfo->CardType = (uint8_t)(hsd->CardType);
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
 8001f28:	0f90      	lsrs	r0, r2, #30
 8001f2a:	7008      	strb	r0, [r1, #0]
  pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 8001f2c:	f3c2 6083 	ubfx	r0, r2, #26, #4
  pCardInfo->SD_csd.Reserved1      = tmp & 0x03U;
 8001f30:	f3c2 6201 	ubfx	r2, r2, #24, #2
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
  pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 8001f34:	7048      	strb	r0, [r1, #1]
  pCardInfo->SD_csd.Reserved1      = tmp & 0x03U;
 8001f36:	708a      	strb	r2, [r1, #2]
  
  /* Byte 1 */
  tmp = (hsd->CSD[0U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.TAAC = (uint8_t)tmp;
 8001f38:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
 8001f3c:	70ca      	strb	r2, [r1, #3]
  
  /* Byte 2 */
  tmp = (hsd->CSD[0U] & 0x0000FF00U) >> 8U;
  pCardInfo->SD_csd.NSAC = (uint8_t)tmp;
 8001f3e:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 8001f42:	710a      	strb	r2, [r1, #4]
  
  /* Byte 3 */
  tmp = hsd->CSD[0U] & 0x000000FFU;
  pCardInfo->SD_csd.MaxBusClkFrec = (uint8_t)tmp;
 8001f44:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
 8001f48:	714a      	strb	r2, [r1, #5]
  
  /* Byte 4 */
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
 8001f4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
 8001f4c:	0e10      	lsrs	r0, r2, #24
 8001f4e:	0100      	lsls	r0, r0, #4
 8001f50:	80c8      	strh	r0, [r1, #6]
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8001f52:	88c8      	ldrh	r0, [r1, #6]
  * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
  *         contains all SD cardinformation  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
 8001f54:	b5f0      	push	{r4, r5, r6, r7, lr}
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8001f56:	b280      	uxth	r0, r0
 8001f58:	f3c2 5403 	ubfx	r4, r2, #20, #4
 8001f5c:	4320      	orrs	r0, r4
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 8001f5e:	f3c2 4203 	ubfx	r2, r2, #16, #4
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8001f62:	80c8      	strh	r0, [r1, #6]
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 8001f64:	720a      	strb	r2, [r1, #8]
  
  /* Byte 6 */
  tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
 8001f66:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
  pCardInfo->SD_csd.PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
 8001f6a:	09d0      	lsrs	r0, r2, #7
 8001f6c:	7248      	strb	r0, [r1, #9]
  pCardInfo->SD_csd.WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
 8001f6e:	f3c2 1080 	ubfx	r0, r2, #6, #1
 8001f72:	7288      	strb	r0, [r1, #10]
  pCardInfo->SD_csd.RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
 8001f74:	f3c2 1040 	ubfx	r0, r2, #5, #1
 8001f78:	72c8      	strb	r0, [r1, #11]
  pCardInfo->SD_csd.DSRImpl         = (uint8_t)((tmp & 0x10U) >> 4U);
 8001f7a:	f3c2 1000 	ubfx	r0, r2, #4, #1
 8001f7e:	7308      	strb	r0, [r1, #12]
  pCardInfo->SD_csd.Reserved2       = 0U; /*!< Reserved */
 8001f80:	2000      	movs	r0, #0
 8001f82:	7348      	strb	r0, [r1, #13]
  
  if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0))
 8001f84:	6a1c      	ldr	r4, [r3, #32]
 8001f86:	2c01      	cmp	r4, #1
 8001f88:	d83c      	bhi.n	8002004 <HAL_SD_Get_CardInfo+0xec>
  {
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x03U) << 10U;
 8001f8a:	0292      	lsls	r2, r2, #10
 8001f8c:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 8001f90:	610a      	str	r2, [r1, #16]
    
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
 8001f92:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001f94:	690c      	ldr	r4, [r1, #16]
 8001f96:	0092      	lsls	r2, r2, #2
 8001f98:	f402 727f 	and.w	r2, r2, #1020	; 0x3fc
 8001f9c:	4322      	orrs	r2, r4
 8001f9e:	610a      	str	r2, [r1, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
 8001fa0:	690c      	ldr	r4, [r1, #16]
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8001fa2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
 8001fa4:	ea44 7492 	orr.w	r4, r4, r2, lsr #30
 8001fa8:	610c      	str	r4, [r1, #16]
    
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8001faa:	f3c2 64c2 	ubfx	r4, r2, #27, #3
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
 8001fae:	f3c2 6202 	ubfx	r2, r2, #24, #3
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
    
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8001fb2:	750c      	strb	r4, [r1, #20]
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
 8001fb4:	754a      	strb	r2, [r1, #21]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
 8001fb6:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
 8001fb8:	b2d4      	uxtb	r4, r2
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8001fba:	0052      	lsls	r2, r2, #1
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
 8001fbc:	0965      	lsrs	r5, r4, #5
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8001fbe:	f002 0206 	and.w	r2, r2, #6
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 8001fc2:	f3c4 0482 	ubfx	r4, r4, #2, #3
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
 8001fc6:	758d      	strb	r5, [r1, #22]
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 8001fc8:	75cc      	strb	r4, [r1, #23]
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8001fca:	760a      	strb	r2, [r1, #24]
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 8001fcc:	7e0c      	ldrb	r4, [r1, #24]
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 8001fce:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 8001fd2:	ea44 14d2 	orr.w	r4, r4, r2, lsr #7
 8001fd6:	760c      	strb	r4, [r1, #24]
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
 8001fd8:	690c      	ldr	r4, [r1, #16]
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
 8001fda:	f891 e018 	ldrb.w	lr, [r1, #24]
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
 8001fde:	1c66      	adds	r6, r4, #1
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
    pCardInfo->CardBlockSize = 1U << (pCardInfo->SD_csd.RdBlockLen);
 8001fe0:	7a0c      	ldrb	r4, [r1, #8]
 8001fe2:	2501      	movs	r5, #1
 8001fe4:	fa05 f404 	lsl.w	r4, r5, r4
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 8001fe8:	f10e 0e02 	add.w	lr, lr, #2
 8001fec:	fa05 fe0e 	lsl.w	lr, r5, lr
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
    pCardInfo->CardBlockSize = 1U << (pCardInfo->SD_csd.RdBlockLen);
 8001ff0:	650c      	str	r4, [r1, #80]	; 0x50
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 8001ff2:	fba6 4504 	umull	r4, r5, r6, r4
 8001ff6:	fbae 6704 	umull	r6, r7, lr, r4
 8001ffa:	fb0e 7705 	mla	r7, lr, r5, r7
 8001ffe:	e9c1 6712 	strd	r6, r7, [r1, #72]	; 0x48
 8002002:	e023      	b.n	800204c <HAL_SD_Get_CardInfo+0x134>
  }
  else if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8002004:	2c02      	cmp	r4, #2
 8002006:	d120      	bne.n	800204a <HAL_SD_Get_CardInfo+0x132>
  {
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x3FU) << 16U;
 8002008:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800200a:	0412      	lsls	r2, r2, #16
 800200c:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
 8002010:	610a      	str	r2, [r1, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8002012:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    
    pCardInfo->SD_csd.DeviceSize |= (tmp << 8U);
 8002014:	690c      	ldr	r4, [r1, #16]
 8002016:	0e15      	lsrs	r5, r2, #24
 8002018:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
 800201c:	610c      	str	r4, [r1, #16]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
 800201e:	690c      	ldr	r4, [r1, #16]
 8002020:	f3c2 4507 	ubfx	r5, r2, #16, #8
 8002024:	432c      	orrs	r4, r5
 8002026:	610c      	str	r4, [r1, #16]
    
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    
    pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1U)) * 512U * 1024U);
 8002028:	690c      	ldr	r4, [r1, #16]
 800202a:	2500      	movs	r5, #0
 800202c:	3401      	adds	r4, #1
 800202e:	f145 0500 	adc.w	r5, r5, #0
 8002032:	04ed      	lsls	r5, r5, #19
 8002034:	ea45 3554 	orr.w	r5, r5, r4, lsr #13
 8002038:	04e4      	lsls	r4, r4, #19
 800203a:	648c      	str	r4, [r1, #72]	; 0x48
    pCardInfo->CardBlockSize = 512U;    
 800203c:	f44f 7400 	mov.w	r4, #512	; 0x200
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
    
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 8002040:	f3c2 2207 	ubfx	r2, r2, #8, #8
    
    pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1U)) * 512U * 1024U);
 8002044:	64cd      	str	r5, [r1, #76]	; 0x4c
    pCardInfo->CardBlockSize = 512U;    
 8002046:	650c      	str	r4, [r1, #80]	; 0x50
 8002048:	e000      	b.n	800204c <HAL_SD_Get_CardInfo+0x134>
  }
  else
  {
    /* Not supported card type */
    errorstate = SD_ERROR;
 800204a:	2029      	movs	r0, #41	; 0x29
  }
    
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
 800204c:	f3c2 1480 	ubfx	r4, r2, #6, #1
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
 8002050:	0052      	lsls	r2, r2, #1
 8002052:	f002 027e 	and.w	r2, r2, #126	; 0x7e
  {
    /* Not supported card type */
    errorstate = SD_ERROR;
  }
    
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
 8002056:	764c      	strb	r4, [r1, #25]
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
 8002058:	768a      	strb	r2, [r1, #26]
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
 800205a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80U) >> 7U;
 800205c:	7e8d      	ldrb	r5, [r1, #26]
 800205e:	f3c2 14c0 	ubfx	r4, r2, #7, #1
 8002062:	432c      	orrs	r4, r5
  pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7FU);
 8002064:	f002 027f 	and.w	r2, r2, #127	; 0x7f
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
  pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80U) >> 7U;
 8002068:	768c      	strb	r4, [r1, #26]
  pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7FU);
 800206a:	76ca      	strb	r2, [r1, #27]
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
 800206c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80U) >> 7U;
 800206e:	0fd4      	lsrs	r4, r2, #31
 8002070:	770c      	strb	r4, [r1, #28]
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
 8002072:	f3c2 7441 	ubfx	r4, r2, #29, #2
 8002076:	774c      	strb	r4, [r1, #29]
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 8002078:	f3c2 6482 	ubfx	r4, r2, #26, #3
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 800207c:	0d92      	lsrs	r2, r2, #22
 800207e:	f002 020c 	and.w	r2, r2, #12
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 8002082:	778c      	strb	r4, [r1, #30]
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 8002084:	77ca      	strb	r2, [r1, #31]
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
 8002086:	8eda      	ldrh	r2, [r3, #54]	; 0x36
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 8002088:	7fcd      	ldrb	r5, [r1, #31]
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
 800208a:	b2d4      	uxtb	r4, r2
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 800208c:	ea45 1594 	orr.w	r5, r5, r4, lsr #6
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
 8002090:	f3c4 1440 	ubfx	r4, r4, #5, #1
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 8002094:	77cd      	strb	r5, [r1, #31]
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.Reserved3           = 0U;
  pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01U);
 8002096:	f002 0201 	and.w	r2, r2, #1
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
 800209a:	f881 4020 	strb.w	r4, [r1, #32]
  pCardInfo->SD_csd.Reserved3           = 0U;
 800209e:	2400      	movs	r4, #0
 80020a0:	f881 4021 	strb.w	r4, [r1, #33]	; 0x21
  pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01U);
 80020a4:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
 80020a8:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 80020aa:	0a24      	lsrs	r4, r4, #8
 80020ac:	b2e2      	uxtb	r2, r4
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
 80020ae:	09d5      	lsrs	r5, r2, #7
 80020b0:	f881 5023 	strb.w	r5, [r1, #35]	; 0x23
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
 80020b4:	f3c2 1580 	ubfx	r5, r2, #6, #1
 80020b8:	f881 5024 	strb.w	r5, [r1, #36]	; 0x24
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
 80020bc:	f3c2 1540 	ubfx	r5, r2, #5, #1
 80020c0:	f881 5025 	strb.w	r5, [r1, #37]	; 0x25
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
 80020c4:	f004 0403 	and.w	r4, r4, #3
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
 80020c8:	f3c2 1500 	ubfx	r5, r2, #4, #1
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
 80020cc:	f3c2 0281 	ubfx	r2, r2, #2, #2
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
 80020d0:	f881 5026 	strb.w	r5, [r1, #38]	; 0x26
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
 80020d4:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
 80020d8:	f881 4028 	strb.w	r4, [r1, #40]	; 0x28
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
  pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFEU) >> 1U;
 80020dc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  pCardInfo->SD_csd.Reserved4 = 1U;
 80020de:	2401      	movs	r4, #1
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
  pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFEU) >> 1U;
 80020e0:	f3c2 0246 	ubfx	r2, r2, #1, #7
 80020e4:	f881 2029 	strb.w	r2, [r1, #41]	; 0x29
  pCardInfo->SD_csd.Reserved4 = 1U;
 80020e8:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
  
  /* Byte 0 */
  tmp = (uint8_t)((hsd->CID[0U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ManufacturerID = tmp;
 80020ec:	f893 203b 	ldrb.w	r2, [r3, #59]	; 0x3b
 80020f0:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
  
  /* Byte 1 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x00FF0000U) >> 16U);
 80020f4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  pCardInfo->SD_cid.OEM_AppliID = tmp << 8U;
 80020f6:	f3c2 4507 	ubfx	r5, r2, #16, #8
 80020fa:	022d      	lsls	r5, r5, #8
 80020fc:	85cd      	strh	r5, [r1, #46]	; 0x2e
  
  /* Byte 2 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.OEM_AppliID |= tmp;
 80020fe:	8dcd      	ldrh	r5, [r1, #46]	; 0x2e
 8002100:	b2ae      	uxth	r6, r5
 8002102:	f3c2 2507 	ubfx	r5, r2, #8, #8
 8002106:	4335      	orrs	r5, r6
 8002108:	0612      	lsls	r2, r2, #24
 800210a:	85cd      	strh	r5, [r1, #46]	; 0x2e
  
  /* Byte 3 */
  tmp = (uint8_t)(hsd->CID[0U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName1 = tmp << 24U;
 800210c:	630a      	str	r2, [r1, #48]	; 0x30
  
  /* Byte 4 */
  tmp = (uint8_t)((hsd->CID[1U] & 0xFF000000U) >> 24U);
 800210e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  pCardInfo->SD_cid.ProdName1 |= tmp << 16U;
 8002110:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 8002112:	0e16      	lsrs	r6, r2, #24
 8002114:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
 8002118:	630d      	str	r5, [r1, #48]	; 0x30
  
  /* Byte 5 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
 800211a:	6b0e      	ldr	r6, [r1, #48]	; 0x30
 800211c:	0a15      	lsrs	r5, r2, #8
 800211e:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
 8002122:	4335      	orrs	r5, r6
 8002124:	630d      	str	r5, [r1, #48]	; 0x30
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdName1 |= tmp;
 8002126:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 8002128:	f3c2 2607 	ubfx	r6, r2, #8, #8
 800212c:	4335      	orrs	r5, r6
  
  /* Byte 7 */
  tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName2 = tmp;
 800212e:	b2d2      	uxtb	r2, r2
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdName1 |= tmp;
 8002130:	630d      	str	r5, [r1, #48]	; 0x30
  
  /* Byte 7 */
  tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName2 = tmp;
 8002132:	f881 2034 	strb.w	r2, [r1, #52]	; 0x34
  
  /* Byte 8 */
  tmp = (uint8_t)((hsd->CID[2U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdRev = tmp;
 8002136:	f893 2043 	ldrb.w	r2, [r3, #67]	; 0x43
 800213a:	f881 2035 	strb.w	r2, [r1, #53]	; 0x35
  
  /* Byte 9 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x00FF0000U) >> 16U);
 800213e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002140:	0c15      	lsrs	r5, r2, #16
 8002142:	062d      	lsls	r5, r5, #24
  pCardInfo->SD_cid.ProdSN = tmp << 24U;
 8002144:	638d      	str	r5, [r1, #56]	; 0x38
  
  /* Byte 10 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdSN |= tmp << 16U;
 8002146:	6b8e      	ldr	r6, [r1, #56]	; 0x38
 8002148:	0215      	lsls	r5, r2, #8
 800214a:	f405 057f 	and.w	r5, r5, #16711680	; 0xff0000
 800214e:	4335      	orrs	r5, r6
 8002150:	638d      	str	r5, [r1, #56]	; 0x38
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
 8002152:	6b8d      	ldr	r5, [r1, #56]	; 0x38
 8002154:	0212      	lsls	r2, r2, #8
 8002156:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 800215a:	432a      	orrs	r2, r5
 800215c:	638a      	str	r2, [r1, #56]	; 0x38
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
 800215e:	6b8d      	ldr	r5, [r1, #56]	; 0x38
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
 8002160:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  pCardInfo->SD_cid.ProdSN |= tmp;
 8002162:	ea45 6512 	orr.w	r5, r5, r2, lsr #24
 8002166:	638d      	str	r5, [r1, #56]	; 0x38
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8002168:	f891 503c 	ldrb.w	r5, [r1, #60]	; 0x3c
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
 800216c:	f3c2 4207 	ubfx	r2, r2, #16, #8
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8002170:	ea45 1512 	orr.w	r5, r5, r2, lsr #4
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
 8002174:	0212      	lsls	r2, r2, #8
 8002176:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 800217a:	f881 503c 	strb.w	r5, [r1, #60]	; 0x3c
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
 800217e:	87ca      	strh	r2, [r1, #62]	; 0x3e
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
 8002180:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  pCardInfo->SD_cid.ManufactDate |= tmp;
 8002182:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
 8002184:	b295      	uxth	r5, r2
 8002186:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800218a:	432a      	orrs	r2, r5
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
  pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFEU) >> 1U;
 800218c:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ManufactDate |= tmp;
 8002190:	87ca      	strh	r2, [r1, #62]	; 0x3e
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
  pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFEU) >> 1U;
 8002192:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
  pCardInfo->SD_cid.Reserved2 = 1U;
 8002196:	f881 4041 	strb.w	r4, [r1, #65]	; 0x41
  
  return errorstate;
}
 800219a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800219c <HAL_SD_Init>:
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 800219c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
 80021a0:	2500      	movs	r5, #0
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 80021a2:	b091      	sub	sp, #68	; 0x44
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
  SD_InitTypeDef tmpinit;
  
  /* Allocate lock resource and initialize it */
  hsd->Lock = HAL_UNLOCKED;
 80021a4:	7705      	strb	r5, [r0, #28]
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 80021a6:	4604      	mov	r4, r0
 80021a8:	460e      	mov	r6, r1
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
 80021aa:	f88d 5012 	strb.w	r5, [sp, #18]
  SD_InitTypeDef tmpinit;
  
  /* Allocate lock resource and initialize it */
  hsd->Lock = HAL_UNLOCKED;
  /* Initialize the low level hardware (MSP) */
  HAL_SD_MspInit(hsd);
 80021ae:	f7fe f9d7 	bl	8000560 <HAL_SD_MspInit>
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
 80021b2:	2376      	movs	r3, #118	; 0x76
 80021b4:	930f      	str	r3, [sp, #60]	; 0x3c
  
  /* Default SDIO peripheral configuration for SD card initialization */
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
 80021b6:	950d      	str	r5, [sp, #52]	; 0x34
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 80021b8:	950e      	str	r5, [sp, #56]	; 0x38
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
 80021ba:	ab10      	add	r3, sp, #64	; 0x40
 80021bc:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 80021c0:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
  hsd->Lock = HAL_UNLOCKED;
  /* Initialize the low level hardware (MSP) */
  HAL_SD_MspInit(hsd);
  
  /* Default SDIO peripheral configuration for SD card initialization */
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
 80021c4:	950a      	str	r5, [sp, #40]	; 0x28
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
 80021c6:	950b      	str	r5, [sp, #44]	; 0x2c
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
 80021c8:	950c      	str	r5, [sp, #48]	; 0x30
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
  
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
 80021ca:	4f9e      	ldr	r7, [pc, #632]	; (8002444 <HAL_SD_Init+0x2a8>)
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
 80021cc:	6820      	ldr	r0, [r4, #0]
 80021ce:	ab0a      	add	r3, sp, #40	; 0x28
 80021d0:	cb0e      	ldmia	r3, {r1, r2, r3}
 80021d2:	f000 fea7 	bl	8002f24 <SDIO_Init>
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
 80021d6:	f88d 5013 	strb.w	r5, [sp, #19]
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
  
  /* Set Power State to ON */
  SDIO_PowerState_ON(hsd->Instance);
 80021da:	6820      	ldr	r0, [r4, #0]
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
  
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
 80021dc:	603d      	str	r5, [r7, #0]
  
  /* Set Power State to ON */
  SDIO_PowerState_ON(hsd->Instance);
 80021de:	f000 fec4 	bl	8002f6a <SDIO_PowerState_ON>
  
  /* 1ms: required power up waiting time before starting the SD initialization 
     sequence */
  HAL_Delay(1);
 80021e2:	2001      	movs	r0, #1
 80021e4:	f7fe fcc0 	bl	8000b68 <HAL_Delay>
  
  /* Enable SDIO Clock */
  __HAL_SD_SDIO_ENABLE();
 80021e8:	2301      	movs	r3, #1
 80021ea:	603b      	str	r3, [r7, #0]
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80021ec:	a905      	add	r1, sp, #20
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80021ee:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80021f2:	6820      	ldr	r0, [r4, #0]
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80021f4:	9309      	str	r3, [sp, #36]	; 0x24
  /* Enable SDIO Clock */
  __HAL_SD_SDIO_ENABLE();
  
  /* CMD0: GO_IDLE_STATE -----------------------------------------------------*/
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
 80021f6:	9505      	str	r5, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
 80021f8:	9506      	str	r5, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
 80021fa:	9507      	str	r5, [sp, #28]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80021fc:	9508      	str	r5, [sp, #32]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80021fe:	f000 febc 	bl	8002f7a <SDIO_SendCommand>
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t timeout, tmp;
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 8002202:	6820      	ldr	r0, [r4, #0]
 8002204:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002206:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800220a:	f3c3 13c0 	ubfx	r3, r3, #7, #1
    
  while((timeout > 0U) && (!tmp))
 800220e:	2b00      	cmp	r3, #0
 8002210:	f040 817e 	bne.w	8002510 <HAL_SD_Init+0x374>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 8002214:	6b43      	ldr	r3, [r0, #52]	; 0x34
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
    
  while((timeout > 0U) && (!tmp))
 8002216:	3a01      	subs	r2, #1
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 8002218:	f3c3 13c0 	ubfx	r3, r3, #7, #1
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
    
  while((timeout > 0U) && (!tmp))
 800221c:	d1f7      	bne.n	800220e <HAL_SD_Init+0x72>
  }
  
  if(timeout == 0U)
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    return errorstate;
 800221e:	2303      	movs	r3, #3
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
  
  /* Check for error conditions */
  errorstate = SD_CmdError(hsd);
 8002220:	f88d 3013 	strb.w	r3, [sp, #19]
  
  if(errorstate != SD_OK)
 8002224:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8002228:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 800222c:	2b00      	cmp	r3, #0
 800222e:	f040 80a3 	bne.w	8002378 <HAL_SD_Init+0x1dc>
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
 8002232:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 8002236:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
 8002238:	2308      	movs	r3, #8
 800223a:	9306      	str	r3, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800223c:	a905      	add	r1, sp, #20
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800223e:	2340      	movs	r3, #64	; 0x40
 8002240:	9307      	str	r3, [sp, #28]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002242:	f000 fe9a 	bl	8002f7a <SDIO_SendCommand>
static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_ERROR;
  uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
 8002246:	6820      	ldr	r0, [r4, #0]
 8002248:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800224a:	f013 0f45 	tst.w	r3, #69	; 0x45
 800224e:	bf14      	ite	ne
 8002250:	2201      	movne	r2, #1
 8002252:	2200      	moveq	r2, #0
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_ERROR;
  uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
 8002254:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
  
  while((!tmp) && (timeout > 0U))
 8002258:	b942      	cbnz	r2, 800226c <HAL_SD_Init+0xd0>
 800225a:	b13b      	cbz	r3, 800226c <HAL_SD_Init+0xd0>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT);
 800225c:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800225e:	f012 0f45 	tst.w	r2, #69	; 0x45
 8002262:	bf14      	ite	ne
 8002264:	2201      	movne	r2, #1
 8002266:	2200      	moveq	r2, #0
    timeout--;
 8002268:	3b01      	subs	r3, #1
 800226a:	e7f5      	b.n	8002258 <HAL_SD_Init+0xbc>
  }
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT); 
 800226c:	6b42      	ldr	r2, [r0, #52]	; 0x34
  
  if((timeout == 0U) || tmp)
 800226e:	b10b      	cbz	r3, 8002274 <HAL_SD_Init+0xd8>
 8002270:	0757      	lsls	r7, r2, #29
 8002272:	d503      	bpl.n	800227c <HAL_SD_Init+0xe0>
  {
    /* Card is not V2.0 compliant or card does not support the set voltage range */
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8002274:	2304      	movs	r3, #4
 8002276:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8002278:	2503      	movs	r5, #3
 800227a:	e005      	b.n	8002288 <HAL_SD_Init+0xec>
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDREND))
 800227c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800227e:	0659      	lsls	r1, r3, #25
  {
    /* Card is SD V2.0 compliant */
    errorstate = SD_OK;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CMDREND);
 8002280:	bf46      	itte	mi
 8002282:	2340      	movmi	r3, #64	; 0x40
 8002284:	6383      	strmi	r3, [r0, #56]	; 0x38
    
    return errorstate;
  }
  
  return errorstate;
 8002286:	2529      	movpl	r5, #41	; 0x29
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
  
  /* Check for error conditions */ 
  errorstate = SD_CmdResp7Error(hsd);
 8002288:	f88d 5013 	strb.w	r5, [sp, #19]
  
  if (errorstate == SD_OK)
 800228c:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8002290:	2300      	movs	r3, #0
 8002292:	b922      	cbnz	r2, 800229e <HAL_SD_Init+0x102>
  {
    /* SD Card 2.0 */
    hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
 8002294:	2201      	movs	r2, #1
 8002296:	6222      	str	r2, [r4, #32]
    sdtype        = SD_HIGH_CAPACITY;
 8002298:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 800229c:	e000      	b.n	80022a0 <HAL_SD_Init+0x104>
static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
 800229e:	461d      	mov	r5, r3
    sdtype        = SD_HIGH_CAPACITY;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80022a0:	2737      	movs	r7, #55	; 0x37
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80022a2:	a905      	add	r1, sp, #20
    hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
    sdtype        = SD_HIGH_CAPACITY;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = 0U;
 80022a4:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80022a6:	9706      	str	r7, [sp, #24]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80022a8:	f000 fe67 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80022ac:	4639      	mov	r1, r7
 80022ae:	4620      	mov	r0, r4
 80022b0:	f7ff fdbc 	bl	8001e2c <SD_CmdResp1Error>
 80022b4:	f88d 0013 	strb.w	r0, [sp, #19]
  
  /* If errorstate is Command Timeout, it is a MMC card */
  /* If errorstate is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  if(errorstate == SD_OK)
 80022b8:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80022bc:	f003 08ff 	and.w	r8, r3, #255	; 0xff
 80022c0:	2b00      	cmp	r3, #0
 80022c2:	d159      	bne.n	8002378 <HAL_SD_Init+0x1dc>
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 80022c4:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
 80022c8:	46c1      	mov	r9, r8
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 80022ca:	f445 1580 	orr.w	r5, r5, #1048576	; 0x100000
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80022ce:	2737      	movs	r7, #55	; 0x37
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80022d0:	a905      	add	r1, sp, #20
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80022d2:	f04f 0b40 	mov.w	fp, #64	; 0x40
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80022d6:	f44f 6a80 	mov.w	sl, #1024	; 0x400
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80022da:	6820      	ldr	r0, [r4, #0]
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80022dc:	9706      	str	r7, [sp, #24]
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
 80022de:	f8cd 9014 	str.w	r9, [sp, #20]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80022e2:	f8cd b01c 	str.w	fp, [sp, #28]
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80022e6:	f8cd 9020 	str.w	r9, [sp, #32]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80022ea:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80022ee:	f000 fe44 	bl	8002f7a <SDIO_SendCommand>
      
      /* Check for error conditions */
      errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80022f2:	4639      	mov	r1, r7
 80022f4:	4620      	mov	r0, r4
 80022f6:	f7ff fd99 	bl	8001e2c <SD_CmdResp1Error>
 80022fa:	f88d 0013 	strb.w	r0, [sp, #19]
      
      if(errorstate != SD_OK)
 80022fe:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8002302:	f003 07ff 	and.w	r7, r3, #255	; 0xff
 8002306:	2b00      	cmp	r3, #0
 8002308:	d136      	bne.n	8002378 <HAL_SD_Init+0x1dc>
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
 800230a:	2329      	movs	r3, #41	; 0x29
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800230c:	a905      	add	r1, sp, #20
 800230e:	6820      	ldr	r0, [r4, #0]
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
 8002310:	9306      	str	r3, [sp, #24]
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 8002312:	9505      	str	r5, [sp, #20]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8002314:	f8cd b01c 	str.w	fp, [sp, #28]
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002318:	9708      	str	r7, [sp, #32]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800231a:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800231e:	f000 fe2c 	bl	8002f7a <SDIO_SendCommand>
  */
static HAL_SD_ErrorTypedef SD_CmdResp3Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8002322:	6823      	ldr	r3, [r4, #0]
 8002324:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002326:	f012 0f45 	tst.w	r2, #69	; 0x45
 800232a:	d0fb      	beq.n	8002324 <HAL_SD_Init+0x188>
  {
  }
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 800232c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800232e:	0752      	lsls	r2, r2, #29
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8002330:	bf45      	ittet	mi
 8002332:	2204      	movmi	r2, #4
    
    return errorstate;
 8002334:	2703      	movmi	r7, #3
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002336:	f240 52ff 	movwpl	r2, #1535	; 0x5ff
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 800233a:	639a      	strmi	r2, [r3, #56]	; 0x38
    
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800233c:	bf58      	it	pl
 800233e:	639a      	strpl	r2, [r3, #56]	; 0x38
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
      
      /* Check for error conditions */
      errorstate = SD_CmdResp3Error(hsd);
 8002340:	f88d 7013 	strb.w	r7, [sp, #19]
      
      if(errorstate != SD_OK)
 8002344:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8002348:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 800234c:	b9a3      	cbnz	r3, 8002378 <HAL_SD_Init+0x1dc>
      {
        return errorstate;
      }
      
      /* Get command response */
      response = SDIO_GetResponse(SDIO_RESP1);
 800234e:	f000 fe2b 	bl	8002fa8 <SDIO_GetResponse>
     or SD card 1.x */
  if(errorstate == SD_OK)
  {
    /* SD CARD */
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
 8002352:	2800      	cmp	r0, #0
      response = SDIO_GetResponse(SDIO_RESP1);
      
      /* Get operating voltage*/
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
      
      count++;
 8002354:	f108 0801 	add.w	r8, r8, #1
 8002358:	f64f 73ff 	movw	r3, #65535	; 0xffff
     or SD card 1.x */
  if(errorstate == SD_OK)
  {
    /* SD CARD */
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
 800235c:	db02      	blt.n	8002364 <HAL_SD_Init+0x1c8>
 800235e:	4598      	cmp	r8, r3
 8002360:	d1b5      	bne.n	80022ce <HAL_SD_Init+0x132>
 8002362:	e001      	b.n	8002368 <HAL_SD_Init+0x1cc>
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
      
      count++;
    }
    
    if(count >= SD_MAX_VOLT_TRIAL)
 8002364:	4598      	cmp	r8, r3
 8002366:	d103      	bne.n	8002370 <HAL_SD_Init+0x1d4>
    {
      errorstate = SD_INVALID_VOLTRANGE;
 8002368:	231b      	movs	r3, #27
 800236a:	f88d 3013 	strb.w	r3, [sp, #19]
 800236e:	e003      	b.n	8002378 <HAL_SD_Init+0x1dc>
      
      return errorstate;
    }
    
    if((response & SD_HIGH_CAPACITY) == SD_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 8002370:	0043      	lsls	r3, r0, #1
    {
      hsd->CardType = HIGH_CAPACITY_SD_CARD;
 8002372:	bf44      	itt	mi
 8002374:	2302      	movmi	r3, #2
 8002376:	6223      	strmi	r3, [r4, #32]
    }
    
  } /* else MMC Card */
  
  return errorstate;
 8002378:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800237c:	b2db      	uxtb	r3, r3
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
  
  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd); 
 800237e:	f88d 3012 	strb.w	r3, [sp, #18]
  
  if(errorstate != SD_OK)     
 8002382:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8002386:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 800238a:	2b00      	cmp	r3, #0
 800238c:	f040 80ba 	bne.w	8002504 <HAL_SD_Init+0x368>
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint16_t sd_rca = 1U;
  
  if(SDIO_GetPowerState(hsd->Instance) == 0U) /* Power off */
 8002390:	6820      	ldr	r0, [r4, #0]
 8002392:	f000 fdee 	bl	8002f72 <SDIO_GetPowerState>
 8002396:	2800      	cmp	r0, #0
 8002398:	f000 8080 	beq.w	800249c <HAL_SD_Init+0x300>
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
  }
  
  if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
 800239c:	6a23      	ldr	r3, [r4, #32]
 800239e:	2b04      	cmp	r3, #4
 80023a0:	d020      	beq.n	80023e4 <HAL_SD_Init+0x248>
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
 80023a2:	2302      	movs	r3, #2
 80023a4:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 80023a6:	23c0      	movs	r3, #192	; 0xc0
 80023a8:	9307      	str	r3, [sp, #28]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80023aa:	a905      	add	r1, sp, #20
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80023ac:	f44f 6380 	mov.w	r3, #1024	; 0x400
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80023b0:	6820      	ldr	r0, [r4, #0]
  }
  
  if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
 80023b2:	9505      	str	r5, [sp, #20]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80023b4:	9508      	str	r5, [sp, #32]
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80023b6:	9309      	str	r3, [sp, #36]	; 0x24
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80023b8:	f000 fddf 	bl	8002f7a <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 80023bc:	4620      	mov	r0, r4
 80023be:	f7ff fc7d 	bl	8001cbc <SD_CmdResp2Error>
    
    if(errorstate != SD_OK)
 80023c2:	2800      	cmp	r0, #0
 80023c4:	d16c      	bne.n	80024a0 <HAL_SD_Init+0x304>
    {
      return errorstate;
    }
    
    /* Get Card identification number data */
    hsd->CID[0U] = SDIO_GetResponse(SDIO_RESP1);
 80023c6:	f000 fdef 	bl	8002fa8 <SDIO_GetResponse>
 80023ca:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->CID[1U] = SDIO_GetResponse(SDIO_RESP2);
 80023cc:	2004      	movs	r0, #4
 80023ce:	f000 fdeb 	bl	8002fa8 <SDIO_GetResponse>
 80023d2:	63e0      	str	r0, [r4, #60]	; 0x3c
    hsd->CID[2U] = SDIO_GetResponse(SDIO_RESP3);
 80023d4:	2008      	movs	r0, #8
 80023d6:	f000 fde7 	bl	8002fa8 <SDIO_GetResponse>
 80023da:	6420      	str	r0, [r4, #64]	; 0x40
    hsd->CID[3U] = SDIO_GetResponse(SDIO_RESP4);
 80023dc:	200c      	movs	r0, #12
 80023de:	f000 fde3 	bl	8002fa8 <SDIO_GetResponse>
 80023e2:	6460      	str	r0, [r4, #68]	; 0x44
  }
  
  if((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1)    || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 80023e4:	6a23      	ldr	r3, [r4, #32]
 80023e6:	2b02      	cmp	r3, #2
 80023e8:	d901      	bls.n	80023ee <HAL_SD_Init+0x252>
 80023ea:	2b06      	cmp	r3, #6
 80023ec:	d132      	bne.n	8002454 <HAL_SD_Init+0x2b8>
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
 80023ee:	2303      	movs	r3, #3
 80023f0:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80023f2:	a905      	add	r1, sp, #20
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80023f4:	2340      	movs	r3, #64	; 0x40
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80023f6:	6820      	ldr	r0, [r4, #0]
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80023f8:	9307      	str	r3, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80023fa:	f000 fdbe 	bl	8002f7a <SDIO_SendCommand>
static HAL_SD_ErrorTypedef SD_CmdResp6Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD, uint16_t *pRCA)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 80023fe:	6820      	ldr	r0, [r4, #0]
 8002400:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002402:	f013 0f45 	tst.w	r3, #69	; 0x45
 8002406:	d0fb      	beq.n	8002400 <HAL_SD_Init+0x264>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8002408:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800240a:	075f      	lsls	r7, r3, #29
 800240c:	d503      	bpl.n	8002416 <HAL_SD_Init+0x27a>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 800240e:	2304      	movs	r3, #4
 8002410:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8002412:	2503      	movs	r5, #3
 8002414:	e045      	b.n	80024a2 <HAL_SD_Init+0x306>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8002416:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002418:	f013 0701 	ands.w	r7, r3, #1
 800241c:	d002      	beq.n	8002424 <HAL_SD_Init+0x288>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 800241e:	2501      	movs	r5, #1
 8002420:	6385      	str	r5, [r0, #56]	; 0x38
 8002422:	e03e      	b.n	80024a2 <HAL_SD_Init+0x306>
  {
    /* No error flag set */
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 8002424:	f000 fdbc 	bl	8002fa0 <SDIO_GetCommandResponse>
 8002428:	2803      	cmp	r0, #3
 800242a:	d176      	bne.n	800251a <HAL_SD_Init+0x37e>
    
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800242c:	6823      	ldr	r3, [r4, #0]
 800242e:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8002432:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it.  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 8002434:	4638      	mov	r0, r7
 8002436:	f000 fdb7 	bl	8002fa8 <SDIO_GetResponse>
  
  if((response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED)) == SD_ALLZERO)
 800243a:	f410 4f60 	tst.w	r0, #57344	; 0xe000
 800243e:	d103      	bne.n	8002448 <HAL_SD_Init+0x2ac>
  {
    *pRCA = (uint16_t) (response_r1 >> 16U);
 8002440:	0c00      	lsrs	r0, r0, #16
 8002442:	e008      	b.n	8002456 <HAL_SD_Init+0x2ba>
 8002444:	422580a0 	.word	0x422580a0
    
    return errorstate;
  }
  
  if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
 8002448:	0481      	lsls	r1, r0, #18
 800244a:	d468      	bmi.n	800251e <HAL_SD_Init+0x382>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((response_r1 & SD_R6_ILLEGAL_CMD) == SD_R6_ILLEGAL_CMD)
 800244c:	0442      	lsls	r2, r0, #17
 800244e:	d464      	bmi.n	800251a <HAL_SD_Init+0x37e>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
 8002450:	0403      	lsls	r3, r0, #16
 8002452:	d466      	bmi.n	8002522 <HAL_SD_Init+0x386>
  */
static HAL_SD_ErrorTypedef SD_Initialize_Cards(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint16_t sd_rca = 1U;
 8002454:	2001      	movs	r0, #1
    {
      return errorstate;
    }
  }
  
  if (hsd->CardType != SECURE_DIGITAL_IO_CARD)
 8002456:	6a23      	ldr	r3, [r4, #32]
 8002458:	2b04      	cmp	r3, #4
 800245a:	d022      	beq.n	80024a2 <HAL_SD_Init+0x306>
  {
    /* Get the SD card RCA */
    hsd->RCA = sd_rca;
 800245c:	6260      	str	r0, [r4, #36]	; 0x24
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
 800245e:	2309      	movs	r3, #9
  {
    /* Get the SD card RCA */
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8002460:	0400      	lsls	r0, r0, #16
 8002462:	9005      	str	r0, [sp, #20]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
 8002464:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002466:	a905      	add	r1, sp, #20
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 8002468:	23c0      	movs	r3, #192	; 0xc0
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800246a:	6820      	ldr	r0, [r4, #0]
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 800246c:	9307      	str	r3, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800246e:	f000 fd84 	bl	8002f7a <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 8002472:	4620      	mov	r0, r4
 8002474:	f7ff fc22 	bl	8001cbc <SD_CmdResp2Error>
    
    if(errorstate != SD_OK)
 8002478:	4605      	mov	r5, r0
 800247a:	b990      	cbnz	r0, 80024a2 <HAL_SD_Init+0x306>
    {
      return errorstate;
    }
    
    /* Get Card Specific Data */
    hsd->CSD[0U] = SDIO_GetResponse(SDIO_RESP1);
 800247c:	f000 fd94 	bl	8002fa8 <SDIO_GetResponse>
 8002480:	62a0      	str	r0, [r4, #40]	; 0x28
    hsd->CSD[1U] = SDIO_GetResponse(SDIO_RESP2);
 8002482:	2004      	movs	r0, #4
 8002484:	f000 fd90 	bl	8002fa8 <SDIO_GetResponse>
 8002488:	62e0      	str	r0, [r4, #44]	; 0x2c
    hsd->CSD[2U] = SDIO_GetResponse(SDIO_RESP3);
 800248a:	2008      	movs	r0, #8
 800248c:	f000 fd8c 	bl	8002fa8 <SDIO_GetResponse>
 8002490:	6320      	str	r0, [r4, #48]	; 0x30
    hsd->CSD[3U] = SDIO_GetResponse(SDIO_RESP4);
 8002492:	200c      	movs	r0, #12
 8002494:	f000 fd88 	bl	8002fa8 <SDIO_GetResponse>
 8002498:	6360      	str	r0, [r4, #52]	; 0x34
 800249a:	e002      	b.n	80024a2 <HAL_SD_Init+0x306>
  
  if(SDIO_GetPowerState(hsd->Instance) == 0U) /* Power off */
  {
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
 800249c:	2525      	movs	r5, #37	; 0x25
 800249e:	e000      	b.n	80024a2 <HAL_SD_Init+0x306>
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
    
    if(errorstate != SD_OK)
 80024a0:	4605      	mov	r5, r0
  {
    return errorstate;
  }
  
  /* Initialize the present SDIO card(s) and put them in idle state */
  errorstate = SD_Initialize_Cards(hsd);
 80024a2:	f88d 5012 	strb.w	r5, [sp, #18]
  
  if (errorstate != SD_OK)
 80024a6:	f89d 3012 	ldrb.w	r3, [sp, #18]
 80024aa:	bb5b      	cbnz	r3, 8002504 <HAL_SD_Init+0x368>
  {
    return errorstate;
  }
  
  /* Read CSD/CID MSD registers */
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
 80024ac:	4631      	mov	r1, r6
 80024ae:	4620      	mov	r0, r4
 80024b0:	f7ff fd32 	bl	8001f18 <HAL_SD_Get_CardInfo>
 80024b4:	f88d 0012 	strb.w	r0, [sp, #18]
  
  if (errorstate == SD_OK)
 80024b8:	f89d 3012 	ldrb.w	r3, [sp, #18]
 80024bc:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80024c0:	b9ab      	cbnz	r3, 80024ee <HAL_SD_Init+0x352>
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
 80024c2:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80024c6:	6820      	ldr	r0, [r4, #0]
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80024c8:	9208      	str	r2, [sp, #32]
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
 80024ca:	041b      	lsls	r3, r3, #16
 80024cc:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80024ce:	2340      	movs	r3, #64	; 0x40
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
 80024d0:	2507      	movs	r5, #7
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80024d2:	9307      	str	r3, [sp, #28]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80024d4:	a905      	add	r1, sp, #20
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80024d6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80024da:	9309      	str	r3, [sp, #36]	; 0x24
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
 80024dc:	9506      	str	r5, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80024de:	f000 fd4c 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEL_DESEL_CARD);
 80024e2:	4629      	mov	r1, r5
 80024e4:	4620      	mov	r0, r4
 80024e6:	f7ff fca1 	bl	8001e2c <SD_CmdResp1Error>
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
  
  if (errorstate == SD_OK)
  {
    /* Select the Card */
    errorstate = SD_Select_Deselect(hsd, (uint32_t)(((uint32_t)SDCardInfo->RCA) << 16U));
 80024ea:	f88d 0012 	strb.w	r0, [sp, #18]
  }
  
  /* Configure SDIO peripheral interface */
  SDIO_Init(hsd->Instance, hsd->Init);   
 80024ee:	f104 0310 	add.w	r3, r4, #16
 80024f2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80024f6:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80024fa:	1d23      	adds	r3, r4, #4
 80024fc:	cb0e      	ldmia	r3, {r1, r2, r3}
 80024fe:	6820      	ldr	r0, [r4, #0]
 8002500:	f000 fd10 	bl	8002f24 <SDIO_Init>
  
  return errorstate;
 8002504:	f89d 0012 	ldrb.w	r0, [sp, #18]
 8002508:	b2c0      	uxtb	r0, r0
}
 800250a:	b011      	add	sp, #68	; 0x44
 800250c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    errorstate = SD_CMD_RSP_TIMEOUT;
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002510:	f240 53ff 	movw	r3, #1535	; 0x5ff
 8002514:	6383      	str	r3, [r0, #56]	; 0x38
  
  return errorstate;
 8002516:	2300      	movs	r3, #0
 8002518:	e682      	b.n	8002220 <HAL_SD_Init+0x84>
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 800251a:	2510      	movs	r5, #16
 800251c:	e7c1      	b.n	80024a2 <HAL_SD_Init+0x306>
    return errorstate;
  }
  
  if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 800251e:	2513      	movs	r5, #19
 8002520:	e7bf      	b.n	80024a2 <HAL_SD_Init+0x306>
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8002522:	250f      	movs	r5, #15
 8002524:	e7bd      	b.n	80024a2 <HAL_SD_Init+0x306>
 8002526:	bf00      	nop

08002528 <HAL_SD_StopTransfer>:
  * @brief  Aborts an ongoing data transfer.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
{
 8002528:	b530      	push	{r4, r5, lr}
 800252a:	b087      	sub	sp, #28
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
 800252c:	2300      	movs	r3, #0
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800252e:	2240      	movs	r2, #64	; 0x40
  * @brief  Aborts an ongoing data transfer.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
{
 8002530:	4604      	mov	r4, r0
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
 8002532:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
 8002534:	250c      	movs	r5, #12
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002536:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002538:	a901      	add	r1, sp, #4
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800253a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800253e:	6800      	ldr	r0, [r0, #0]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8002540:	9203      	str	r2, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8002542:	9305      	str	r3, [sp, #20]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
 8002544:	9502      	str	r5, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002546:	f000 fd18 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_STOP_TRANSMISSION);
 800254a:	4629      	mov	r1, r5
 800254c:	4620      	mov	r0, r4
 800254e:	f7ff fc6d 	bl	8001e2c <SD_CmdResp1Error>
  
  return errorstate;
}
 8002552:	b007      	add	sp, #28
 8002554:	bd30      	pop	{r4, r5, pc}

08002556 <HAL_SD_ReadBlocks>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8002556:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800255a:	4604      	mov	r4, r0
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 800255c:	6800      	ldr	r0, [r0, #0]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800255e:	4617      	mov	r7, r2
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8002560:	2200      	movs	r2, #0
 8002562:	62c2      	str	r2, [r0, #44]	; 0x2c
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8002564:	6a22      	ldr	r2, [r4, #32]
 8002566:	2a02      	cmp	r2, #2
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8002568:	b08d      	sub	sp, #52	; 0x34
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
    ReadAddr /= 512U;
 800256a:	bf04      	itt	eq
 800256c:	0a7f      	lsreq	r7, r7, #9
 800256e:	ea47 57c3 	orreq.w	r7, r7, r3, lsl #23
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8002572:	f04f 0340 	mov.w	r3, #64	; 0x40
 8002576:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002578:	f04f 0300 	mov.w	r3, #0
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800257c:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002580:	9304      	str	r3, [sp, #16]
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
 8002582:	bf08      	it	eq
 8002584:	f44f 7800 	moveq.w	r8, #512	; 0x200
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8002588:	2610      	movs	r6, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800258a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800258e:	460d      	mov	r5, r1
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002590:	a901      	add	r1, sp, #4
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8002592:	9602      	str	r6, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8002594:	9305      	str	r3, [sp, #20]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8002596:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    BlockSize = 512U;
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
 800259a:	f8cd 8004 	str.w	r8, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800259e:	f000 fcec 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 80025a2:	4631      	mov	r1, r6
 80025a4:	4620      	mov	r0, r4
 80025a6:	f7ff fc41 	bl	8001e2c <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 80025aa:	4606      	mov	r6, r0
 80025ac:	2800      	cmp	r0, #0
 80025ae:	f040 8090 	bne.w	80026d2 <HAL_SD_ReadBlocks+0x17c>
  {
    return errorstate;
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 80025b2:	f04f 33ff 	mov.w	r3, #4294967295
 80025b6:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
 80025b8:	fb09 f308 	mul.w	r3, r9, r8
 80025bc:	9307      	str	r3, [sp, #28]
  sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
 80025be:	2390      	movs	r3, #144	; 0x90
 80025c0:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 80025c2:	2302      	movs	r3, #2
 80025c4:	9309      	str	r3, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 80025c6:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 80025c8:	2301      	movs	r3, #1
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 80025ca:	a906      	add	r1, sp, #24
 80025cc:	6820      	ldr	r0, [r4, #0]
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 80025ce:	930b      	str	r3, [sp, #44]	; 0x2c
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 80025d0:	f000 fcf6 	bl	8002fc0 <SDIO_DataConfig>
  
  if(NumberOfBlocks > 1U)
 80025d4:	f1b9 0f01 	cmp.w	r9, #1
  {
    /* Send CMD18 READ_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
 80025d8:	bf8c      	ite	hi
 80025da:	2312      	movhi	r3, #18
  }
  else
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
 80025dc:	2311      	movls	r3, #17
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80025de:	a901      	add	r1, sp, #4
 80025e0:	6820      	ldr	r0, [r4, #0]
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
  }
  else
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
 80025e2:	9302      	str	r3, [sp, #8]
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
 80025e4:	9701      	str	r7, [sp, #4]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80025e6:	f000 fcc8 	bl	8002f7a <SDIO_SendCommand>
  
  /* Read block(s) in polling mode */
  if(NumberOfBlocks > 1U)
 80025ea:	f1b9 0f01 	cmp.w	r9, #1
 80025ee:	d91a      	bls.n	8002626 <HAL_SD_ReadBlocks+0xd0>
  {
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
 80025f0:	2112      	movs	r1, #18
 80025f2:	4620      	mov	r0, r4
 80025f4:	f7ff fc1a 	bl	8001e2c <SD_CmdResp1Error>
    
    if (errorstate != SD_OK)
 80025f8:	2800      	cmp	r0, #0
 80025fa:	d16b      	bne.n	80026d4 <HAL_SD_ReadBlocks+0x17e>
      return errorstate;
    }
    
    /* Poll on SDIO flags */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 80025fc:	6822      	ldr	r2, [r4, #0]
 80025fe:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002600:	f240 332a 	movw	r3, #810	; 0x32a
 8002604:	400b      	ands	r3, r1
 8002606:	bb4b      	cbnz	r3, 800265c <HAL_SD_ReadBlocks+0x106>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 8002608:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800260a:	0418      	lsls	r0, r3, #16
 800260c:	d5f7      	bpl.n	80025fe <HAL_SD_ReadBlocks+0xa8>
 800260e:	1f2f      	subs	r7, r5, #4
 8002610:	f105 081c 	add.w	r8, r5, #28
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
 8002614:	6820      	ldr	r0, [r4, #0]
 8002616:	f000 fca0 	bl	8002f5a <SDIO_ReadFIFO>
 800261a:	f847 0f04 	str.w	r0, [r7, #4]!
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
 800261e:	45b8      	cmp	r8, r7
 8002620:	d1f8      	bne.n	8002614 <HAL_SD_ReadBlocks+0xbe>
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
        }
        
        tempbuff += 8U;
 8002622:	3520      	adds	r5, #32
 8002624:	e7ea      	b.n	80025fc <HAL_SD_ReadBlocks+0xa6>
    }      
  }
  else
  {
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_SINGLE_BLOCK); 
 8002626:	2111      	movs	r1, #17
 8002628:	4620      	mov	r0, r4
 800262a:	f7ff fbff 	bl	8001e2c <SD_CmdResp1Error>
    
    if (errorstate != SD_OK)
 800262e:	2800      	cmp	r0, #0
 8002630:	d150      	bne.n	80026d4 <HAL_SD_ReadBlocks+0x17e>
      return errorstate;
    }    
    
    /* In case of single block transfer, no need of stop transfer at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 8002632:	6822      	ldr	r2, [r4, #0]
 8002634:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002636:	f240 632a 	movw	r3, #1578	; 0x62a
 800263a:	400b      	ands	r3, r1
 800263c:	b973      	cbnz	r3, 800265c <HAL_SD_ReadBlocks+0x106>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))      
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 800263e:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8002640:	0419      	lsls	r1, r3, #16
 8002642:	d5f7      	bpl.n	8002634 <HAL_SD_ReadBlocks+0xde>
 8002644:	1f2f      	subs	r7, r5, #4
 8002646:	f105 081c 	add.w	r8, r5, #28
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
 800264a:	6820      	ldr	r0, [r4, #0]
 800264c:	f000 fc85 	bl	8002f5a <SDIO_ReadFIFO>
 8002650:	f847 0f04 	str.w	r0, [r7, #4]!
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
 8002654:	45b8      	cmp	r8, r7
 8002656:	d1f8      	bne.n	800264a <HAL_SD_ReadBlocks+0xf4>
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
        }
        
        tempbuff += 8U;
 8002658:	3520      	adds	r5, #32
 800265a:	e7ea      	b.n	8002632 <HAL_SD_ReadBlocks+0xdc>
      }
    }
  }
  
  /* Send stop transmission command in case of multiblock read */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800265c:	6823      	ldr	r3, [r4, #0]
 800265e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002660:	05db      	lsls	r3, r3, #23
 8002662:	d509      	bpl.n	8002678 <HAL_SD_ReadBlocks+0x122>
 8002664:	f1b9 0f01 	cmp.w	r9, #1
 8002668:	d906      	bls.n	8002678 <HAL_SD_ReadBlocks+0x122>
  {    
    if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) ||\
 800266a:	6a23      	ldr	r3, [r4, #32]
 800266c:	2b02      	cmp	r3, #2
 800266e:	d803      	bhi.n	8002678 <HAL_SD_ReadBlocks+0x122>
      (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
        (hsd->CardType == HIGH_CAPACITY_SD_CARD))
    {
      /* Send stop transmission command */
      errorstate = HAL_SD_StopTransfer(hsd);
 8002670:	4620      	mov	r0, r4
 8002672:	f7ff ff59 	bl	8002528 <HAL_SD_StopTransfer>
 8002676:	4606      	mov	r6, r0
    }
  }
  
  /* Get error state */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8002678:	6823      	ldr	r3, [r4, #0]
 800267a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800267c:	0717      	lsls	r7, r2, #28
 800267e:	d503      	bpl.n	8002688 <HAL_SD_ReadBlocks+0x132>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8002680:	2208      	movs	r2, #8
 8002682:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 8002684:	2004      	movs	r0, #4
 8002686:	e025      	b.n	80026d4 <HAL_SD_ReadBlocks+0x17e>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8002688:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800268a:	0790      	lsls	r0, r2, #30
 800268c:	d502      	bpl.n	8002694 <HAL_SD_ReadBlocks+0x13e>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 800268e:	2002      	movs	r0, #2
 8002690:	6398      	str	r0, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
 8002692:	e01f      	b.n	80026d4 <HAL_SD_ReadBlocks+0x17e>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 8002694:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002696:	0691      	lsls	r1, r2, #26
 8002698:	d503      	bpl.n	80026a2 <HAL_SD_ReadBlocks+0x14c>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 800269a:	2220      	movs	r2, #32
 800269c:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_RX_OVERRUN;
    
    return errorstate;
 800269e:	2006      	movs	r0, #6
 80026a0:	e018      	b.n	80026d4 <HAL_SD_ReadBlocks+0x17e>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 80026a2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80026a4:	0592      	lsls	r2, r2, #22
 80026a6:	d402      	bmi.n	80026ae <HAL_SD_ReadBlocks+0x158>
 80026a8:	f04f 37ff 	mov.w	r7, #4294967295
 80026ac:	e00a      	b.n	80026c4 <HAL_SD_ReadBlocks+0x16e>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 80026ae:	f44f 7200 	mov.w	r2, #512	; 0x200
 80026b2:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 80026b4:	2007      	movs	r0, #7
 80026b6:	e00d      	b.n	80026d4 <HAL_SD_ReadBlocks+0x17e>
  }
  
  count = SD_DATATIMEOUT;
  
  /* Empty FIFO if there is still any data */
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 80026b8:	b147      	cbz	r7, 80026cc <HAL_SD_ReadBlocks+0x176>
  {
    *tempbuff = SDIO_ReadFIFO(hsd->Instance);
 80026ba:	f000 fc4e 	bl	8002f5a <SDIO_ReadFIFO>
 80026be:	f845 0b04 	str.w	r0, [r5], #4
    tempbuff++;
    count--;
 80026c2:	3f01      	subs	r7, #1
  }
  
  count = SD_DATATIMEOUT;
  
  /* Empty FIFO if there is still any data */
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 80026c4:	6820      	ldr	r0, [r4, #0]
 80026c6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80026c8:	029b      	lsls	r3, r3, #10
 80026ca:	d4f5      	bmi.n	80026b8 <HAL_SD_ReadBlocks+0x162>
    tempbuff++;
    count--;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80026cc:	f240 53ff 	movw	r3, #1535	; 0x5ff
 80026d0:	6383      	str	r3, [r0, #56]	; 0x38
 80026d2:	4630      	mov	r0, r6
  
  return errorstate;
}
 80026d4:	b00d      	add	sp, #52	; 0x34
 80026d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080026da <HAL_SD_WriteBlocks>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 80026da:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80026de:	4605      	mov	r5, r0
 80026e0:	b08c      	sub	sp, #48	; 0x30
  uint32_t totalnumberofbytes = 0U, bytestransferred = 0U, count = 0U, restwords = 0U;
  uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
  uint8_t cardstate  = 0U;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 80026e2:	6800      	ldr	r0, [r0, #0]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 80026e4:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
 80026e8:	9f15      	ldr	r7, [sp, #84]	; 0x54
 80026ea:	4614      	mov	r4, r2
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t totalnumberofbytes = 0U, bytestransferred = 0U, count = 0U, restwords = 0U;
  uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
  uint8_t cardstate  = 0U;
 80026ec:	2200      	movs	r2, #0
 80026ee:	f88d 2003 	strb.w	r2, [sp, #3]
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 80026f2:	62c2      	str	r2, [r0, #44]	; 0x2c
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 80026f4:	6a2a      	ldr	r2, [r5, #32]
 80026f6:	2a02      	cmp	r2, #2
  {
    BlockSize = 512U;
    WriteAddr /= 512U;
 80026f8:	bf04      	itt	eq
 80026fa:	0a64      	lsreq	r4, r4, #9
 80026fc:	ea44 54c3 	orreq.w	r4, r4, r3, lsl #23
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8002700:	f04f 0340 	mov.w	r3, #64	; 0x40
 8002704:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002706:	f04f 0300 	mov.w	r3, #0
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
 800270a:	bf08      	it	eq
 800270c:	f44f 7800 	moveq.w	r8, #512	; 0x200
    WriteAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8002710:	f04f 0910 	mov.w	r9, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002714:	9304      	str	r3, [sp, #16]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8002716:	460e      	mov	r6, r1
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8002718:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800271c:	a901      	add	r1, sp, #4
    BlockSize = 512U;
    WriteAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
 800271e:	f8cd 8004 	str.w	r8, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8002722:	f8cd 9008 	str.w	r9, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8002726:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002728:	f000 fc27 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 800272c:	4649      	mov	r1, r9
 800272e:	4628      	mov	r0, r5
 8002730:	f7ff fb7c 	bl	8001e2c <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 8002734:	2800      	cmp	r0, #0
 8002736:	f040 80c3 	bne.w	80028c0 <HAL_SD_WriteBlocks+0x1e6>
  {
    return errorstate;
  }
  
  if(NumberOfBlocks > 1U)
 800273a:	2f01      	cmp	r7, #1
  {
    /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
 800273c:	bf8c      	ite	hi
 800273e:	2319      	movhi	r3, #25
  }
  else
  {
    /* Send CMD24 WRITE_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
 8002740:	2318      	movls	r3, #24
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002742:	a901      	add	r1, sp, #4
 8002744:	6828      	ldr	r0, [r5, #0]
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
  }
  else
  {
    /* Send CMD24 WRITE_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
 8002746:	9302      	str	r3, [sp, #8]
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
 8002748:	9401      	str	r4, [sp, #4]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800274a:	f000 fc16 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  if(NumberOfBlocks > 1U)
 800274e:	2f01      	cmp	r7, #1
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_MULT_BLOCK);
 8002750:	bf8c      	ite	hi
 8002752:	2119      	movhi	r1, #25
  }
  else
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_SINGLE_BLOCK);
 8002754:	2118      	movls	r1, #24
 8002756:	4628      	mov	r0, r5
 8002758:	f7ff fb68 	bl	8001e2c <SD_CmdResp1Error>
 800275c:	4604      	mov	r4, r0
  }  
  
  if (errorstate != SD_OK)
 800275e:	2800      	cmp	r0, #0
 8002760:	f040 80ae 	bne.w	80028c0 <HAL_SD_WriteBlocks+0x1e6>
  
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 8002764:	f04f 33ff 	mov.w	r3, #4294967295
 8002768:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 800276a:	2390      	movs	r3, #144	; 0x90
 800276c:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
 800276e:	9009      	str	r0, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8002770:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8002772:	2301      	movs	r3, #1
  {
    return errorstate;
  }
  
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
 8002774:	fb07 f808 	mul.w	r8, r7, r8
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8002778:	a906      	add	r1, sp, #24
 800277a:	6828      	ldr	r0, [r5, #0]
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
 800277c:	f8cd 801c 	str.w	r8, [sp, #28]
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8002780:	930b      	str	r3, [sp, #44]	; 0x2c
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8002782:	f000 fc1d 	bl	8002fc0 <SDIO_DataConfig>
  
  /* Write block(s) in polling mode */
  if(NumberOfBlocks > 1U)
 8002786:	2f01      	cmp	r7, #1
 8002788:	d940      	bls.n	800280c <HAL_SD_WriteBlocks+0x132>
  {
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 800278a:	682b      	ldr	r3, [r5, #0]
 800278c:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800278e:	f240 321a 	movw	r2, #794	; 0x31a
 8002792:	400a      	ands	r2, r1
 8002794:	bb9a      	cbnz	r2, 80027fe <HAL_SD_WriteBlocks+0x124>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
#endif /* SDIO_STA_STBITERR */     
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
 8002796:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8002798:	0449      	lsls	r1, r1, #17
 800279a:	d5f7      	bpl.n	800278c <HAL_SD_WriteBlocks+0xb2>
      {
        if ((totalnumberofbytes - bytestransferred) < 32U)
 800279c:	ebc4 0308 	rsb	r3, r4, r8
 80027a0:	2b1f      	cmp	r3, #31
 80027a2:	d813      	bhi.n	80027cc <HAL_SD_WriteBlocks+0xf2>
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
 80027a4:	f013 0f03 	tst.w	r3, #3
 80027a8:	ea4f 0393 	mov.w	r3, r3, lsr #2
 80027ac:	bf18      	it	ne
 80027ae:	3301      	addne	r3, #1
 80027b0:	ea4f 0983 	mov.w	r9, r3, lsl #2
 80027b4:	eb06 0a09 	add.w	sl, r6, r9
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 80027b8:	4556      	cmp	r6, sl
 80027ba:	d005      	beq.n	80027c8 <HAL_SD_WriteBlocks+0xee>
          {
            SDIO_WriteFIFO(hsd->Instance, tempbuff);
 80027bc:	4631      	mov	r1, r6
 80027be:	6828      	ldr	r0, [r5, #0]
 80027c0:	f000 fbce 	bl	8002f60 <SDIO_WriteFIFO>
            tempbuff++;
 80027c4:	3604      	adds	r6, #4
 80027c6:	e7f7      	b.n	80027b8 <HAL_SD_WriteBlocks+0xde>
 80027c8:	444c      	add	r4, r9
 80027ca:	e00d      	b.n	80027e8 <HAL_SD_WriteBlocks+0x10e>
 80027cc:	4691      	mov	r9, r2
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
 80027ce:	eb06 0109 	add.w	r1, r6, r9
 80027d2:	6828      	ldr	r0, [r5, #0]
 80027d4:	f109 0904 	add.w	r9, r9, #4
 80027d8:	f000 fbc2 	bl	8002f60 <SDIO_WriteFIFO>
          }
        }
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
 80027dc:	f1b9 0f20 	cmp.w	r9, #32
 80027e0:	d1f5      	bne.n	80027ce <HAL_SD_WriteBlocks+0xf4>
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
          }
          
          tempbuff += 8U;
 80027e2:	f106 0a20 	add.w	sl, r6, #32
          bytestransferred += 32U;
 80027e6:	3420      	adds	r4, #32
 80027e8:	4656      	mov	r6, sl
 80027ea:	e7ce      	b.n	800278a <HAL_SD_WriteBlocks+0xb0>
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
 80027ec:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80027ee:	0449      	lsls	r1, r1, #17
 80027f0:	d40e      	bmi.n	8002810 <HAL_SD_WriteBlocks+0x136>
  }
  else
  {
    /* In case of single data block transfer no need of stop command at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 80027f2:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80027f4:	f240 621a 	movw	r2, #1562	; 0x61a
 80027f8:	400a      	ands	r2, r1
 80027fa:	2a00      	cmp	r2, #0
 80027fc:	d0f6      	beq.n	80027ec <HAL_SD_WriteBlocks+0x112>
      }
    }  
  }
  
  /* Send stop transmission command in case of multiblock write */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 80027fe:	682b      	ldr	r3, [r5, #0]
 8002800:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002802:	05d8      	lsls	r0, r3, #23
 8002804:	d429      	bmi.n	800285a <HAL_SD_WriteBlocks+0x180>
 8002806:	e030      	b.n	800286a <HAL_SD_WriteBlocks+0x190>
 8002808:	444c      	add	r4, r9
 800280a:	4656      	mov	r6, sl
  }
  else
  {
    /* In case of single data block transfer no need of stop command at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 800280c:	682b      	ldr	r3, [r5, #0]
 800280e:	e7f0      	b.n	80027f2 <HAL_SD_WriteBlocks+0x118>
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
      {
        if ((totalnumberofbytes - bytestransferred) < 32U)
 8002810:	ebc4 0308 	rsb	r3, r4, r8
 8002814:	2b1f      	cmp	r3, #31
 8002816:	d811      	bhi.n	800283c <HAL_SD_WriteBlocks+0x162>
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
 8002818:	f013 0f03 	tst.w	r3, #3
 800281c:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8002820:	bf18      	it	ne
 8002822:	3301      	addne	r3, #1
 8002824:	ea4f 0983 	mov.w	r9, r3, lsl #2
 8002828:	eb06 0a09 	add.w	sl, r6, r9
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 800282c:	4556      	cmp	r6, sl
 800282e:	d0eb      	beq.n	8002808 <HAL_SD_WriteBlocks+0x12e>
          {
            SDIO_WriteFIFO(hsd->Instance, tempbuff);
 8002830:	4631      	mov	r1, r6
 8002832:	6828      	ldr	r0, [r5, #0]
 8002834:	f000 fb94 	bl	8002f60 <SDIO_WriteFIFO>
            tempbuff++; 
 8002838:	3604      	adds	r6, #4
 800283a:	e7f7      	b.n	800282c <HAL_SD_WriteBlocks+0x152>
 800283c:	4691      	mov	r9, r2
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
 800283e:	eb06 0109 	add.w	r1, r6, r9
 8002842:	6828      	ldr	r0, [r5, #0]
 8002844:	f109 0904 	add.w	r9, r9, #4
 8002848:	f000 fb8a 	bl	8002f60 <SDIO_WriteFIFO>
          }
        }
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
 800284c:	f1b9 0f20 	cmp.w	r9, #32
 8002850:	d1f5      	bne.n	800283e <HAL_SD_WriteBlocks+0x164>
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
          }
          
          tempbuff += 8U;
 8002852:	f106 0a20 	add.w	sl, r6, #32
          bytestransferred += 32U;
 8002856:	3420      	adds	r4, #32
 8002858:	e7d7      	b.n	800280a <HAL_SD_WriteBlocks+0x130>
      }
    }  
  }
  
  /* Send stop transmission command in case of multiblock write */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800285a:	2f01      	cmp	r7, #1
 800285c:	d905      	bls.n	800286a <HAL_SD_WriteBlocks+0x190>
  {    
    if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 800285e:	6a2b      	ldr	r3, [r5, #32]
 8002860:	2b02      	cmp	r3, #2
 8002862:	d802      	bhi.n	800286a <HAL_SD_WriteBlocks+0x190>
      (hsd->CardType == HIGH_CAPACITY_SD_CARD))
    {
      /* Send stop transmission command */
      errorstate = HAL_SD_StopTransfer(hsd);
 8002864:	4628      	mov	r0, r5
 8002866:	f7ff fe5f 	bl	8002528 <HAL_SD_StopTransfer>
    }
  }
  
  /* Get error state */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 800286a:	682b      	ldr	r3, [r5, #0]
 800286c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800286e:	0714      	lsls	r4, r2, #28
 8002870:	d503      	bpl.n	800287a <HAL_SD_WriteBlocks+0x1a0>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8002872:	2208      	movs	r2, #8
 8002874:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 8002876:	2004      	movs	r0, #4
 8002878:	e022      	b.n	80028c0 <HAL_SD_WriteBlocks+0x1e6>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 800287a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800287c:	0790      	lsls	r0, r2, #30
 800287e:	d502      	bpl.n	8002886 <HAL_SD_WriteBlocks+0x1ac>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8002880:	2002      	movs	r0, #2
 8002882:	6398      	str	r0, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
 8002884:	e01c      	b.n	80028c0 <HAL_SD_WriteBlocks+0x1e6>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR))
 8002886:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002888:	06d1      	lsls	r1, r2, #27
 800288a:	d503      	bpl.n	8002894 <HAL_SD_WriteBlocks+0x1ba>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
 800288c:	2210      	movs	r2, #16
 800288e:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_TX_UNDERRUN;
    
    return errorstate;
 8002890:	2005      	movs	r0, #5
 8002892:	e015      	b.n	80028c0 <HAL_SD_WriteBlocks+0x1e6>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 8002894:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002896:	0592      	lsls	r2, r2, #22
 8002898:	d504      	bpl.n	80028a4 <HAL_SD_WriteBlocks+0x1ca>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 800289a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800289e:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 80028a0:	2007      	movs	r0, #7
 80028a2:	e00d      	b.n	80028c0 <HAL_SD_WriteBlocks+0x1e6>
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80028a4:	f240 52ff 	movw	r2, #1535	; 0x5ff
 80028a8:	639a      	str	r2, [r3, #56]	; 0x38
  /* Wait till the card is in programming state */
  errorstate = SD_IsCardProgramming(hsd, &cardstate);
  
  while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
  {
    errorstate = SD_IsCardProgramming(hsd, &cardstate);
 80028aa:	f10d 0103 	add.w	r1, sp, #3
 80028ae:	4628      	mov	r0, r5
 80028b0:	f7ff fa1a 	bl	8001ce8 <SD_IsCardProgramming>
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
  
  /* Wait till the card is in programming state */
  errorstate = SD_IsCardProgramming(hsd, &cardstate);
  
  while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
 80028b4:	b920      	cbnz	r0, 80028c0 <HAL_SD_WriteBlocks+0x1e6>
 80028b6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80028ba:	3b06      	subs	r3, #6
 80028bc:	2b01      	cmp	r3, #1
 80028be:	d9f4      	bls.n	80028aa <HAL_SD_WriteBlocks+0x1d0>
  {
    errorstate = SD_IsCardProgramming(hsd, &cardstate);
  }
  
  return errorstate;
}
 80028c0:	b00c      	add	sp, #48	; 0x30
 80028c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080028c6 <HAL_SD_SendSDStatus>:
  * @param  pSDstatus: Pointer to the buffer that will contain the SD card status 
  *         SD Status register)
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
 80028c6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80028c8:	4605      	mov	r5, r0
 80028ca:	b08d      	sub	sp, #52	; 0x34
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U;
  
  /* Check SD response */
  if ((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 80028cc:	2000      	movs	r0, #0
  * @param  pSDstatus: Pointer to the buffer that will contain the SD card status 
  *         SD Status register)
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
 80028ce:	460e      	mov	r6, r1
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U;
  
  /* Check SD response */
  if ((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 80028d0:	f000 fb6a 	bl	8002fa8 <SDIO_GetResponse>
 80028d4:	f010 7000 	ands.w	r0, r0, #33554432	; 0x2000000
 80028d8:	f040 8082 	bne.w	80029e0 <HAL_SD_SendSDStatus+0x11a>
    
    return errorstate;
  }
  
  /* Set block size for card if it is not equal to current block size for card */
  sdio_cmdinitstructure.Argument         = 64U;
 80028dc:	2740      	movs	r7, #64	; 0x40
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 80028de:	2410      	movs	r4, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80028e0:	9004      	str	r0, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80028e2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80028e6:	a901      	add	r1, sp, #4
 80028e8:	6828      	ldr	r0, [r5, #0]
    
    return errorstate;
  }
  
  /* Set block size for card if it is not equal to current block size for card */
  sdio_cmdinitstructure.Argument         = 64U;
 80028ea:	9701      	str	r7, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 80028ec:	9402      	str	r4, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80028ee:	9703      	str	r7, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80028f0:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80028f2:	f000 fb42 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 80028f6:	4621      	mov	r1, r4
 80028f8:	4628      	mov	r0, r5
 80028fa:	f7ff fa97 	bl	8001e2c <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 80028fe:	2800      	cmp	r0, #0
 8002900:	d16f      	bne.n	80029e2 <HAL_SD_SendSDStatus+0x11c>
  {
    return errorstate;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8002902:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002904:	6828      	ldr	r0, [r5, #0]
  {
    return errorstate;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8002906:	40a3      	lsls	r3, r4
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002908:	a901      	add	r1, sp, #4
    return errorstate;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 800290a:	2437      	movs	r4, #55	; 0x37
  {
    return errorstate;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 800290c:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 800290e:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002910:	f000 fb33 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8002914:	4621      	mov	r1, r4
 8002916:	4628      	mov	r0, r5
 8002918:	f7ff fa88 	bl	8001e2c <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 800291c:	4604      	mov	r4, r0
 800291e:	2800      	cmp	r0, #0
 8002920:	d15f      	bne.n	80029e2 <HAL_SD_SendSDStatus+0x11c>
  {
    return errorstate;
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 8002922:	f04f 33ff 	mov.w	r3, #4294967295
 8002926:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = 64U;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B;
 8002928:	2360      	movs	r3, #96	; 0x60
 800292a:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 800292c:	2302      	movs	r3, #2
 800292e:	9309      	str	r3, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8002930:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8002932:	2301      	movs	r3, #1
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8002934:	a906      	add	r1, sp, #24
 8002936:	6828      	ldr	r0, [r5, #0]
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = 64U;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8002938:	930b      	str	r3, [sp, #44]	; 0x2c
    return errorstate;
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = 64U;
 800293a:	9707      	str	r7, [sp, #28]
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 800293c:	f000 fb40 	bl	8002fc0 <SDIO_DataConfig>
  
  /* Send ACMD13 (SD_APP_STATUS)  with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = 0U;
 8002940:	9401      	str	r4, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_STATUS;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002942:	a901      	add	r1, sp, #4
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
  
  /* Send ACMD13 (SD_APP_STATUS)  with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_STATUS;
 8002944:	240d      	movs	r4, #13
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002946:	6828      	ldr	r0, [r5, #0]
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
  
  /* Send ACMD13 (SD_APP_STATUS)  with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_STATUS;
 8002948:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800294a:	f000 fb16 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_APP_STATUS);
 800294e:	4621      	mov	r1, r4
 8002950:	4628      	mov	r0, r5
 8002952:	f7ff fa6b 	bl	8001e2c <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 8002956:	2800      	cmp	r0, #0
 8002958:	d143      	bne.n	80029e2 <HAL_SD_SendSDStatus+0x11c>
    return errorstate;
  }
  
  /* Get status data */
#ifdef SDIO_STA_STBITERR 
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 800295a:	682b      	ldr	r3, [r5, #0]
 800295c:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800295e:	f240 622a 	movw	r2, #1578	; 0x62a
 8002962:	400a      	ands	r2, r1
 8002964:	b972      	cbnz	r2, 8002984 <HAL_SD_SendSDStatus+0xbe>
#else /* SDIO_STA_STBITERR not defined */
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))    
#endif /* SDIO_STA_STBITERR */
  {
    if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 8002966:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002968:	0417      	lsls	r7, r2, #16
 800296a:	d5f7      	bpl.n	800295c <HAL_SD_SendSDStatus+0x96>
 800296c:	1f34      	subs	r4, r6, #4
 800296e:	f106 071c 	add.w	r7, r6, #28
    {
      for (count = 0U; count < 8U; count++)
      {
        *(pSDstatus + count) = SDIO_ReadFIFO(hsd->Instance);
 8002972:	6828      	ldr	r0, [r5, #0]
 8002974:	f000 faf1 	bl	8002f5a <SDIO_ReadFIFO>
 8002978:	f844 0f04 	str.w	r0, [r4, #4]!
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))    
#endif /* SDIO_STA_STBITERR */
  {
    if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
    {
      for (count = 0U; count < 8U; count++)
 800297c:	42bc      	cmp	r4, r7
 800297e:	d1f8      	bne.n	8002972 <HAL_SD_SendSDStatus+0xac>
      {
        *(pSDstatus + count) = SDIO_ReadFIFO(hsd->Instance);
      }
      
      pSDstatus += 8U;
 8002980:	3620      	adds	r6, #32
 8002982:	e7ea      	b.n	800295a <HAL_SD_SendSDStatus+0x94>
    }
  }
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8002984:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002986:	0714      	lsls	r4, r2, #28
 8002988:	d503      	bpl.n	8002992 <HAL_SD_SendSDStatus+0xcc>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 800298a:	2208      	movs	r2, #8
 800298c:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 800298e:	2004      	movs	r0, #4
 8002990:	e027      	b.n	80029e2 <HAL_SD_SendSDStatus+0x11c>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8002992:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002994:	0790      	lsls	r0, r2, #30
 8002996:	d502      	bpl.n	800299e <HAL_SD_SendSDStatus+0xd8>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8002998:	2002      	movs	r0, #2
 800299a:	6398      	str	r0, [r3, #56]	; 0x38
 800299c:	e021      	b.n	80029e2 <HAL_SD_SendSDStatus+0x11c>
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 800299e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029a0:	0691      	lsls	r1, r2, #26
 80029a2:	d503      	bpl.n	80029ac <HAL_SD_SendSDStatus+0xe6>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 80029a4:	2220      	movs	r2, #32
 80029a6:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_RX_OVERRUN;
    
    return errorstate;
 80029a8:	2006      	movs	r0, #6
 80029aa:	e01a      	b.n	80029e2 <HAL_SD_SendSDStatus+0x11c>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 80029ac:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029ae:	0592      	lsls	r2, r2, #22
 80029b0:	d402      	bmi.n	80029b8 <HAL_SD_SendSDStatus+0xf2>
 80029b2:	f04f 34ff 	mov.w	r4, #4294967295
 80029b6:	e00a      	b.n	80029ce <HAL_SD_SendSDStatus+0x108>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 80029b8:	f44f 7200 	mov.w	r2, #512	; 0x200
 80029bc:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 80029be:	2007      	movs	r0, #7
 80029c0:	e00f      	b.n	80029e2 <HAL_SD_SendSDStatus+0x11c>
  {
    /* No error flag set */
  }  
  
  count = SD_DATATIMEOUT;
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 80029c2:	b144      	cbz	r4, 80029d6 <HAL_SD_SendSDStatus+0x110>
  {
    *pSDstatus = SDIO_ReadFIFO(hsd->Instance);
 80029c4:	f000 fac9 	bl	8002f5a <SDIO_ReadFIFO>
 80029c8:	f846 0b04 	str.w	r0, [r6], #4
    pSDstatus++;
    count--;
 80029cc:	3c01      	subs	r4, #1
  {
    /* No error flag set */
  }  
  
  count = SD_DATATIMEOUT;
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 80029ce:	6828      	ldr	r0, [r5, #0]
 80029d0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80029d2:	029b      	lsls	r3, r3, #10
 80029d4:	d4f5      	bmi.n	80029c2 <HAL_SD_SendSDStatus+0xfc>
    pSDstatus++;
    count--;
  }
  
  /* Clear all the static status flags*/
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80029d6:	f240 53ff 	movw	r3, #1535	; 0x5ff
 80029da:	6383      	str	r3, [r0, #56]	; 0x38
 80029dc:	2000      	movs	r0, #0
 80029de:	e000      	b.n	80029e2 <HAL_SD_SendSDStatus+0x11c>
  /* Check SD response */
  if ((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
  {
    errorstate = SD_LOCK_UNLOCK_FAILED;
    
    return errorstate;
 80029e0:	200e      	movs	r0, #14
  
  /* Clear all the static status flags*/
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
  
  return errorstate;
}
 80029e2:	b00d      	add	sp, #52	; 0x34
 80029e4:	bdf0      	pop	{r4, r5, r6, r7, pc}

080029e6 <HAL_SD_GetStatus>:
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 80029e6:	b530      	push	{r4, r5, lr}
    
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80029e8:	6a43      	ldr	r3, [r0, #36]	; 0x24
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 80029ea:	b087      	sub	sp, #28
    
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80029ec:	041b      	lsls	r3, r3, #16
 80029ee:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80029f0:	2340      	movs	r3, #64	; 0x40
 80029f2:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80029f4:	2300      	movs	r3, #0
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 80029f6:	4604      	mov	r4, r0
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 80029f8:	250d      	movs	r5, #13
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80029fa:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80029fc:	a901      	add	r1, sp, #4
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80029fe:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002a02:	6800      	ldr	r0, [r0, #0]
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8002a04:	9502      	str	r5, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8002a06:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002a08:	f000 fab7 	bl	8002f7a <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEND_STATUS);
 8002a0c:	4629      	mov	r1, r5
 8002a0e:	4620      	mov	r0, r4
 8002a10:	f7ff fa0c 	bl	8001e2c <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 8002a14:	b938      	cbnz	r0, 8002a26 <HAL_SD_GetStatus+0x40>
  {
    return errorstate;
  }
  
  /* Get SD card status */
  *pCardStatus = SDIO_GetResponse(SDIO_RESP1);
 8002a16:	f000 fac7 	bl	8002fa8 <SDIO_GetResponse>
  cardstate = SD_GetState(hsd);
  
  /* Find SD status according to card state*/
  if (cardstate == SD_CARD_TRANSFER)
  {
    return SD_TRANSFER_OK;
 8002a1a:	f3c0 2043 	ubfx	r0, r0, #9, #4
 8002a1e:	3804      	subs	r0, #4
 8002a20:	bf18      	it	ne
 8002a22:	2001      	movne	r0, #1
 8002a24:	e000      	b.n	8002a28 <HAL_SD_GetStatus+0x42>
  }
  else if(cardstate == SD_CARD_ERROR)
  {
    return SD_TRANSFER_ERROR;
 8002a26:	2002      	movs	r0, #2
  }
  else
  {
    return SD_TRANSFER_BUSY;
  }
}
 8002a28:	b007      	add	sp, #28
 8002a2a:	bd30      	pop	{r4, r5, pc}

08002a2c <HAL_SD_GetCardStatus>:
  * @param  pCardStatus: Pointer to the HAL_SD_CardStatusTypedef structure that 
  *         will contain the SD card status information 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypedef *pCardStatus)
{
 8002a2c:	b510      	push	{r4, lr}
 8002a2e:	b090      	sub	sp, #64	; 0x40
 8002a30:	460c      	mov	r4, r1
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t tmp = 0U;
  uint32_t sd_status[16U];
  
  errorstate = HAL_SD_SendSDStatus(hsd, sd_status);
 8002a32:	4669      	mov	r1, sp
 8002a34:	f7ff ff47 	bl	80028c6 <HAL_SD_SendSDStatus>
  
  if (errorstate  != SD_OK)
 8002a38:	2800      	cmp	r0, #0
 8002a3a:	d12f      	bne.n	8002a9c <HAL_SD_GetCardStatus+0x70>
  {
    return errorstate;
  }
  
  /* Byte 0 */
  tmp = (sd_status[0U] & 0xC0U) >> 6U;
 8002a3c:	9b00      	ldr	r3, [sp, #0]
  pCardStatus->DAT_BUS_WIDTH = (uint8_t)tmp;
 8002a3e:	f3c3 1281 	ubfx	r2, r3, #6, #2
  
  /* Byte 0 */
  tmp = (sd_status[0U] & 0x20U) >> 5U;
  pCardStatus->SECURED_MODE = (uint8_t)tmp;
 8002a42:	f3c3 1340 	ubfx	r3, r3, #5, #1
    return errorstate;
  }
  
  /* Byte 0 */
  tmp = (sd_status[0U] & 0xC0U) >> 6U;
  pCardStatus->DAT_BUS_WIDTH = (uint8_t)tmp;
 8002a46:	7022      	strb	r2, [r4, #0]
  
  /* Byte 0 */
  tmp = (sd_status[0U] & 0x20U) >> 5U;
  pCardStatus->SECURED_MODE = (uint8_t)tmp;
 8002a48:	7063      	strb	r3, [r4, #1]
  
  /* Byte 2 */
  tmp = (sd_status[2U] & 0xFFU);
  pCardStatus->SD_CARD_TYPE = (uint8_t)(tmp << 8U);
 8002a4a:	8060      	strh	r0, [r4, #2]
  
  /* Byte 3 */
  tmp = (sd_status[3U] & 0xFFU);
  pCardStatus->SD_CARD_TYPE |= (uint8_t)tmp;
 8002a4c:	8863      	ldrh	r3, [r4, #2]
 8002a4e:	f89d 200c 	ldrb.w	r2, [sp, #12]
 8002a52:	b29b      	uxth	r3, r3
 8002a54:	4313      	orrs	r3, r2
 8002a56:	8063      	strh	r3, [r4, #2]
  
  /* Byte 4 */
  tmp = (sd_status[4U] & 0xFFU);
  pCardStatus->SIZE_OF_PROTECTED_AREA = (uint8_t)(tmp << 24U);
 8002a58:	6060      	str	r0, [r4, #4]
  
  /* Byte 5 */
  tmp = (sd_status[5U] & 0xFFU);
  pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)(tmp << 16U);
 8002a5a:	6863      	ldr	r3, [r4, #4]
 8002a5c:	6063      	str	r3, [r4, #4]
  
  /* Byte 6 */
  tmp = (sd_status[6U] & 0xFFU);
  pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)(tmp << 8U);
 8002a5e:	6863      	ldr	r3, [r4, #4]
 8002a60:	6063      	str	r3, [r4, #4]
  
  /* Byte 7 */
  tmp = (sd_status[7U] & 0xFFU);
  pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)tmp;
 8002a62:	6863      	ldr	r3, [r4, #4]
 8002a64:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8002a68:	4313      	orrs	r3, r2
 8002a6a:	6063      	str	r3, [r4, #4]
  
  /* Byte 8 */
  tmp = (sd_status[8U] & 0xFFU);
  pCardStatus->SPEED_CLASS = (uint8_t)tmp;
 8002a6c:	f89d 3020 	ldrb.w	r3, [sp, #32]
 8002a70:	7223      	strb	r3, [r4, #8]
  
  /* Byte 9 */
  tmp = (sd_status[9U] & 0xFFU);
  pCardStatus->PERFORMANCE_MOVE = (uint8_t)tmp;
 8002a72:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
 8002a76:	7263      	strb	r3, [r4, #9]
  
  /* Byte 10 */
  tmp = (sd_status[10U] & 0xF0U) >> 4U;
  pCardStatus->AU_SIZE = (uint8_t)tmp;
 8002a78:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  tmp = (sd_status[11U] & 0xFFU);
  pCardStatus->ERASE_SIZE = (uint8_t)(tmp << 8U);
  
  /* Byte 12 */
  tmp = (sd_status[12U] & 0xFFU);
  pCardStatus->ERASE_SIZE |= (uint8_t)tmp;
 8002a7a:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
  tmp = (sd_status[9U] & 0xFFU);
  pCardStatus->PERFORMANCE_MOVE = (uint8_t)tmp;
  
  /* Byte 10 */
  tmp = (sd_status[10U] & 0xF0U) >> 4U;
  pCardStatus->AU_SIZE = (uint8_t)tmp;
 8002a7e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8002a82:	72a3      	strb	r3, [r4, #10]
  
  /* Byte 11 */
  tmp = (sd_status[11U] & 0xFFU);
  pCardStatus->ERASE_SIZE = (uint8_t)(tmp << 8U);
 8002a84:	81a0      	strh	r0, [r4, #12]
  
  /* Byte 12 */
  tmp = (sd_status[12U] & 0xFFU);
  pCardStatus->ERASE_SIZE |= (uint8_t)tmp;
 8002a86:	89a3      	ldrh	r3, [r4, #12]
 8002a88:	b29b      	uxth	r3, r3
 8002a8a:	4313      	orrs	r3, r2
 8002a8c:	81a3      	strh	r3, [r4, #12]
  
  /* Byte 13 */
  tmp = (sd_status[13U] & 0xFCU) >> 2U;
 8002a8e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  pCardStatus->ERASE_TIMEOUT = (uint8_t)tmp;
 8002a90:	f3c3 0285 	ubfx	r2, r3, #2, #6
  
  /* Byte 13 */
  tmp = (sd_status[13U] & 0x3U);
  pCardStatus->ERASE_OFFSET = (uint8_t)tmp;
 8002a94:	f003 0303 	and.w	r3, r3, #3
  tmp = (sd_status[12U] & 0xFFU);
  pCardStatus->ERASE_SIZE |= (uint8_t)tmp;
  
  /* Byte 13 */
  tmp = (sd_status[13U] & 0xFCU) >> 2U;
  pCardStatus->ERASE_TIMEOUT = (uint8_t)tmp;
 8002a98:	73a2      	strb	r2, [r4, #14]
  
  /* Byte 13 */
  tmp = (sd_status[13U] & 0x3U);
  pCardStatus->ERASE_OFFSET = (uint8_t)tmp;
 8002a9a:	73e3      	strb	r3, [r4, #15]
  
  return errorstate;
}
 8002a9c:	b010      	add	sp, #64	; 0x40
 8002a9e:	bd10      	pop	{r4, pc}

08002aa0 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8002aa0:	6803      	ldr	r3, [r0, #0]
 8002aa2:	68da      	ldr	r2, [r3, #12]
 8002aa4:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8002aa8:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002aaa:	695a      	ldr	r2, [r3, #20]
 8002aac:	f022 0201 	bic.w	r2, r2, #1
 8002ab0:	615a      	str	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8002ab2:	2320      	movs	r3, #32
 8002ab4:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
 8002ab8:	4770      	bx	lr
	...

08002abc <UART_SetConfig>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8002abc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 8002ac0:	6807      	ldr	r7, [r0, #0]
 8002ac2:	693b      	ldr	r3, [r7, #16]
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8002ac4:	4604      	mov	r4, r0

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8002ac6:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8002aca:	68c3      	ldr	r3, [r0, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002acc:	68a1      	ldr	r1, [r4, #8]
 8002ace:	69c0      	ldr	r0, [r0, #28]

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8002ad0:	4313      	orrs	r3, r2
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002ad2:	6922      	ldr	r2, [r4, #16]

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
  
  /* Write to USART CR2 */
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 8002ad4:	613b      	str	r3, [r7, #16]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;
 8002ad6:	68fb      	ldr	r3, [r7, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002ad8:	4311      	orrs	r1, r2
 8002ada:	6962      	ldr	r2, [r4, #20]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8002adc:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002ae0:	430a      	orrs	r2, r1
 8002ae2:	4302      	orrs	r2, r0

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8002ae4:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002ae8:	4313      	orrs	r3, r2
  
  /* Write to USART CR1 */
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 8002aea:	60fb      	str	r3, [r7, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 8002aec:	697b      	ldr	r3, [r7, #20]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 8002aee:	f423 7240 	bic.w	r2, r3, #768	; 0x300
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8002af2:	69a3      	ldr	r3, [r4, #24]
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002af4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8002af8:	ea43 0302 	orr.w	r3, r3, r2
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 8002afc:	617b      	str	r3, [r7, #20]
 8002afe:	4b7c      	ldr	r3, [pc, #496]	; (8002cf0 <UART_SetConfig+0x234>)
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002b00:	d17c      	bne.n	8002bfc <UART_SetConfig+0x140>
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8002b02:	429f      	cmp	r7, r3
 8002b04:	d003      	beq.n	8002b0e <UART_SetConfig+0x52>
 8002b06:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002b0a:	429f      	cmp	r7, r3
 8002b0c:	d131      	bne.n	8002b72 <UART_SetConfig+0xb6>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8002b0e:	f7ff f8bd 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002b12:	6863      	ldr	r3, [r4, #4]
 8002b14:	2519      	movs	r5, #25
 8002b16:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8002b1a:	4368      	muls	r0, r5
 8002b1c:	fbb0 f8f8 	udiv	r8, r0, r8
 8002b20:	f7ff f8b4 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002b24:	6866      	ldr	r6, [r4, #4]
 8002b26:	4368      	muls	r0, r5
 8002b28:	0076      	lsls	r6, r6, #1
 8002b2a:	fbb0 f6f6 	udiv	r6, r0, r6
 8002b2e:	f7ff f8ad 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002b32:	6863      	ldr	r3, [r4, #4]
 8002b34:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002b38:	005b      	lsls	r3, r3, #1
 8002b3a:	4368      	muls	r0, r5
 8002b3c:	fbb0 f0f3 	udiv	r0, r0, r3
 8002b40:	fbb0 f0f9 	udiv	r0, r0, r9
 8002b44:	fb09 6610 	mls	r6, r9, r0, r6
 8002b48:	f7ff f8a0 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002b4c:	fbb8 f8f9 	udiv	r8, r8, r9
 8002b50:	6861      	ldr	r1, [r4, #4]
 8002b52:	00f6      	lsls	r6, r6, #3
 8002b54:	3632      	adds	r6, #50	; 0x32
 8002b56:	fbb6 f6f9 	udiv	r6, r6, r9
 8002b5a:	0076      	lsls	r6, r6, #1
 8002b5c:	4368      	muls	r0, r5
 8002b5e:	0049      	lsls	r1, r1, #1
 8002b60:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8002b64:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 8002b68:	fbb0 faf1 	udiv	sl, r0, r1
 8002b6c:	f7ff f88e 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002b70:	e030      	b.n	8002bd4 <UART_SetConfig+0x118>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8002b72:	f7ff f873 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002b76:	6863      	ldr	r3, [r4, #4]
 8002b78:	2519      	movs	r5, #25
 8002b7a:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8002b7e:	4368      	muls	r0, r5
 8002b80:	fbb0 f8f8 	udiv	r8, r0, r8
 8002b84:	f7ff f86a 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002b88:	6866      	ldr	r6, [r4, #4]
 8002b8a:	4368      	muls	r0, r5
 8002b8c:	0076      	lsls	r6, r6, #1
 8002b8e:	fbb0 f6f6 	udiv	r6, r0, r6
 8002b92:	f7ff f863 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002b96:	6863      	ldr	r3, [r4, #4]
 8002b98:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002b9c:	005b      	lsls	r3, r3, #1
 8002b9e:	4368      	muls	r0, r5
 8002ba0:	fbb0 f0f3 	udiv	r0, r0, r3
 8002ba4:	fbb0 f0f9 	udiv	r0, r0, r9
 8002ba8:	fb09 6610 	mls	r6, r9, r0, r6
 8002bac:	f7ff f856 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002bb0:	fbb8 f8f9 	udiv	r8, r8, r9
 8002bb4:	00f6      	lsls	r6, r6, #3
 8002bb6:	6861      	ldr	r1, [r4, #4]
 8002bb8:	3632      	adds	r6, #50	; 0x32
 8002bba:	fbb6 f6f9 	udiv	r6, r6, r9
 8002bbe:	0076      	lsls	r6, r6, #1
 8002bc0:	4368      	muls	r0, r5
 8002bc2:	0049      	lsls	r1, r1, #1
 8002bc4:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8002bc8:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 8002bcc:	fbb0 faf1 	udiv	sl, r0, r1
 8002bd0:	f7ff f844 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002bd4:	4345      	muls	r5, r0
 8002bd6:	6860      	ldr	r0, [r4, #4]
 8002bd8:	0040      	lsls	r0, r0, #1
 8002bda:	fbb5 f0f0 	udiv	r0, r5, r0
 8002bde:	fbb0 f0f9 	udiv	r0, r0, r9
 8002be2:	fb09 a210 	mls	r2, r9, r0, sl
 8002be6:	00d2      	lsls	r2, r2, #3
 8002be8:	3232      	adds	r2, #50	; 0x32
 8002bea:	fbb2 f3f9 	udiv	r3, r2, r9
 8002bee:	f003 0307 	and.w	r3, r3, #7
 8002bf2:	4443      	add	r3, r8
 8002bf4:	441e      	add	r6, r3
 8002bf6:	60be      	str	r6, [r7, #8]
 8002bf8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
  }
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8002bfc:	429f      	cmp	r7, r3
 8002bfe:	d002      	beq.n	8002c06 <UART_SetConfig+0x14a>
 8002c00:	4b3c      	ldr	r3, [pc, #240]	; (8002cf4 <UART_SetConfig+0x238>)
 8002c02:	429f      	cmp	r7, r3
 8002c04:	d130      	bne.n	8002c68 <UART_SetConfig+0x1ac>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8002c06:	f7ff f841 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002c0a:	6863      	ldr	r3, [r4, #4]
 8002c0c:	2519      	movs	r5, #25
 8002c0e:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8002c12:	4368      	muls	r0, r5
 8002c14:	fbb0 f8f8 	udiv	r8, r0, r8
 8002c18:	f7ff f838 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002c1c:	6866      	ldr	r6, [r4, #4]
 8002c1e:	4368      	muls	r0, r5
 8002c20:	00b6      	lsls	r6, r6, #2
 8002c22:	fbb0 f6f6 	udiv	r6, r0, r6
 8002c26:	f7ff f831 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002c2a:	6863      	ldr	r3, [r4, #4]
 8002c2c:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002c30:	009b      	lsls	r3, r3, #2
 8002c32:	4368      	muls	r0, r5
 8002c34:	fbb0 f0f3 	udiv	r0, r0, r3
 8002c38:	fbb0 f0f9 	udiv	r0, r0, r9
 8002c3c:	fb09 6610 	mls	r6, r9, r0, r6
 8002c40:	f7ff f824 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002c44:	fbb8 f8f9 	udiv	r8, r8, r9
 8002c48:	6861      	ldr	r1, [r4, #4]
 8002c4a:	0136      	lsls	r6, r6, #4
 8002c4c:	4368      	muls	r0, r5
 8002c4e:	0089      	lsls	r1, r1, #2
 8002c50:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8002c54:	3632      	adds	r6, #50	; 0x32
 8002c56:	fbb0 faf1 	udiv	sl, r0, r1
 8002c5a:	fbb6 f6f9 	udiv	r6, r6, r9
 8002c5e:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 8002c62:	f7ff f813 	bl	8001c8c <HAL_RCC_GetPCLK2Freq>
 8002c66:	e02f      	b.n	8002cc8 <UART_SetConfig+0x20c>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8002c68:	f7fe fff8 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002c6c:	6863      	ldr	r3, [r4, #4]
 8002c6e:	2519      	movs	r5, #25
 8002c70:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8002c74:	4368      	muls	r0, r5
 8002c76:	fbb0 f8f8 	udiv	r8, r0, r8
 8002c7a:	f7fe ffef 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002c7e:	6866      	ldr	r6, [r4, #4]
 8002c80:	4368      	muls	r0, r5
 8002c82:	00b6      	lsls	r6, r6, #2
 8002c84:	fbb0 f6f6 	udiv	r6, r0, r6
 8002c88:	f7fe ffe8 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002c8c:	6863      	ldr	r3, [r4, #4]
 8002c8e:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002c92:	009b      	lsls	r3, r3, #2
 8002c94:	4368      	muls	r0, r5
 8002c96:	fbb0 f0f3 	udiv	r0, r0, r3
 8002c9a:	fbb0 f0f9 	udiv	r0, r0, r9
 8002c9e:	fb09 6610 	mls	r6, r9, r0, r6
 8002ca2:	f7fe ffdb 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002ca6:	fbb8 f8f9 	udiv	r8, r8, r9
 8002caa:	6861      	ldr	r1, [r4, #4]
 8002cac:	0136      	lsls	r6, r6, #4
 8002cae:	3632      	adds	r6, #50	; 0x32
 8002cb0:	4368      	muls	r0, r5
 8002cb2:	fbb6 f6f9 	udiv	r6, r6, r9
 8002cb6:	0089      	lsls	r1, r1, #2
 8002cb8:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8002cbc:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 8002cc0:	fbb0 faf1 	udiv	sl, r0, r1
 8002cc4:	f7fe ffca 	bl	8001c5c <HAL_RCC_GetPCLK1Freq>
 8002cc8:	4345      	muls	r5, r0
 8002cca:	6860      	ldr	r0, [r4, #4]
 8002ccc:	0080      	lsls	r0, r0, #2
 8002cce:	fbb5 f0f0 	udiv	r0, r5, r0
 8002cd2:	fbb0 f0f9 	udiv	r0, r0, r9
 8002cd6:	fb09 a210 	mls	r2, r9, r0, sl
 8002cda:	0112      	lsls	r2, r2, #4
 8002cdc:	3232      	adds	r2, #50	; 0x32
 8002cde:	fbb2 f3f9 	udiv	r3, r2, r9
 8002ce2:	f003 030f 	and.w	r3, r3, #15
 8002ce6:	4433      	add	r3, r6
 8002ce8:	4443      	add	r3, r8
 8002cea:	60bb      	str	r3, [r7, #8]
 8002cec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002cf0:	40011000 	.word	0x40011000
 8002cf4:	40011400 	.word	0x40011400

08002cf8 <HAL_UART_Init>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8002cf8:	b510      	push	{r4, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 8002cfa:	4604      	mov	r4, r0
 8002cfc:	b340      	cbz	r0, 8002d50 <HAL_UART_Init+0x58>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  
  if(huart->gState == HAL_UART_STATE_RESET)
 8002cfe:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8002d02:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002d06:	b91b      	cbnz	r3, 8002d10 <HAL_UART_Init+0x18>
  {  
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8002d08:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
 8002d0c:	f7fd fc5e 	bl	80005cc <HAL_UART_MspInit>
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8002d10:	6822      	ldr	r2, [r4, #0]
    huart->Lock = HAL_UNLOCKED;
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8002d12:	2324      	movs	r3, #36	; 0x24
 8002d14:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8002d18:	68d3      	ldr	r3, [r2, #12]
 8002d1a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002d1e:	60d3      	str	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8002d20:	4620      	mov	r0, r4
 8002d22:	f7ff fecb 	bl	8002abc <UART_SetConfig>
  
  /* In asynchronous mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002d26:	6823      	ldr	r3, [r4, #0]
 8002d28:	691a      	ldr	r2, [r3, #16]
 8002d2a:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8002d2e:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8002d30:	695a      	ldr	r2, [r3, #20]
 8002d32:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8002d36:	615a      	str	r2, [r3, #20]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8002d38:	68da      	ldr	r2, [r3, #12]
 8002d3a:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002d3e:	60da      	str	r2, [r3, #12]
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002d40:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
 8002d42:	2320      	movs	r3, #32
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002d44:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8002d46:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8002d4a:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
  
  return HAL_OK;
 8002d4e:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 8002d50:	2001      	movs	r0, #1
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->gState= HAL_UART_STATE_READY;
  huart->RxState= HAL_UART_STATE_READY;
  
  return HAL_OK;
}
 8002d52:	bd10      	pop	{r4, pc}

08002d54 <HAL_UART_TxCpltCallback>:
 8002d54:	4770      	bx	lr

08002d56 <HAL_UART_RxCpltCallback>:
 8002d56:	4770      	bx	lr

08002d58 <UART_Receive_IT>:
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8002d58:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8002d5c:	2b22      	cmp	r3, #34	; 0x22
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 8002d5e:	b510      	push	{r4, lr}
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8002d60:	d132      	bne.n	8002dc8 <UART_Receive_IT+0x70>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8002d62:	6883      	ldr	r3, [r0, #8]
 8002d64:	6901      	ldr	r1, [r0, #16]
 8002d66:	6802      	ldr	r2, [r0, #0]
 8002d68:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8002d6c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002d6e:	d10b      	bne.n	8002d88 <UART_Receive_IT+0x30>
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FFU);
 8002d70:	6852      	ldr	r2, [r2, #4]
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
 8002d72:	b921      	cbnz	r1, 8002d7e <UART_Receive_IT+0x26>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FFU);
 8002d74:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8002d78:	f823 2b02 	strh.w	r2, [r3], #2
 8002d7c:	e002      	b.n	8002d84 <UART_Receive_IT+0x2c>
        huart->pRxBuffPtr += 2U;
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FFU);
 8002d7e:	b2d2      	uxtb	r2, r2
 8002d80:	f823 2b01 	strh.w	r2, [r3], #1
        huart->pRxBuffPtr += 1U;
 8002d84:	6283      	str	r3, [r0, #40]	; 0x28
 8002d86:	e00a      	b.n	8002d9e <UART_Receive_IT+0x46>
      }
    }
    else
    {
      if(huart->Init.Parity == UART_PARITY_NONE)
 8002d88:	b919      	cbnz	r1, 8002d92 <UART_Receive_IT+0x3a>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FFU);
 8002d8a:	1c59      	adds	r1, r3, #1
 8002d8c:	6281      	str	r1, [r0, #40]	; 0x28
 8002d8e:	6852      	ldr	r2, [r2, #4]
 8002d90:	e004      	b.n	8002d9c <UART_Receive_IT+0x44>
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007FU);
 8002d92:	6852      	ldr	r2, [r2, #4]
 8002d94:	1c59      	adds	r1, r3, #1
 8002d96:	6281      	str	r1, [r0, #40]	; 0x28
 8002d98:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8002d9c:	701a      	strb	r2, [r3, #0]
      }
    }

    if(--huart->RxXferCount == 0U)
 8002d9e:	8dc4      	ldrh	r4, [r0, #46]	; 0x2e
 8002da0:	3c01      	subs	r4, #1
 8002da2:	b2a4      	uxth	r4, r4
 8002da4:	85c4      	strh	r4, [r0, #46]	; 0x2e
 8002da6:	b98c      	cbnz	r4, 8002dcc <UART_Receive_IT+0x74>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8002da8:	6803      	ldr	r3, [r0, #0]
 8002daa:	68da      	ldr	r2, [r3, #12]
 8002dac:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8002db0:	60da      	str	r2, [r3, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002db2:	695a      	ldr	r2, [r3, #20]
 8002db4:	f022 0201 	bic.w	r2, r2, #1
 8002db8:	615a      	str	r2, [r3, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8002dba:	2320      	movs	r3, #32
 8002dbc:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
     
      HAL_UART_RxCpltCallback(huart);
 8002dc0:	f7ff ffc9 	bl	8002d56 <HAL_UART_RxCpltCallback>
 8002dc4:	4620      	mov	r0, r4
 8002dc6:	bd10      	pop	{r4, pc}
    }
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8002dc8:	2002      	movs	r0, #2
 8002dca:	bd10      	pop	{r4, pc}
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007FU);
      }
    }

    if(--huart->RxXferCount == 0U)
 8002dcc:	2000      	movs	r0, #0
  }
  else
  {
    return HAL_BUSY;
  }
}
 8002dce:	bd10      	pop	{r4, pc}

08002dd0 <HAL_UART_ErrorCallback>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
 __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8002dd0:	4770      	bx	lr
	...

08002dd4 <HAL_UART_IRQHandler>:
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8002dd4:	6803      	ldr	r3, [r0, #0]
 8002dd6:	681a      	ldr	r2, [r3, #0]
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8002dd8:	68d9      	ldr	r1, [r3, #12]
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8002dda:	b570      	push	{r4, r5, r6, lr}
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8002ddc:	0716      	lsls	r6, r2, #28
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8002dde:	4604      	mov	r4, r0
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8002de0:	695d      	ldr	r5, [r3, #20]
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8002de2:	d107      	bne.n	8002df4 <HAL_UART_IRQHandler+0x20>
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8002de4:	0696      	lsls	r6, r2, #26
 8002de6:	d55a      	bpl.n	8002e9e <HAL_UART_IRQHandler+0xca>
 8002de8:	068d      	lsls	r5, r1, #26
 8002dea:	d558      	bpl.n	8002e9e <HAL_UART_IRQHandler+0xca>
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8002dec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if(errorflags == RESET)
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
    {
      UART_Receive_IT(huart);
 8002df0:	f7ff bfb2 	b.w	8002d58 <UART_Receive_IT>
      return;
    }
  }

  /* If some errors occur */
  if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8002df4:	f015 0001 	ands.w	r0, r5, #1
 8002df8:	d102      	bne.n	8002e00 <HAL_UART_IRQHandler+0x2c>
 8002dfa:	f411 7f90 	tst.w	r1, #288	; 0x120
 8002dfe:	d04e      	beq.n	8002e9e <HAL_UART_IRQHandler+0xca>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8002e00:	07d3      	lsls	r3, r2, #31
 8002e02:	d505      	bpl.n	8002e10 <HAL_UART_IRQHandler+0x3c>
 8002e04:	05ce      	lsls	r6, r1, #23
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8002e06:	bf42      	ittt	mi
 8002e08:	6be3      	ldrmi	r3, [r4, #60]	; 0x3c
 8002e0a:	f043 0301 	orrmi.w	r3, r3, #1
 8002e0e:	63e3      	strmi	r3, [r4, #60]	; 0x3c
    }
    
    /* UART noise error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002e10:	0755      	lsls	r5, r2, #29
 8002e12:	d504      	bpl.n	8002e1e <HAL_UART_IRQHandler+0x4a>
 8002e14:	b118      	cbz	r0, 8002e1e <HAL_UART_IRQHandler+0x4a>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8002e16:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002e18:	f043 0302 	orr.w	r3, r3, #2
 8002e1c:	63e3      	str	r3, [r4, #60]	; 0x3c
    }
    
    /* UART frame error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002e1e:	0793      	lsls	r3, r2, #30
 8002e20:	d504      	bpl.n	8002e2c <HAL_UART_IRQHandler+0x58>
 8002e22:	b118      	cbz	r0, 8002e2c <HAL_UART_IRQHandler+0x58>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8002e24:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002e26:	f043 0304 	orr.w	r3, r3, #4
 8002e2a:	63e3      	str	r3, [r4, #60]	; 0x3c
    }
    
    /* UART Over-Run interrupt occurred --------------------------------------*/
    if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002e2c:	0716      	lsls	r6, r2, #28
 8002e2e:	d504      	bpl.n	8002e3a <HAL_UART_IRQHandler+0x66>
 8002e30:	b118      	cbz	r0, 8002e3a <HAL_UART_IRQHandler+0x66>
    { 
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8002e32:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002e34:	f043 0308 	orr.w	r3, r3, #8
 8002e38:	63e3      	str	r3, [r4, #60]	; 0x3c
    }

    /* Call UART Error Call back function if need be --------------------------*/    
    if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 8002e3a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002e3c:	2b00      	cmp	r3, #0
 8002e3e:	d066      	beq.n	8002f0e <HAL_UART_IRQHandler+0x13a>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8002e40:	0695      	lsls	r5, r2, #26
 8002e42:	d504      	bpl.n	8002e4e <HAL_UART_IRQHandler+0x7a>
 8002e44:	0688      	lsls	r0, r1, #26
 8002e46:	d502      	bpl.n	8002e4e <HAL_UART_IRQHandler+0x7a>
      {
        UART_Receive_IT(huart);
 8002e48:	4620      	mov	r0, r4
 8002e4a:	f7ff ff85 	bl	8002d58 <UART_Receive_IT>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8002e4e:	6823      	ldr	r3, [r4, #0]
 8002e50:	695b      	ldr	r3, [r3, #20]
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8002e52:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8002e54:	0711      	lsls	r1, r2, #28
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8002e56:	4620      	mov	r0, r4
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8002e58:	d402      	bmi.n	8002e60 <HAL_UART_IRQHandler+0x8c>
 8002e5a:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 8002e5e:	d01a      	beq.n	8002e96 <HAL_UART_IRQHandler+0xc2>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8002e60:	f7ff fe1e 	bl	8002aa0 <UART_EndRxTransfer>
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8002e64:	6823      	ldr	r3, [r4, #0]
 8002e66:	695a      	ldr	r2, [r3, #20]
 8002e68:	0652      	lsls	r2, r2, #25
 8002e6a:	d510      	bpl.n	8002e8e <HAL_UART_IRQHandler+0xba>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8002e6c:	695a      	ldr	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8002e6e:	6b60      	ldr	r0, [r4, #52]	; 0x34
        UART_EndRxTransfer(huart);
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8002e70:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002e74:	615a      	str	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8002e76:	b150      	cbz	r0, 8002e8e <HAL_UART_IRQHandler+0xba>
          {
            /* Set the UART DMA Abort callback : 
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8002e78:	4b25      	ldr	r3, [pc, #148]	; (8002f10 <HAL_UART_IRQHandler+0x13c>)
 8002e7a:	6503      	str	r3, [r0, #80]	; 0x50
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8002e7c:	f7fd fefb 	bl	8000c76 <HAL_DMA_Abort_IT>
 8002e80:	2800      	cmp	r0, #0
 8002e82:	d044      	beq.n	8002f0e <HAL_UART_IRQHandler+0x13a>
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8002e84:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8002e86:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8002e8a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8002e8c:	4718      	bx	r3
            }
          }
          else
          {
            /* Call user error callback */
            HAL_UART_ErrorCallback(huart);
 8002e8e:	4620      	mov	r0, r4
 8002e90:	f7ff ff9e 	bl	8002dd0 <HAL_UART_ErrorCallback>
 8002e94:	bd70      	pop	{r4, r5, r6, pc}
      }
      else
      {
        /* Non Blocking error : transfer could go on. 
           Error is notified to user through user error callback */
        HAL_UART_ErrorCallback(huart);
 8002e96:	f7ff ff9b 	bl	8002dd0 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002e9a:	63e5      	str	r5, [r4, #60]	; 0x3c
 8002e9c:	bd70      	pop	{r4, r5, r6, pc}
    }
    return;
  } /* End if some error occurs */

  /* UART in mode Transmitter ------------------------------------------------*/
  if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8002e9e:	0616      	lsls	r6, r2, #24
 8002ea0:	d527      	bpl.n	8002ef2 <HAL_UART_IRQHandler+0x11e>
 8002ea2:	060d      	lsls	r5, r1, #24
 8002ea4:	d525      	bpl.n	8002ef2 <HAL_UART_IRQHandler+0x11e>
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Tx process is ongoing */
  if(huart->gState == HAL_UART_STATE_BUSY_TX)
 8002ea6:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8002eaa:	2a21      	cmp	r2, #33	; 0x21
 8002eac:	d12f      	bne.n	8002f0e <HAL_UART_IRQHandler+0x13a>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8002eae:	68a2      	ldr	r2, [r4, #8]
 8002eb0:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8002eb4:	6a22      	ldr	r2, [r4, #32]
 8002eb6:	d10a      	bne.n	8002ece <HAL_UART_IRQHandler+0xfa>
    {
      tmp = (uint16_t*) huart->pTxBuffPtr;
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FFU);
 8002eb8:	8811      	ldrh	r1, [r2, #0]
 8002eba:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8002ebe:	6059      	str	r1, [r3, #4]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8002ec0:	6921      	ldr	r1, [r4, #16]
 8002ec2:	b909      	cbnz	r1, 8002ec8 <HAL_UART_IRQHandler+0xf4>
      {
        huart->pTxBuffPtr += 2U;
 8002ec4:	3202      	adds	r2, #2
 8002ec6:	e000      	b.n	8002eca <HAL_UART_IRQHandler+0xf6>
      }
      else
      {
        huart->pTxBuffPtr += 1U;
 8002ec8:	3201      	adds	r2, #1
 8002eca:	6222      	str	r2, [r4, #32]
 8002ecc:	e003      	b.n	8002ed6 <HAL_UART_IRQHandler+0x102>
      }
    } 
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FFU);
 8002ece:	1c51      	adds	r1, r2, #1
 8002ed0:	6221      	str	r1, [r4, #32]
 8002ed2:	7812      	ldrb	r2, [r2, #0]
 8002ed4:	605a      	str	r2, [r3, #4]
    }

    if(--huart->TxXferCount == 0U)
 8002ed6:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8002ed8:	3a01      	subs	r2, #1
 8002eda:	b292      	uxth	r2, r2
 8002edc:	84e2      	strh	r2, [r4, #38]	; 0x26
 8002ede:	b9b2      	cbnz	r2, 8002f0e <HAL_UART_IRQHandler+0x13a>
    {
      /* Disable the UART Transmit Complete Interrupt */
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8002ee0:	68da      	ldr	r2, [r3, #12]
 8002ee2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002ee6:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */    
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8002ee8:	68da      	ldr	r2, [r3, #12]
 8002eea:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002eee:	60da      	str	r2, [r3, #12]
 8002ef0:	bd70      	pop	{r4, r5, r6, pc}
    UART_Transmit_IT(huart);
    return;
  }
  
  /* UART in mode Transmitter end --------------------------------------------*/
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8002ef2:	0650      	lsls	r0, r2, #25
 8002ef4:	d50b      	bpl.n	8002f0e <HAL_UART_IRQHandler+0x13a>
 8002ef6:	064a      	lsls	r2, r1, #25
 8002ef8:	d509      	bpl.n	8002f0e <HAL_UART_IRQHandler+0x13a>
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8002efa:	68da      	ldr	r2, [r3, #12]
 8002efc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002f00:	60da      	str	r2, [r3, #12]
  
  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8002f02:	2320      	movs	r3, #32
 8002f04:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    
  HAL_UART_TxCpltCallback(huart);
 8002f08:	4620      	mov	r0, r4
 8002f0a:	f7ff ff23 	bl	8002d54 <HAL_UART_TxCpltCallback>
 8002f0e:	bd70      	pop	{r4, r5, r6, pc}
 8002f10:	08002f15 	.word	0x08002f15

08002f14 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8002f14:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8002f16:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0;
 8002f18:	2300      	movs	r3, #0
 8002f1a:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0;
 8002f1c:	84c3      	strh	r3, [r0, #38]	; 0x26

  HAL_UART_ErrorCallback(huart);
 8002f1e:	f7ff ff57 	bl	8002dd0 <HAL_UART_ErrorCallback>
 8002f22:	bd08      	pop	{r3, pc}

08002f24 <SDIO_Init>:
  * @param  SDIOx: Pointer to SDIO register base
  * @param  Init: SDIO initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_Init(SDIO_TypeDef *SDIOx, SDIO_InitTypeDef Init)
{
 8002f24:	b084      	sub	sp, #16
 8002f26:	b510      	push	{r4, lr}
 8002f28:	ac03      	add	r4, sp, #12
 8002f2a:	e884 000e 	stmia.w	r4, {r1, r2, r3}
             Init.HardwareFlowControl |\
             Init.ClockDiv
             ); 
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 8002f2e:	9b04      	ldr	r3, [sp, #16]
 8002f30:	6842      	ldr	r2, [r0, #4]
 8002f32:	4319      	orrs	r1, r3
 8002f34:	9b05      	ldr	r3, [sp, #20]
 8002f36:	4319      	orrs	r1, r3
 8002f38:	9b06      	ldr	r3, [sp, #24]
 8002f3a:	4319      	orrs	r1, r3
 8002f3c:	9b07      	ldr	r3, [sp, #28]
 8002f3e:	4319      	orrs	r1, r3
 8002f40:	9b08      	ldr	r3, [sp, #32]

  return HAL_OK;
}
 8002f42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
             Init.HardwareFlowControl |\
             Init.ClockDiv
             ); 
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 8002f46:	4319      	orrs	r1, r3
 8002f48:	f422 43fd 	bic.w	r3, r2, #32384	; 0x7e80
 8002f4c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8002f50:	430b      	orrs	r3, r1
 8002f52:	6043      	str	r3, [r0, #4]

  return HAL_OK;
}
 8002f54:	b004      	add	sp, #16
 8002f56:	2000      	movs	r0, #0
 8002f58:	4770      	bx	lr

08002f5a <SDIO_ReadFIFO>:
 8002f5a:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8002f5e:	4770      	bx	lr

08002f60 <SDIO_WriteFIFO>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_WriteFIFO(SDIO_TypeDef *SDIOx, uint32_t *pWriteData)
{ 
  /* Write data to FIFO */ 
  SDIOx->FIFO = *pWriteData;
 8002f60:	680b      	ldr	r3, [r1, #0]
 8002f62:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80

  return HAL_OK;
}
 8002f66:	2000      	movs	r0, #0
 8002f68:	4770      	bx	lr

08002f6a <SDIO_PowerState_ON>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_PowerState_ON(SDIO_TypeDef *SDIOx)
{  
  /* Set power state to ON */ 
  SDIOx->POWER = SDIO_POWER_PWRCTRL;
 8002f6a:	2303      	movs	r3, #3
 8002f6c:	6003      	str	r3, [r0, #0]
  
  return HAL_OK; 
}
 8002f6e:	2000      	movs	r0, #0
 8002f70:	4770      	bx	lr

08002f72 <SDIO_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(SDIO_TypeDef *SDIOx)  
{
  return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
 8002f72:	6800      	ldr	r0, [r0, #0]
}
 8002f74:	f000 0003 	and.w	r0, r0, #3
 8002f78:	4770      	bx	lr

08002f7a <SDIO_SendCommand>:
  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->Response));
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->WaitForInterrupt));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->CPSM));

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;
 8002f7a:	680b      	ldr	r3, [r1, #0]
  * @param  SDIO_CmdInitStruct: pointer to a SDIO_CmdInitTypeDef structure that contains 
  *         the configuration information for the SDIO command
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
 8002f7c:	b510      	push	{r4, lr}
  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->Response));
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->WaitForInterrupt));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->CPSM));

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;
 8002f7e:	6083      	str	r3, [r0, #8]
                       SDIO_CmdInitStruct->Response         |\
                       SDIO_CmdInitStruct->WaitForInterrupt |\
                       SDIO_CmdInitStruct->CPSM);
  
  /* Write to SDIO CMD register */
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8002f80:	684c      	ldr	r4, [r1, #4]
 8002f82:	688b      	ldr	r3, [r1, #8]
 8002f84:	68c2      	ldr	r2, [r0, #12]
 8002f86:	431c      	orrs	r4, r3
 8002f88:	68cb      	ldr	r3, [r1, #12]
 8002f8a:	6909      	ldr	r1, [r1, #16]
 8002f8c:	4323      	orrs	r3, r4
 8002f8e:	4319      	orrs	r1, r3
 8002f90:	f422 637f 	bic.w	r3, r2, #4080	; 0xff0
 8002f94:	f023 030f 	bic.w	r3, r3, #15
 8002f98:	430b      	orrs	r3, r1
 8002f9a:	60c3      	str	r3, [r0, #12]
  
  return HAL_OK;  
}
 8002f9c:	2000      	movs	r0, #0
 8002f9e:	bd10      	pop	{r4, pc}

08002fa0 <SDIO_GetCommandResponse>:
  * @param  SDIOx: Pointer to SDIO register base
  * @retval Command index of the last command response received
  */
uint8_t SDIO_GetCommandResponse(SDIO_TypeDef *SDIOx)
{
  return (uint8_t)(SDIOx->RESPCMD);
 8002fa0:	6900      	ldr	r0, [r0, #16]
}
 8002fa2:	b2c0      	uxtb	r0, r0
 8002fa4:	4770      	bx	lr
	...

08002fa8 <SDIO_GetResponse>:
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4  
  * @retval The Corresponding response register value
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
 8002fa8:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0U;
 8002faa:	2300      	movs	r3, #0
 8002fac:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));

  /* Get the response */
  tmp = SDIO_RESP_ADDR + SDIO_RESP;
 8002fae:	4b03      	ldr	r3, [pc, #12]	; (8002fbc <SDIO_GetResponse+0x14>)
 8002fb0:	4403      	add	r3, r0
 8002fb2:	9301      	str	r3, [sp, #4]
  
  return (*(__IO uint32_t *) tmp);
 8002fb4:	9b01      	ldr	r3, [sp, #4]
 8002fb6:	6818      	ldr	r0, [r3, #0]
}  
 8002fb8:	b002      	add	sp, #8
 8002fba:	4770      	bx	lr
 8002fbc:	40012c14 	.word	0x40012c14

08002fc0 <SDIO_DataConfig>:
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_DataConfig(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 8002fc0:	b510      	push	{r4, lr}
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8002fc2:	68ca      	ldr	r2, [r1, #12]
 8002fc4:	688c      	ldr	r4, [r1, #8]
  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->TransferDir));
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->DPSM));

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;
 8002fc6:	680b      	ldr	r3, [r1, #0]
 8002fc8:	6243      	str	r3, [r0, #36]	; 0x24
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8002fca:	4314      	orrs	r4, r2

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;
 8002fcc:	684b      	ldr	r3, [r1, #4]
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8002fce:	690a      	ldr	r2, [r1, #16]

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;
 8002fd0:	6283      	str	r3, [r0, #40]	; 0x28
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8002fd2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8002fd4:	4314      	orrs	r4, r2
 8002fd6:	694a      	ldr	r2, [r1, #20]
 8002fd8:	f023 03f7 	bic.w	r3, r3, #247	; 0xf7
 8002fdc:	4322      	orrs	r2, r4
 8002fde:	4313      	orrs	r3, r2
 8002fe0:	62c3      	str	r3, [r0, #44]	; 0x2c

  return HAL_OK;

}
 8002fe2:	2000      	movs	r0, #0
 8002fe4:	bd10      	pop	{r4, pc}

08002fe6 <USB_CoreInit>:
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8002fe6:	b084      	sub	sp, #16
 8002fe8:	b538      	push	{r3, r4, r5, lr}
 8002fea:	ad05      	add	r5, sp, #20
 8002fec:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8002ff0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002ff2:	2b01      	cmp	r3, #1
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8002ff4:	4604      	mov	r4, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8002ff6:	d117      	bne.n	8003028 <USB_CoreInit+0x42>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8002ff8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8002ffa:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8002ffe:	6383      	str	r3, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8003000:	68c3      	ldr	r3, [r0, #12]
 8003002:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8003006:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800300a:	60c3      	str	r3, [r0, #12]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 800300c:	68c3      	ldr	r3, [r0, #12]
 800300e:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8003012:	60c3      	str	r3, [r0, #12]
    if(cfg.use_external_vbus == 1U)
 8003014:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8003016:	2b01      	cmp	r3, #1
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8003018:	bf02      	ittt	eq
 800301a:	68c3      	ldreq	r3, [r0, #12]
 800301c:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 8003020:	60c3      	streq	r3, [r0, #12]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
 8003022:	f000 fc81 	bl	8003928 <USB_CoreReset>
 8003026:	e008      	b.n	800303a <USB_CoreInit+0x54>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8003028:	68c3      	ldr	r3, [r0, #12]
 800302a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800302e:	60c3      	str	r3, [r0, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
 8003030:	f000 fc7a 	bl	8003928 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8003034:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8003038:	63a3      	str	r3, [r4, #56]	; 0x38
  }
 
  if(cfg.dma_enable == ENABLE)
 800303a:	9b08      	ldr	r3, [sp, #32]
 800303c:	2b01      	cmp	r3, #1
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 800303e:	bf02      	ittt	eq
 8003040:	68a3      	ldreq	r3, [r4, #8]
 8003042:	f043 0320 	orreq.w	r3, r3, #32
 8003046:	60a3      	streq	r3, [r4, #8]
  }  

  return HAL_OK;
}
 8003048:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800304c:	2000      	movs	r0, #0
 800304e:	b004      	add	sp, #16
 8003050:	4770      	bx	lr

08003052 <USB_EnableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8003052:	6883      	ldr	r3, [r0, #8]
 8003054:	f043 0301 	orr.w	r3, r3, #1
 8003058:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 800305a:	2000      	movs	r0, #0
 800305c:	4770      	bx	lr

0800305e <USB_DisableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800305e:	6883      	ldr	r3, [r0, #8]
 8003060:	f023 0301 	bic.w	r3, r3, #1
 8003064:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8003066:	2000      	movs	r0, #0
 8003068:	4770      	bx	lr

0800306a <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 800306a:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 800306c:	68c3      	ldr	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 800306e:	2901      	cmp	r1, #1
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8003070:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8003074:	60c3      	str	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 8003076:	d104      	bne.n	8003082 <USB_SetCurrentMode+0x18>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 8003078:	68c3      	ldr	r3, [r0, #12]
 800307a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800307e:	60c3      	str	r3, [r0, #12]
 8003080:	e004      	b.n	800308c <USB_SetCurrentMode+0x22>
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
 8003082:	b919      	cbnz	r1, 800308c <USB_SetCurrentMode+0x22>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 8003084:	68c3      	ldr	r3, [r0, #12]
 8003086:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800308a:	60c3      	str	r3, [r0, #12]
  }
  HAL_Delay(50U);
 800308c:	2032      	movs	r0, #50	; 0x32
 800308e:	f7fd fd6b 	bl	8000b68 <HAL_Delay>
  
  return HAL_OK;
}
 8003092:	2000      	movs	r0, #0
 8003094:	bd08      	pop	{r3, pc}
	...

08003098 <USB_DevInit>:
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8003098:	b084      	sub	sp, #16
 800309a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800309e:	4604      	mov	r4, r0
 80030a0:	a807      	add	r0, sp, #28
 80030a2:	e880 000e 	stmia.w	r0, {r1, r2, r3}
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 80030a6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80030a8:	9e11      	ldr	r6, [sp, #68]	; 0x44
 80030aa:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80030ac:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80030b0:	4688      	mov	r8, r1
 80030b2:	63a3      	str	r3, [r4, #56]	; 0x38
  
  if (cfg.vbus_sensing_enable == 0U)
 80030b4:	b91e      	cbnz	r6, 80030be <USB_DevInit+0x26>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 80030b6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80030b8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80030bc:	63a3      	str	r3, [r4, #56]	; 0x38
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 80030be:	2300      	movs	r3, #0
 80030c0:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 80030c4:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 80030c8:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 80030cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80030ce:	2b01      	cmp	r3, #1

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 80030d0:	f504 6500 	add.w	r5, r4, #2048	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 80030d4:	d106      	bne.n	80030e4 <USB_DevInit+0x4c>
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 80030d6:	9909      	ldr	r1, [sp, #36]	; 0x24
 80030d8:	b129      	cbz	r1, 80030e6 <USB_DevInit+0x4e>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 80030da:	4619      	mov	r1, r3
 80030dc:	4620      	mov	r0, r4
 80030de:	f000 f897 	bl	8003210 <USB_SetDevSpeed>
 80030e2:	e003      	b.n	80030ec <USB_DevInit+0x54>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 80030e4:	2103      	movs	r1, #3
 80030e6:	4620      	mov	r0, r4
 80030e8:	f000 f892 	bl	8003210 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 80030ec:	2110      	movs	r1, #16
 80030ee:	4620      	mov	r0, r4
 80030f0:	f000 f86c 	bl	80031cc <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 80030f4:	4620      	mov	r0, r4
 80030f6:	f000 f87b 	bl	80031f0 <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 80030fa:	2300      	movs	r3, #0
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 80030fc:	f04f 32ff 	mov.w	r2, #4294967295
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8003100:	612b      	str	r3, [r5, #16]
 8003102:	4619      	mov	r1, r3
  USBx_DEVICE->DOEPMSK = 0U;
 8003104:	616b      	str	r3, [r5, #20]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8003106:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 800310a:	61aa      	str	r2, [r5, #24]
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 800310c:	f04f 0eff 	mov.w	lr, #255	; 0xff
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
 8003110:	61eb      	str	r3, [r5, #28]
 8003112:	f504 6210 	add.w	r2, r4, #2304	; 0x900
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003116:	4543      	cmp	r3, r8
 8003118:	d00c      	beq.n	8003134 <USB_DevInit+0x9c>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800311a:	f8d2 c000 	ldr.w	ip, [r2]
 800311e:	f1bc 0f00 	cmp.w	ip, #0
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8003122:	bfb4      	ite	lt
 8003124:	6010      	strlt	r0, [r2, #0]
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8003126:	6011      	strge	r1, [r2, #0]
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003128:	3301      	adds	r3, #1
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
 800312a:	6111      	str	r1, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 800312c:	f8c2 e008 	str.w	lr, [r2, #8]
 8003130:	3220      	adds	r2, #32
 8003132:	e7f0      	b.n	8003116 <USB_DevInit+0x7e>
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003134:	2200      	movs	r2, #0
 8003136:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
 800313a:	4611      	mov	r1, r2
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 800313c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8003140:	f04f 0eff 	mov.w	lr, #255	; 0xff
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003144:	4542      	cmp	r2, r8
 8003146:	d00c      	beq.n	8003162 <USB_DevInit+0xca>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8003148:	f8d3 c000 	ldr.w	ip, [r3]
 800314c:	f1bc 0f00 	cmp.w	ip, #0
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8003150:	bfb4      	ite	lt
 8003152:	6018      	strlt	r0, [r3, #0]
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8003154:	6019      	strge	r1, [r3, #0]
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003156:	3201      	adds	r2, #1
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8003158:	6119      	str	r1, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 800315a:	f8c3 e008 	str.w	lr, [r3, #8]
 800315e:	3320      	adds	r3, #32
 8003160:	e7f0      	b.n	8003144 <USB_DevInit+0xac>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8003162:	692b      	ldr	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 8003164:	2f01      	cmp	r7, #1
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8003166:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800316a:	612b      	str	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 800316c:	d108      	bne.n	8003180 <USB_DevInit+0xe8>
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 800316e:	4b15      	ldr	r3, [pc, #84]	; (80031c4 <USB_DevInit+0x12c>)
 8003170:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 8003172:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003174:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003178:	f043 0303 	orr.w	r3, r3, #3
 800317c:	632b      	str	r3, [r5, #48]	; 0x30
    
    i= USBx_DEVICE->DTHRCTL;
 800317e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8003180:	2300      	movs	r3, #0
 8003182:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 8003184:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8003188:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 800318a:	b91f      	cbnz	r7, 8003194 <USB_DevInit+0xfc>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 800318c:	69a3      	ldr	r3, [r4, #24]
 800318e:	f043 0310 	orr.w	r3, r3, #16
 8003192:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 8003194:	69a2      	ldr	r2, [r4, #24]
 8003196:	4b0c      	ldr	r3, [pc, #48]	; (80031c8 <USB_DevInit+0x130>)
 8003198:	4313      	orrs	r3, r2
 800319a:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 800319c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800319e:	b11b      	cbz	r3, 80031a8 <USB_DevInit+0x110>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 80031a0:	69a3      	ldr	r3, [r4, #24]
 80031a2:	f043 0308 	orr.w	r3, r3, #8
 80031a6:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 80031a8:	2e01      	cmp	r6, #1
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 80031aa:	bf01      	itttt	eq
 80031ac:	69a3      	ldreq	r3, [r4, #24]
 80031ae:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 80031b2:	f043 0304 	orreq.w	r3, r3, #4
 80031b6:	61a3      	streq	r3, [r4, #24]
  }
  
  return HAL_OK;
}
 80031b8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80031bc:	2000      	movs	r0, #0
 80031be:	b004      	add	sp, #16
 80031c0:	4770      	bx	lr
 80031c2:	bf00      	nop
 80031c4:	00800100 	.word	0x00800100
 80031c8:	803c3800 	.word	0x803c3800

080031cc <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0U;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 80031cc:	0189      	lsls	r1, r1, #6
 80031ce:	f041 0120 	orr.w	r1, r1, #32
 80031d2:	4a06      	ldr	r2, [pc, #24]	; (80031ec <USB_FlushTxFifo+0x20>)
 80031d4:	6101      	str	r1, [r0, #16]
 
  do
  {
    if (++count > 200000U)
 80031d6:	3a01      	subs	r2, #1
 80031d8:	d005      	beq.n	80031e6 <USB_FlushTxFifo+0x1a>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 80031da:	6903      	ldr	r3, [r0, #16]
 80031dc:	f013 0320 	ands.w	r3, r3, #32
 80031e0:	d1f9      	bne.n	80031d6 <USB_FlushTxFifo+0xa>
  
  return HAL_OK;
 80031e2:	4618      	mov	r0, r3
 80031e4:	4770      	bx	lr
 
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 80031e6:	2003      	movs	r0, #3
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
  
  return HAL_OK;
}
 80031e8:	4770      	bx	lr
 80031ea:	bf00      	nop
 80031ec:	00030d41 	.word	0x00030d41

080031f0 <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0U;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80031f0:	2310      	movs	r3, #16
 80031f2:	4a06      	ldr	r2, [pc, #24]	; (800320c <USB_FlushRxFifo+0x1c>)
 80031f4:	6103      	str	r3, [r0, #16]
  
  do
  {
    if (++count > 200000U)
 80031f6:	3a01      	subs	r2, #1
 80031f8:	d005      	beq.n	8003206 <USB_FlushRxFifo+0x16>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 80031fa:	6903      	ldr	r3, [r0, #16]
 80031fc:	f013 0310 	ands.w	r3, r3, #16
 8003200:	d1f9      	bne.n	80031f6 <USB_FlushRxFifo+0x6>
  
  return HAL_OK;
 8003202:	4618      	mov	r0, r3
 8003204:	4770      	bx	lr
  
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 8003206:	2003      	movs	r0, #3
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
  
  return HAL_OK;
}
 8003208:	4770      	bx	lr
 800320a:	bf00      	nop
 800320c:	00030d41 	.word	0x00030d41

08003210 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 8003210:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8003214:	4319      	orrs	r1, r3
 8003216:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 800321a:	2000      	movs	r0, #0
 800321c:	4770      	bx	lr

0800321e <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0U;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 800321e:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8003222:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 8003226:	f013 0006 	ands.w	r0, r3, #6
 800322a:	d012      	beq.n	8003252 <USB_GetDevSpeed+0x34>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 800322c:	6893      	ldr	r3, [r2, #8]
 800322e:	f003 0306 	and.w	r3, r3, #6
 8003232:	2b02      	cmp	r3, #2
 8003234:	d00c      	beq.n	8003250 <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 8003236:	6893      	ldr	r3, [r2, #8]
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8003238:	f003 0306 	and.w	r3, r3, #6
 800323c:	2b06      	cmp	r3, #6
 800323e:	d007      	beq.n	8003250 <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8003240:	6893      	ldr	r3, [r2, #8]
 8003242:	f003 0306 	and.w	r3, r3, #6
 8003246:	2b04      	cmp	r3, #4
  {
    speed = USB_OTG_SPEED_LOW;
 8003248:	bf14      	ite	ne
 800324a:	2000      	movne	r0, #0
 800324c:	2002      	moveq	r0, #2
 800324e:	4770      	bx	lr
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
 8003250:	2003      	movs	r0, #3
  {
    speed = USB_OTG_SPEED_LOW;
  }
  
  return speed;
}
 8003252:	4770      	bx	lr

08003254 <USB_ActivateEndpoint>:
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8003254:	784b      	ldrb	r3, [r1, #1]
 8003256:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 800325a:	2b01      	cmp	r3, #1
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800325c:	b570      	push	{r4, r5, r6, lr}
 800325e:	780e      	ldrb	r6, [r1, #0]
  if (ep->is_in == 1U)
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 8003260:	69d4      	ldr	r4, [r2, #28]
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8003262:	d11b      	bne.n	800329c <USB_ActivateEndpoint+0x48>
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 8003264:	40b3      	lsls	r3, r6
 8003266:	b29b      	uxth	r3, r3
 8003268:	4323      	orrs	r3, r4
 800326a:	61d3      	str	r3, [r2, #28]
   
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
 800326c:	780e      	ldrb	r6, [r1, #0]
 800326e:	f44f 6510 	mov.w	r5, #2304	; 0x900
 8003272:	eb05 1546 	add.w	r5, r5, r6, lsl #5
 8003276:	582b      	ldr	r3, [r5, r0]
 8003278:	041a      	lsls	r2, r3, #16
 800327a:	d42a      	bmi.n	80032d2 <USB_ActivateEndpoint+0x7e>
    {
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
 800327c:	582c      	ldr	r4, [r5, r0]
 800327e:	688a      	ldr	r2, [r1, #8]
 8003280:	f044 5380 	orr.w	r3, r4, #268435456	; 0x10000000
 8003284:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003288:	f3c2 020a 	ubfx	r2, r2, #0, #11
 800328c:	431a      	orrs	r2, r3
 800328e:	78cb      	ldrb	r3, [r1, #3]
 8003290:	ea42 4383 	orr.w	r3, r2, r3, lsl #18
 8003294:	ea43 5386 	orr.w	r3, r3, r6, lsl #22
 8003298:	502b      	str	r3, [r5, r0]
 800329a:	e01a      	b.n	80032d2 <USB_ActivateEndpoint+0x7e>
        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
    } 
  }
  else
  {
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
 800329c:	f44f 3580 	mov.w	r5, #65536	; 0x10000
 80032a0:	fa05 f306 	lsl.w	r3, r5, r6
 80032a4:	4323      	orrs	r3, r4
 80032a6:	61d3      	str	r3, [r2, #28]
     
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 80032a8:	780c      	ldrb	r4, [r1, #0]
 80032aa:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 80032ae:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 80032b2:	5823      	ldr	r3, [r4, r0]
 80032b4:	041b      	lsls	r3, r3, #16
 80032b6:	d40c      	bmi.n	80032d2 <USB_ActivateEndpoint+0x7e>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
 80032b8:	5822      	ldr	r2, [r4, r0]
 80032ba:	688b      	ldr	r3, [r1, #8]
 80032bc:	f3c3 050a 	ubfx	r5, r3, #0, #11
 80032c0:	f042 5380 	orr.w	r3, r2, #268435456	; 0x10000000
 80032c4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80032c8:	78ca      	ldrb	r2, [r1, #3]
 80032ca:	432b      	orrs	r3, r5
 80032cc:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 80032d0:	5023      	str	r3, [r4, r0]
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 80032d2:	2000      	movs	r0, #0
 80032d4:	bd70      	pop	{r4, r5, r6, pc}

080032d6 <USB_DeactivateEndpoint>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 80032d6:	b530      	push	{r4, r5, lr}
  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 80032d8:	784c      	ldrb	r4, [r1, #1]
 80032da:	780a      	ldrb	r2, [r1, #0]
  {
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));
 80032dc:	f8d0 583c 	ldr.w	r5, [r0, #2108]	; 0x83c
 80032e0:	f500 6300 	add.w	r3, r0, #2048	; 0x800
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 80032e4:	2c01      	cmp	r4, #1
 80032e6:	d116      	bne.n	8003316 <USB_DeactivateEndpoint+0x40>
  {
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));
 80032e8:	fa04 f202 	lsl.w	r2, r4, r2
 80032ec:	b292      	uxth	r2, r2
 80032ee:	ea25 0202 	bic.w	r2, r5, r2
 80032f2:	63da      	str	r2, [r3, #60]	; 0x3c
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   
 80032f4:	780d      	ldrb	r5, [r1, #0]
 80032f6:	69da      	ldr	r2, [r3, #28]
 80032f8:	40ac      	lsls	r4, r5
 80032fa:	b2a4      	uxth	r4, r4
 80032fc:	ea22 0404 	bic.w	r4, r2, r4
 8003300:	61dc      	str	r4, [r3, #28]
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
 8003302:	780a      	ldrb	r2, [r1, #0]
 8003304:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8003308:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800330c:	581a      	ldr	r2, [r3, r0]
 800330e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003312:	501a      	str	r2, [r3, r0]
 8003314:	e014      	b.n	8003340 <USB_DeactivateEndpoint+0x6a>
  }
  else
  {
     USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));
 8003316:	2401      	movs	r4, #1
 8003318:	fa04 f202 	lsl.w	r2, r4, r2
 800331c:	ea25 4202 	bic.w	r2, r5, r2, lsl #16
 8003320:	63da      	str	r2, [r3, #60]	; 0x3c
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));     
 8003322:	780d      	ldrb	r5, [r1, #0]
 8003324:	69da      	ldr	r2, [r3, #28]
 8003326:	40ac      	lsls	r4, r5
 8003328:	ea22 4404 	bic.w	r4, r2, r4, lsl #16
 800332c:	61dc      	str	r4, [r3, #28]
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
 800332e:	780a      	ldrb	r2, [r1, #0]
 8003330:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8003334:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8003338:	581a      	ldr	r2, [r3, r0]
 800333a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800333e:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 8003340:	2000      	movs	r0, #0
 8003342:	bd30      	pop	{r4, r5, pc}

08003344 <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8003344:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint16_t pktcnt = 0U;
  
  /* IN endpoint */
  if (ep->is_in == 1U)
 8003348:	784b      	ldrb	r3, [r1, #1]
 800334a:	780c      	ldrb	r4, [r1, #0]
 800334c:	2b01      	cmp	r3, #1
 800334e:	f04f 0520 	mov.w	r5, #32
 8003352:	694b      	ldr	r3, [r1, #20]
 8003354:	f040 809b 	bne.w	800348e <USB_EPStartXfer+0x14a>
 8003358:	f44f 6610 	mov.w	r6, #2304	; 0x900
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800335c:	fb15 6404 	smlabb	r4, r5, r4, r6
 8003360:	4404      	add	r4, r0
 8003362:	6927      	ldr	r7, [r4, #16]
  
  /* IN endpoint */
  if (ep->is_in == 1U)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8003364:	b9ab      	cbnz	r3, 8003392 <USB_EPStartXfer+0x4e>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003366:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 800336a:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 800336e:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8003370:	780c      	ldrb	r4, [r1, #0]
 8003372:	fb15 6404 	smlabb	r4, r5, r4, r6
 8003376:	4404      	add	r4, r0
 8003378:	6927      	ldr	r7, [r4, #16]
 800337a:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
 800337e:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8003380:	780c      	ldrb	r4, [r1, #0]
 8003382:	fb15 6504 	smlabb	r5, r5, r4, r6
 8003386:	4405      	add	r5, r0
 8003388:	692c      	ldr	r4, [r5, #16]
 800338a:	0ce4      	lsrs	r4, r4, #19
 800338c:	04e4      	lsls	r4, r4, #19
 800338e:	612c      	str	r4, [r5, #16]
 8003390:	e03f      	b.n	8003412 <USB_EPStartXfer+0xce>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8003392:	0cff      	lsrs	r7, r7, #19
 8003394:	04ff      	lsls	r7, r7, #19
 8003396:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003398:	780c      	ldrb	r4, [r1, #0]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 800339a:	f8d1 c008 	ldr.w	ip, [r1, #8]
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800339e:	fb15 6404 	smlabb	r4, r5, r4, r6
 80033a2:	4404      	add	r4, r0
 80033a4:	6927      	ldr	r7, [r4, #16]
 80033a6:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 80033aa:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 80033ae:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 80033b0:	780f      	ldrb	r7, [r1, #0]
 80033b2:	fb15 6707 	smlabb	r7, r5, r7, r6
 80033b6:	4407      	add	r7, r0
 80033b8:	eb03 040c 	add.w	r4, r3, ip
 80033bc:	3c01      	subs	r4, #1
 80033be:	fbb4 f4fc 	udiv	r4, r4, ip
 80033c2:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 8003578 <USB_EPStartXfer+0x234>
 80033c6:	f8d7 e010 	ldr.w	lr, [r7, #16]
 80033ca:	04e4      	lsls	r4, r4, #19
 80033cc:	ea04 0c0c 	and.w	ip, r4, ip
 80033d0:	ea4c 040e 	orr.w	r4, ip, lr
 80033d4:	613c      	str	r4, [r7, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 80033d6:	780c      	ldrb	r4, [r1, #0]
 80033d8:	fb15 6404 	smlabb	r4, r5, r4, r6
 80033dc:	4404      	add	r4, r0
 80033de:	f3c3 0e12 	ubfx	lr, r3, #0, #19
 80033e2:	6927      	ldr	r7, [r4, #16]
 80033e4:	ea4e 0707 	orr.w	r7, lr, r7
 80033e8:	6127      	str	r7, [r4, #16]
      
      if (ep->type == EP_TYPE_ISOC)
 80033ea:	78cc      	ldrb	r4, [r1, #3]
 80033ec:	2c01      	cmp	r4, #1
 80033ee:	f040 80ba 	bne.w	8003566 <USB_EPStartXfer+0x222>
      {
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 80033f2:	780c      	ldrb	r4, [r1, #0]
 80033f4:	fb15 6404 	smlabb	r4, r5, r4, r6
 80033f8:	4404      	add	r4, r0
 80033fa:	6927      	ldr	r7, [r4, #16]
 80033fc:	f027 47c0 	bic.w	r7, r7, #1610612736	; 0x60000000
 8003400:	6127      	str	r7, [r4, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
 8003402:	780c      	ldrb	r4, [r1, #0]
 8003404:	fb15 6504 	smlabb	r5, r5, r4, r6
 8003408:	4405      	add	r5, r0
 800340a:	692c      	ldr	r4, [r5, #16]
 800340c:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 8003410:	612c      	str	r4, [r5, #16]
      }       
    }

    if (dma == 1U)
 8003412:	2a01      	cmp	r2, #1
 8003414:	d106      	bne.n	8003424 <USB_EPStartXfer+0xe0>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8003416:	780c      	ldrb	r4, [r1, #0]
 8003418:	690d      	ldr	r5, [r1, #16]
 800341a:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 800341e:	f8c4 5914 	str.w	r5, [r4, #2324]	; 0x914
 8003422:	e00b      	b.n	800343c <USB_EPStartXfer+0xf8>
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 8003424:	78cc      	ldrb	r4, [r1, #3]
 8003426:	2c01      	cmp	r4, #1
 8003428:	d00b      	beq.n	8003442 <USB_EPStartXfer+0xfe>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 800342a:	b13b      	cbz	r3, 800343c <USB_EPStartXfer+0xf8>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;
 800342c:	780f      	ldrb	r7, [r1, #0]
 800342e:	f8d0 5834 	ldr.w	r5, [r0, #2100]	; 0x834
 8003432:	2401      	movs	r4, #1
 8003434:	40bc      	lsls	r4, r7
 8003436:	432c      	orrs	r4, r5
 8003438:	f8c0 4834 	str.w	r4, [r0, #2100]	; 0x834
        }
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 800343c:	78cc      	ldrb	r4, [r1, #3]
 800343e:	2c01      	cmp	r4, #1
 8003440:	d111      	bne.n	8003466 <USB_EPStartXfer+0x122>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8003442:	f8d0 4808 	ldr.w	r4, [r0, #2056]	; 0x808
 8003446:	f414 7f80 	tst.w	r4, #256	; 0x100
 800344a:	780c      	ldrb	r4, [r1, #0]
 800344c:	f04f 0520 	mov.w	r5, #32
 8003450:	f44f 6610 	mov.w	r6, #2304	; 0x900
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8003454:	fb15 6404 	smlabb	r4, r5, r4, r6
 8003458:	5825      	ldr	r5, [r4, r0]
 800345a:	bf0c      	ite	eq
 800345c:	f045 5500 	orreq.w	r5, r5, #536870912	; 0x20000000
      }
      else
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8003460:	f045 5580 	orrne.w	r5, r5, #268435456	; 0x10000000
 8003464:	5025      	str	r5, [r4, r0]
      }
    } 
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8003466:	780d      	ldrb	r5, [r1, #0]
 8003468:	f44f 6410 	mov.w	r4, #2304	; 0x900
 800346c:	eb04 1445 	add.w	r4, r4, r5, lsl #5
 8003470:	5905      	ldr	r5, [r0, r4]
 8003472:	f045 4504 	orr.w	r5, r5, #2214592512	; 0x84000000
 8003476:	5105      	str	r5, [r0, r4]
    
    if (ep->type == EP_TYPE_ISOC)
 8003478:	78cc      	ldrb	r4, [r1, #3]
 800347a:	2c01      	cmp	r4, #1
 800347c:	d177      	bne.n	800356e <USB_EPStartXfer+0x22a>
    {
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 800347e:	780c      	ldrb	r4, [r1, #0]
 8003480:	9200      	str	r2, [sp, #0]
 8003482:	b29b      	uxth	r3, r3
 8003484:	4622      	mov	r2, r4
 8003486:	68c9      	ldr	r1, [r1, #12]
 8003488:	f000 f922 	bl	80036d0 <USB_WritePacket>
 800348c:	e06f      	b.n	800356e <USB_EPStartXfer+0x22a>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 800348e:	f44f 6630 	mov.w	r6, #2816	; 0xb00
 8003492:	fb15 6404 	smlabb	r4, r5, r4, r6
 8003496:	4404      	add	r4, r0
 8003498:	6927      	ldr	r7, [r4, #16]
 800349a:	0cff      	lsrs	r7, r7, #19
 800349c:	04ff      	lsls	r7, r7, #19
 800349e:	6127      	str	r7, [r4, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 80034a0:	780c      	ldrb	r4, [r1, #0]
 80034a2:	fb15 6404 	smlabb	r4, r5, r4, r6
 80034a6:	4404      	add	r4, r0
 80034a8:	6927      	ldr	r7, [r4, #16]
 80034aa:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 80034ae:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 80034b2:	6127      	str	r7, [r4, #16]
 80034b4:	780c      	ldrb	r4, [r1, #0]
 80034b6:	688f      	ldr	r7, [r1, #8]

    if (ep->xfer_len == 0U)
 80034b8:	b983      	cbnz	r3, 80034dc <USB_EPStartXfer+0x198>
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 80034ba:	fb15 6404 	smlabb	r4, r5, r4, r6
 80034be:	4404      	add	r4, r0
 80034c0:	f3c7 0712 	ubfx	r7, r7, #0, #19
 80034c4:	6923      	ldr	r3, [r4, #16]
 80034c6:	431f      	orrs	r7, r3
 80034c8:	6127      	str	r7, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 80034ca:	780b      	ldrb	r3, [r1, #0]
 80034cc:	fb15 6503 	smlabb	r5, r5, r3, r6
 80034d0:	4405      	add	r5, r0
 80034d2:	692b      	ldr	r3, [r5, #16]
 80034d4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80034d8:	612b      	str	r3, [r5, #16]
 80034da:	e01d      	b.n	8003518 <USB_EPStartXfer+0x1d4>
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 80034dc:	fb15 6404 	smlabb	r4, r5, r4, r6
 80034e0:	4404      	add	r4, r0
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 80034e2:	443b      	add	r3, r7
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 80034e4:	f8df c090 	ldr.w	ip, [pc, #144]	; 8003578 <USB_EPStartXfer+0x234>
 80034e8:	f8d4 e010 	ldr.w	lr, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 80034ec:	3b01      	subs	r3, #1
 80034ee:	fbb3 f3f7 	udiv	r3, r3, r7
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 80034f2:	ea4f 48c3 	mov.w	r8, r3, lsl #19
 80034f6:	ea08 0c0c 	and.w	ip, r8, ip
 80034fa:	ea4c 0e0e 	orr.w	lr, ip, lr
 80034fe:	f8c4 e010 	str.w	lr, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
 8003502:	780c      	ldrb	r4, [r1, #0]
 8003504:	fb15 6504 	smlabb	r5, r5, r4, r6
 8003508:	4405      	add	r5, r0
 800350a:	b29b      	uxth	r3, r3
 800350c:	692c      	ldr	r4, [r5, #16]
 800350e:	435f      	muls	r7, r3
 8003510:	f3c7 0712 	ubfx	r7, r7, #0, #19
 8003514:	4327      	orrs	r7, r4
 8003516:	612f      	str	r7, [r5, #16]
    }

    if (dma == 1U)
 8003518:	2a01      	cmp	r2, #1
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 800351a:	bf01      	itttt	eq
 800351c:	780b      	ldrbeq	r3, [r1, #0]
 800351e:	68ca      	ldreq	r2, [r1, #12]
 8003520:	eb00 1343 	addeq.w	r3, r0, r3, lsl #5
 8003524:	f8c3 2b14 	streq.w	r2, [r3, #2836]	; 0xb14
    }
    
    if (ep->type == EP_TYPE_ISOC)
 8003528:	78cb      	ldrb	r3, [r1, #3]
 800352a:	2b01      	cmp	r3, #1
 800352c:	d111      	bne.n	8003552 <USB_EPStartXfer+0x20e>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 800352e:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8003532:	f413 7f80 	tst.w	r3, #256	; 0x100
 8003536:	780b      	ldrb	r3, [r1, #0]
 8003538:	f04f 0220 	mov.w	r2, #32
 800353c:	f44f 6430 	mov.w	r4, #2816	; 0xb00
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 8003540:	fb12 4303 	smlabb	r3, r2, r3, r4
 8003544:	58c2      	ldr	r2, [r0, r3]
 8003546:	bf0c      	ite	eq
 8003548:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
      }
      else
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800354c:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
 8003550:	50c2      	str	r2, [r0, r3]
      }
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8003552:	780a      	ldrb	r2, [r1, #0]
 8003554:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8003558:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800355c:	58c2      	ldr	r2, [r0, r3]
 800355e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8003562:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
 8003564:	e003      	b.n	800356e <USB_EPStartXfer+0x22a>
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
      }       
    }

    if (dma == 1U)
 8003566:	2a01      	cmp	r2, #1
 8003568:	f47f af5f 	bne.w	800342a <USB_EPStartXfer+0xe6>
 800356c:	e753      	b.n	8003416 <USB_EPStartXfer+0xd2>
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
  }
  return HAL_OK;
}
 800356e:	2000      	movs	r0, #0
 8003570:	b002      	add	sp, #8
 8003572:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003576:	bf00      	nop
 8003578:	1ff80000 	.word	0x1ff80000

0800357c <USB_EP0StartXfer>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
  /* IN endpoint */
  if (ep->is_in == 1U)
 800357c:	784b      	ldrb	r3, [r1, #1]
 800357e:	2b01      	cmp	r3, #1
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8003580:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003582:	780b      	ldrb	r3, [r1, #0]
 8003584:	694d      	ldr	r5, [r1, #20]
 8003586:	f04f 0420 	mov.w	r4, #32
  /* IN endpoint */
  if (ep->is_in == 1U)
 800358a:	d163      	bne.n	8003654 <USB_EP0StartXfer+0xd8>
 800358c:	f44f 6610 	mov.w	r6, #2304	; 0x900
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003590:	fb14 6303 	smlabb	r3, r4, r3, r6
 8003594:	4403      	add	r3, r0
{
  /* IN endpoint */
  if (ep->is_in == 1U)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8003596:	bb05      	cbnz	r5, 80035da <USB_EP0StartXfer+0x5e>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003598:	691d      	ldr	r5, [r3, #16]
 800359a:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 800359e:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 80035a2:	611d      	str	r5, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 80035a4:	780b      	ldrb	r3, [r1, #0]
 80035a6:	fb14 6303 	smlabb	r3, r4, r3, r6
 80035aa:	4403      	add	r3, r0
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
    
    }
    
    if (dma == 1)
 80035ac:	2a01      	cmp	r2, #1
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 80035ae:	691d      	ldr	r5, [r3, #16]
 80035b0:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 80035b4:	611d      	str	r5, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 80035b6:	780b      	ldrb	r3, [r1, #0]
 80035b8:	fb14 6403 	smlabb	r4, r4, r3, r6
 80035bc:	4404      	add	r4, r0
 80035be:	6923      	ldr	r3, [r4, #16]
 80035c0:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 80035c4:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 80035c8:	6123      	str	r3, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
    
    }
    
    if (dma == 1)
 80035ca:	d139      	bne.n	8003640 <USB_EP0StartXfer+0xc4>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 80035cc:	780b      	ldrb	r3, [r1, #0]
 80035ce:	690a      	ldr	r2, [r1, #16]
 80035d0:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 80035d4:	f8c3 2914 	str.w	r2, [r3, #2324]	; 0x914
 80035d8:	e032      	b.n	8003640 <USB_EP0StartXfer+0xc4>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80035da:	691f      	ldr	r7, [r3, #16]
 80035dc:	0cff      	lsrs	r7, r7, #19
 80035de:	04ff      	lsls	r7, r7, #19
 80035e0:	611f      	str	r7, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 80035e2:	780b      	ldrb	r3, [r1, #0]
 80035e4:	fb14 6403 	smlabb	r4, r4, r3, r6
 80035e8:	4404      	add	r4, r0
 80035ea:	6923      	ldr	r3, [r4, #16]
 80035ec:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 80035f0:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 80035f4:	6123      	str	r3, [r4, #16]
      
      if(ep->xfer_len > ep->maxpacket)
 80035f6:	688b      	ldr	r3, [r1, #8]
 80035f8:	429d      	cmp	r5, r3
      {
        ep->xfer_len = ep->maxpacket;
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 80035fa:	780d      	ldrb	r5, [r1, #0]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
      
      if(ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
 80035fc:	bf88      	it	hi
 80035fe:	614b      	strhi	r3, [r1, #20]
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8003600:	2420      	movs	r4, #32
 8003602:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8003606:	fb14 3505 	smlabb	r5, r4, r5, r3
 800360a:	4405      	add	r5, r0
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
    
    }
    
    if (dma == 1)
 800360c:	2a01      	cmp	r2, #1
      
      if(ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 800360e:	692e      	ldr	r6, [r5, #16]
 8003610:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 8003614:	612e      	str	r6, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8003616:	780d      	ldrb	r5, [r1, #0]
 8003618:	fb14 3305 	smlabb	r3, r4, r5, r3
 800361c:	4403      	add	r3, r0
 800361e:	694d      	ldr	r5, [r1, #20]
 8003620:	691c      	ldr	r4, [r3, #16]
 8003622:	f3c5 0612 	ubfx	r6, r5, #0, #19
 8003626:	ea44 0406 	orr.w	r4, r4, r6
 800362a:	611c      	str	r4, [r3, #16]
    
    }
    
    if (dma == 1)
 800362c:	d0ce      	beq.n	80035cc <USB_EP0StartXfer+0x50>
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
    }
    else
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0U)
 800362e:	b13d      	cbz	r5, 8003640 <USB_EP0StartXfer+0xc4>
      {
        USBx_DEVICE->DIEPEMPMSK |= 1U << (ep->num);
 8003630:	780d      	ldrb	r5, [r1, #0]
 8003632:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8003636:	2301      	movs	r3, #1
 8003638:	40ab      	lsls	r3, r5
 800363a:	4313      	orrs	r3, r2
 800363c:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
      }
    }
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
 8003640:	780a      	ldrb	r2, [r1, #0]
 8003642:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8003646:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800364a:	58c2      	ldr	r2, [r0, r3]
 800364c:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8003650:	50c2      	str	r2, [r0, r3]
 8003652:	e03b      	b.n	80036cc <USB_EP0StartXfer+0x150>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8003654:	f44f 6730 	mov.w	r7, #2816	; 0xb00
 8003658:	fb14 7303 	smlabb	r3, r4, r3, r7
 800365c:	4403      	add	r3, r0
 800365e:	691e      	ldr	r6, [r3, #16]
 8003660:	0cf6      	lsrs	r6, r6, #19
 8003662:	04f6      	lsls	r6, r6, #19
 8003664:	611e      	str	r6, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8003666:	780b      	ldrb	r3, [r1, #0]
 8003668:	fb14 7303 	smlabb	r3, r4, r3, r7
 800366c:	4403      	add	r3, r0
 800366e:	691e      	ldr	r6, [r3, #16]
 8003670:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
 8003674:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
 8003678:	611e      	str	r6, [r3, #16]
 800367a:	688e      	ldr	r6, [r1, #8]
      
    if (ep->xfer_len > 0U)
 800367c:	b105      	cbz	r5, 8003680 <USB_EP0StartXfer+0x104>
    {
      ep->xfer_len = ep->maxpacket;
 800367e:	614e      	str	r6, [r1, #20]
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8003680:	780b      	ldrb	r3, [r1, #0]
 8003682:	f44f 6530 	mov.w	r5, #2816	; 0xb00
 8003686:	fb14 5303 	smlabb	r3, r4, r3, r5
 800368a:	4403      	add	r3, r0
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 800368c:	f3c6 0612 	ubfx	r6, r6, #0, #19
    if (ep->xfer_len > 0U)
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8003690:	691f      	ldr	r7, [r3, #16]
 8003692:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
 8003696:	611f      	str	r7, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 8003698:	780b      	ldrb	r3, [r1, #0]
 800369a:	fb14 5403 	smlabb	r4, r4, r3, r5
 800369e:	4404      	add	r4, r0
    

    if (dma == 1U)
 80036a0:	2a01      	cmp	r2, #1
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 80036a2:	6923      	ldr	r3, [r4, #16]
 80036a4:	ea46 0603 	orr.w	r6, r6, r3
 80036a8:	6126      	str	r6, [r4, #16]
    

    if (dma == 1U)
 80036aa:	d106      	bne.n	80036ba <USB_EP0StartXfer+0x13e>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 80036ac:	780b      	ldrb	r3, [r1, #0]
 80036ae:	2220      	movs	r2, #32
 80036b0:	fb12 5303 	smlabb	r3, r2, r3, r5
 80036b4:	4403      	add	r3, r0
 80036b6:	68ca      	ldr	r2, [r1, #12]
 80036b8:	615a      	str	r2, [r3, #20]
    }
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 80036ba:	780a      	ldrb	r2, [r1, #0]
 80036bc:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 80036c0:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80036c4:	58c2      	ldr	r2, [r0, r3]
 80036c6:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80036ca:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 80036cc:	2000      	movs	r0, #0
 80036ce:	bdf0      	pop	{r4, r5, r6, r7, pc}

080036d0 <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 80036d0:	b510      	push	{r4, lr}
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
 80036d2:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80036d6:	b96c      	cbnz	r4, 80036f4 <USB_WritePacket+0x24>
 80036d8:	3303      	adds	r3, #3
  {
    count32b =  (len + 3U) / 4U;
    for (i = 0U; i < count32b; i++, src += 4U)
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 80036da:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 80036de:	f023 0303 	bic.w	r3, r3, #3
 80036e2:	eb00 3202 	add.w	r2, r0, r2, lsl #12
 80036e6:	440b      	add	r3, r1
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
  {
    count32b =  (len + 3U) / 4U;
    for (i = 0U; i < count32b; i++, src += 4U)
 80036e8:	4299      	cmp	r1, r3
 80036ea:	d003      	beq.n	80036f4 <USB_WritePacket+0x24>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 80036ec:	f851 0b04 	ldr.w	r0, [r1], #4
 80036f0:	6010      	str	r0, [r2, #0]
 80036f2:	e7f9      	b.n	80036e8 <USB_WritePacket+0x18>
    }
  }
  return HAL_OK;
}
 80036f4:	2000      	movs	r0, #0
 80036f6:	bd10      	pop	{r4, pc}

080036f8 <USB_ReadPacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 80036f8:	3203      	adds	r2, #3
 80036fa:	f022 0203 	bic.w	r2, r2, #3
 80036fe:	440a      	add	r2, r1
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 8003700:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
 8003704:	4291      	cmp	r1, r2
 8003706:	d003      	beq.n	8003710 <USB_ReadPacket+0x18>
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 8003708:	6803      	ldr	r3, [r0, #0]
 800370a:	f841 3b04 	str.w	r3, [r1], #4
 800370e:	e7f9      	b.n	8003704 <USB_ReadPacket+0xc>
    
  }
  return ((void *)dest);
}
 8003710:	4608      	mov	r0, r1
 8003712:	4770      	bx	lr

08003714 <USB_EPSetStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8003714:	784b      	ldrb	r3, [r1, #1]
 8003716:	2b01      	cmp	r3, #1
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
 8003718:	b510      	push	{r4, lr}
 800371a:	f04f 0220 	mov.w	r2, #32
 800371e:	780c      	ldrb	r4, [r1, #0]
  if (ep->is_in == 1U)
 8003720:	d114      	bne.n	800374c <USB_EPSetStall+0x38>
  {
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0U)
 8003722:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8003726:	fb12 3304 	smlabb	r3, r2, r4, r3
 800372a:	58c2      	ldr	r2, [r0, r3]
 800372c:	2a00      	cmp	r2, #0
    {
      USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
 800372e:	bfa2      	ittt	ge
 8003730:	58c2      	ldrge	r2, [r0, r3]
 8003732:	f022 4280 	bicge.w	r2, r2, #1073741824	; 0x40000000
 8003736:	50c2      	strge	r2, [r0, r3]
    } 
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8003738:	780a      	ldrb	r2, [r1, #0]
 800373a:	f44f 6310 	mov.w	r3, #2304	; 0x900
 800373e:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8003742:	58c2      	ldr	r2, [r0, r3]
 8003744:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8003748:	50c2      	str	r2, [r0, r3]
 800374a:	e013      	b.n	8003774 <USB_EPSetStall+0x60>
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0U)
 800374c:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8003750:	fb12 3304 	smlabb	r3, r2, r4, r3
 8003754:	58c2      	ldr	r2, [r0, r3]
 8003756:	2a00      	cmp	r2, #0
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 8003758:	bfa2      	ittt	ge
 800375a:	58c2      	ldrge	r2, [r0, r3]
 800375c:	f022 4280 	bicge.w	r2, r2, #1073741824	; 0x40000000
 8003760:	50c2      	strge	r2, [r0, r3]
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8003762:	780a      	ldrb	r2, [r1, #0]
 8003764:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8003768:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800376c:	58c2      	ldr	r2, [r0, r3]
 800376e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8003772:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 8003774:	2000      	movs	r0, #0
 8003776:	bd10      	pop	{r4, pc}

08003778 <USB_EPClearStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8003778:	784b      	ldrb	r3, [r1, #1]
 800377a:	2b01      	cmp	r3, #1
 800377c:	780b      	ldrb	r3, [r1, #0]
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800377e:	b530      	push	{r4, r5, lr}
 8003780:	f04f 0220 	mov.w	r2, #32
  if (ep->is_in == 1U)
  {
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8003784:	bf0c      	ite	eq
 8003786:	f44f 6510 	moveq.w	r5, #2304	; 0x900
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800378a:	f44f 6530 	movne.w	r5, #2816	; 0xb00
 800378e:	fb12 5303 	smlabb	r3, r2, r3, r5
 8003792:	581c      	ldr	r4, [r3, r0]
 8003794:	f424 1400 	bic.w	r4, r4, #2097152	; 0x200000
 8003798:	501c      	str	r4, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 800379a:	78cb      	ldrb	r3, [r1, #3]
 800379c:	3b02      	subs	r3, #2
 800379e:	2b01      	cmp	r3, #1
 80037a0:	d806      	bhi.n	80037b0 <USB_EPClearStall+0x38>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80037a2:	780b      	ldrb	r3, [r1, #0]
 80037a4:	fb12 5203 	smlabb	r2, r2, r3, r5
 80037a8:	5813      	ldr	r3, [r2, r0]
 80037aa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80037ae:	5013      	str	r3, [r2, r0]
    }    
  }
  return HAL_OK;
}
 80037b0:	2000      	movs	r0, #0
 80037b2:	bd30      	pop	{r4, r5, pc}

080037b4 <USB_StopDevice>:
  * @brief  USB_StopDevice : Stop the usb device mode
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
{
 80037b4:	b538      	push	{r3, r4, r5, lr}
 80037b6:	f500 612e 	add.w	r1, r0, #2784	; 0xae0
 80037ba:	4604      	mov	r4, r0
 80037bc:	f500 6310 	add.w	r3, r0, #2304	; 0x900
  uint32_t i;
  
  /* Clear Pending interrupt */
  for (i = 0U; i < 15U ; i++)
  {
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 80037c0:	22ff      	movs	r2, #255	; 0xff
 80037c2:	609a      	str	r2, [r3, #8]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 80037c4:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
 80037c8:	3320      	adds	r3, #32
HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t i;
  
  /* Clear Pending interrupt */
  for (i = 0U; i < 15U ; i++)
 80037ca:	428b      	cmp	r3, r1
 80037cc:	d1f9      	bne.n	80037c2 <USB_StopDevice+0xe>
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  
  /* Clear interrupt masks */
  USBx_DEVICE->DIEPMSK  = 0U;
 80037ce:	2500      	movs	r5, #0
  for (i = 0U; i < 15U ; i++)
  {
    USBx_INEP(i)->DIEPINT  = 0xFFU;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 80037d0:	f04f 32ff 	mov.w	r2, #4294967295
 80037d4:	f8c4 2818 	str.w	r2, [r4, #2072]	; 0x818
  USBx_DEVICE->DIEPMSK  = 0U;
  USBx_DEVICE->DOEPMSK  = 0U;
  USBx_DEVICE->DAINTMSK = 0U;
  
  /* Flush the FIFO */
  USB_FlushRxFifo(USBx);
 80037d8:	4620      	mov	r0, r4
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  
  /* Clear interrupt masks */
  USBx_DEVICE->DIEPMSK  = 0U;
 80037da:	f8c4 5810 	str.w	r5, [r4, #2064]	; 0x810
  USBx_DEVICE->DOEPMSK  = 0U;
 80037de:	f8c4 5814 	str.w	r5, [r4, #2068]	; 0x814
  USBx_DEVICE->DAINTMSK = 0U;
 80037e2:	f8c4 581c 	str.w	r5, [r4, #2076]	; 0x81c
  
  /* Flush the FIFO */
  USB_FlushRxFifo(USBx);
 80037e6:	f7ff fd03 	bl	80031f0 <USB_FlushRxFifo>
  USB_FlushTxFifo(USBx ,  0x10U);  
 80037ea:	2110      	movs	r1, #16
 80037ec:	4620      	mov	r0, r4
 80037ee:	f7ff fced 	bl	80031cc <USB_FlushTxFifo>
  
  return HAL_OK;
}
 80037f2:	4628      	mov	r0, r5
 80037f4:	bd38      	pop	{r3, r4, r5, pc}

080037f6 <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 80037f6:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80037fa:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80037fe:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= (address << 4U) & USB_OTG_DCFG_DAD ;
 8003802:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8003806:	0109      	lsls	r1, r1, #4
 8003808:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 800380c:	430b      	orrs	r3, r1
 800380e:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  
  return HAL_OK;  
}
 8003812:	2000      	movs	r0, #0
 8003814:	4770      	bx	lr

08003816 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 8003816:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
 8003818:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 800381c:	f023 0302 	bic.w	r3, r3, #2
 8003820:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 8003824:	2003      	movs	r0, #3
 8003826:	f7fd f99f 	bl	8000b68 <HAL_Delay>
  
  return HAL_OK;  
}
 800382a:	2000      	movs	r0, #0
 800382c:	bd08      	pop	{r3, pc}

0800382e <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 800382e:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 8003830:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8003834:	f043 0302 	orr.w	r3, r3, #2
 8003838:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 800383c:	2003      	movs	r0, #3
 800383e:	f7fd f993 	bl	8000b68 <HAL_Delay>
  
  return HAL_OK;  
}
 8003842:	2000      	movs	r0, #0
 8003844:	bd08      	pop	{r3, pc}

08003846 <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v = 0U;
  
  v = USBx->GINTSTS;
 8003846:	6942      	ldr	r2, [r0, #20]
  v &= USBx->GINTMSK;
 8003848:	6980      	ldr	r0, [r0, #24]
  return v;  
}
 800384a:	4010      	ands	r0, r2
 800384c:	4770      	bx	lr

0800384e <USB_ReadDevAllOutEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 800384e:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8003852:	f8d0 0818 	ldr.w	r0, [r0, #2072]	; 0x818
  v &= USBx_DEVICE->DAINTMSK;
 8003856:	69db      	ldr	r3, [r3, #28]
  return ((v & 0xffff0000U) >> 16U);
 8003858:	4018      	ands	r0, r3
}
 800385a:	0c00      	lsrs	r0, r0, #16
 800385c:	4770      	bx	lr

0800385e <USB_ReadDevAllInEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 800385e:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8003862:	f8d0 0818 	ldr.w	r0, [r0, #2072]	; 0x818
  v &= USBx_DEVICE->DAINTMSK;
 8003866:	69db      	ldr	r3, [r3, #28]
  return ((v & 0xFFFFU));
 8003868:	4018      	ands	r0, r3
}
 800386a:	b280      	uxth	r0, r0
 800386c:	4770      	bx	lr

0800386e <USB_ReadDevOutEPInterrupt>:
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 800386e:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 8003872:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  v &= USBx_DEVICE->DOEPMSK;
 8003876:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 800387a:	688a      	ldr	r2, [r1, #8]
  v &= USBx_DEVICE->DOEPMSK;
 800387c:	6940      	ldr	r0, [r0, #20]
  return v;
}
 800387e:	4010      	ands	r0, r2
 8003880:	4770      	bx	lr

08003882 <USB_ReadDevInEPInterrupt>:
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 8003882:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 8003886:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 800388a:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 800388e:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  return v;
 8003892:	fa23 f101 	lsr.w	r1, r3, r1
 8003896:	01c9      	lsls	r1, r1, #7
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
  emp = USBx_DEVICE->DIEPEMPMSK;
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 8003898:	6880      	ldr	r0, [r0, #8]
  return v;
 800389a:	b2c9      	uxtb	r1, r1
 800389c:	4311      	orrs	r1, r2
}
 800389e:	4008      	ands	r0, r1
 80038a0:	4770      	bx	lr

080038a2 <USB_GetMode>:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS ) & 0x1U);
 80038a2:	6940      	ldr	r0, [r0, #20]
}
 80038a4:	f000 0001 	and.w	r0, r0, #1
 80038a8:	4770      	bx	lr

080038aa <USB_ActivateSetup>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 80038aa:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 80038ae:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 80038b2:	f023 0307 	bic.w	r3, r3, #7
 80038b6:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 80038ba:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 80038be:	689a      	ldr	r2, [r3, #8]
 80038c0:	f002 0206 	and.w	r2, r2, #6
 80038c4:	2a04      	cmp	r2, #4
  {
    USBx_INEP(0U)->DIEPCTL |= 3U;
 80038c6:	bf02      	ittt	eq
 80038c8:	f8d0 2900 	ldreq.w	r2, [r0, #2304]	; 0x900
 80038cc:	f042 0203 	orreq.w	r2, r2, #3
 80038d0:	f8c0 2900 	streq.w	r2, [r0, #2304]	; 0x900
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 80038d4:	685a      	ldr	r2, [r3, #4]
 80038d6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80038da:	605a      	str	r2, [r3, #4]

  return HAL_OK;
}
 80038dc:	2000      	movs	r0, #0
 80038de:	4770      	bx	lr

080038e0 <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup : pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 80038e0:	b510      	push	{r4, lr}
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 80038e2:	2400      	movs	r4, #0
 80038e4:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
 80038e8:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80038ec:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80038f0:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 80038f4:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80038f8:	f044 0418 	orr.w	r4, r4, #24
 80038fc:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 8003900:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
 8003904:	2901      	cmp	r1, #1
  * @param  psetup : pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8003906:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 800390a:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
  
  if (dma == 1U)
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 800390e:	bf08      	it	eq
 8003910:	f04f 2380 	moveq.w	r3, #2147516416	; 0x80008000
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 8003914:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8003918:	bf04      	itt	eq
 800391a:	f8c0 2b14 	streq.w	r2, [r0, #2836]	; 0xb14
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 800391e:	f8c0 3b00 	streq.w	r3, [r0, #2816]	; 0xb00
  }
  
  return HAL_OK;  
}
 8003922:	2000      	movs	r0, #0
 8003924:	bd10      	pop	{r4, pc}
	...

08003928 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx : Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8003928:	4b0a      	ldr	r3, [pc, #40]	; (8003954 <USB_CoreReset+0x2c>)
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 800392a:	3b01      	subs	r3, #1
 800392c:	d101      	bne.n	8003932 <USB_CoreReset+0xa>
    {
      return HAL_TIMEOUT;
 800392e:	2003      	movs	r0, #3
 8003930:	4770      	bx	lr
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8003932:	6902      	ldr	r2, [r0, #16]
 8003934:	2a00      	cmp	r2, #0
 8003936:	daf8      	bge.n	800392a <USB_CoreReset+0x2>
  
  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8003938:	6903      	ldr	r3, [r0, #16]
 800393a:	4a06      	ldr	r2, [pc, #24]	; (8003954 <USB_CoreReset+0x2c>)
 800393c:	f043 0301 	orr.w	r3, r3, #1
 8003940:	6103      	str	r3, [r0, #16]

  do
  {
    if (++count > 200000U)
 8003942:	3a01      	subs	r2, #1
 8003944:	d0f3      	beq.n	800392e <USB_CoreReset+0x6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8003946:	6903      	ldr	r3, [r0, #16]
 8003948:	f013 0301 	ands.w	r3, r3, #1
 800394c:	d1f9      	bne.n	8003942 <USB_CoreReset+0x1a>
  
  return HAL_OK;
 800394e:	4618      	mov	r0, r3
}
 8003950:	4770      	bx	lr
 8003952:	bf00      	nop
 8003954:	00030d41 	.word	0x00030d41

08003958 <disk_status>:
	BYTE pdrv		/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat;
  
  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 8003958:	4b03      	ldr	r3, [pc, #12]	; (8003968 <disk_status+0x10>)
 800395a:	181a      	adds	r2, r3, r0
 800395c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8003960:	7a10      	ldrb	r0, [r2, #8]
 8003962:	685b      	ldr	r3, [r3, #4]
 8003964:	685b      	ldr	r3, [r3, #4]
 8003966:	4718      	bx	r3
 8003968:	2000018c 	.word	0x2000018c

0800396c <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;
  
  if(disk.is_initialized[pdrv] == 0)
 800396c:	4b06      	ldr	r3, [pc, #24]	; (8003988 <disk_initialize+0x1c>)
 800396e:	5c1a      	ldrb	r2, [r3, r0]
 8003970:	b942      	cbnz	r2, 8003984 <disk_initialize+0x18>
  { 
    disk.is_initialized[pdrv] = 1;
 8003972:	2201      	movs	r2, #1
 8003974:	541a      	strb	r2, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8003976:	181a      	adds	r2, r3, r0
 8003978:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800397c:	7a10      	ldrb	r0, [r2, #8]
 800397e:	685b      	ldr	r3, [r3, #4]
 8003980:	681b      	ldr	r3, [r3, #0]
 8003982:	4718      	bx	r3
  }
  return stat;
}
 8003984:	2000      	movs	r0, #0
 8003986:	4770      	bx	lr
 8003988:	2000018c 	.word	0x2000018c

0800398c <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 800398c:	b430      	push	{r4, r5}
  DRESULT res;
 
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800398e:	4c05      	ldr	r4, [pc, #20]	; (80039a4 <disk_read+0x18>)
 8003990:	1825      	adds	r5, r4, r0
 8003992:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 8003996:	6860      	ldr	r0, [r4, #4]
 8003998:	6884      	ldr	r4, [r0, #8]
 800399a:	7a28      	ldrb	r0, [r5, #8]
 800399c:	46a4      	mov	ip, r4
  return res;
}
 800399e:	bc30      	pop	{r4, r5}
	UINT count		/* Number of sectors to read */
)
{
  DRESULT res;
 
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 80039a0:	4760      	bx	ip
 80039a2:	bf00      	nop
 80039a4:	2000018c 	.word	0x2000018c

080039a8 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 80039a8:	b430      	push	{r4, r5}
  DRESULT res;
  
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 80039aa:	4c05      	ldr	r4, [pc, #20]	; (80039c0 <disk_write+0x18>)
 80039ac:	1825      	adds	r5, r4, r0
 80039ae:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 80039b2:	6860      	ldr	r0, [r4, #4]
 80039b4:	68c4      	ldr	r4, [r0, #12]
 80039b6:	7a28      	ldrb	r0, [r5, #8]
 80039b8:	46a4      	mov	ip, r4
  return res;
}
 80039ba:	bc30      	pop	{r4, r5}
	UINT count        	/* Number of sectors to write */
)
{
  DRESULT res;
  
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 80039bc:	4760      	bx	ip
 80039be:	bf00      	nop
 80039c0:	2000018c 	.word	0x2000018c

080039c4 <disk_ioctl>:
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 80039c4:	4b05      	ldr	r3, [pc, #20]	; (80039dc <disk_ioctl+0x18>)
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 80039c6:	b410      	push	{r4}
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 80039c8:	181c      	adds	r4, r3, r0
 80039ca:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80039ce:	7a20      	ldrb	r0, [r4, #8]
 80039d0:	685b      	ldr	r3, [r3, #4]
  return res;
}
 80039d2:	f85d 4b04 	ldr.w	r4, [sp], #4
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 80039d6:	691b      	ldr	r3, [r3, #16]
 80039d8:	4718      	bx	r3
 80039da:	bf00      	nop
 80039dc:	2000018c 	.word	0x2000018c

080039e0 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
 80039e0:	3801      	subs	r0, #1
 80039e2:	440a      	add	r2, r1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 80039e4:	4291      	cmp	r1, r2
 80039e6:	d004      	beq.n	80039f2 <mem_cpy+0x12>
		*d++ = *s++;
 80039e8:	f811 3b01 	ldrb.w	r3, [r1], #1
 80039ec:	f800 3f01 	strb.w	r3, [r0, #1]!
 80039f0:	e7f8      	b.n	80039e4 <mem_cpy+0x4>
}
 80039f2:	4770      	bx	lr

080039f4 <mem_set>:

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
 80039f4:	4402      	add	r2, r0
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80039f6:	4290      	cmp	r0, r2
 80039f8:	d002      	beq.n	8003a00 <mem_set+0xc>
		*d++ = (BYTE)val;
 80039fa:	f800 1b01 	strb.w	r1, [r0], #1
 80039fe:	e7fa      	b.n	80039f6 <mem_set+0x2>
}
 8003a00:	4770      	bx	lr

08003a02 <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8003a02:	f8d0 3224 	ldr.w	r3, [r0, #548]	; 0x224
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
 8003a06:	f8d0 2200 	ldr.w	r2, [r0, #512]	; 0x200
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8003a0a:	3304      	adds	r3, #4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
 8003a0c:	0a49      	lsrs	r1, r1, #9
 8003a0e:	f892 0202 	ldrb.w	r0, [r2, #514]	; 0x202
 8003a12:	fbb1 f1f0 	udiv	r1, r1, r0
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8003a16:	6818      	ldr	r0, [r3, #0]
		if (!ncl) return 0;		/* End of table? (error) */
 8003a18:	b130      	cbz	r0, 8003a28 <clmt_clust+0x26>
		if (cl < ncl) break;	/* In this fragment? */
 8003a1a:	4281      	cmp	r1, r0
 8003a1c:	d302      	bcc.n	8003a24 <clmt_clust+0x22>
		cl -= ncl; tbl++;		/* Next fragment */
 8003a1e:	1a09      	subs	r1, r1, r0
 8003a20:	3308      	adds	r3, #8
	}
 8003a22:	e7f8      	b.n	8003a16 <clmt_clust+0x14>
	return cl + *tbl;	/* Return the cluster number */
 8003a24:	685b      	ldr	r3, [r3, #4]
 8003a26:	18c8      	adds	r0, r1, r3
}
 8003a28:	4770      	bx	lr

08003a2a <sum_sfn>:
#if _USE_LFN
static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 8003a2a:	f100 010b 	add.w	r1, r0, #11
	BYTE sum = 0;
 8003a2e:	2300      	movs	r3, #0
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 8003a30:	01da      	lsls	r2, r3, #7
 8003a32:	ea42 0353 	orr.w	r3, r2, r3, lsr #1
 8003a36:	f810 2b01 	ldrb.w	r2, [r0], #1
 8003a3a:	fa52 f383 	uxtab	r3, r2, r3
 8003a3e:	4288      	cmp	r0, r1
 8003a40:	b2db      	uxtb	r3, r3
 8003a42:	d1f5      	bne.n	8003a30 <sum_sfn+0x6>
	return sum;
}
 8003a44:	4618      	mov	r0, r3
 8003a46:	4770      	bx	lr

08003a48 <get_ldnumber>:
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 8003a48:	6802      	ldr	r2, [r0, #0]

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 8003a4a:	b510      	push	{r4, lr}
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 8003a4c:	b18a      	cbz	r2, 8003a72 <get_ldnumber+0x2a>
 8003a4e:	4611      	mov	r1, r2
 8003a50:	460b      	mov	r3, r1
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8003a52:	f811 4b01 	ldrb.w	r4, [r1], #1
 8003a56:	2c1f      	cmp	r4, #31
 8003a58:	d909      	bls.n	8003a6e <get_ldnumber+0x26>
 8003a5a:	2c3a      	cmp	r4, #58	; 0x3a
 8003a5c:	d1f8      	bne.n	8003a50 <get_ldnumber+0x8>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8003a5e:	1c51      	adds	r1, r2, #1
 8003a60:	428b      	cmp	r3, r1
 8003a62:	d106      	bne.n	8003a72 <get_ldnumber+0x2a>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 8003a64:	7812      	ldrb	r2, [r2, #0]
 8003a66:	2a30      	cmp	r2, #48	; 0x30
 8003a68:	d103      	bne.n	8003a72 <get_ldnumber+0x2a>
					vol = (int)i;
					*path = ++tt;
 8003a6a:	3301      	adds	r3, #1
 8003a6c:	6003      	str	r3, [r0, #0]
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 8003a6e:	2000      	movs	r0, #0
 8003a70:	bd10      	pop	{r4, pc}
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 8003a72:	f04f 30ff 	mov.w	r0, #4294967295
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8003a76:	bd10      	pop	{r4, pc}

08003a78 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
 8003a78:	b508      	push	{r3, lr}
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
 8003a7a:	b190      	cbz	r0, 8003aa2 <validate+0x2a>
 8003a7c:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 8003a80:	b17b      	cbz	r3, 8003aa2 <validate+0x2a>
 8003a82:	f893 2200 	ldrb.w	r2, [r3, #512]	; 0x200
 8003a86:	b162      	cbz	r2, 8003aa2 <validate+0x2a>
 8003a88:	f8b3 1206 	ldrh.w	r1, [r3, #518]	; 0x206
 8003a8c:	f8b0 2204 	ldrh.w	r2, [r0, #516]	; 0x204
 8003a90:	4291      	cmp	r1, r2
 8003a92:	d106      	bne.n	8003aa2 <validate+0x2a>
 8003a94:	f893 0201 	ldrb.w	r0, [r3, #513]	; 0x201
 8003a98:	f7ff ff5e 	bl	8003958 <disk_status>
 8003a9c:	f010 0001 	ands.w	r0, r0, #1
 8003aa0:	d000      	beq.n	8003aa4 <validate+0x2c>
		return FR_INVALID_OBJECT;
 8003aa2:	2009      	movs	r0, #9

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
 8003aa4:	bd08      	pop	{r3, pc}

08003aa6 <ld_clust.isra.0>:
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
 8003aa6:	7eca      	ldrb	r2, [r1, #27]
 8003aa8:	7e8b      	ldrb	r3, [r1, #26]
	if (fs->fs_type == FS_FAT32)
 8003aaa:	2803      	cmp	r0, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
 8003aac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (fs->fs_type == FS_FAT32)
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
 8003ab0:	bf01      	itttt	eq
 8003ab2:	7d48      	ldrbeq	r0, [r1, #21]
 8003ab4:	7d0a      	ldrbeq	r2, [r1, #20]
 8003ab6:	ea42 2200 	orreq.w	r2, r2, r0, lsl #8
 8003aba:	ea43 4302 	orreq.w	r3, r3, r2, lsl #16

	return cl;
}
 8003abe:	4618      	mov	r0, r3
 8003ac0:	4770      	bx	lr

08003ac2 <sync_window.part.1>:
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 8003ac2:	b570      	push	{r4, r5, r6, lr}
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
 8003ac4:	f8d0 5230 	ldr.w	r5, [r0, #560]	; 0x230
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 8003ac8:	4604      	mov	r4, r0
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
 8003aca:	4601      	mov	r1, r0
 8003acc:	2301      	movs	r3, #1
 8003ace:	462a      	mov	r2, r5
 8003ad0:	f890 0201 	ldrb.w	r0, [r0, #513]	; 0x201
 8003ad4:	f7ff ff68 	bl	80039a8 <disk_write>
 8003ad8:	b9d0      	cbnz	r0, 8003b10 <sync_window.part.1+0x4e>
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003ada:	f8d4 3224 	ldr.w	r3, [r4, #548]	; 0x224
 8003ade:	f8d4 221c 	ldr.w	r2, [r4, #540]	; 0x21c
	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
 8003ae2:	f884 0204 	strb.w	r0, [r4, #516]	; 0x204
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003ae6:	1aeb      	subs	r3, r5, r3
 8003ae8:	4293      	cmp	r3, r2
 8003aea:	d301      	bcc.n	8003af0 <sync_window.part.1+0x2e>
	FATFS* fs		/* File system object */
)
{
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
 8003aec:	2000      	movs	r0, #0
 8003aee:	bd70      	pop	{r4, r5, r6, pc}
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003af0:	f894 6203 	ldrb.w	r6, [r4, #515]	; 0x203
 8003af4:	2e01      	cmp	r6, #1
 8003af6:	d9f9      	bls.n	8003aec <sync_window.part.1+0x2a>
					wsect += fs->fsize;
 8003af8:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
					disk_write(fs->drv, fs->win.d8, wsect, 1);
 8003afc:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
 8003b00:	441d      	add	r5, r3
					disk_write(fs->drv, fs->win.d8, wsect, 1);
 8003b02:	462a      	mov	r2, r5
 8003b04:	2301      	movs	r3, #1
 8003b06:	4621      	mov	r1, r4
 8003b08:	f7ff ff4e 	bl	80039a8 <disk_write>
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003b0c:	3e01      	subs	r6, #1
 8003b0e:	e7f1      	b.n	8003af4 <sync_window.part.1+0x32>


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
 8003b10:	2001      	movs	r0, #1
				}
			}
		}
	}
	return res;
}
 8003b12:	bd70      	pop	{r4, r5, r6, pc}

08003b14 <sync_window>:
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003b14:	f890 3204 	ldrb.w	r3, [r0, #516]	; 0x204
 8003b18:	b10b      	cbz	r3, 8003b1e <sync_window+0xa>
 8003b1a:	f7ff bfd2 	b.w	8003ac2 <sync_window.part.1>
				}
			}
		}
	}
	return res;
}
 8003b1e:	4618      	mov	r0, r3
 8003b20:	4770      	bx	lr

08003b22 <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS* fs		/* File system object */
)
{
 8003b22:	b538      	push	{r3, r4, r5, lr}
 8003b24:	4604      	mov	r4, r0
	FRESULT res;


	res = sync_window(fs);
 8003b26:	f7ff fff5 	bl	8003b14 <sync_window>
 8003b2a:	4605      	mov	r5, r0
	if (res == FR_OK) {
 8003b2c:	2800      	cmp	r0, #0
 8003b2e:	d152      	bne.n	8003bd6 <sync_fs+0xb4>
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 8003b30:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8003b34:	2b03      	cmp	r3, #3
 8003b36:	d145      	bne.n	8003bc4 <sync_fs+0xa2>
 8003b38:	f894 3205 	ldrb.w	r3, [r4, #517]	; 0x205
 8003b3c:	2b01      	cmp	r3, #1
 8003b3e:	d141      	bne.n	8003bc4 <sync_fs+0xa2>
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
 8003b40:	4601      	mov	r1, r0
 8003b42:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003b46:	4620      	mov	r0, r4
 8003b48:	f7ff ff54 	bl	80039f4 <mem_set>
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
 8003b4c:	2255      	movs	r2, #85	; 0x55
 8003b4e:	f884 21fe 	strb.w	r2, [r4, #510]	; 0x1fe
 8003b52:	22aa      	movs	r2, #170	; 0xaa
 8003b54:	f884 21ff 	strb.w	r2, [r4, #511]	; 0x1ff
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
 8003b58:	2252      	movs	r2, #82	; 0x52
 8003b5a:	7022      	strb	r2, [r4, #0]
 8003b5c:	7062      	strb	r2, [r4, #1]
 8003b5e:	2261      	movs	r2, #97	; 0x61
 8003b60:	70a2      	strb	r2, [r4, #2]
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
 8003b62:	f884 21e7 	strb.w	r2, [r4, #487]	; 0x1e7
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
 8003b66:	f8d4 2210 	ldr.w	r2, [r4, #528]	; 0x210
 8003b6a:	f884 21e8 	strb.w	r2, [r4, #488]	; 0x1e8
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
 8003b6e:	2141      	movs	r1, #65	; 0x41
 8003b70:	70e1      	strb	r1, [r4, #3]
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
 8003b72:	f884 11e6 	strb.w	r1, [r4, #486]	; 0x1e6
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
 8003b76:	1211      	asrs	r1, r2, #8
 8003b78:	f884 11e9 	strb.w	r1, [r4, #489]	; 0x1e9
 8003b7c:	0c11      	lsrs	r1, r2, #16
 8003b7e:	0e12      	lsrs	r2, r2, #24
 8003b80:	f884 21eb 	strb.w	r2, [r4, #491]	; 0x1eb
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
 8003b84:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
 8003b88:	f884 11ea 	strb.w	r1, [r4, #490]	; 0x1ea
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
 8003b8c:	1211      	asrs	r1, r2, #8
 8003b8e:	f884 21ec 	strb.w	r2, [r4, #492]	; 0x1ec
 8003b92:	f884 11ed 	strb.w	r1, [r4, #493]	; 0x1ed
 8003b96:	0c11      	lsrs	r1, r2, #16
 8003b98:	0e12      	lsrs	r2, r2, #24
 8003b9a:	f884 21ef 	strb.w	r2, [r4, #495]	; 0x1ef
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 8003b9e:	f8d4 2220 	ldr.w	r2, [r4, #544]	; 0x220
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
 8003ba2:	f884 11ee 	strb.w	r1, [r4, #494]	; 0x1ee
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
 8003ba6:	2072      	movs	r0, #114	; 0x72
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 8003ba8:	3201      	adds	r2, #1
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
 8003baa:	f884 01e4 	strb.w	r0, [r4, #484]	; 0x1e4
 8003bae:	f884 01e5 	strb.w	r0, [r4, #485]	; 0x1e5
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 8003bb2:	f8c4 2230 	str.w	r2, [r4, #560]	; 0x230
			disk_write(fs->drv, fs->win.d8, fs->winsect, 1);
 8003bb6:	4621      	mov	r1, r4
 8003bb8:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
 8003bbc:	f7ff fef4 	bl	80039a8 <disk_write>
			fs->fsi_flag = 0;
 8003bc0:	f884 5205 	strb.w	r5, [r4, #517]	; 0x205
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 8003bc4:	2200      	movs	r2, #0
 8003bc6:	4611      	mov	r1, r2
 8003bc8:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
 8003bcc:	f7ff fefa 	bl	80039c4 <disk_ioctl>
 8003bd0:	3000      	adds	r0, #0
 8003bd2:	bf18      	it	ne
 8003bd4:	2001      	movne	r0, #1
			res = FR_DISK_ERR;
	}

	return res;
}
 8003bd6:	bd38      	pop	{r3, r4, r5, pc}

08003bd8 <move_window>:
)
{
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
 8003bd8:	f8d0 3230 	ldr.w	r3, [r0, #560]	; 0x230
 8003bdc:	428b      	cmp	r3, r1
static
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[].d8 */
)
{
 8003bde:	b570      	push	{r4, r5, r6, lr}
 8003be0:	4606      	mov	r6, r0
 8003be2:	460d      	mov	r5, r1
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
 8003be4:	d012      	beq.n	8003c0c <move_window+0x34>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
 8003be6:	f7ff ff95 	bl	8003b14 <sync_window>
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
 8003bea:	4604      	mov	r4, r0
 8003bec:	b978      	cbnz	r0, 8003c0e <move_window+0x36>
			if (disk_read(fs->drv, fs->win.d8, sector, 1) != RES_OK) {
 8003bee:	462a      	mov	r2, r5
 8003bf0:	2301      	movs	r3, #1
 8003bf2:	4631      	mov	r1, r6
 8003bf4:	f896 0201 	ldrb.w	r0, [r6, #513]	; 0x201
 8003bf8:	f7ff fec8 	bl	800398c <disk_read>
 8003bfc:	2800      	cmp	r0, #0
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
 8003bfe:	bf1c      	itt	ne
 8003c00:	f04f 35ff 	movne.w	r5, #4294967295
 8003c04:	2401      	movne	r4, #1
			}
			fs->winsect = sector;
 8003c06:	f8c6 5230 	str.w	r5, [r6, #560]	; 0x230
 8003c0a:	e000      	b.n	8003c0e <move_window+0x36>
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[].d8 */
)
{
	FRESULT res = FR_OK;
 8003c0c:	2400      	movs	r4, #0
			}
			fs->winsect = sector;
		}
	}
	return res;
}
 8003c0e:	4620      	mov	r0, r4
 8003c10:	bd70      	pop	{r4, r5, r6, pc}
	...

08003c14 <check_fs>:
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8003c14:	2300      	movs	r3, #0
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 8003c16:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8003c18:	f880 3204 	strb.w	r3, [r0, #516]	; 0x204
 8003c1c:	f04f 33ff 	mov.w	r3, #4294967295
 8003c20:	f8c0 3230 	str.w	r3, [r0, #560]	; 0x230
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 8003c24:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
 8003c26:	f7ff ffd7 	bl	8003bd8 <move_window>
 8003c2a:	b9c0      	cbnz	r0, 8003c5e <check_fs+0x4a>
		return 3;

	if (LD_WORD(&fs->win.d8[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
 8003c2c:	f894 21ff 	ldrb.w	r2, [r4, #511]	; 0x1ff
 8003c30:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
 8003c34:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003c38:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8003c3c:	4293      	cmp	r3, r2
 8003c3e:	d110      	bne.n	8003c62 <check_fs+0x4e>
		return 2;

	if ((LD_DWORD(&fs->win.d8[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
 8003c40:	f8d4 3036 	ldr.w	r3, [r4, #54]	; 0x36
 8003c44:	4a08      	ldr	r2, [pc, #32]	; (8003c68 <check_fs+0x54>)
 8003c46:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8003c4a:	4293      	cmp	r3, r2
 8003c4c:	d00a      	beq.n	8003c64 <check_fs+0x50>
		return 0;
	if ((LD_DWORD(&fs->win.d8[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8003c4e:	f8d4 0052 	ldr.w	r0, [r4, #82]	; 0x52
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
		return 3;
 8003c52:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8003c56:	1a80      	subs	r0, r0, r2
 8003c58:	bf18      	it	ne
 8003c5a:	2001      	movne	r0, #1
 8003c5c:	bd10      	pop	{r4, pc}
 8003c5e:	2003      	movs	r0, #3
 8003c60:	bd10      	pop	{r4, pc}

	if (LD_WORD(&fs->win.d8[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
 8003c62:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win.d8[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
 8003c64:	bd10      	pop	{r4, pc}
 8003c66:	bf00      	nop
 8003c68:	00544146 	.word	0x00544146

08003c6c <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003c6c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
 8003c70:	2300      	movs	r3, #0
 8003c72:	6003      	str	r3, [r0, #0]
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003c74:	4607      	mov	r7, r0
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 8003c76:	4608      	mov	r0, r1
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003c78:	4615      	mov	r5, r2
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 8003c7a:	f7ff fee5 	bl	8003a48 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8003c7e:	1e06      	subs	r6, r0, #0
 8003c80:	f2c0 8120 	blt.w	8003ec4 <find_volume+0x258>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8003c84:	4b99      	ldr	r3, [pc, #612]	; (8003eec <find_volume+0x280>)
 8003c86:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8003c8a:	2c00      	cmp	r4, #0
 8003c8c:	f000 811c 	beq.w	8003ec8 <find_volume+0x25c>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 8003c90:	603c      	str	r4, [r7, #0]

	if (fs->fs_type) {					/* If the volume has been mounted */
 8003c92:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8003c96:	b18b      	cbz	r3, 8003cbc <find_volume+0x50>
		stat = disk_status(fs->drv);
 8003c98:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
 8003c9c:	f7ff fe5c 	bl	8003958 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8003ca0:	07c1      	lsls	r1, r0, #31
 8003ca2:	d40b      	bmi.n	8003cbc <find_volume+0x50>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8003ca4:	2d00      	cmp	r5, #0
 8003ca6:	f000 8111 	beq.w	8003ecc <find_volume+0x260>
 8003caa:	f000 0304 	and.w	r3, r0, #4
 8003cae:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8003cb2:	2b00      	cmp	r3, #0
 8003cb4:	f000 8116 	beq.w	8003ee4 <find_volume+0x278>
				return FR_WRITE_PROTECTED;
 8003cb8:	200a      	movs	r0, #10
 8003cba:	e113      	b.n	8003ee4 <find_volume+0x278>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8003cbc:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8003cbe:	b2f0      	uxtb	r0, r6
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8003cc0:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8003cc4:	f884 0201 	strb.w	r0, [r4, #513]	; 0x201
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8003cc8:	f7ff fe50 	bl	800396c <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8003ccc:	07c2      	lsls	r2, r0, #31
 8003cce:	f100 80ff 	bmi.w	8003ed0 <find_volume+0x264>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 8003cd2:	b10d      	cbz	r5, 8003cd8 <find_volume+0x6c>
 8003cd4:	0743      	lsls	r3, r0, #29
 8003cd6:	d4ef      	bmi.n	8003cb8 <find_volume+0x4c>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
 8003cd8:	2100      	movs	r1, #0
 8003cda:	4620      	mov	r0, r4
 8003cdc:	f7ff ff9a 	bl	8003c14 <check_fs>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
 8003ce0:	2801      	cmp	r0, #1
 8003ce2:	d11c      	bne.n	8003d1e <find_volume+0xb2>
 8003ce4:	f504 71e3 	add.w	r1, r4, #454	; 0x1c6
 8003ce8:	2200      	movs	r2, #0
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win.d8 + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 8003cea:	f811 3c04 	ldrb.w	r3, [r1, #-4]
 8003cee:	b103      	cbz	r3, 8003cf2 <find_volume+0x86>
 8003cf0:	680b      	ldr	r3, [r1, #0]
 8003cf2:	f84d 3022 	str.w	r3, [sp, r2, lsl #2]
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
 8003cf6:	3201      	adds	r2, #1
 8003cf8:	2a04      	cmp	r2, #4
 8003cfa:	f101 0110 	add.w	r1, r1, #16
 8003cfe:	d1f4      	bne.n	8003cea <find_volume+0x7e>
 8003d00:	2600      	movs	r6, #0
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
 8003d02:	f85d 5026 	ldr.w	r5, [sp, r6, lsl #2]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8003d06:	b12d      	cbz	r5, 8003d14 <find_volume+0xa8>
 8003d08:	4629      	mov	r1, r5
 8003d0a:	4620      	mov	r0, r4
 8003d0c:	f7ff ff82 	bl	8003c14 <check_fs>
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8003d10:	b908      	cbnz	r0, 8003d16 <find_volume+0xaa>
 8003d12:	e00b      	b.n	8003d2c <find_volume+0xc0>
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8003d14:	2002      	movs	r0, #2
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8003d16:	3601      	adds	r6, #1
 8003d18:	2e04      	cmp	r6, #4
 8003d1a:	d1f2      	bne.n	8003d02 <find_volume+0x96>
 8003d1c:	e0da      	b.n	8003ed4 <find_volume+0x268>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003d1e:	2803      	cmp	r0, #3
 8003d20:	f000 80db 	beq.w	8003eda <find_volume+0x26e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8003d24:	b108      	cbz	r0, 8003d2a <find_volume+0xbe>
 8003d26:	200d      	movs	r0, #13
 8003d28:	e0dc      	b.n	8003ee4 <find_volume+0x278>
#if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
 8003d2a:	4605      	mov	r5, r0
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8003d2c:	7b22      	ldrb	r2, [r4, #12]
 8003d2e:	7ae3      	ldrb	r3, [r4, #11]
 8003d30:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003d34:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003d38:	d1f5      	bne.n	8003d26 <find_volume+0xba>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
 8003d3a:	7da3      	ldrb	r3, [r4, #22]
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
 8003d3c:	f894 c010 	ldrb.w	ip, [r4, #16]
	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
 8003d40:	7de0      	ldrb	r0, [r4, #23]
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
 8003d42:	f884 c203 	strb.w	ip, [r4, #515]	; 0x203

	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
 8003d46:	ea53 2000 	orrs.w	r0, r3, r0, lsl #8
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8003d4a:	f10c 33ff 	add.w	r3, ip, #4294967295

	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
 8003d4e:	bf08      	it	eq
 8003d50:	6a60      	ldreq	r0, [r4, #36]	; 0x24
	fs->fsize = fasize;
 8003d52:	f8c4 021c 	str.w	r0, [r4, #540]	; 0x21c

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8003d56:	2b01      	cmp	r3, #1
 8003d58:	d8e5      	bhi.n	8003d26 <find_volume+0xba>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win.d8[BPB_SecPerClus];				/* Number of sectors per cluster */
 8003d5a:	7b63      	ldrb	r3, [r4, #13]
 8003d5c:	f884 3202 	strb.w	r3, [r4, #514]	; 0x202
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
 8003d60:	2b00      	cmp	r3, #0
 8003d62:	d0e0      	beq.n	8003d26 <find_volume+0xba>
 8003d64:	1e5a      	subs	r2, r3, #1
 8003d66:	421a      	tst	r2, r3
 8003d68:	d1dd      	bne.n	8003d26 <find_volume+0xba>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
 8003d6a:	f894 e012 	ldrb.w	lr, [r4, #18]
 8003d6e:	7c62      	ldrb	r2, [r4, #17]
 8003d70:	ea42 2e0e 	orr.w	lr, r2, lr, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
 8003d74:	f01e 0f0f 	tst.w	lr, #15

	fs->csize = fs->win.d8[BPB_SecPerClus];				/* Number of sectors per cluster */
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
 8003d78:	f8a4 e208 	strh.w	lr, [r4, #520]	; 0x208
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
 8003d7c:	d1d3      	bne.n	8003d26 <find_volume+0xba>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win.d8 + BPB_TotSec16);			/* Number of sectors on the volume */
 8003d7e:	7d21      	ldrb	r1, [r4, #20]
 8003d80:	7ce2      	ldrb	r2, [r4, #19]
	if (!tsect) tsect = LD_DWORD(fs->win.d8 + BPB_TotSec32);

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
 8003d82:	7be6      	ldrb	r6, [r4, #15]
	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win.d8 + BPB_TotSec16);			/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win.d8 + BPB_TotSec32);
 8003d84:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
 8003d88:	7ba1      	ldrb	r1, [r4, #14]
	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win.d8 + BPB_TotSec16);			/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win.d8 + BPB_TotSec32);
 8003d8a:	bf08      	it	eq
 8003d8c:	6a22      	ldreq	r2, [r4, #32]

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 8003d8e:	ea51 2106 	orrs.w	r1, r1, r6, lsl #8
 8003d92:	d0c8      	beq.n	8003d26 <find_volume+0xba>
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
 8003d94:	fb00 fc0c 	mul.w	ip, r0, ip

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
 8003d98:	eb01 171e 	add.w	r7, r1, lr, lsr #4
 8003d9c:	4467      	add	r7, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8003d9e:	42ba      	cmp	r2, r7
 8003da0:	d3c1      	bcc.n	8003d26 <find_volume+0xba>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8003da2:	1bd2      	subs	r2, r2, r7
 8003da4:	fbb2 f3f3 	udiv	r3, r2, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8003da8:	2b00      	cmp	r3, #0
 8003daa:	d0bc      	beq.n	8003d26 <find_volume+0xba>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8003dac:	f640 72f5 	movw	r2, #4085	; 0xff5
 8003db0:	4293      	cmp	r3, r2
 8003db2:	f103 0602 	add.w	r6, r3, #2
 8003db6:	eb01 0205 	add.w	r2, r1, r5
 8003dba:	442f      	add	r7, r5
 8003dbc:	d916      	bls.n	8003dec <find_volume+0x180>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8003dbe:	f64f 71f5 	movw	r1, #65525	; 0xfff5
 8003dc2:	428b      	cmp	r3, r1
 8003dc4:	f240 808b 	bls.w	8003ede <find_volume+0x272>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8003dc8:	f8c4 6218 	str.w	r6, [r4, #536]	; 0x218
	fs->volbase = bsect;								/* Volume start sector */
 8003dcc:	f8c4 5220 	str.w	r5, [r4, #544]	; 0x220
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8003dd0:	f8c4 2224 	str.w	r2, [r4, #548]	; 0x224
	fs->database = bsect + sysect;						/* Data start sector */
 8003dd4:	f8c4 722c 	str.w	r7, [r4, #556]	; 0x22c
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8003dd8:	f1be 0f00 	cmp.w	lr, #0
 8003ddc:	d1a3      	bne.n	8003d26 <find_volume+0xba>
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
 8003dde:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8003de0:	f8c4 3228 	str.w	r3, [r4, #552]	; 0x228
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8003de4:	f04f 0803 	mov.w	r8, #3
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	fs->database = bsect + sysect;						/* Data start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
 8003de8:	00b3      	lsls	r3, r6, #2
 8003dea:	e01d      	b.n	8003e28 <find_volume+0x1bc>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
 8003dec:	f04f 0801 	mov.w	r8, #1
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8003df0:	f8c4 6218 	str.w	r6, [r4, #536]	; 0x218
	fs->volbase = bsect;								/* Volume start sector */
 8003df4:	f8c4 5220 	str.w	r5, [r4, #544]	; 0x220
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8003df8:	f8c4 2224 	str.w	r2, [r4, #548]	; 0x224
	fs->database = bsect + sysect;						/* Data start sector */
 8003dfc:	f8c4 722c 	str.w	r7, [r4, #556]	; 0x22c
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8003e00:	f1be 0f00 	cmp.w	lr, #0
 8003e04:	d08f      	beq.n	8003d26 <find_volume+0xba>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003e06:	f1b8 0f02 	cmp.w	r8, #2
 8003e0a:	ea4f 0346 	mov.w	r3, r6, lsl #1
 8003e0e:	bf18      	it	ne
 8003e10:	199b      	addne	r3, r3, r6
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8003e12:	4462      	add	r2, ip
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003e14:	bf18      	it	ne
 8003e16:	f006 0601 	andne.w	r6, r6, #1
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8003e1a:	f8c4 2228 	str.w	r2, [r4, #552]	; 0x228
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003e1e:	bf1c      	itt	ne
 8003e20:	eb06 0353 	addne.w	r3, r6, r3, lsr #1
 8003e24:	f04f 0801 	movne.w	r8, #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
 8003e28:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 8003e2c:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
 8003e30:	f4ff af79 	bcc.w	8003d26 <find_volume+0xba>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8003e34:	f04f 33ff 	mov.w	r3, #4294967295
 8003e38:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
 8003e3c:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
 8003e40:	f1b8 0f03 	cmp.w	r8, #3
#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8003e44:	f04f 0380 	mov.w	r3, #128	; 0x80
 8003e48:	f884 3205 	strb.w	r3, [r4, #517]	; 0x205
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
 8003e4c:	d12d      	bne.n	8003eaa <find_volume+0x23e>
		&& LD_WORD(fs->win.d8 + BPB_FSInfo) == 1
 8003e4e:	f894 2031 	ldrb.w	r2, [r4, #49]	; 0x31
 8003e52:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8003e56:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003e5a:	2b01      	cmp	r3, #1
 8003e5c:	d125      	bne.n	8003eaa <find_volume+0x23e>
		&& move_window(fs, bsect + 1) == FR_OK)
 8003e5e:	1c69      	adds	r1, r5, #1
 8003e60:	4620      	mov	r0, r4
 8003e62:	f7ff feb9 	bl	8003bd8 <move_window>
 8003e66:	bb00      	cbnz	r0, 8003eaa <find_volume+0x23e>
	{
		fs->fsi_flag = 0;
		if (LD_WORD(fs->win.d8 + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8003e68:	f894 21ff 	ldrb.w	r2, [r4, #511]	; 0x1ff
 8003e6c:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win.d8 + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
 8003e70:	f884 0205 	strb.w	r0, [r4, #517]	; 0x205
		if (LD_WORD(fs->win.d8 + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8003e74:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003e78:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8003e7c:	4293      	cmp	r3, r2
 8003e7e:	d114      	bne.n	8003eaa <find_volume+0x23e>
			&& LD_DWORD(fs->win.d8 + FSI_LeadSig) == 0x41615252
 8003e80:	6822      	ldr	r2, [r4, #0]
 8003e82:	4b1b      	ldr	r3, [pc, #108]	; (8003ef0 <find_volume+0x284>)
 8003e84:	429a      	cmp	r2, r3
 8003e86:	d110      	bne.n	8003eaa <find_volume+0x23e>
			&& LD_DWORD(fs->win.d8 + FSI_StrucSig) == 0x61417272)
 8003e88:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 8003e8c:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
 8003e90:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8003e94:	3320      	adds	r3, #32
 8003e96:	429a      	cmp	r2, r3
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win.d8 + FSI_Free_Count);
 8003e98:	bf01      	itttt	eq
 8003e9a:	f8d4 31e8 	ldreq.w	r3, [r4, #488]	; 0x1e8
 8003e9e:	f8c4 3210 	streq.w	r3, [r4, #528]	; 0x210
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win.d8 + FSI_Nxt_Free);
 8003ea2:	f8d4 31ec 	ldreq.w	r3, [r4, #492]	; 0x1ec
 8003ea6:	f8c4 320c 	streq.w	r3, [r4, #524]	; 0x20c
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
	fs->id = ++Fsid;	/* File system mount ID */
 8003eaa:	4a12      	ldr	r2, [pc, #72]	; (8003ef4 <find_volume+0x288>)
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
 8003eac:	f884 8200 	strb.w	r8, [r4, #512]	; 0x200
	fs->id = ++Fsid;	/* File system mount ID */
 8003eb0:	8813      	ldrh	r3, [r2, #0]
 8003eb2:	3301      	adds	r3, #1
 8003eb4:	b29b      	uxth	r3, r3
#if _FS_RPATH
	fs->cdir = 0;		/* Set current directory to root */
 8003eb6:	2000      	movs	r0, #0
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
	fs->id = ++Fsid;	/* File system mount ID */
 8003eb8:	8013      	strh	r3, [r2, #0]
 8003eba:	f8a4 3206 	strh.w	r3, [r4, #518]	; 0x206
#if _FS_RPATH
	fs->cdir = 0;		/* Set current directory to root */
 8003ebe:	f8c4 0214 	str.w	r0, [r4, #532]	; 0x214
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
 8003ec2:	e00f      	b.n	8003ee4 <find_volume+0x278>


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 8003ec4:	200b      	movs	r0, #11
 8003ec6:	e00d      	b.n	8003ee4 <find_volume+0x278>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8003ec8:	200c      	movs	r0, #12
 8003eca:	e00b      	b.n	8003ee4 <find_volume+0x278>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
 8003ecc:	4628      	mov	r0, r5
 8003ece:	e009      	b.n	8003ee4 <find_volume+0x278>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8003ed0:	2003      	movs	r0, #3
 8003ed2:	e007      	b.n	8003ee4 <find_volume+0x278>
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003ed4:	2803      	cmp	r0, #3
 8003ed6:	f47f af26 	bne.w	8003d26 <find_volume+0xba>
 8003eda:	2001      	movs	r0, #1
 8003edc:	e002      	b.n	8003ee4 <find_volume+0x278>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8003ede:	f04f 0802 	mov.w	r8, #2
 8003ee2:	e785      	b.n	8003df0 <find_volume+0x184>
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
 8003ee4:	b004      	add	sp, #16
 8003ee6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003eea:	bf00      	nop
 8003eec:	20000188 	.word	0x20000188
 8003ef0:	41615252 	.word	0x41615252
 8003ef4:	20000184 	.word	0x20000184

08003ef8 <clust2sect>:
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8003ef8:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 8003efc:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8003efe:	3b02      	subs	r3, #2
 8003f00:	4299      	cmp	r1, r3
	return clst * fs->csize + fs->database;
 8003f02:	bf3d      	ittte	cc
 8003f04:	f890 3202 	ldrbcc.w	r3, [r0, #514]	; 0x202
 8003f08:	f8d0 022c 	ldrcc.w	r0, [r0, #556]	; 0x22c
 8003f0c:	fb01 0003 	mlacc	r0, r1, r3, r0
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8003f10:	2000      	movcs	r0, #0
	return clst * fs->csize + fs->database;
}
 8003f12:	4770      	bx	lr

08003f14 <get_fat>:
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8003f14:	2901      	cmp	r1, #1

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
 8003f16:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003f18:	4606      	mov	r6, r0
 8003f1a:	460d      	mov	r5, r1
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8003f1c:	d959      	bls.n	8003fd2 <get_fat+0xbe>
 8003f1e:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 8003f22:	4299      	cmp	r1, r3
 8003f24:	d255      	bcs.n	8003fd2 <get_fat+0xbe>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
 8003f26:	f890 3200 	ldrb.w	r3, [r0, #512]	; 0x200
 8003f2a:	2b02      	cmp	r3, #2
 8003f2c:	d027      	beq.n	8003f7e <get_fat+0x6a>
 8003f2e:	2b03      	cmp	r3, #3
 8003f30:	d036      	beq.n	8003fa0 <get_fat+0x8c>
 8003f32:	2b01      	cmp	r3, #1
 8003f34:	d14d      	bne.n	8003fd2 <get_fat+0xbe>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8003f36:	eb01 0451 	add.w	r4, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8003f3a:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 8003f3e:	eb01 2154 	add.w	r1, r1, r4, lsr #9
 8003f42:	f7ff fe49 	bl	8003bd8 <move_window>
 8003f46:	b110      	cbz	r0, 8003f4e <get_fat+0x3a>

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 8003f48:	f04f 30ff 	mov.w	r0, #4294967295
 8003f4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win.d8[bc++ % SS(fs)];
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8003f4e:	f8d6 1224 	ldr.w	r1, [r6, #548]	; 0x224

		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win.d8[bc++ % SS(fs)];
 8003f52:	1c67      	adds	r7, r4, #1
 8003f54:	f3c4 0408 	ubfx	r4, r4, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8003f58:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 8003f5c:	4630      	mov	r0, r6

		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win.d8[bc++ % SS(fs)];
 8003f5e:	5d34      	ldrb	r4, [r6, r4]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8003f60:	f7ff fe3a 	bl	8003bd8 <move_window>
 8003f64:	2800      	cmp	r0, #0
 8003f66:	d1ef      	bne.n	8003f48 <get_fat+0x34>
			wc |= fs->win.d8[bc % SS(fs)] << 8;
 8003f68:	f3c7 0708 	ubfx	r7, r7, #0, #9
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
 8003f6c:	07eb      	lsls	r3, r5, #31
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win.d8[bc++ % SS(fs)];
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc |= fs->win.d8[bc % SS(fs)] << 8;
 8003f6e:	5df0      	ldrb	r0, [r6, r7]
 8003f70:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
 8003f74:	bf4c      	ite	mi
 8003f76:	0900      	lsrmi	r0, r0, #4
 8003f78:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 8003f7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8003f7e:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 8003f82:	eb01 2115 	add.w	r1, r1, r5, lsr #8
 8003f86:	f7ff fe27 	bl	8003bd8 <move_window>
 8003f8a:	2800      	cmp	r0, #0
 8003f8c:	d1dc      	bne.n	8003f48 <get_fat+0x34>
			p = &fs->win.d8[clst * 2 % SS(fs)];
 8003f8e:	006d      	lsls	r5, r5, #1
 8003f90:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			val = LD_WORD(p);
 8003f94:	1973      	adds	r3, r6, r5
 8003f96:	7858      	ldrb	r0, [r3, #1]
 8003f98:	5d73      	ldrb	r3, [r6, r5]
 8003f9a:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8003f9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			break;

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8003fa0:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 8003fa4:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
 8003fa8:	f7ff fe16 	bl	8003bd8 <move_window>
 8003fac:	2800      	cmp	r0, #0
 8003fae:	d1cb      	bne.n	8003f48 <get_fat+0x34>
			p = &fs->win.d8[clst * 4 % SS(fs)];
 8003fb0:	00ad      	lsls	r5, r5, #2
 8003fb2:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 8003fb6:	1973      	adds	r3, r6, r5
			val = LD_DWORD(p) & 0x0FFFFFFF;
 8003fb8:	7898      	ldrb	r0, [r3, #2]
 8003fba:	78da      	ldrb	r2, [r3, #3]
 8003fbc:	785b      	ldrb	r3, [r3, #1]
 8003fbe:	0400      	lsls	r0, r0, #16
 8003fc0:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
 8003fc4:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8003fc8:	5d73      	ldrb	r3, [r6, r5]
 8003fca:	4318      	orrs	r0, r3
 8003fcc:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 8003fd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			break;

		default:
			val = 1;	/* Internal error */
 8003fd2:	2001      	movs	r0, #1
		}
	}

	return val;
}
 8003fd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003fd6 <dir_sdi>:
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
 8003fd6:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
static
FRESULT dir_sdi (
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
 8003fda:	b570      	push	{r4, r5, r6, lr}
 8003fdc:	4604      	mov	r4, r0
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 8003fde:	2a01      	cmp	r2, #1
static
FRESULT dir_sdi (
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
 8003fe0:	460d      	mov	r5, r1
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
 8003fe2:	f8a4 1206 	strh.w	r1, [r4, #518]	; 0x206
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 8003fe6:	d101      	bne.n	8003fec <dir_sdi+0x16>
		return FR_INT_ERR;
 8003fe8:	2002      	movs	r0, #2
 8003fea:	bd70      	pop	{r4, r5, r6, pc}
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 8003fec:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 8003ff0:	f8d3 1218 	ldr.w	r1, [r3, #536]	; 0x218
 8003ff4:	428a      	cmp	r2, r1
 8003ff6:	d2f7      	bcs.n	8003fe8 <dir_sdi+0x12>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 8003ff8:	b972      	cbnz	r2, 8004018 <dir_sdi+0x42>
 8003ffa:	f893 1200 	ldrb.w	r1, [r3, #512]	; 0x200
 8003ffe:	2903      	cmp	r1, #3
 8004000:	d102      	bne.n	8004008 <dir_sdi+0x32>
		clst = dp->fs->dirbase;
 8004002:	f8d3 1228 	ldr.w	r1, [r3, #552]	; 0x228

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 8004006:	b931      	cbnz	r1, 8004016 <dir_sdi+0x40>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
 8004008:	f8b3 1208 	ldrh.w	r1, [r3, #520]	; 0x208
 800400c:	428d      	cmp	r5, r1
 800400e:	d2eb      	bcs.n	8003fe8 <dir_sdi+0x12>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
 8004010:	f8d3 0228 	ldr.w	r0, [r3, #552]	; 0x228
 8004014:	e019      	b.n	800404a <dir_sdi+0x74>
 8004016:	460a      	mov	r2, r1
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
 8004018:	f893 6202 	ldrb.w	r6, [r3, #514]	; 0x202
 800401c:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
 800401e:	42b5      	cmp	r5, r6
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 8004020:	4611      	mov	r1, r2
 8004022:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
 8004026:	d30e      	bcc.n	8004046 <dir_sdi+0x70>
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 8004028:	f7ff ff74 	bl	8003f14 <get_fat>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800402c:	1c43      	adds	r3, r0, #1
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 800402e:	4602      	mov	r2, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8004030:	d01d      	beq.n	800406e <dir_sdi+0x98>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
 8004032:	2801      	cmp	r0, #1
 8004034:	d9d8      	bls.n	8003fe8 <dir_sdi+0x12>
 8004036:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 800403a:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 800403e:	4298      	cmp	r0, r3
 8004040:	d2d2      	bcs.n	8003fe8 <dir_sdi+0x12>
				return FR_INT_ERR;
			idx -= ic;
 8004042:	1bad      	subs	r5, r5, r6
 8004044:	e7eb      	b.n	800401e <dir_sdi+0x48>
		}
		sect = clust2sect(dp->fs, clst);
 8004046:	f7ff ff57 	bl	8003ef8 <clust2sect>
	}
	dp->clust = clst;	/* Current cluster# */
 800404a:	f8c4 220c 	str.w	r2, [r4, #524]	; 0x20c
	if (!sect) return FR_INT_ERR;
 800404e:	2800      	cmp	r0, #0
 8004050:	d0ca      	beq.n	8003fe8 <dir_sdi+0x12>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
 8004052:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
 8004056:	eb00 1015 	add.w	r0, r0, r5, lsr #4
	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
 800405a:	f005 050f 	and.w	r5, r5, #15
 800405e:	eb03 1545 	add.w	r5, r3, r5, lsl #5
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
 8004062:	f8c4 0210 	str.w	r0, [r4, #528]	; 0x210
	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
 8004066:	f8c4 5214 	str.w	r5, [r4, #532]	; 0x214

	return FR_OK;
 800406a:	2000      	movs	r0, #0
 800406c:	bd70      	pop	{r4, r5, r6, pc}
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800406e:	2001      	movs	r0, #1
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */

	return FR_OK;
}
 8004070:	bd70      	pop	{r4, r5, r6, pc}

08004072 <put_fat>:
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004072:	2901      	cmp	r1, #1
FRESULT put_fat (
	FATFS* fs,	/* File system object */
	DWORD clst,	/* FAT index number (cluster number) to be changed */
	DWORD val	/* New value to be set to the entry */
)
{
 8004074:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004078:	4605      	mov	r5, r0
 800407a:	460c      	mov	r4, r1
 800407c:	4616      	mov	r6, r2
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800407e:	d96b      	bls.n	8004158 <put_fat+0xe6>
 8004080:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 8004084:	4299      	cmp	r1, r3
 8004086:	d267      	bcs.n	8004158 <put_fat+0xe6>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
 8004088:	f890 3200 	ldrb.w	r3, [r0, #512]	; 0x200
 800408c:	2b02      	cmp	r3, #2
 800408e:	d038      	beq.n	8004102 <put_fat+0x90>
 8004090:	2b03      	cmp	r3, #3
 8004092:	d045      	beq.n	8004120 <put_fat+0xae>
 8004094:	2b01      	cmp	r3, #1
 8004096:	d15f      	bne.n	8004158 <put_fat+0xe6>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8004098:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800409c:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 80040a0:	eb01 2158 	add.w	r1, r1, r8, lsr #9
 80040a4:	f7ff fd98 	bl	8003bd8 <move_window>
			if (res != FR_OK) break;
 80040a8:	2800      	cmp	r0, #0
 80040aa:	d156      	bne.n	800415a <put_fat+0xe8>
			p = &fs->win.d8[bc++ % SS(fs)];
 80040ac:	f108 0701 	add.w	r7, r8, #1
 80040b0:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80040b4:	f014 0401 	ands.w	r4, r4, #1
 80040b8:	bf1f      	itttt	ne
 80040ba:	f815 3008 	ldrbne.w	r3, [r5, r8]
 80040be:	f003 030f 	andne.w	r3, r3, #15
 80040c2:	ea43 1306 	orrne.w	r3, r3, r6, lsl #4
 80040c6:	b2db      	uxtbne	r3, r3
 80040c8:	bf08      	it	eq
 80040ca:	b2f3      	uxtbeq	r3, r6
 80040cc:	f805 3008 	strb.w	r3, [r5, r8]
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80040d0:	f8d5 1224 	ldr.w	r1, [r5, #548]	; 0x224
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win.d8[bc++ % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			fs->wflag = 1;
 80040d4:	2301      	movs	r3, #1
 80040d6:	f885 3204 	strb.w	r3, [r5, #516]	; 0x204
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80040da:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 80040de:	4628      	mov	r0, r5
 80040e0:	f7ff fd7a 	bl	8003bd8 <move_window>
			if (res != FR_OK) break;
 80040e4:	bbc8      	cbnz	r0, 800415a <put_fat+0xe8>
			p = &fs->win.d8[bc % SS(fs)];
 80040e6:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 80040ea:	b114      	cbz	r4, 80040f2 <put_fat+0x80>
 80040ec:	f3c6 1207 	ubfx	r2, r6, #4, #8
 80040f0:	e005      	b.n	80040fe <put_fat+0x8c>
 80040f2:	5dea      	ldrb	r2, [r5, r7]
 80040f4:	f022 030f 	bic.w	r3, r2, #15
 80040f8:	f3c6 2203 	ubfx	r2, r6, #8, #4
 80040fc:	431a      	orrs	r2, r3
 80040fe:	55ea      	strb	r2, [r5, r7]
 8004100:	e025      	b.n	800414e <put_fat+0xdc>
			fs->wflag = 1;
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8004102:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 8004106:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 800410a:	f7ff fd65 	bl	8003bd8 <move_window>
			if (res != FR_OK) break;
 800410e:	bb20      	cbnz	r0, 800415a <put_fat+0xe8>
			p = &fs->win.d8[clst * 2 % SS(fs)];
 8004110:	0064      	lsls	r4, r4, #1
 8004112:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
 8004116:	1232      	asrs	r2, r6, #8
 8004118:	552e      	strb	r6, [r5, r4]
 800411a:	442c      	add	r4, r5
 800411c:	7062      	strb	r2, [r4, #1]
 800411e:	e016      	b.n	800414e <put_fat+0xdc>
			fs->wflag = 1;
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8004120:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 8004124:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 8004128:	f7ff fd56 	bl	8003bd8 <move_window>
			if (res != FR_OK) break;
 800412c:	b9a8      	cbnz	r0, 800415a <put_fat+0xe8>
			p = &fs->win.d8[clst * 4 % SS(fs)];
 800412e:	00a4      	lsls	r4, r4, #2
 8004130:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
 8004134:	192b      	adds	r3, r5, r4
			val |= LD_DWORD(p) & 0xF0000000;
 8004136:	78da      	ldrb	r2, [r3, #3]
 8004138:	0612      	lsls	r2, r2, #24
 800413a:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 800413e:	4332      	orrs	r2, r6
			ST_DWORD(p, val);
 8004140:	1211      	asrs	r1, r2, #8
 8004142:	552a      	strb	r2, [r5, r4]
 8004144:	7059      	strb	r1, [r3, #1]
 8004146:	0c11      	lsrs	r1, r2, #16
 8004148:	0e12      	lsrs	r2, r2, #24
 800414a:	7099      	strb	r1, [r3, #2]
 800414c:	70da      	strb	r2, [r3, #3]
			fs->wflag = 1;
 800414e:	2301      	movs	r3, #1
 8004150:	f885 3204 	strb.w	r3, [r5, #516]	; 0x204
 8004154:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			break;

		default :
			res = FR_INT_ERR;
 8004158:	2002      	movs	r0, #2
		}
	}

	return res;
}
 800415a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800415e <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
 800415e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004160:	4605      	mov	r5, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
 8004162:	460f      	mov	r7, r1
 8004164:	b941      	cbnz	r1, 8004178 <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
 8004166:	f8d0 620c 	ldr.w	r6, [r0, #524]	; 0x20c
		if (!scl || scl >= fs->n_fatent) scl = 1;
 800416a:	b1a6      	cbz	r6, 8004196 <create_chain+0x38>
 800416c:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 8004170:	429e      	cmp	r6, r3
 8004172:	bf28      	it	cs
 8004174:	2601      	movcs	r6, #1
 8004176:	e00f      	b.n	8004198 <create_chain+0x3a>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
 8004178:	f7ff fecc 	bl	8003f14 <get_fat>
		if (cs < 2) return 1;			/* Invalid value */
 800417c:	2801      	cmp	r0, #1
 800417e:	d946      	bls.n	800420e <create_chain+0xb0>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 8004180:	1c44      	adds	r4, r0, #1
 8004182:	d102      	bne.n	800418a <create_chain+0x2c>
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
 8004184:	f04f 30ff 	mov.w	r0, #4294967295
 8004188:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* Invalid value */
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 800418a:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 800418e:	4298      	cmp	r0, r3
 8004190:	d33e      	bcc.n	8004210 <create_chain+0xb2>
 8004192:	463e      	mov	r6, r7
 8004194:	e000      	b.n	8004198 <create_chain+0x3a>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8004196:	2601      	movs	r6, #1
 8004198:	4634      	mov	r4, r6
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
 800419a:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
 800419e:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
 80041a0:	429c      	cmp	r4, r3
 80041a2:	d304      	bcc.n	80041ae <create_chain+0x50>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
 80041a4:	2e01      	cmp	r6, #1
 80041a6:	d801      	bhi.n	80041ac <create_chain+0x4e>
 80041a8:	2000      	movs	r0, #0
 80041aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
 80041ac:	2402      	movs	r4, #2
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
 80041ae:	4621      	mov	r1, r4
 80041b0:	4628      	mov	r0, r5
 80041b2:	f7ff feaf 	bl	8003f14 <get_fat>
		if (cs == 0) break;				/* Found a free cluster */
 80041b6:	b130      	cbz	r0, 80041c6 <create_chain+0x68>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 80041b8:	1c41      	adds	r1, r0, #1
 80041ba:	d0e3      	beq.n	8004184 <create_chain+0x26>
 80041bc:	2801      	cmp	r0, #1
 80041be:	d026      	beq.n	800420e <create_chain+0xb0>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
 80041c0:	42b4      	cmp	r4, r6
 80041c2:	d1ea      	bne.n	800419a <create_chain+0x3c>
 80041c4:	e7f0      	b.n	80041a8 <create_chain+0x4a>
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
 80041c6:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 80041ca:	4621      	mov	r1, r4
 80041cc:	4628      	mov	r0, r5
 80041ce:	f7ff ff50 	bl	8004072 <put_fat>
	if (res == FR_OK && clst != 0) {
 80041d2:	b9d0      	cbnz	r0, 800420a <create_chain+0xac>
 80041d4:	b97f      	cbnz	r7, 80041f6 <create_chain+0x98>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
 80041d6:	f8d5 3210 	ldr.w	r3, [r5, #528]	; 0x210
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
 80041da:	f8c5 420c 	str.w	r4, [r5, #524]	; 0x20c
		if (fs->free_clust != 0xFFFFFFFF) {
 80041de:	1c5a      	adds	r2, r3, #1
 80041e0:	d011      	beq.n	8004206 <create_chain+0xa8>
			fs->free_clust--;
 80041e2:	3b01      	subs	r3, #1
 80041e4:	f8c5 3210 	str.w	r3, [r5, #528]	; 0x210
			fs->fsi_flag |= 1;
 80041e8:	f895 3205 	ldrb.w	r3, [r5, #517]	; 0x205
 80041ec:	f043 0301 	orr.w	r3, r3, #1
 80041f0:	f885 3205 	strb.w	r3, [r5, #517]	; 0x205
 80041f4:	e007      	b.n	8004206 <create_chain+0xa8>
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 80041f6:	4622      	mov	r2, r4
 80041f8:	4639      	mov	r1, r7
 80041fa:	4628      	mov	r0, r5
 80041fc:	f7ff ff39 	bl	8004072 <put_fat>
	}
	if (res == FR_OK) {
 8004200:	2800      	cmp	r0, #0
 8004202:	d0e8      	beq.n	80041d6 <create_chain+0x78>
 8004204:	e001      	b.n	800420a <create_chain+0xac>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
 8004206:	4620      	mov	r0, r4
 8004208:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 800420a:	2801      	cmp	r0, #1
 800420c:	d0ba      	beq.n	8004184 <create_chain+0x26>
 800420e:	2001      	movs	r0, #1
	}

	return ncl;		/* Return new cluster number or error code */
}
 8004210:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004212 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8004212:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
 8004216:	f8b0 6206 	ldrh.w	r6, [r0, #518]	; 0x206
 800421a:	3601      	adds	r6, #1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 800421c:	b2b3      	uxth	r3, r6
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 800421e:	4604      	mov	r4, r0
 8004220:	460f      	mov	r7, r1
	UINT c;
#endif


	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 8004222:	b913      	cbnz	r3, 800422a <dir_next+0x18>
		return FR_NO_FILE;
 8004224:	2004      	movs	r0, #4
 8004226:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	UINT c;
#endif


	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 800422a:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800422e:	2b00      	cmp	r3, #0
 8004230:	d0f8      	beq.n	8004224 <dir_next+0x12>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
 8004232:	f016 080f 	ands.w	r8, r6, #15
 8004236:	d16f      	bne.n	8004318 <dir_next+0x106>
		dp->sect++;					/* Next sector */

		if (!dp->clust) {		/* Static table */
 8004238:	f8d0 120c 	ldr.w	r1, [r0, #524]	; 0x20c
	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */
 800423c:	3301      	adds	r3, #1
 800423e:	f8c0 3210 	str.w	r3, [r0, #528]	; 0x210
 8004242:	f8d0 0200 	ldr.w	r0, [r0, #512]	; 0x200

		if (!dp->clust) {		/* Static table */
 8004246:	b921      	cbnz	r1, 8004252 <dir_next+0x40>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
 8004248:	f8b0 3208 	ldrh.w	r3, [r0, #520]	; 0x208
 800424c:	429e      	cmp	r6, r3
 800424e:	d2e9      	bcs.n	8004224 <dir_next+0x12>
 8004250:	e062      	b.n	8004318 <dir_next+0x106>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
 8004252:	f890 3202 	ldrb.w	r3, [r0, #514]	; 0x202
 8004256:	3b01      	subs	r3, #1
 8004258:	ea13 1316 	ands.w	r3, r3, r6, lsr #4
 800425c:	d15c      	bne.n	8004318 <dir_next+0x106>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
 800425e:	f7ff fe59 	bl	8003f14 <get_fat>
				if (clst <= 1) return FR_INT_ERR;
 8004262:	2801      	cmp	r0, #1
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
 8004264:	4605      	mov	r5, r0
				if (clst <= 1) return FR_INT_ERR;
 8004266:	d802      	bhi.n	800426e <dir_next+0x5c>
 8004268:	2002      	movs	r0, #2
 800426a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 800426e:	1c42      	adds	r2, r0, #1
 8004270:	d102      	bne.n	8004278 <dir_next+0x66>
 8004272:	2001      	movs	r0, #1
 8004274:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
 8004278:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 800427c:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 8004280:	429d      	cmp	r5, r3
 8004282:	d340      	bcc.n	8004306 <dir_next+0xf4>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
 8004284:	2f00      	cmp	r7, #0
 8004286:	d0cd      	beq.n	8004224 <dir_next+0x12>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
 8004288:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
 800428c:	f7ff ff67 	bl	800415e <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8004290:	4605      	mov	r5, r0
 8004292:	2800      	cmp	r0, #0
 8004294:	d04b      	beq.n	800432e <dir_next+0x11c>
					if (clst == 1) return FR_INT_ERR;
 8004296:	2801      	cmp	r0, #1
 8004298:	d0e6      	beq.n	8004268 <dir_next+0x56>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 800429a:	1c43      	adds	r3, r0, #1
 800429c:	d0e9      	beq.n	8004272 <dir_next+0x60>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 800429e:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 80042a2:	f7ff fc37 	bl	8003b14 <sync_window>
 80042a6:	4607      	mov	r7, r0
 80042a8:	2800      	cmp	r0, #0
 80042aa:	d1e2      	bne.n	8004272 <dir_next+0x60>
					mem_set(dp->fs->win.d8, 0, SS(dp->fs));		/* Clear window buffer */
 80042ac:	4601      	mov	r1, r0
 80042ae:	f44f 7200 	mov.w	r2, #512	; 0x200
 80042b2:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 80042b6:	f7ff fb9d 	bl	80039f4 <mem_set>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 80042ba:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 80042be:	4629      	mov	r1, r5
 80042c0:	4610      	mov	r0, r2
 80042c2:	f7ff fe19 	bl	8003ef8 <clust2sect>
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dp->fs->wflag = 1;
 80042c6:	f04f 0901 	mov.w	r9, #1
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win.d8, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 80042ca:	f8c2 0230 	str.w	r0, [r2, #560]	; 0x230
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80042ce:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 80042d2:	f893 2202 	ldrb.w	r2, [r3, #514]	; 0x202
 80042d6:	4297      	cmp	r7, r2
 80042d8:	d210      	bcs.n	80042fc <dir_next+0xea>
						dp->fs->wflag = 1;
 80042da:	f883 9204 	strb.w	r9, [r3, #516]	; 0x204
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 80042de:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 80042e2:	f7ff fc17 	bl	8003b14 <sync_window>
 80042e6:	2800      	cmp	r0, #0
 80042e8:	d1c3      	bne.n	8004272 <dir_next+0x60>
						dp->fs->winsect++;
 80042ea:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 80042ee:	f8d2 3230 	ldr.w	r3, [r2, #560]	; 0x230
 80042f2:	3301      	adds	r3, #1
 80042f4:	f8c2 3230 	str.w	r3, [r2, #560]	; 0x230
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win.d8, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80042f8:	3701      	adds	r7, #1
 80042fa:	e7e8      	b.n	80042ce <dir_next+0xbc>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
 80042fc:	f8d3 2230 	ldr.w	r2, [r3, #560]	; 0x230
 8004300:	1bd7      	subs	r7, r2, r7
 8004302:	f8c3 7230 	str.w	r7, [r3, #560]	; 0x230
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
 8004306:	f8c4 520c 	str.w	r5, [r4, #524]	; 0x20c
				dp->sect = clust2sect(dp->fs, clst);
 800430a:	4629      	mov	r1, r5
 800430c:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 8004310:	f7ff fdf2 	bl	8003ef8 <clust2sect>
 8004314:	f8c4 0210 	str.w	r0, [r4, #528]	; 0x210
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
	dp->dir = dp->fs->win.d8 + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
 8004318:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
				dp->sect = clust2sect(dp->fs, clst);
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
 800431c:	f8a4 6206 	strh.w	r6, [r4, #518]	; 0x206
	dp->dir = dp->fs->win.d8 + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
 8004320:	eb03 1348 	add.w	r3, r3, r8, lsl #5
 8004324:	f8c4 3214 	str.w	r3, [r4, #532]	; 0x214

	return FR_OK;
 8004328:	2000      	movs	r0, #0
 800432a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800432e:	2007      	movs	r0, #7

	dp->index = (WORD)i;	/* Current index */
	dp->dir = dp->fs->win.d8 + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */

	return FR_OK;
}
 8004330:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08004334 <remove_chain>:
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004334:	2901      	cmp	r1, #1
static
FRESULT remove_chain (
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8004336:	b570      	push	{r4, r5, r6, lr}
 8004338:	4604      	mov	r4, r0
 800433a:	460d      	mov	r5, r1
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800433c:	d801      	bhi.n	8004342 <remove_chain+0xe>
		res = FR_INT_ERR;
 800433e:	2002      	movs	r0, #2
 8004340:	bd70      	pop	{r4, r5, r6, pc}
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004342:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 8004346:	4299      	cmp	r1, r3
 8004348:	d2f9      	bcs.n	800433e <remove_chain+0xa>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
 800434a:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 800434e:	429d      	cmp	r5, r3
 8004350:	d205      	bcs.n	800435e <remove_chain+0x2a>
			nxt = get_fat(fs, clst);			/* Get cluster status */
 8004352:	4629      	mov	r1, r5
 8004354:	4620      	mov	r0, r4
 8004356:	f7ff fddd 	bl	8003f14 <get_fat>
			if (nxt == 0) break;				/* Empty cluster? */
 800435a:	4606      	mov	r6, r0
 800435c:	b908      	cbnz	r0, 8004362 <remove_chain+0x2e>
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
 800435e:	2000      	movs	r0, #0
 8004360:	bd70      	pop	{r4, r5, r6, pc}
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 8004362:	2801      	cmp	r0, #1
 8004364:	d0eb      	beq.n	800433e <remove_chain+0xa>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8004366:	1c41      	adds	r1, r0, #1
 8004368:	d014      	beq.n	8004394 <remove_chain+0x60>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 800436a:	2200      	movs	r2, #0
 800436c:	4629      	mov	r1, r5
 800436e:	4620      	mov	r0, r4
 8004370:	f7ff fe7f 	bl	8004072 <put_fat>
			if (res != FR_OK) break;
 8004374:	b978      	cbnz	r0, 8004396 <remove_chain+0x62>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
 8004376:	f8d4 3210 	ldr.w	r3, [r4, #528]	; 0x210
 800437a:	1c5a      	adds	r2, r3, #1
 800437c:	d008      	beq.n	8004390 <remove_chain+0x5c>
				fs->free_clust++;
 800437e:	3301      	adds	r3, #1
 8004380:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
				fs->fsi_flag |= 1;
 8004384:	f894 3205 	ldrb.w	r3, [r4, #517]	; 0x205
 8004388:	f043 0301 	orr.w	r3, r3, #1
 800438c:	f884 3205 	strb.w	r3, [r4, #517]	; 0x205
static
FRESULT remove_chain (
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8004390:	4635      	mov	r5, r6
 8004392:	e7da      	b.n	800434a <remove_chain+0x16>
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8004394:	2001      	movs	r0, #1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
 8004396:	bd70      	pop	{r4, r5, r6, pc}

08004398 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8004398:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800439a:	9001      	str	r0, [sp, #4]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 800439c:	a804      	add	r0, sp, #16
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 800439e:	9100      	str	r1, [sp, #0]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 80043a0:	f840 1d04 	str.w	r1, [r0, #-4]!
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 80043a4:	4614      	mov	r4, r2
	int vol;
	FRESULT res;
	const TCHAR *rp = path;


	vol = get_ldnumber(&rp);
 80043a6:	f7ff fb4f 	bl	8003a48 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 80043aa:	1e01      	subs	r1, r0, #0
 80043ac:	db16      	blt.n	80043dc <f_mount+0x44>
	cfs = FatFs[vol];					/* Pointer to fs object */
 80043ae:	4b0e      	ldr	r3, [pc, #56]	; (80043e8 <f_mount+0x50>)
 80043b0:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]

	if (cfs) {
 80043b4:	b110      	cbz	r0, 80043bc <f_mount+0x24>
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 80043b6:	2200      	movs	r2, #0
 80043b8:	f880 2200 	strb.w	r2, [r0, #512]	; 0x200
	}

	if (fs) {
 80043bc:	9801      	ldr	r0, [sp, #4]
 80043be:	b110      	cbz	r0, 80043c6 <f_mount+0x2e>
		fs->fs_type = 0;				/* Clear new fs object */
 80043c0:	2200      	movs	r2, #0
 80043c2:	f880 2200 	strb.w	r2, [r0, #512]	; 0x200
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 80043c6:	f843 0021 	str.w	r0, [r3, r1, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80043ca:	b150      	cbz	r0, 80043e2 <f_mount+0x4a>
 80043cc:	2c01      	cmp	r4, #1
 80043ce:	d107      	bne.n	80043e0 <f_mount+0x48>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
 80043d0:	2200      	movs	r2, #0
 80043d2:	4669      	mov	r1, sp
 80043d4:	a801      	add	r0, sp, #4
 80043d6:	f7ff fc49 	bl	8003c6c <find_volume>
	LEAVE_FF(fs, res);
 80043da:	e002      	b.n	80043e2 <f_mount+0x4a>
	FRESULT res;
	const TCHAR *rp = path;


	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
 80043dc:	200b      	movs	r0, #11
 80043de:	e000      	b.n	80043e2 <f_mount+0x4a>
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 80043e0:	2000      	movs	r0, #0

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 80043e2:	b004      	add	sp, #16
 80043e4:	bd10      	pop	{r4, pc}
 80043e6:	bf00      	nop
 80043e8:	20000188 	.word	0x20000188

080043ec <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 80043ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80043f0:	4698      	mov	r8, r3
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
 80043f2:	2300      	movs	r3, #0
 80043f4:	f8c8 3000 	str.w	r3, [r8]
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 80043f8:	4604      	mov	r4, r0
 80043fa:	460f      	mov	r7, r1
 80043fc:	4616      	mov	r6, r2
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
 80043fe:	f7ff fb3b 	bl	8003a78 <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 8004402:	2800      	cmp	r0, #0
 8004404:	f040 80dd 	bne.w	80045c2 <f_write+0x1d6>
	if (fp->err)							/* Check error */
 8004408:	f894 0207 	ldrb.w	r0, [r4, #519]	; 0x207
 800440c:	2800      	cmp	r0, #0
 800440e:	f040 80d8 	bne.w	80045c2 <f_write+0x1d6>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8004412:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 8004416:	0799      	lsls	r1, r3, #30
 8004418:	f140 80d2 	bpl.w	80045c0 <f_write+0x1d4>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
 800441c:	f8d4 3208 	ldr.w	r3, [r4, #520]	; 0x208
 8004420:	42f3      	cmn	r3, r6
 8004422:	d35d      	bcc.n	80044e0 <f_write+0xf4>
		mem_cpy(&fp->buf.d8[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 8004424:	f8d4 3208 	ldr.w	r3, [r4, #520]	; 0x208
 8004428:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
 800442c:	4293      	cmp	r3, r2
 800442e:	f240 80be 	bls.w	80045ae <f_write+0x1c2>
 8004432:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
 8004436:	e0ba      	b.n	80045ae <f_write+0x1c2>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 8004438:	f8d4 1208 	ldr.w	r1, [r4, #520]	; 0x208
 800443c:	f3c1 0308 	ubfx	r3, r1, #0, #9
 8004440:	2b00      	cmp	r3, #0
 8004442:	f040 809f 	bne.w	8004584 <f_write+0x198>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 8004446:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 800444a:	f890 9202 	ldrb.w	r9, [r0, #514]	; 0x202
 800444e:	f109 39ff 	add.w	r9, r9, #4294967295
 8004452:	ea09 2951 	and.w	r9, r9, r1, lsr #9
			if (!csect) {					/* On the cluster boundary? */
 8004456:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
 800445a:	d044      	beq.n	80044e6 <f_write+0xfa>
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
 800445c:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 8004460:	065b      	lsls	r3, r3, #25
 8004462:	d467      	bmi.n	8004534 <f_write+0x148>
				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 8004464:	f8d4 b200 	ldr.w	fp, [r4, #512]	; 0x200
 8004468:	f8d4 1214 	ldr.w	r1, [r4, #532]	; 0x214
 800446c:	4658      	mov	r0, fp
 800446e:	f7ff fd43 	bl	8003ef8 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8004472:	2800      	cmp	r0, #0
 8004474:	d04c      	beq.n	8004510 <f_write+0x124>
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 8004476:	0a75      	lsrs	r5, r6, #9
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
 8004478:	eb00 0a09 	add.w	sl, r0, r9
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 800447c:	d06d      	beq.n	800455a <f_write+0x16e>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 800447e:	f89b 3202 	ldrb.w	r3, [fp, #514]	; 0x202
					cc = fp->fs->csize - csect;
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
 8004482:	f89b 0201 	ldrb.w	r0, [fp, #513]	; 0x201
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 8004486:	eb09 0205 	add.w	r2, r9, r5
 800448a:	429a      	cmp	r2, r3
					cc = fp->fs->csize - csect;
 800448c:	bf88      	it	hi
 800448e:	ebc9 0503 	rsbhi	r5, r9, r3
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
 8004492:	462b      	mov	r3, r5
 8004494:	4652      	mov	r2, sl
 8004496:	4639      	mov	r1, r7
 8004498:	f7ff fa86 	bl	80039a8 <disk_write>
 800449c:	2800      	cmp	r0, #0
 800449e:	d13b      	bne.n	8004518 <f_write+0x12c>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win.d8, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 80044a0:	f8d4 1218 	ldr.w	r1, [r4, #536]	; 0x218
 80044a4:	ebca 0101 	rsb	r1, sl, r1
 80044a8:	428d      	cmp	r5, r1
 80044aa:	d90c      	bls.n	80044c6 <f_write+0xda>
					mem_cpy(fp->buf.d8, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 80044ac:	f44f 7200 	mov.w	r2, #512	; 0x200
 80044b0:	eb07 2141 	add.w	r1, r7, r1, lsl #9
 80044b4:	4620      	mov	r0, r4
 80044b6:	f7ff fa93 	bl	80039e0 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
 80044ba:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 80044be:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80044c2:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
 80044c6:	026d      	lsls	r5, r5, #9
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 80044c8:	f8d4 3208 	ldr.w	r3, [r4, #520]	; 0x208
 80044cc:	442b      	add	r3, r5
 80044ce:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
 80044d2:	f8d8 3000 	ldr.w	r3, [r8]
 80044d6:	442b      	add	r3, r5
 80044d8:	442f      	add	r7, r5
 80044da:	f8c8 3000 	str.w	r3, [r8]
 80044de:	1b76      	subs	r6, r6, r5
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
 80044e0:	2e00      	cmp	r6, #0
 80044e2:	d1a9      	bne.n	8004438 <f_write+0x4c>
 80044e4:	e79e      	b.n	8004424 <f_write+0x38>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
 80044e6:	b919      	cbnz	r1, 80044f0 <f_write+0x104>
					clst = fp->sclust;		/* Follow from the origin */
 80044e8:	f8d4 1210 	ldr.w	r1, [r4, #528]	; 0x210
					if (clst == 0)			/* When no cluster is allocated, */
 80044ec:	b971      	cbnz	r1, 800450c <f_write+0x120>
 80044ee:	e008      	b.n	8004502 <f_write+0x116>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
 80044f0:	f8d4 3224 	ldr.w	r3, [r4, #548]	; 0x224
 80044f4:	b11b      	cbz	r3, 80044fe <f_write+0x112>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 80044f6:	4620      	mov	r0, r4
 80044f8:	f7ff fa83 	bl	8003a02 <clmt_clust>
 80044fc:	e003      	b.n	8004506 <f_write+0x11a>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 80044fe:	f8d4 1214 	ldr.w	r1, [r4, #532]	; 0x214
 8004502:	f7ff fe2c 	bl	800415e <create_chain>
 8004506:	4601      	mov	r1, r0
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8004508:	2800      	cmp	r0, #0
 800450a:	d08b      	beq.n	8004424 <f_write+0x38>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 800450c:	2901      	cmp	r1, #1
 800450e:	d101      	bne.n	8004514 <f_write+0x128>
 8004510:	2002      	movs	r0, #2
 8004512:	e002      	b.n	800451a <f_write+0x12e>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8004514:	1c4a      	adds	r2, r1, #1
 8004516:	d104      	bne.n	8004522 <f_write+0x136>
 8004518:	2001      	movs	r0, #1
 800451a:	f884 0207 	strb.w	r0, [r4, #519]	; 0x207
 800451e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				fp->clust = clst;			/* Update current cluster */
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
 8004522:	f8d4 3210 	ldr.w	r3, [r4, #528]	; 0x210
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;			/* Update current cluster */
 8004526:	f8c4 1214 	str.w	r1, [r4, #532]	; 0x214
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
 800452a:	2b00      	cmp	r3, #0
 800452c:	d196      	bne.n	800445c <f_write+0x70>
 800452e:	f8c4 1210 	str.w	r1, [r4, #528]	; 0x210
 8004532:	e793      	b.n	800445c <f_write+0x70>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
 8004534:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 8004538:	f8d4 2218 	ldr.w	r2, [r4, #536]	; 0x218
 800453c:	f890 0201 	ldrb.w	r0, [r0, #513]	; 0x201
 8004540:	2301      	movs	r3, #1
 8004542:	4621      	mov	r1, r4
 8004544:	f7ff fa30 	bl	80039a8 <disk_write>
 8004548:	2800      	cmp	r0, #0
 800454a:	d1e5      	bne.n	8004518 <f_write+0x12c>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 800454c:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 8004550:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004554:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
 8004558:	e784      	b.n	8004464 <f_write+0x78>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 800455a:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 800455e:	459a      	cmp	sl, r3
 8004560:	d00e      	beq.n	8004580 <f_write+0x194>
				if (fp->fptr < fp->fsize &&
 8004562:	f8d4 2208 	ldr.w	r2, [r4, #520]	; 0x208
 8004566:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 800456a:	429a      	cmp	r2, r3
 800456c:	d208      	bcs.n	8004580 <f_write+0x194>
					disk_read(fp->fs->drv, fp->buf.d8, sect, 1) != RES_OK)
 800456e:	2301      	movs	r3, #1
 8004570:	4652      	mov	r2, sl
 8004572:	4621      	mov	r1, r4
 8004574:	f89b 0201 	ldrb.w	r0, [fp, #513]	; 0x201
 8004578:	f7ff fa08 	bl	800398c <disk_read>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
 800457c:	2800      	cmp	r0, #0
 800457e:	d1cb      	bne.n	8004518 <f_write+0x12c>
					disk_read(fp->fs->drv, fp->buf.d8, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
 8004580:	f8c4 a218 	str.w	sl, [r4, #536]	; 0x218
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 8004584:	f8d4 0208 	ldr.w	r0, [r4, #520]	; 0x208
 8004588:	f3c0 0008 	ubfx	r0, r0, #0, #9
 800458c:	f5c0 7500 	rsb	r5, r0, #512	; 0x200
 8004590:	42b5      	cmp	r5, r6
 8004592:	bf28      	it	cs
 8004594:	4635      	movcs	r5, r6
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win.d8[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf.d8[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 8004596:	462a      	mov	r2, r5
 8004598:	4639      	mov	r1, r7
 800459a:	4420      	add	r0, r4
 800459c:	f7ff fa20 	bl	80039e0 <mem_cpy>
		fp->flag |= FA__DIRTY;
 80045a0:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 80045a4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80045a8:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
 80045ac:	e78c      	b.n	80044c8 <f_write+0xdc>
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 80045ae:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 80045b2:	f043 0320 	orr.w	r3, r3, #32
 80045b6:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206

	LEAVE_FF(fp->fs, FR_OK);
 80045ba:	2000      	movs	r0, #0
 80045bc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->err)							/* Check error */
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
 80045c0:	2007      	movs	r0, #7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
 80045c2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080045c6 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 80045c6:	b570      	push	{r4, r5, r6, lr}
 80045c8:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
 80045ca:	f7ff fa55 	bl	8003a78 <validate>
	if (res == FR_OK) {
 80045ce:	2800      	cmp	r0, #0
 80045d0:	d15d      	bne.n	800468e <f_sync+0xc8>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 80045d2:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 80045d6:	f003 0220 	and.w	r2, r3, #32
 80045da:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 80045de:	2a00      	cmp	r2, #0
 80045e0:	d055      	beq.n	800468e <f_sync+0xc8>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
 80045e2:	065b      	lsls	r3, r3, #25
 80045e4:	d511      	bpl.n	800460a <f_sync+0x44>
				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
 80045e6:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 80045ea:	f8d4 2218 	ldr.w	r2, [r4, #536]	; 0x218
 80045ee:	f890 0201 	ldrb.w	r0, [r0, #513]	; 0x201
 80045f2:	2301      	movs	r3, #1
 80045f4:	4621      	mov	r1, r4
 80045f6:	f7ff f9d7 	bl	80039a8 <disk_write>
 80045fa:	2800      	cmp	r0, #0
 80045fc:	d145      	bne.n	800468a <f_sync+0xc4>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 80045fe:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 8004602:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004606:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 800460a:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
 800460e:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 8004612:	f7ff fae1 	bl	8003bd8 <move_window>
			if (res == FR_OK) {
 8004616:	4606      	mov	r6, r0
 8004618:	bbc8      	cbnz	r0, 800468e <f_sync+0xc8>
				dir = fp->dir_ptr;
 800461a:	f8d4 5220 	ldr.w	r5, [r4, #544]	; 0x220
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 800461e:	7aeb      	ldrb	r3, [r5, #11]
 8004620:	f043 0320 	orr.w	r3, r3, #32
 8004624:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
 8004626:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 800462a:	772b      	strb	r3, [r5, #28]
 800462c:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 8004630:	121b      	asrs	r3, r3, #8
 8004632:	776b      	strb	r3, [r5, #29]
 8004634:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 8004638:	77ab      	strb	r3, [r5, #30]
 800463a:	f894 320f 	ldrb.w	r3, [r4, #527]	; 0x20f
 800463e:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
 8004640:	f8d4 3210 	ldr.w	r3, [r4, #528]	; 0x210
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8004644:	76ab      	strb	r3, [r5, #26]
 8004646:	121a      	asrs	r2, r3, #8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8004648:	0c1b      	lsrs	r3, r3, #16
 800464a:	752b      	strb	r3, [r5, #20]
 800464c:	121b      	asrs	r3, r3, #8
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 800464e:	76ea      	strb	r2, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8004650:	756b      	strb	r3, [r5, #21]
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = GET_FATTIME();							/* Update updated time */
 8004652:	f7fb fe35 	bl	80002c0 <get_fattime>
				ST_DWORD(dir + DIR_WrtTime, tm);
 8004656:	1203      	asrs	r3, r0, #8
 8004658:	75a8      	strb	r0, [r5, #22]
 800465a:	75eb      	strb	r3, [r5, #23]
 800465c:	0c03      	lsrs	r3, r0, #16
 800465e:	0e00      	lsrs	r0, r0, #24
 8004660:	762b      	strb	r3, [r5, #24]
 8004662:	7668      	strb	r0, [r5, #25]
				ST_WORD(dir + DIR_LstAccDate, 0);
 8004664:	74ae      	strb	r6, [r5, #18]
 8004666:	74ee      	strb	r6, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
 8004668:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 800466c:	f023 0320 	bic.w	r3, r3, #32
 8004670:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
				fp->fs->wflag = 1;
 8004674:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 8004678:	2201      	movs	r2, #1
 800467a:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
				res = sync_fs(fp->fs);
 800467e:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 8004682:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				tm = GET_FATTIME();							/* Update updated time */
				ST_DWORD(dir + DIR_WrtTime, tm);
				ST_WORD(dir + DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
				fp->fs->wflag = 1;
				res = sync_fs(fp->fs);
 8004686:	f7ff ba4c 	b.w	8003b22 <sync_fs>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 800468a:	2001      	movs	r0, #1
 800468c:	bd70      	pop	{r4, r5, r6, pc}
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 800468e:	bd70      	pop	{r4, r5, r6, pc}

08004690 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 8004690:	b510      	push	{r4, lr}
 8004692:	4604      	mov	r4, r0
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 8004694:	f7ff ff97 	bl	80045c6 <f_sync>
	if (res == FR_OK)
 8004698:	b928      	cbnz	r0, 80046a6 <f_close+0x16>
#endif
	{
		res = validate(fp);				/* Lock volume */
 800469a:	4620      	mov	r0, r4
 800469c:	f7ff f9ec 	bl	8003a78 <validate>
		if (res == FR_OK) {
 80046a0:	b908      	cbnz	r0, 80046a6 <f_close+0x16>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
 80046a2:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 80046a6:	bd10      	pop	{r4, pc}

080046a8 <ff_convert>:
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 80046a8:	287f      	cmp	r0, #127	; 0x7f

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	chr,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
)
{
 80046aa:	b510      	push	{r4, lr}
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 80046ac:	d916      	bls.n	80046dc <ff_convert+0x34>
		c = chr;

	} else {
		if (dir) {		/* OEMCP to Unicode */
 80046ae:	b969      	cbnz	r1, 80046cc <ff_convert+0x24>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
				if (chr == Tbl[c]) break;
 80046b0:	4a0b      	ldr	r2, [pc, #44]	; (80046e0 <ff_convert+0x38>)
 80046b2:	f832 4011 	ldrh.w	r4, [r2, r1, lsl #1]
 80046b6:	4284      	cmp	r4, r0
 80046b8:	b28b      	uxth	r3, r1
 80046ba:	d003      	beq.n	80046c4 <ff_convert+0x1c>
 80046bc:	3101      	adds	r1, #1
	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
 80046be:	2980      	cmp	r1, #128	; 0x80
 80046c0:	d1f7      	bne.n	80046b2 <ff_convert+0xa>
 80046c2:	460b      	mov	r3, r1
				if (chr == Tbl[c]) break;
			}
			c = (c + 0x80) & 0xFF;
 80046c4:	f103 0080 	add.w	r0, r3, #128	; 0x80
 80046c8:	b2c0      	uxtb	r0, r0
 80046ca:	bd10      	pop	{r4, pc}
	if (chr < 0x80) {	/* ASCII */
		c = chr;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 80046cc:	28ff      	cmp	r0, #255	; 0xff
 80046ce:	d804      	bhi.n	80046da <ff_convert+0x32>
 80046d0:	4b03      	ldr	r3, [pc, #12]	; (80046e0 <ff_convert+0x38>)
 80046d2:	3880      	subs	r0, #128	; 0x80
 80046d4:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 80046d8:	bd10      	pop	{r4, pc}
 80046da:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
 80046dc:	bd10      	pop	{r4, pc}
 80046de:	bf00      	nop
 80046e0:	08006f96 	.word	0x08006f96

080046e4 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
 80046e4:	4906      	ldr	r1, [pc, #24]	; (8004700 <ff_wtoupper+0x1c>)
 80046e6:	2300      	movs	r3, #0
 80046e8:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
 80046ec:	b132      	cbz	r2, 80046fc <ff_wtoupper+0x18>
 80046ee:	4282      	cmp	r2, r0
 80046f0:	d001      	beq.n	80046f6 <ff_wtoupper+0x12>
 80046f2:	3301      	adds	r3, #1
 80046f4:	e7f8      	b.n	80046e8 <ff_wtoupper+0x4>

	return tbl_lower[i] ? tbl_upper[i] : chr;
 80046f6:	4a03      	ldr	r2, [pc, #12]	; (8004704 <ff_wtoupper+0x20>)
 80046f8:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
}
 80046fc:	4770      	bx	lr
 80046fe:	bf00      	nop
 8004700:	08006b04 	.word	0x08006b04
 8004704:	08006d28 	.word	0x08006d28

08004708 <dir_find.part.9>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
 8004708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	res = dir_sdi(dp, 0);			/* Rewind directory object */
	if (res != FR_OK) return res;

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 800470c:	f64f 79ff 	movw	r9, #65535	; 0xffff
 8004710:	f04f 08ff 	mov.w	r8, #255	; 0xff
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
 8004714:	b085      	sub	sp, #20
 8004716:	4606      	mov	r6, r0

	res = dir_sdi(dp, 0);			/* Rewind directory object */
	if (res != FR_OK) return res;

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8004718:	f8a0 9220 	strh.w	r9, [r0, #544]	; 0x220
 800471c:	4644      	mov	r4, r8
#endif
	do {
		res = move_window(dp->fs, dp->sect);
 800471e:	f8d6 1210 	ldr.w	r1, [r6, #528]	; 0x210
 8004722:	f8d6 0200 	ldr.w	r0, [r6, #512]	; 0x200
 8004726:	f7ff fa57 	bl	8003bd8 <move_window>
		if (res != FR_OK) break;
 800472a:	2800      	cmp	r0, #0
 800472c:	f040 8087 	bne.w	800483e <dir_find.part.9+0x136>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
 8004730:	f8d6 5214 	ldr.w	r5, [r6, #532]	; 0x214
		c = dir[DIR_Name];
 8004734:	782a      	ldrb	r2, [r5, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8004736:	2a00      	cmp	r2, #0
 8004738:	d078      	beq.n	800482c <dir_find.part.9+0x124>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800473a:	2ae5      	cmp	r2, #229	; 0xe5
 800473c:	d069      	beq.n	8004812 <dir_find.part.9+0x10a>
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 800473e:	7ae9      	ldrb	r1, [r5, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8004740:	070f      	lsls	r7, r1, #28
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 8004742:	f001 033f 	and.w	r3, r1, #63	; 0x3f
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8004746:	d502      	bpl.n	800474e <dir_find.part.9+0x46>
 8004748:	2b0f      	cmp	r3, #15
 800474a:	d162      	bne.n	8004812 <dir_find.part.9+0x10a>
 800474c:	e001      	b.n	8004752 <dir_find.part.9+0x4a>
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 800474e:	2b0f      	cmp	r3, #15
 8004750:	d14a      	bne.n	80047e8 <dir_find.part.9+0xe0>
				if (dp->lfn) {
 8004752:	f8d6 b21c 	ldr.w	fp, [r6, #540]	; 0x21c
 8004756:	f1bb 0f00 	cmp.w	fp, #0
 800475a:	d05f      	beq.n	800481c <dir_find.part.9+0x114>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 800475c:	0650      	lsls	r0, r2, #25
 800475e:	d507      	bpl.n	8004770 <dir_find.part.9+0x68>
						sum = dir[LDIR_Chksum];
						c &= ~LLEF; ord = c;	/* LFN start order */
 8004760:	f002 04bf 	and.w	r4, r2, #191	; 0xbf
						dp->lfn_idx = dp->index;	/* Start index of LFN */
 8004764:	f8b6 2206 	ldrh.w	r2, [r6, #518]	; 0x206
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dp->lfn) {
					if (c & LLEF) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
 8004768:	7b69      	ldrb	r1, [r5, #13]
						c &= ~LLEF; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
 800476a:	f8a6 2220 	strh.w	r2, [r6, #544]	; 0x220
 800476e:	e002      	b.n	8004776 <dir_find.part.9+0x6e>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8004770:	42a2      	cmp	r2, r4
 8004772:	d152      	bne.n	800481a <dir_find.part.9+0x112>
 8004774:	4641      	mov	r1, r8
 8004776:	f895 800d 	ldrb.w	r8, [r5, #13]
 800477a:	4588      	cmp	r8, r1
 800477c:	d14c      	bne.n	8004818 <dir_find.part.9+0x110>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Get offset in the LFN buffer */
 800477e:	782b      	ldrb	r3, [r5, #0]
 8004780:	9301      	str	r3, [sp, #4]
 8004782:	f023 0740 	bic.w	r7, r3, #64	; 0x40
 8004786:	1e7a      	subs	r2, r7, #1
 8004788:	270d      	movs	r7, #13
 800478a:	4357      	muls	r7, r2
	s = 0; wc = 1;
 800478c:	2001      	movs	r0, #1
 800478e:	f04f 0a00 	mov.w	sl, #0
	do {
		uc = LD_WORD(dir + LfnOfs[s]);	/* Pick an LFN character from the entry */
 8004792:	4b2c      	ldr	r3, [pc, #176]	; (8004844 <dir_find.part.9+0x13c>)
 8004794:	f81a 1003 	ldrb.w	r1, [sl, r3]
 8004798:	186a      	adds	r2, r5, r1
 800479a:	f892 e001 	ldrb.w	lr, [r2, #1]
 800479e:	5c6a      	ldrb	r2, [r5, r1]
 80047a0:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
		if (wc) {	/* Last character has not been processed */
 80047a4:	b188      	cbz	r0, 80047ca <dir_find.part.9+0xc2>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
 80047a6:	4610      	mov	r0, r2
 80047a8:	f7ff ff9c 	bl	80046e4 <ff_wtoupper>
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 80047ac:	2ffe      	cmp	r7, #254	; 0xfe
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir + LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last character has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
 80047ae:	9003      	str	r0, [sp, #12]
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 80047b0:	d833      	bhi.n	800481a <dir_find.part.9+0x112>
 80047b2:	1c7a      	adds	r2, r7, #1
 80047b4:	f83b 0017 	ldrh.w	r0, [fp, r7, lsl #1]
 80047b8:	9202      	str	r2, [sp, #8]
 80047ba:	f7ff ff93 	bl	80046e4 <ff_wtoupper>
 80047be:	9903      	ldr	r1, [sp, #12]
 80047c0:	4281      	cmp	r1, r0
 80047c2:	d12a      	bne.n	800481a <dir_find.part.9+0x112>
 80047c4:	9a02      	ldr	r2, [sp, #8]
 80047c6:	4617      	mov	r7, r2
 80047c8:	e001      	b.n	80047ce <dir_find.part.9+0xc6>
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
 80047ca:	454a      	cmp	r2, r9
 80047cc:	d125      	bne.n	800481a <dir_find.part.9+0x112>
		}
	} while (++s < 13);				/* Repeat until all characters in the entry are checked */
 80047ce:	f10a 0a01 	add.w	sl, sl, #1
 80047d2:	f1ba 0f0d 	cmp.w	sl, #13
 80047d6:	d1dc      	bne.n	8004792 <dir_find.part.9+0x8a>

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
 80047d8:	9b01      	ldr	r3, [sp, #4]
 80047da:	0659      	lsls	r1, r3, #25
 80047dc:	d52c      	bpl.n	8004838 <dir_find.part.9+0x130>
 80047de:	b358      	cbz	r0, 8004838 <dir_find.part.9+0x130>
 80047e0:	f83b 3017 	ldrh.w	r3, [fp, r7, lsl #1]
 80047e4:	b343      	cbz	r3, 8004838 <dir_find.part.9+0x130>
 80047e6:	e018      	b.n	800481a <dir_find.part.9+0x112>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 80047e8:	b924      	cbnz	r4, 80047f4 <dir_find.part.9+0xec>
 80047ea:	4628      	mov	r0, r5
 80047ec:	f7ff f91d 	bl	8003a2a <sum_sfn>
 80047f0:	4540      	cmp	r0, r8
 80047f2:	d01d      	beq.n	8004830 <dir_find.part.9+0x128>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
 80047f4:	f8d6 3218 	ldr.w	r3, [r6, #536]	; 0x218
 80047f8:	7ada      	ldrb	r2, [r3, #11]
 80047fa:	07d2      	lsls	r2, r2, #31
 80047fc:	d409      	bmi.n	8004812 <dir_find.part.9+0x10a>
 80047fe:	f105 000b 	add.w	r0, r5, #11
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8004802:	4285      	cmp	r5, r0
 8004804:	d016      	beq.n	8004834 <dir_find.part.9+0x12c>
 8004806:	f815 1b01 	ldrb.w	r1, [r5], #1
 800480a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800480e:	4291      	cmp	r1, r2
 8004810:	d0f7      	beq.n	8004802 <dir_find.part.9+0xfa>
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8004812:	f8a6 9220 	strh.w	r9, [r6, #544]	; 0x220
 8004816:	e000      	b.n	800481a <dir_find.part.9+0x112>
						sum = dir[LDIR_Chksum];
						c &= ~LLEF; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8004818:	4688      	mov	r8, r1
 800481a:	24ff      	movs	r4, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
 800481c:	2100      	movs	r1, #0
 800481e:	4630      	mov	r0, r6
 8004820:	f7ff fcf7 	bl	8004212 <dir_next>
	} while (res == FR_OK);
 8004824:	2800      	cmp	r0, #0
 8004826:	f43f af7a 	beq.w	800471e <dir_find.part.9+0x16>
 800482a:	e008      	b.n	800483e <dir_find.part.9+0x136>
	do {
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800482c:	2004      	movs	r0, #4
 800482e:	e006      	b.n	800483e <dir_find.part.9+0x136>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 8004830:	4620      	mov	r0, r4
 8004832:	e004      	b.n	800483e <dir_find.part.9+0x136>
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8004834:	2000      	movs	r0, #0
 8004836:	e002      	b.n	800483e <dir_find.part.9+0x136>
						sum = dir[LDIR_Chksum];
						c &= ~LLEF; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8004838:	3c01      	subs	r4, #1
 800483a:	b2e4      	uxtb	r4, r4
 800483c:	e7ee      	b.n	800481c <dir_find.part.9+0x114>
#endif
		res = dir_next(dp, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
 800483e:	b005      	add	sp, #20
 8004840:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004844:	08006f88 	.word	0x08006f88

08004848 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 8004848:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	UINT n, nent;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
 800484c:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
 8004850:	f8d0 621c 	ldr.w	r6, [r0, #540]	; 0x21c
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 8004854:	b087      	sub	sp, #28
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
	mem_cpy(sn, fn, 12);
 8004856:	220c      	movs	r2, #12
 8004858:	4621      	mov	r1, r4
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 800485a:	4605      	mov	r5, r0
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
	mem_cpy(sn, fn, 12);
 800485c:	eb0d 0002 	add.w	r0, sp, r2
 8004860:	f7ff f8be 	bl	80039e0 <mem_cpy>

	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
 8004864:	f89d 2017 	ldrb.w	r2, [sp, #23]
 8004868:	f002 0120 	and.w	r1, r2, #32
 800486c:	f001 03ff 	and.w	r3, r1, #255	; 0xff
 8004870:	2900      	cmp	r1, #0
 8004872:	f040 80f4 	bne.w	8004a5e <dir_register+0x216>
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 8004876:	07d2      	lsls	r2, r2, #31
 8004878:	d563      	bpl.n	8004942 <dir_register+0xfa>
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
 800487a:	72e3      	strb	r3, [r4, #11]
		for (n = 1; n < 100; n++) {
 800487c:	2701      	movs	r7, #1

	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
 800487e:	f8c5 321c 	str.w	r3, [r5, #540]	; 0x21c
	UINT i, j;
	WCHAR wc;
	DWORD sr;


	mem_cpy(dst, src, 11);
 8004882:	220b      	movs	r2, #11
 8004884:	a903      	add	r1, sp, #12
 8004886:	4620      	mov	r0, r4
 8004888:	f7ff f8aa 	bl	80039e0 <mem_cpy>

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 800488c:	2f05      	cmp	r7, #5
 800488e:	d801      	bhi.n	8004894 <dir_register+0x4c>
 8004890:	463b      	mov	r3, r7
 8004892:	e015      	b.n	80048c0 <dir_register+0x78>
 8004894:	1eb0      	subs	r0, r6, #2
 8004896:	463b      	mov	r3, r7
		sr = seq;
		while (*lfn) {	/* Create a CRC */
 8004898:	f830 2f02 	ldrh.w	r2, [r0, #2]!
 800489c:	b182      	cbz	r2, 80048c0 <dir_register+0x78>
 800489e:	2110      	movs	r1, #16
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
				sr = (sr << 1) + (wc & 1);
 80048a0:	f002 0e01 	and.w	lr, r2, #1
 80048a4:	eb0e 0343 	add.w	r3, lr, r3, lsl #1
				wc >>= 1;
				if (sr & 0x10000) sr ^= 0x11021;
 80048a8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80048ac:	bf1c      	itt	ne
 80048ae:	f483 3388 	eorne.w	r3, r3, #69632	; 0x11000
 80048b2:	f083 0321 	eorne.w	r3, r3, #33	; 0x21

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
		sr = seq;
		while (*lfn) {	/* Create a CRC */
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
 80048b6:	3901      	subs	r1, #1
				sr = (sr << 1) + (wc & 1);
				wc >>= 1;
 80048b8:	ea4f 0252 	mov.w	r2, r2, lsr #1

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
		sr = seq;
		while (*lfn) {	/* Create a CRC */
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
 80048bc:	d1f0      	bne.n	80048a0 <dir_register+0x58>
 80048be:	e7eb      	b.n	8004898 <dir_register+0x50>
	DWORD sr;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 80048c0:	2207      	movs	r2, #7
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
 80048c2:	f003 000f 	and.w	r0, r3, #15
 80048c6:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
 80048ca:	2939      	cmp	r1, #57	; 0x39
 80048cc:	bf88      	it	hi
 80048ce:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
		ns[i--] = c;
 80048d2:	3a01      	subs	r2, #1
 80048d4:	a801      	add	r0, sp, #4
 80048d6:	4410      	add	r0, r2
		seq /= 16;
	} while (seq);
 80048d8:	091b      	lsrs	r3, r3, #4
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
 80048da:	7041      	strb	r1, [r0, #1]
		seq /= 16;
	} while (seq);
 80048dc:	d1f1      	bne.n	80048c2 <dir_register+0x7a>
	ns[i] = '~';
 80048de:	a906      	add	r1, sp, #24
 80048e0:	4411      	add	r1, r2
 80048e2:	207e      	movs	r0, #126	; 0x7e
 80048e4:	f801 0c14 	strb.w	r0, [r1, #-20]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 80048e8:	429a      	cmp	r2, r3
 80048ea:	d004      	beq.n	80048f6 <dir_register+0xae>
 80048ec:	5ce1      	ldrb	r1, [r4, r3]
 80048ee:	2920      	cmp	r1, #32
 80048f0:	d001      	beq.n	80048f6 <dir_register+0xae>
 80048f2:	3301      	adds	r3, #1
 80048f4:	e7f8      	b.n	80048e8 <dir_register+0xa0>
 80048f6:	4423      	add	r3, r4
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 80048f8:	2a07      	cmp	r2, #7
 80048fa:	bf9b      	ittet	ls
 80048fc:	a906      	addls	r1, sp, #24
 80048fe:	1889      	addls	r1, r1, r2
 8004900:	2120      	movhi	r1, #32
 8004902:	f811 1c14 	ldrbls.w	r1, [r1, #-20]
 8004906:	f803 1b01 	strb.w	r1, [r3], #1
	} while (j < 8);
 800490a:	eba3 0104 	sub.w	r1, r3, r4
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800490e:	bf98      	it	ls
 8004910:	3201      	addls	r2, #1
	} while (j < 8);
 8004912:	2907      	cmp	r1, #7
 8004914:	d9f0      	bls.n	80048f8 <dir_register+0xb0>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8004916:	2100      	movs	r1, #0
 8004918:	4628      	mov	r0, r5
 800491a:	f7ff fb5c 	bl	8003fd6 <dir_sdi>
	if (res != FR_OK) return res;
 800491e:	b940      	cbnz	r0, 8004932 <dir_register+0xea>
 8004920:	4628      	mov	r0, r5
 8004922:	f7ff fef1 	bl	8004708 <dir_find.part.9>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
 8004926:	b920      	cbnz	r0, 8004932 <dir_register+0xea>
	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
 8004928:	3701      	adds	r7, #1
 800492a:	2f64      	cmp	r7, #100	; 0x64
 800492c:	d1a9      	bne.n	8004882 <dir_register+0x3a>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 800492e:	2007      	movs	r0, #7
 8004930:	e0be      	b.n	8004ab0 <dir_register+0x268>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 8004932:	2804      	cmp	r0, #4
 8004934:	f040 80bc 	bne.w	8004ab0 <dir_register+0x268>
		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
 8004938:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800493c:	72e3      	strb	r3, [r4, #11]
 800493e:	f8c5 621c 	str.w	r6, [r5, #540]	; 0x21c
	}

	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
 8004942:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8004946:	079b      	lsls	r3, r3, #30
 8004948:	d50a      	bpl.n	8004960 <dir_register+0x118>
 800494a:	2400      	movs	r4, #0
		for (n = 0; lfn[n]; n++) ;
 800494c:	f836 3014 	ldrh.w	r3, [r6, r4, lsl #1]
 8004950:	b10b      	cbz	r3, 8004956 <dir_register+0x10e>
 8004952:	3401      	adds	r4, #1
 8004954:	e7fa      	b.n	800494c <dir_register+0x104>
		nent = (n + 25) / 13;
 8004956:	3419      	adds	r4, #25
 8004958:	230d      	movs	r3, #13
 800495a:	fbb4 f4f3 	udiv	r4, r4, r3
 800495e:	e000      	b.n	8004962 <dir_register+0x11a>
	} else {						/* Otherwise allocate an entry for an SFN  */
		nent = 1;
 8004960:	2401      	movs	r4, #1
{
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
 8004962:	2100      	movs	r1, #0
 8004964:	4628      	mov	r0, r5
 8004966:	f7ff fb36 	bl	8003fd6 <dir_sdi>
	if (res == FR_OK) {
 800496a:	2800      	cmp	r0, #0
 800496c:	f040 809d 	bne.w	8004aaa <dir_register+0x262>
 8004970:	4606      	mov	r6, r0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
 8004972:	f8d5 1210 	ldr.w	r1, [r5, #528]	; 0x210
 8004976:	f8d5 0200 	ldr.w	r0, [r5, #512]	; 0x200
 800497a:	f7ff f92d 	bl	8003bd8 <move_window>
			if (res != FR_OK) break;
 800497e:	2800      	cmp	r0, #0
 8004980:	f040 8093 	bne.w	8004aaa <dir_register+0x262>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
 8004984:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 8004988:	781b      	ldrb	r3, [r3, #0]
 800498a:	2be5      	cmp	r3, #229	; 0xe5
 800498c:	d000      	beq.n	8004990 <dir_register+0x148>
 800498e:	b92b      	cbnz	r3, 800499c <dir_register+0x154>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 8004990:	3601      	adds	r6, #1
 8004992:	42b4      	cmp	r4, r6
 8004994:	d103      	bne.n	800499e <dir_register+0x156>
	} else {						/* Otherwise allocate an entry for an SFN  */
		nent = 1;
	}
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 8004996:	3c01      	subs	r4, #1
 8004998:	d063      	beq.n	8004a62 <dir_register+0x21a>
 800499a:	e007      	b.n	80049ac <dir_register+0x164>
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
 800499c:	4606      	mov	r6, r0
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
 800499e:	2101      	movs	r1, #1
 80049a0:	4628      	mov	r0, r5
 80049a2:	f7ff fc36 	bl	8004212 <dir_next>
		} while (res == FR_OK);
 80049a6:	2800      	cmp	r0, #0
 80049a8:	d0e3      	beq.n	8004972 <dir_register+0x12a>
 80049aa:	e07e      	b.n	8004aaa <dir_register+0x262>
		nent = 1;
	}
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
		res = dir_sdi(dp, dp->index - nent);
 80049ac:	f8b5 1206 	ldrh.w	r1, [r5, #518]	; 0x206
 80049b0:	4628      	mov	r0, r5
 80049b2:	1b09      	subs	r1, r1, r4
 80049b4:	f7ff fb0f 	bl	8003fd6 <dir_sdi>
		if (res == FR_OK) {
 80049b8:	2800      	cmp	r0, #0
 80049ba:	d179      	bne.n	8004ab0 <dir_register+0x268>
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
 80049bc:	f8d5 0218 	ldr.w	r0, [r5, #536]	; 0x218

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 80049c0:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 8004ab8 <dir_register+0x270>
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
		res = dir_sdi(dp, dp->index - nent);
		if (res == FR_OK) {
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
 80049c4:	f7ff f831 	bl	8003a2a <sum_sfn>
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80049c8:	270f      	movs	r7, #15
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
		res = dir_sdi(dp, dp->index - nent);
		if (res == FR_OK) {
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
 80049ca:	4606      	mov	r6, r0
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
 80049cc:	f8d5 1210 	ldr.w	r1, [r5, #528]	; 0x210
 80049d0:	f8d5 0200 	ldr.w	r0, [r5, #512]	; 0x200
 80049d4:	f7ff f900 	bl	8003bd8 <move_window>
 80049d8:	4603      	mov	r3, r0
				if (res != FR_OK) break;
 80049da:	2800      	cmp	r0, #0
 80049dc:	d168      	bne.n	8004ab0 <dir_register+0x268>
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
 80049de:	f8d5 2214 	ldr.w	r2, [r5, #532]	; 0x214
 80049e2:	f8d5 921c 	ldr.w	r9, [r5, #540]	; 0x21c
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
 80049e6:	7310      	strb	r0, [r2, #12]
		if (res == FR_OK) {
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
				if (res != FR_OK) break;
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
 80049e8:	fa5f fe84 	uxtb.w	lr, r4


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir + LDIR_FstClusLO, 0);
 80049ec:	7690      	strb	r0, [r2, #26]
 80049ee:	76d0      	strb	r0, [r2, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
 80049f0:	f10e 31ff 	add.w	r1, lr, #4294967295
 80049f4:	200d      	movs	r0, #13
 80049f6:	4341      	muls	r1, r0
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
 80049f8:	7356      	strb	r6, [r2, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80049fa:	72d7      	strb	r7, [r2, #11]
	dir[LDIR_Type] = 0;
	ST_WORD(dir + LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
 80049fc:	4618      	mov	r0, r3
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 80049fe:	f64f 7aff 	movw	sl, #65535	; 0xffff
 8004a02:	4550      	cmp	r0, sl
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004a04:	f813 c008 	ldrb.w	ip, [r3, r8]
	ST_WORD(dir + LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8004a08:	bf18      	it	ne
 8004a0a:	f839 0011 	ldrhne.w	r0, [r9, r1, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004a0e:	f802 000c 	strb.w	r0, [r2, ip]
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
	} while (++s < 13);
 8004a12:	f103 0301 	add.w	r3, r3, #1

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004a16:	4494      	add	ip, r2
	ST_WORD(dir + LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8004a18:	bf18      	it	ne
 8004a1a:	3101      	addne	r1, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004a1c:	ea4f 2b10 	mov.w	fp, r0, lsr #8
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
 8004a20:	2800      	cmp	r0, #0
 8004a22:	bf08      	it	eq
 8004a24:	4650      	moveq	r0, sl
	} while (++s < 13);
 8004a26:	2b0d      	cmp	r3, #13

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004a28:	f88c b001 	strb.w	fp, [ip, #1]
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
	} while (++s < 13);
 8004a2c:	d1e9      	bne.n	8004a02 <dir_register+0x1ba>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLEF;	/* Bottom LFN part is the start of LFN sequence */
 8004a2e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004a32:	4298      	cmp	r0, r3
 8004a34:	d002      	beq.n	8004a3c <dir_register+0x1f4>
 8004a36:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
 8004a3a:	b90b      	cbnz	r3, 8004a40 <dir_register+0x1f8>
 8004a3c:	f04e 0e40 	orr.w	lr, lr, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 8004a40:	f882 e000 	strb.w	lr, [r2]
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
				if (res != FR_OK) break;
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
				dp->fs->wflag = 1;
 8004a44:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
 8004a48:	2201      	movs	r2, #1
 8004a4a:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
				res = dir_next(dp, 0);	/* Next entry */
 8004a4e:	2100      	movs	r1, #0
 8004a50:	4628      	mov	r0, r5
 8004a52:	f7ff fbde 	bl	8004212 <dir_next>
			} while (res == FR_OK && --nent);
 8004a56:	bb58      	cbnz	r0, 8004ab0 <dir_register+0x268>
 8004a58:	3c01      	subs	r4, #1
 8004a5a:	d1b7      	bne.n	80049cc <dir_register+0x184>
 8004a5c:	e001      	b.n	8004a62 <dir_register+0x21a>

	fn = dp->fn; lfn = dp->lfn;
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;
 8004a5e:	2006      	movs	r0, #6
 8004a60:	e026      	b.n	8004ab0 <dir_register+0x268>
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
#endif

	if (res == FR_OK) {				/* Set SFN entry */
		res = move_window(dp->fs, dp->sect);
 8004a62:	f8d5 1210 	ldr.w	r1, [r5, #528]	; 0x210
 8004a66:	f8d5 0200 	ldr.w	r0, [r5, #512]	; 0x200
 8004a6a:	f7ff f8b5 	bl	8003bd8 <move_window>
		if (res == FR_OK) {
 8004a6e:	4604      	mov	r4, r0
 8004a70:	b9c8      	cbnz	r0, 8004aa6 <dir_register+0x25e>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
 8004a72:	2220      	movs	r2, #32
 8004a74:	4621      	mov	r1, r4
 8004a76:	f8d5 0214 	ldr.w	r0, [r5, #532]	; 0x214
 8004a7a:	f7fe ffbb 	bl	80039f4 <mem_set>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
 8004a7e:	220b      	movs	r2, #11
 8004a80:	f8d5 1218 	ldr.w	r1, [r5, #536]	; 0x218
 8004a84:	f8d5 0214 	ldr.w	r0, [r5, #532]	; 0x214
 8004a88:	f7fe ffaa 	bl	80039e0 <mem_cpy>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 8004a8c:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004a90:	f8d5 2214 	ldr.w	r2, [r5, #532]	; 0x214
 8004a94:	7adb      	ldrb	r3, [r3, #11]
 8004a96:	f003 0318 	and.w	r3, r3, #24
 8004a9a:	7313      	strb	r3, [r2, #12]
#endif
			dp->fs->wflag = 1;
 8004a9c:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
 8004aa0:	2201      	movs	r2, #1
 8004aa2:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
 8004aa6:	4620      	mov	r0, r4
 8004aa8:	e002      	b.n	8004ab0 <dir_register+0x268>
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
		} while (res == FR_OK);
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8004aaa:	2804      	cmp	r0, #4
 8004aac:	bf08      	it	eq
 8004aae:	2007      	moveq	r0, #7
			dp->fs->wflag = 1;
		}
	}

	return res;
}
 8004ab0:	b007      	add	sp, #28
 8004ab2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004ab6:	bf00      	nop
 8004ab8:	08006f88 	.word	0x08006f88

08004abc <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8004abc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
 8004ac0:	780b      	ldrb	r3, [r1, #0]
 8004ac2:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8004ac4:	4605      	mov	r5, r0
 8004ac6:	4688      	mov	r8, r1
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
 8004ac8:	d001      	beq.n	8004ace <follow_path+0x12>
 8004aca:	2b5c      	cmp	r3, #92	; 0x5c
 8004acc:	d103      	bne.n	8004ad6 <follow_path+0x1a>
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
 8004ace:	f108 0801 	add.w	r8, r8, #1
 8004ad2:	2300      	movs	r3, #0
 8004ad4:	e003      	b.n	8004ade <follow_path+0x22>
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
 8004ad6:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 8004ada:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8004ade:	f8c5 3208 	str.w	r3, [r5, #520]	; 0x208
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
		path++;
	dp->sclust = 0;							/* Always start from the root directory */
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8004ae2:	f898 3000 	ldrb.w	r3, [r8]
 8004ae6:	2b1f      	cmp	r3, #31
 8004ae8:	d84e      	bhi.n	8004b88 <follow_path+0xcc>
		res = dir_sdi(dp, 0);
 8004aea:	2100      	movs	r1, #0
 8004aec:	4628      	mov	r0, r5
 8004aee:	f7ff fa72 	bl	8003fd6 <dir_sdi>
		dp->dir = 0;
 8004af2:	2300      	movs	r3, #0
 8004af4:	f8c5 3214 	str.w	r3, [r5, #532]	; 0x214
 8004af8:	e13b      	b.n	8004d72 <follow_path+0x2b6>
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 8004afa:	2b5c      	cmp	r3, #92	; 0x5c
 8004afc:	d044      	beq.n	8004b88 <follow_path+0xcc>
	lfn = dp->lfn;
 8004afe:	f8d5 921c 	ldr.w	r9, [r5, #540]	; 0x21c
 8004b02:	f104 3aff 	add.w	sl, r4, #4294967295
 8004b06:	f1a9 0702 	sub.w	r7, r9, #2
	si = di = 0;
 8004b0a:	2600      	movs	r6, #0
	for (;;) {
		w = p[si++];					/* Get a character */
 8004b0c:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8004b10:	281f      	cmp	r0, #31
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dp->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
 8004b12:	f106 0801 	add.w	r8, r6, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8004b16:	d83f      	bhi.n	8004b98 <follow_path+0xdc>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
	}
	*path = &p[si];						/* Return pointer to the next segment */
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8004b18:	2820      	cmp	r0, #32
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
	}
	*path = &p[si];						/* Return pointer to the next segment */
 8004b1a:	44a0      	add	r8, r4
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8004b1c:	bf34      	ite	cc
 8004b1e:	2404      	movcc	r4, #4
 8004b20:	2400      	movcs	r4, #0
#if _FS_RPATH
	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
 8004b22:	2e01      	cmp	r6, #1
 8004b24:	d151      	bne.n	8004bca <follow_path+0x10e>
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
 8004b26:	f8b9 3000 	ldrh.w	r3, [r9]
 8004b2a:	2b2e      	cmp	r3, #46	; 0x2e
 8004b2c:	d153      	bne.n	8004bd6 <follow_path+0x11a>
		lfn[di] = 0;
 8004b2e:	2300      	movs	r3, #0
 8004b30:	f829 3016 	strh.w	r3, [r9, r6, lsl #1]
		for (i = 0; i < 11; i++)
			dp->fn[i] = (i < di) ? '.' : ' ';
 8004b34:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
 8004b38:	429e      	cmp	r6, r3
 8004b3a:	bf8c      	ite	hi
 8004b3c:	212e      	movhi	r1, #46	; 0x2e
 8004b3e:	2120      	movls	r1, #32
 8004b40:	54d1      	strb	r1, [r2, r3]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
#if _FS_RPATH
	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
		lfn[di] = 0;
		for (i = 0; i < 11; i++)
 8004b42:	3301      	adds	r3, #1
 8004b44:	2b0b      	cmp	r3, #11
 8004b46:	d1f5      	bne.n	8004b34 <follow_path+0x78>
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
 8004b48:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004b4c:	f044 0420 	orr.w	r4, r4, #32
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
 8004b50:	72dc      	strb	r4, [r3, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8004b52:	2100      	movs	r1, #0
 8004b54:	4628      	mov	r0, r5
 8004b56:	f7ff fa3e 	bl	8003fd6 <dir_sdi>
	if (res != FR_OK) return res;
 8004b5a:	b910      	cbnz	r0, 8004b62 <follow_path+0xa6>
 8004b5c:	4628      	mov	r0, r5
 8004b5e:	f7ff fdd3 	bl	8004708 <dir_find.part.9>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
 8004b62:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004b66:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
 8004b68:	2800      	cmp	r0, #0
 8004b6a:	d042      	beq.n	8004bf2 <follow_path+0x136>
				if (res == FR_NO_FILE) {	/* Object is not found */
 8004b6c:	2804      	cmp	r0, #4
 8004b6e:	f040 8100 	bne.w	8004d72 <follow_path+0x2b6>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
 8004b72:	f013 0f20 	tst.w	r3, #32
 8004b76:	f003 0304 	and.w	r3, r3, #4
 8004b7a:	d03e      	beq.n	8004bfa <follow_path+0x13e>
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
 8004b7c:	2200      	movs	r2, #0
 8004b7e:	f8c5 2208 	str.w	r2, [r5, #520]	; 0x208
 8004b82:	f8c5 2214 	str.w	r2, [r5, #532]	; 0x214
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
 8004b86:	bbb3      	cbnz	r3, 8004bf6 <follow_path+0x13a>
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 8004b88:	f898 3000 	ldrb.w	r3, [r8]
 8004b8c:	2b2f      	cmp	r3, #47	; 0x2f
 8004b8e:	4644      	mov	r4, r8
 8004b90:	f108 0801 	add.w	r8, r8, #1
 8004b94:	d1b1      	bne.n	8004afa <follow_path+0x3e>
 8004b96:	e7f7      	b.n	8004b88 <follow_path+0xcc>
	lfn = dp->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8004b98:	282f      	cmp	r0, #47	; 0x2f
 8004b9a:	d0bd      	beq.n	8004b18 <follow_path+0x5c>
 8004b9c:	285c      	cmp	r0, #92	; 0x5c
 8004b9e:	d0bb      	beq.n	8004b18 <follow_path+0x5c>
		if (di >= _MAX_LFN)				/* Reject too long name */
 8004ba0:	f5b8 7f80 	cmp.w	r8, #256	; 0x100
 8004ba4:	d03c      	beq.n	8004c20 <follow_path+0x164>
			w = (w << 8) + b;			/* Create a DBC */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
#endif
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 8004ba6:	2101      	movs	r1, #1
 8004ba8:	f7ff fd7e 	bl	80046a8 <ff_convert>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8004bac:	2800      	cmp	r0, #0
 8004bae:	d037      	beq.n	8004c20 <follow_path+0x164>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
 8004bb0:	287f      	cmp	r0, #127	; 0x7f
 8004bb2:	d806      	bhi.n	8004bc2 <follow_path+0x106>
 8004bb4:	4a70      	ldr	r2, [pc, #448]	; (8004d78 <follow_path+0x2bc>)
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 8004bb6:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8004bba:	b113      	cbz	r3, 8004bc2 <follow_path+0x106>
 8004bbc:	4298      	cmp	r0, r3
 8004bbe:	d1fa      	bne.n	8004bb6 <follow_path+0xfa>
 8004bc0:	e02e      	b.n	8004c20 <follow_path+0x164>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
 8004bc2:	f827 0f02 	strh.w	r0, [r7, #2]!
 8004bc6:	4646      	mov	r6, r8
 8004bc8:	e7a0      	b.n	8004b0c <follow_path+0x50>
	}
	*path = &p[si];						/* Return pointer to the next segment */
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
#if _FS_RPATH
	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
 8004bca:	2e02      	cmp	r6, #2
 8004bcc:	d103      	bne.n	8004bd6 <follow_path+0x11a>
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
 8004bce:	f8b9 3002 	ldrh.w	r3, [r9, #2]
 8004bd2:	2b2e      	cmp	r3, #46	; 0x2e
 8004bd4:	d0a7      	beq.n	8004b26 <follow_path+0x6a>
 8004bd6:	eb09 0346 	add.w	r3, r9, r6, lsl #1
 8004bda:	e004      	b.n	8004be6 <follow_path+0x12a>
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
		w = lfn[di - 1];
 8004bdc:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
		if (w != ' ' && w != '.') break;
 8004be0:	2a20      	cmp	r2, #32
 8004be2:	d103      	bne.n	8004bec <follow_path+0x130>
		di--;
 8004be4:	3e01      	subs	r6, #1
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
 8004be6:	2e00      	cmp	r6, #0
 8004be8:	d1f8      	bne.n	8004bdc <follow_path+0x120>
 8004bea:	e019      	b.n	8004c20 <follow_path+0x164>
		w = lfn[di - 1];
		if (w != ' ' && w != '.') break;
 8004bec:	2a2e      	cmp	r2, #46	; 0x2e
 8004bee:	d0f9      	beq.n	8004be4 <follow_path+0x128>
 8004bf0:	e01a      	b.n	8004c28 <follow_path+0x16c>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8004bf2:	075a      	lsls	r2, r3, #29
 8004bf4:	d506      	bpl.n	8004c04 <follow_path+0x148>
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
 8004bf6:	2000      	movs	r0, #0
 8004bf8:	e0bb      	b.n	8004d72 <follow_path+0x2b6>
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8004bfa:	2b00      	cmp	r3, #0
 8004bfc:	bf14      	ite	ne
 8004bfe:	2004      	movne	r0, #4
 8004c00:	2005      	moveq	r0, #5
 8004c02:	e0b6      	b.n	8004d72 <follow_path+0x2b6>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
 8004c04:	f8d5 1214 	ldr.w	r1, [r5, #532]	; 0x214
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
 8004c08:	7acb      	ldrb	r3, [r1, #11]
 8004c0a:	06db      	lsls	r3, r3, #27
 8004c0c:	d50a      	bpl.n	8004c24 <follow_path+0x168>
 8004c0e:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
 8004c12:	f893 0200 	ldrb.w	r0, [r3, #512]	; 0x200
 8004c16:	f7fe ff46 	bl	8003aa6 <ld_clust.isra.0>
 8004c1a:	f8c5 0208 	str.w	r0, [r5, #520]	; 0x208
 8004c1e:	e7b3      	b.n	8004b88 <follow_path+0xcc>
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
#endif
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8004c20:	2006      	movs	r0, #6
 8004c22:	e0a6      	b.n	8004d72 <follow_path+0x2b6>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8004c24:	2005      	movs	r0, #5
			}
			dp->sclust = ld_clust(dp->fs, dir);
		}
	}

	return res;
 8004c26:	e0a4      	b.n	8004d72 <follow_path+0x2b6>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
 8004c28:	2300      	movs	r3, #0

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
 8004c2a:	2120      	movs	r1, #32
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
 8004c2c:	f829 3016 	strh.w	r3, [r9, r6, lsl #1]

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
 8004c30:	220b      	movs	r2, #11
 8004c32:	f8d5 0218 	ldr.w	r0, [r5, #536]	; 0x218
 8004c36:	f7fe fedd 	bl	80039f4 <mem_set>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
 8004c3a:	eb09 0746 	add.w	r7, r9, r6, lsl #1

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 8004c3e:	4619      	mov	r1, r3
 8004c40:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
 8004c44:	2b20      	cmp	r3, #32
 8004c46:	d101      	bne.n	8004c4c <follow_path+0x190>
 8004c48:	3101      	adds	r1, #1
 8004c4a:	e7f9      	b.n	8004c40 <follow_path+0x184>
 8004c4c:	2b2e      	cmp	r3, #46	; 0x2e
 8004c4e:	d0fb      	beq.n	8004c48 <follow_path+0x18c>
	if (si) cf |= NS_LOSS | NS_LFN;
 8004c50:	b109      	cbz	r1, 8004c56 <follow_path+0x19a>
 8004c52:	f044 0403 	orr.w	r4, r4, #3
 8004c56:	463b      	mov	r3, r7
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 8004c58:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
 8004c5c:	2a2e      	cmp	r2, #46	; 0x2e
 8004c5e:	d001      	beq.n	8004c64 <follow_path+0x1a8>
 8004c60:	3e01      	subs	r6, #1
 8004c62:	d1f9      	bne.n	8004c58 <follow_path+0x19c>
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8004c64:	2300      	movs	r3, #0
 8004c66:	f04f 0a08 	mov.w	sl, #8
 8004c6a:	461f      	mov	r7, r3
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
 8004c6c:	f839 0011 	ldrh.w	r0, [r9, r1, lsl #1]
 8004c70:	f101 0b01 	add.w	fp, r1, #1
		if (!w) break;					/* Break on end of the LFN */
 8004c74:	2800      	cmp	r0, #0
 8004c76:	d049      	beq.n	8004d0c <follow_path+0x250>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8004c78:	2820      	cmp	r0, #32
 8004c7a:	d003      	beq.n	8004c84 <follow_path+0x1c8>
 8004c7c:	282e      	cmp	r0, #46	; 0x2e
 8004c7e:	d105      	bne.n	8004c8c <follow_path+0x1d0>
 8004c80:	455e      	cmp	r6, fp
 8004c82:	d008      	beq.n	8004c96 <follow_path+0x1da>
			cf |= NS_LOSS | NS_LFN; continue;
 8004c84:	f044 0403 	orr.w	r4, r4, #3
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8004c88:	4659      	mov	r1, fp
 8004c8a:	e7ef      	b.n	8004c6c <follow_path+0x1b0>
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
 8004c8c:	4553      	cmp	r3, sl
 8004c8e:	d204      	bcs.n	8004c9a <follow_path+0x1de>
 8004c90:	455e      	cmp	r6, fp
 8004c92:	d116      	bne.n	8004cc2 <follow_path+0x206>
 8004c94:	e069      	b.n	8004d6a <follow_path+0x2ae>
 8004c96:	4553      	cmp	r3, sl
 8004c98:	d367      	bcc.n	8004d6a <follow_path+0x2ae>
			if (ni == 11) {				/* Long extension */
 8004c9a:	f1ba 0f0b 	cmp.w	sl, #11
 8004c9e:	d104      	bne.n	8004caa <follow_path+0x1ee>
				cf |= NS_LOSS | NS_LFN; break;
 8004ca0:	f044 0403 	orr.w	r4, r4, #3
 8004ca4:	f04f 0a0b 	mov.w	sl, #11
 8004ca8:	e030      	b.n	8004d0c <follow_path+0x250>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 8004caa:	455e      	cmp	r6, fp
 8004cac:	d002      	beq.n	8004cb4 <follow_path+0x1f8>
 8004cae:	f044 0403 	orr.w	r4, r4, #3
			if (si > di) break;			/* No extension */
 8004cb2:	d32b      	bcc.n	8004d0c <follow_path+0x250>
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
 8004cb4:	00bf      	lsls	r7, r7, #2
 8004cb6:	b2ff      	uxtb	r7, r7
 8004cb8:	46b3      	mov	fp, r6
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8004cba:	f04f 0a0b 	mov.w	sl, #11
 8004cbe:	2308      	movs	r3, #8
 8004cc0:	e7e2      	b.n	8004c88 <follow_path+0x1cc>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII character */
 8004cc2:	287f      	cmp	r0, #127	; 0x7f
 8004cc4:	d90c      	bls.n	8004ce0 <follow_path+0x224>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 8004cc6:	2100      	movs	r1, #0
 8004cc8:	9301      	str	r3, [sp, #4]
 8004cca:	f7ff fced 	bl	80046a8 <ff_convert>
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 8004cce:	9b01      	ldr	r3, [sp, #4]
 8004cd0:	b118      	cbz	r0, 8004cda <follow_path+0x21e>
 8004cd2:	4a2a      	ldr	r2, [pc, #168]	; (8004d7c <follow_path+0x2c0>)
 8004cd4:	4410      	add	r0, r2
 8004cd6:	f810 0c80 	ldrb.w	r0, [r0, #-128]
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
 8004cda:	f044 0402 	orr.w	r4, r4, #2
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 8004cde:	b128      	cbz	r0, 8004cec <follow_path+0x230>
 8004ce0:	4a27      	ldr	r2, [pc, #156]	; (8004d80 <follow_path+0x2c4>)
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 8004ce2:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8004ce6:	b129      	cbz	r1, 8004cf4 <follow_path+0x238>
 8004ce8:	4288      	cmp	r0, r1
 8004cea:	d1fa      	bne.n	8004ce2 <follow_path+0x226>
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 8004cec:	f044 0403 	orr.w	r4, r4, #3
 8004cf0:	205f      	movs	r0, #95	; 0x5f
 8004cf2:	e006      	b.n	8004d02 <follow_path+0x246>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
 8004cf4:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
 8004cf8:	b289      	uxth	r1, r1
 8004cfa:	2919      	cmp	r1, #25
 8004cfc:	d82b      	bhi.n	8004d56 <follow_path+0x29a>
					b |= 2;
 8004cfe:	f047 0702 	orr.w	r7, r7, #2
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
 8004d02:	f8d5 1218 	ldr.w	r1, [r5, #536]	; 0x218
 8004d06:	54c8      	strb	r0, [r1, r3]
 8004d08:	3301      	adds	r3, #1
 8004d0a:	e7bd      	b.n	8004c88 <follow_path+0x1cc>
	}

	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with deleted mark, replace it with RDDEM */
 8004d0c:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004d10:	781a      	ldrb	r2, [r3, #0]
 8004d12:	2ae5      	cmp	r2, #229	; 0xe5
 8004d14:	bf04      	itt	eq
 8004d16:	2205      	moveq	r2, #5
 8004d18:	701a      	strbeq	r2, [r3, #0]

	if (ni == 8) b <<= 2;
 8004d1a:	f1ba 0f08 	cmp.w	sl, #8
 8004d1e:	bf04      	itt	eq
 8004d20:	00bf      	lsleq	r7, r7, #2
 8004d22:	b2ff      	uxtbeq	r7, r7
 8004d24:	f007 030c 	and.w	r3, r7, #12
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
 8004d28:	2b0c      	cmp	r3, #12
 8004d2a:	d003      	beq.n	8004d34 <follow_path+0x278>
 8004d2c:	f007 0203 	and.w	r2, r7, #3
 8004d30:	2a03      	cmp	r2, #3
 8004d32:	d101      	bne.n	8004d38 <follow_path+0x27c>
		cf |= NS_LFN;
 8004d34:	f044 0402 	orr.w	r4, r4, #2
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 8004d38:	07a1      	lsls	r1, r4, #30
 8004d3a:	d409      	bmi.n	8004d50 <follow_path+0x294>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 8004d3c:	f007 0703 	and.w	r7, r7, #3
 8004d40:	2f01      	cmp	r7, #1
 8004d42:	bf08      	it	eq
 8004d44:	f044 0410 	orreq.w	r4, r4, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 8004d48:	2b04      	cmp	r3, #4
 8004d4a:	bf08      	it	eq
 8004d4c:	f044 0408 	orreq.w	r4, r4, #8
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
 8004d50:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004d54:	e6fc      	b.n	8004b50 <follow_path+0x94>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
 8004d56:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
 8004d5a:	b289      	uxth	r1, r1
 8004d5c:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
 8004d5e:	bf9e      	ittt	ls
 8004d60:	3820      	subls	r0, #32
 8004d62:	f047 0701 	orrls.w	r7, r7, #1
 8004d66:	b280      	uxthls	r0, r0
 8004d68:	e7cb      	b.n	8004d02 <follow_path+0x246>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
 8004d6a:	f1ba 0f0b 	cmp.w	sl, #11
 8004d6e:	d1a1      	bne.n	8004cb4 <follow_path+0x1f8>
 8004d70:	e796      	b.n	8004ca0 <follow_path+0x1e4>
			dp->sclust = ld_clust(dp->fs, dir);
		}
	}

	return res;
}
 8004d72:	b003      	add	sp, #12
 8004d74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004d78:	08006d17 	.word	0x08006d17
 8004d7c:	08006f08 	.word	0x08006f08
 8004d80:	08006d20 	.word	0x08006d20

08004d84 <f_chdir>:


FRESULT f_chdir (
	const TCHAR* path	/* Pointer to the directory path */
)
{
 8004d84:	b530      	push	{r4, r5, lr}
 8004d86:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
	DIR dj;
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
 8004d8a:	2200      	movs	r2, #0


FRESULT f_chdir (
	const TCHAR* path	/* Pointer to the directory path */
)
{
 8004d8c:	9001      	str	r0, [sp, #4]
	DIR dj;
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
 8004d8e:	a901      	add	r1, sp, #4
 8004d90:	a885      	add	r0, sp, #532	; 0x214
 8004d92:	f7fe ff6b 	bl	8003c6c <find_volume>
	if (res == FR_OK) {
 8004d96:	bb68      	cbnz	r0, 8004df4 <f_chdir+0x70>
		INIT_BUF(dj);
 8004d98:	f44f 7000 	mov.w	r0, #512	; 0x200
 8004d9c:	f000 fa7a 	bl	8005294 <ff_memalloc>
 8004da0:	4605      	mov	r5, r0
 8004da2:	b308      	cbz	r0, 8004de8 <f_chdir+0x64>
 8004da4:	908c      	str	r0, [sp, #560]	; 0x230
 8004da6:	ab02      	add	r3, sp, #8
		res = follow_path(&dj, path);		/* Follow the path */
 8004da8:	9901      	ldr	r1, [sp, #4]


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004daa:	938b      	str	r3, [sp, #556]	; 0x22c
		res = follow_path(&dj, path);		/* Follow the path */
 8004dac:	a805      	add	r0, sp, #20
 8004dae:	f7ff fe85 	bl	8004abc <follow_path>
 8004db2:	4604      	mov	r4, r0
		FREE_BUF();
 8004db4:	4628      	mov	r0, r5
 8004db6:	f000 fa6f 	bl	8005298 <ff_memfree>
		if (res == FR_OK) {					/* Follow completed */
 8004dba:	b98c      	cbnz	r4, 8004de0 <f_chdir+0x5c>
			if (!dj.dir) {
 8004dbc:	998a      	ldr	r1, [sp, #552]	; 0x228
 8004dbe:	b921      	cbnz	r1, 8004dca <f_chdir+0x46>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
 8004dc0:	9b85      	ldr	r3, [sp, #532]	; 0x214
 8004dc2:	9a87      	ldr	r2, [sp, #540]	; 0x21c
 8004dc4:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
 8004dc8:	e00c      	b.n	8004de4 <f_chdir+0x60>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
 8004dca:	7acb      	ldrb	r3, [r1, #11]
 8004dcc:	06db      	lsls	r3, r3, #27
 8004dce:	d50f      	bpl.n	8004df0 <f_chdir+0x6c>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
 8004dd0:	9d85      	ldr	r5, [sp, #532]	; 0x214
 8004dd2:	f895 0200 	ldrb.w	r0, [r5, #512]	; 0x200
 8004dd6:	f7fe fe66 	bl	8003aa6 <ld_clust.isra.0>
 8004dda:	f8c5 0214 	str.w	r0, [r5, #532]	; 0x214
 8004dde:	e001      	b.n	8004de4 <f_chdir+0x60>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8004de0:	2c04      	cmp	r4, #4
 8004de2:	d003      	beq.n	8004dec <f_chdir+0x68>


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004de4:	4620      	mov	r0, r4
 8004de6:	e005      	b.n	8004df4 <f_chdir+0x70>
 8004de8:	2011      	movs	r0, #17
 8004dea:	e003      	b.n	8004df4 <f_chdir+0x70>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8004dec:	2005      	movs	r0, #5
 8004dee:	e001      	b.n	8004df4 <f_chdir+0x70>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
 8004df0:	2405      	movs	r4, #5
 8004df2:	e7f7      	b.n	8004de4 <f_chdir+0x60>
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}

	LEAVE_FF(dj.fs, res);
}
 8004df4:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
 8004df8:	bd30      	pop	{r4, r5, pc}

08004dfa <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8004dfa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004dfe:	f5ad 7d0e 	sub.w	sp, sp, #568	; 0x238
 8004e02:	4691      	mov	r9, r2
 8004e04:	9101      	str	r1, [sp, #4]
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
 8004e06:	4606      	mov	r6, r0
 8004e08:	2800      	cmp	r0, #0
 8004e0a:	f000 80a5 	beq.w	8004f58 <f_open+0x15e>
	fp->fs = 0;			/* Clear file object */
 8004e0e:	2300      	movs	r3, #0
 8004e10:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
 8004e14:	f002 021e 	and.w	r2, r2, #30
 8004e18:	a901      	add	r1, sp, #4
 8004e1a:	a885      	add	r0, sp, #532	; 0x214
 8004e1c:	f7fe ff26 	bl	8003c6c <find_volume>
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
 8004e20:	2800      	cmp	r0, #0
 8004e22:	f040 80a6 	bne.w	8004f72 <f_open+0x178>
		INIT_BUF(dj);
 8004e26:	f44f 7000 	mov.w	r0, #512	; 0x200
 8004e2a:	f000 fa33 	bl	8005294 <ff_memalloc>
 8004e2e:	4680      	mov	r8, r0
 8004e30:	2800      	cmp	r0, #0
 8004e32:	f000 8093 	beq.w	8004f5c <f_open+0x162>
 8004e36:	908c      	str	r0, [sp, #560]	; 0x230
 8004e38:	ab02      	add	r3, sp, #8
		res = follow_path(&dj, path);	/* Follow the file path */
 8004e3a:	9901      	ldr	r1, [sp, #4]
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004e3c:	938b      	str	r3, [sp, #556]	; 0x22c
		res = follow_path(&dj, path);	/* Follow the file path */
 8004e3e:	a805      	add	r0, sp, #20
 8004e40:	f7ff fe3c 	bl	8004abc <follow_path>
		dir = dj.dir;
 8004e44:	9d8a      	ldr	r5, [sp, #552]	; 0x228
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 8004e46:	4604      	mov	r4, r0
 8004e48:	b910      	cbnz	r0, 8004e50 <f_open+0x56>
			if (!dir)	/* Default directory itself */
				res = FR_INVALID_NAME;
 8004e4a:	2d00      	cmp	r5, #0
 8004e4c:	bf08      	it	eq
 8004e4e:	2406      	moveq	r4, #6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8004e50:	f019 0f1c 	tst.w	r9, #28
	if (!fp) return FR_INVALID_OBJECT;
	fp->fs = 0;			/* Clear file object */

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 8004e54:	f009 071f 	and.w	r7, r9, #31
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8004e58:	d048      	beq.n	8004eec <f_open+0xf2>
			if (res != FR_OK) {					/* No file, create new */
 8004e5a:	b15c      	cbz	r4, 8004e74 <f_open+0x7a>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 8004e5c:	2c04      	cmp	r4, #4
 8004e5e:	d103      	bne.n	8004e68 <f_open+0x6e>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
 8004e60:	a805      	add	r0, sp, #20
 8004e62:	f7ff fcf1 	bl	8004848 <dir_register>
 8004e66:	4604      	mov	r4, r0
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 8004e68:	f047 0708 	orr.w	r7, r7, #8
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8004e6c:	2c00      	cmp	r4, #0
 8004e6e:	d17c      	bne.n	8004f6a <f_open+0x170>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
 8004e70:	9d8a      	ldr	r5, [sp, #552]	; 0x228
 8004e72:	e006      	b.n	8004e82 <f_open+0x88>
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8004e74:	7aeb      	ldrb	r3, [r5, #11]
 8004e76:	f013 0f11 	tst.w	r3, #17
 8004e7a:	d173      	bne.n	8004f64 <f_open+0x16a>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 8004e7c:	f019 0f04 	tst.w	r9, #4
 8004e80:	d172      	bne.n	8004f68 <f_open+0x16e>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8004e82:	0738      	lsls	r0, r7, #28
 8004e84:	d540      	bpl.n	8004f08 <f_open+0x10e>
				dw = GET_FATTIME();				/* Created time */
 8004e86:	f7fb fa1b 	bl	80002c0 <get_fattime>
				ST_DWORD(dir + DIR_CrtTime, dw);
 8004e8a:	1203      	asrs	r3, r0, #8
				dir[DIR_Attr] = 0;				/* Reset attribute */
 8004e8c:	2400      	movs	r4, #0
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
				dw = GET_FATTIME();				/* Created time */
				ST_DWORD(dir + DIR_CrtTime, dw);
 8004e8e:	73a8      	strb	r0, [r5, #14]
 8004e90:	73eb      	strb	r3, [r5, #15]
 8004e92:	0c03      	lsrs	r3, r0, #16
 8004e94:	0e00      	lsrs	r0, r0, #24
 8004e96:	742b      	strb	r3, [r5, #16]
 8004e98:	7468      	strb	r0, [r5, #17]
				dir[DIR_Attr] = 0;				/* Reset attribute */
 8004e9a:	72ec      	strb	r4, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
 8004e9c:	772c      	strb	r4, [r5, #28]
 8004e9e:	776c      	strb	r4, [r5, #29]
 8004ea0:	77ac      	strb	r4, [r5, #30]
 8004ea2:	77ec      	strb	r4, [r5, #31]
 8004ea4:	9b85      	ldr	r3, [sp, #532]	; 0x214
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
 8004ea6:	4629      	mov	r1, r5
 8004ea8:	f893 0200 	ldrb.w	r0, [r3, #512]	; 0x200
 8004eac:	f7fe fdfb 	bl	8003aa6 <ld_clust.isra.0>
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8004eb0:	76ac      	strb	r4, [r5, #26]
 8004eb2:	76ec      	strb	r4, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8004eb4:	752c      	strb	r4, [r5, #20]
 8004eb6:	756c      	strb	r4, [r5, #21]
				ST_DWORD(dir + DIR_CrtTime, dw);
				dir[DIR_Attr] = 0;				/* Reset attribute */
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
 8004eb8:	9b85      	ldr	r3, [sp, #532]	; 0x214
 8004eba:	2201      	movs	r2, #1
 8004ebc:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
				if (cl) {						/* Remove the cluster chain if exist */
 8004ec0:	4681      	mov	r9, r0
 8004ec2:	b1f8      	cbz	r0, 8004f04 <f_open+0x10a>
					dw = dj.fs->winsect;
					res = remove_chain(dj.fs, cl);
 8004ec4:	4601      	mov	r1, r0
 8004ec6:	4618      	mov	r0, r3
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
				if (cl) {						/* Remove the cluster chain if exist */
					dw = dj.fs->winsect;
 8004ec8:	f8d3 a230 	ldr.w	sl, [r3, #560]	; 0x230
					res = remove_chain(dj.fs, cl);
 8004ecc:	f7ff fa32 	bl	8004334 <remove_chain>
					if (res == FR_OK) {
 8004ed0:	4604      	mov	r4, r0
 8004ed2:	2800      	cmp	r0, #0
 8004ed4:	d149      	bne.n	8004f6a <f_open+0x170>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8004ed6:	9885      	ldr	r0, [sp, #532]	; 0x214
 8004ed8:	f109 33ff 	add.w	r3, r9, #4294967295
 8004edc:	f8c0 320c 	str.w	r3, [r0, #524]	; 0x20c
						res = move_window(dj.fs, dw);
 8004ee0:	4651      	mov	r1, sl
 8004ee2:	f7fe fe79 	bl	8003bd8 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
 8004ee6:	4604      	mov	r4, r0
 8004ee8:	b150      	cbz	r0, 8004f00 <f_open+0x106>
 8004eea:	e015      	b.n	8004f18 <f_open+0x11e>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Follow succeeded */
 8004eec:	2c00      	cmp	r4, #0
 8004eee:	d13c      	bne.n	8004f6a <f_open+0x170>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
 8004ef0:	7aeb      	ldrb	r3, [r5, #11]
 8004ef2:	06d9      	lsls	r1, r3, #27
 8004ef4:	d434      	bmi.n	8004f60 <f_open+0x166>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 8004ef6:	f019 0f02 	tst.w	r9, #2
 8004efa:	d001      	beq.n	8004f00 <f_open+0x106>
 8004efc:	07da      	lsls	r2, r3, #31
 8004efe:	d431      	bmi.n	8004f64 <f_open+0x16a>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 8004f00:	073b      	lsls	r3, r7, #28
 8004f02:	d501      	bpl.n	8004f08 <f_open+0x10e>
				mode |= FA__WRITTEN;
 8004f04:	f047 0720 	orr.w	r7, r7, #32
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 8004f08:	9b85      	ldr	r3, [sp, #532]	; 0x214
 8004f0a:	f8d3 3230 	ldr.w	r3, [r3, #560]	; 0x230
 8004f0e:	f8c6 321c 	str.w	r3, [r6, #540]	; 0x21c
			fp->dir_ptr = dir;
 8004f12:	f8c6 5220 	str.w	r5, [r6, #544]	; 0x220
 8004f16:	2400      	movs	r4, #0
				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
					res = FR_NO_FILE;
			}
		}
#endif
		FREE_BUF();
 8004f18:	4640      	mov	r0, r8
 8004f1a:	f000 f9bd 	bl	8005298 <ff_memfree>

		if (res == FR_OK) {
 8004f1e:	bb3c      	cbnz	r4, 8004f70 <f_open+0x176>
			fp->flag = mode;					/* File access mode */
 8004f20:	f886 7206 	strb.w	r7, [r6, #518]	; 0x206
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 8004f24:	9f85      	ldr	r7, [sp, #532]	; 0x214
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
 8004f26:	f886 4207 	strb.w	r4, [r6, #519]	; 0x207
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 8004f2a:	f897 0200 	ldrb.w	r0, [r7, #512]	; 0x200
 8004f2e:	4629      	mov	r1, r5
 8004f30:	f7fe fdb9 	bl	8003aa6 <ld_clust.isra.0>
 8004f34:	f8c6 0210 	str.w	r0, [r6, #528]	; 0x210
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
 8004f38:	69eb      	ldr	r3, [r5, #28]
 8004f3a:	f8c6 320c 	str.w	r3, [r6, #524]	; 0x20c
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
 8004f3e:	f8b7 3206 	ldrh.w	r3, [r7, #518]	; 0x206
		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
			fp->fptr = 0;						/* File pointer */
 8004f42:	f8c6 4208 	str.w	r4, [r6, #520]	; 0x208
			fp->dsect = 0;
 8004f46:	f8c6 4218 	str.w	r4, [r6, #536]	; 0x218
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
 8004f4a:	f8c6 4224 	str.w	r4, [r6, #548]	; 0x224
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
 8004f4e:	f8c6 7200 	str.w	r7, [r6, #512]	; 0x200
			fp->id = fp->fs->id;
 8004f52:	f8a6 3204 	strh.w	r3, [r6, #516]	; 0x204
 8004f56:	e00b      	b.n	8004f70 <f_open+0x176>
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
 8004f58:	2009      	movs	r0, #9
 8004f5a:	e00a      	b.n	8004f72 <f_open+0x178>
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004f5c:	2011      	movs	r0, #17
 8004f5e:	e008      	b.n	8004f72 <f_open+0x178>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
					res = FR_NO_FILE;
 8004f60:	2404      	movs	r4, #4
 8004f62:	e002      	b.n	8004f6a <f_open+0x170>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
 8004f64:	2407      	movs	r4, #7
 8004f66:	e000      	b.n	8004f6a <f_open+0x170>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
 8004f68:	2408      	movs	r4, #8
				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
					res = FR_NO_FILE;
			}
		}
#endif
		FREE_BUF();
 8004f6a:	4640      	mov	r0, r8
 8004f6c:	f000 f994 	bl	8005298 <ff_memfree>
 8004f70:	4620      	mov	r0, r4
			fp->id = fp->fs->id;
		}
	}

	LEAVE_FF(dj.fs, res);
}
 8004f72:	f50d 7d0e 	add.w	sp, sp, #568	; 0x238
 8004f76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08004f7a <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
 8004f7a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004f7e:	f5ad 7d15 	sub.w	sp, sp, #596	; 0x254
 8004f82:	9007      	str	r0, [sp, #28]
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
 8004f84:	f7fb f99c 	bl	80002c0 <get_fattime>
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
 8004f88:	2201      	movs	r2, #1
)
{
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
 8004f8a:	4607      	mov	r7, r0
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
 8004f8c:	a907      	add	r1, sp, #28
 8004f8e:	a88b      	add	r0, sp, #556	; 0x22c
 8004f90:	f7fe fe6c 	bl	8003c6c <find_volume>
	if (res == FR_OK) {
 8004f94:	2800      	cmp	r0, #0
 8004f96:	f040 80e9 	bne.w	800516c <f_mkdir+0x1f2>
		INIT_BUF(dj);
 8004f9a:	f44f 7000 	mov.w	r0, #512	; 0x200
 8004f9e:	f000 f979 	bl	8005294 <ff_memalloc>
 8004fa2:	4682      	mov	sl, r0
 8004fa4:	b1b8      	cbz	r0, 8004fd6 <f_mkdir+0x5c>
 8004fa6:	9092      	str	r0, [sp, #584]	; 0x248
 8004fa8:	ab08      	add	r3, sp, #32
		res = follow_path(&dj, path);			/* Follow the file path */
 8004faa:	9907      	ldr	r1, [sp, #28]


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004fac:	9391      	str	r3, [sp, #580]	; 0x244
		res = follow_path(&dj, path);			/* Follow the file path */
 8004fae:	a80b      	add	r0, sp, #44	; 0x2c
 8004fb0:	f7ff fd84 	bl	8004abc <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8004fb4:	4604      	mov	r4, r0
 8004fb6:	b180      	cbz	r0, 8004fda <f_mkdir+0x60>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
 8004fb8:	2804      	cmp	r0, #4
 8004fba:	d107      	bne.n	8004fcc <f_mkdir+0x52>
 8004fbc:	9b91      	ldr	r3, [sp, #580]	; 0x244
 8004fbe:	7adb      	ldrb	r3, [r3, #11]
 8004fc0:	f003 0320 	and.w	r3, r3, #32
 8004fc4:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 8004fc8:	b14b      	cbz	r3, 8004fde <f_mkdir+0x64>
			res = FR_INVALID_NAME;
 8004fca:	2406      	movs	r4, #6
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
			}
		}
		FREE_BUF();
 8004fcc:	4650      	mov	r0, sl
 8004fce:	f000 f963 	bl	8005298 <ff_memfree>
 8004fd2:	4620      	mov	r0, r4
 8004fd4:	e0ca      	b.n	800516c <f_mkdir+0x1f2>


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004fd6:	2011      	movs	r0, #17
 8004fd8:	e0c8      	b.n	800516c <f_mkdir+0x1f2>
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8004fda:	2408      	movs	r4, #8
 8004fdc:	e7f6      	b.n	8004fcc <f_mkdir+0x52>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
 8004fde:	988b      	ldr	r0, [sp, #556]	; 0x22c
 8004fe0:	f7ff f8bd 	bl	800415e <create_chain>
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8004fe4:	4606      	mov	r6, r0
 8004fe6:	b138      	cbz	r0, 8004ff8 <f_mkdir+0x7e>
			if (dcl == 1) res = FR_INT_ERR;
 8004fe8:	2e01      	cmp	r6, #1
 8004fea:	d107      	bne.n	8004ffc <f_mkdir+0x82>
 8004fec:	2402      	movs	r4, #2
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
 8004fee:	4631      	mov	r1, r6
 8004ff0:	988b      	ldr	r0, [sp, #556]	; 0x22c
 8004ff2:	f7ff f99f 	bl	8004334 <remove_chain>
 8004ff6:	e7e9      	b.n	8004fcc <f_mkdir+0x52>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8004ff8:	2407      	movs	r4, #7
 8004ffa:	e7f8      	b.n	8004fee <f_mkdir+0x74>
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8004ffc:	1c73      	adds	r3, r6, #1
 8004ffe:	f000 8089 	beq.w	8005114 <f_mkdir+0x19a>
			if (res == FR_OK)					/* Flush FAT */
				res = sync_window(dj.fs);
 8005002:	988b      	ldr	r0, [sp, #556]	; 0x22c
 8005004:	f7fe fd86 	bl	8003b14 <sync_window>
			if (res == FR_OK) {					/* Initialize the new directory table */
 8005008:	4604      	mov	r4, r0
 800500a:	2800      	cmp	r0, #0
 800500c:	d1ef      	bne.n	8004fee <f_mkdir+0x74>
				dsc = clust2sect(dj.fs, dcl);
 800500e:	9d8b      	ldr	r5, [sp, #556]	; 0x22c
 8005010:	4631      	mov	r1, r6
 8005012:	4628      	mov	r0, r5
 8005014:	f7fe ff70 	bl	8003ef8 <clust2sect>
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
 8005018:	4621      	mov	r1, r4
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
				res = sync_window(dj.fs);
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
 800501a:	9006      	str	r0, [sp, #24]
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
 800501c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005020:	4628      	mov	r0, r5
 8005022:	f7fe fce7 	bl	80039f4 <mem_set>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
 8005026:	220b      	movs	r2, #11
 8005028:	2120      	movs	r1, #32
 800502a:	4628      	mov	r0, r5
 800502c:	f7fe fce2 	bl	80039f4 <mem_set>
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
 8005030:	f3c7 2307 	ubfx	r3, r7, #8, #8
 8005034:	9300      	str	r3, [sp, #0]
 8005036:	f89d 3000 	ldrb.w	r3, [sp]
 800503a:	75eb      	strb	r3, [r5, #23]
 800503c:	f3c7 4307 	ubfx	r3, r7, #16, #8
 8005040:	9301      	str	r3, [sp, #4]
 8005042:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8005046:	762b      	strb	r3, [r5, #24]
 8005048:	0e3b      	lsrs	r3, r7, #24
 800504a:	9302      	str	r3, [sp, #8]
 800504c:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8005050:	766b      	strb	r3, [r5, #25]
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8005052:	b2f3      	uxtb	r3, r6
 8005054:	9303      	str	r3, [sp, #12]
 8005056:	f89d 300c 	ldrb.w	r3, [sp, #12]
 800505a:	76ab      	strb	r3, [r5, #26]
 800505c:	f3c6 2307 	ubfx	r3, r6, #8, #8
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
 8005060:	2210      	movs	r2, #16
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8005062:	9304      	str	r3, [sp, #16]
 8005064:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8005068:	76eb      	strb	r3, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 800506a:	fa26 f802 	lsr.w	r8, r6, r2
 800506e:	fa5f f388 	uxtb.w	r3, r8
 8005072:	9305      	str	r3, [sp, #20]
 8005074:	f89d 3014 	ldrb.w	r3, [sp, #20]
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
 8005078:	72ea      	strb	r2, [r5, #11]
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
 800507a:	242e      	movs	r4, #46	; 0x2e
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
 800507c:	2220      	movs	r2, #32
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
 800507e:	fa5f fb87 	uxtb.w	fp, r7
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005082:	ea4f 2818 	mov.w	r8, r8, lsr #8
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
 8005086:	18a8      	adds	r0, r5, r2
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005088:	752b      	strb	r3, [r5, #20]
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
 800508a:	4629      	mov	r1, r5
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
 800508c:	702c      	strb	r4, [r5, #0]
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
 800508e:	f885 b016 	strb.w	fp, [r5, #22]
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005092:	f885 8015 	strb.w	r8, [r5, #21]
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
 8005096:	f7fe fca3 	bl	80039e0 <mem_cpy>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
 800509a:	f885 4021 	strb.w	r4, [r5, #33]	; 0x21
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 800509e:	998b      	ldr	r1, [sp, #556]	; 0x22c
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
 80050a0:	9a8d      	ldr	r2, [sp, #564]	; 0x234
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 80050a2:	f891 0200 	ldrb.w	r0, [r1, #512]	; 0x200
 80050a6:	9b06      	ldr	r3, [sp, #24]
 80050a8:	2803      	cmp	r0, #3
 80050aa:	d104      	bne.n	80050b6 <f_mkdir+0x13c>
 80050ac:	f8d1 1228 	ldr.w	r1, [r1, #552]	; 0x228
					pcl = 0;
 80050b0:	428a      	cmp	r2, r1
 80050b2:	bf08      	it	eq
 80050b4:	2200      	moveq	r2, #0
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 80050b6:	f885 203a 	strb.w	r2, [r5, #58]	; 0x3a
 80050ba:	1211      	asrs	r1, r2, #8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 80050bc:	0c12      	lsrs	r2, r2, #16
 80050be:	f885 2034 	strb.w	r2, [r5, #52]	; 0x34
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 80050c2:	af0b      	add	r7, sp, #44	; 0x2c
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 80050c4:	1212      	asrs	r2, r2, #8
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 80050c6:	f885 103b 	strb.w	r1, [r5, #59]	; 0x3b
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 80050ca:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 80050ce:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 80050d2:	f892 9202 	ldrb.w	r9, [r2, #514]	; 0x202
 80050d6:	f1b9 0f00 	cmp.w	r9, #0
 80050da:	d01d      	beq.n	8005118 <f_mkdir+0x19e>
					dj.fs->winsect = dsc++;
 80050dc:	f8d7 0200 	ldr.w	r0, [r7, #512]	; 0x200
 80050e0:	1c5a      	adds	r2, r3, #1
 80050e2:	f8c0 3230 	str.w	r3, [r0, #560]	; 0x230
					dj.fs->wflag = 1;
 80050e6:	f04f 0301 	mov.w	r3, #1
 80050ea:	f880 3204 	strb.w	r3, [r0, #516]	; 0x204
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
 80050ee:	9206      	str	r2, [sp, #24]
 80050f0:	f7fe fce7 	bl	8003ac2 <sync_window.part.1>
					dj.fs->wflag = 1;
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
 80050f4:	4604      	mov	r4, r0
 80050f6:	2800      	cmp	r0, #0
 80050f8:	f47f af79 	bne.w	8004fee <f_mkdir+0x74>
					mem_set(dir, 0, SS(dj.fs));
 80050fc:	4601      	mov	r1, r0
 80050fe:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005102:	4628      	mov	r0, r5
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 8005104:	f109 39ff 	add.w	r9, r9, #4294967295
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
 8005108:	f7fe fc74 	bl	80039f4 <mem_set>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 800510c:	fa5f f989 	uxtb.w	r9, r9
					dj.fs->winsect = dsc++;
 8005110:	9b06      	ldr	r3, [sp, #24]
 8005112:	e7e0      	b.n	80050d6 <f_mkdir+0x15c>
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8005114:	2401      	movs	r4, #1
 8005116:	e76a      	b.n	8004fee <f_mkdir+0x74>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
 8005118:	4638      	mov	r0, r7
 800511a:	f7ff fb95 	bl	8004848 <dir_register>
			if (res != FR_OK) {
 800511e:	4604      	mov	r4, r0
 8005120:	2800      	cmp	r0, #0
 8005122:	f47f af64 	bne.w	8004fee <f_mkdir+0x74>
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
 8005126:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
 800512a:	2210      	movs	r2, #16
 800512c:	72da      	strb	r2, [r3, #11]
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
 800512e:	f89d 2000 	ldrb.w	r2, [sp]
 8005132:	75da      	strb	r2, [r3, #23]
 8005134:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8005138:	761a      	strb	r2, [r3, #24]
 800513a:	f89d 2008 	ldrb.w	r2, [sp, #8]
 800513e:	765a      	strb	r2, [r3, #25]
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8005140:	f89d 200c 	ldrb.w	r2, [sp, #12]
 8005144:	769a      	strb	r2, [r3, #26]
 8005146:	f89d 2010 	ldrb.w	r2, [sp, #16]
 800514a:	76da      	strb	r2, [r3, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 800514c:	f89d 2014 	ldrb.w	r2, [sp, #20]
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
 8005150:	f883 b016 	strb.w	fp, [r3, #22]
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005154:	751a      	strb	r2, [r3, #20]
 8005156:	f883 8015 	strb.w	r8, [r3, #21]
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
 800515a:	f8d7 0200 	ldr.w	r0, [r7, #512]	; 0x200
 800515e:	2301      	movs	r3, #1
 8005160:	f880 3204 	strb.w	r3, [r0, #516]	; 0x204
				res = sync_fs(dj.fs);
 8005164:	f7fe fcdd 	bl	8003b22 <sync_fs>
 8005168:	4604      	mov	r4, r0
 800516a:	e72f      	b.n	8004fcc <f_mkdir+0x52>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
 800516c:	f50d 7d15 	add.w	sp, sp, #596	; 0x254
 8005170:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08005174 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 8005174:	b530      	push	{r4, r5, lr}
  uint8_t ret = 1;
  uint8_t DiskNum = 0;
  
  if(disk.nbr <= _VOLUMES)
 8005176:	4b0f      	ldr	r3, [pc, #60]	; (80051b4 <FATFS_LinkDriverEx+0x40>)
 8005178:	7a5c      	ldrb	r4, [r3, #9]
 800517a:	2c01      	cmp	r4, #1
 800517c:	d818      	bhi.n	80051b0 <FATFS_LinkDriverEx+0x3c>
  {
    disk.is_initialized[disk.nbr] = 0;
 800517e:	7a5d      	ldrb	r5, [r3, #9]
 8005180:	b2ed      	uxtb	r5, r5
 8005182:	2400      	movs	r4, #0
 8005184:	555c      	strb	r4, [r3, r5]
    disk.drv[disk.nbr] = drv;  
 8005186:	7a5d      	ldrb	r5, [r3, #9]
 8005188:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 800518c:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;  
 800518e:	7a58      	ldrb	r0, [r3, #9]
 8005190:	4418      	add	r0, r3
 8005192:	7202      	strb	r2, [r0, #8]
    DiskNum = disk.nbr++;
 8005194:	7a5a      	ldrb	r2, [r3, #9]
 8005196:	b2d2      	uxtb	r2, r2
 8005198:	1c50      	adds	r0, r2, #1
 800519a:	b2c0      	uxtb	r0, r0
 800519c:	7258      	strb	r0, [r3, #9]
    path[0] = DiskNum + '0';
    path[1] = ':';
 800519e:	233a      	movs	r3, #58	; 0x3a
  {
    disk.is_initialized[disk.nbr] = 0;
    disk.drv[disk.nbr] = drv;  
    disk.lun[disk.nbr] = lun;  
    DiskNum = disk.nbr++;
    path[0] = DiskNum + '0';
 80051a0:	3230      	adds	r2, #48	; 0x30
    path[1] = ':';
 80051a2:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
 80051a4:	232f      	movs	r3, #47	; 0x2f
  {
    disk.is_initialized[disk.nbr] = 0;
    disk.drv[disk.nbr] = drv;  
    disk.lun[disk.nbr] = lun;  
    DiskNum = disk.nbr++;
    path[0] = DiskNum + '0';
 80051a6:	700a      	strb	r2, [r1, #0]
    path[1] = ':';
    path[2] = '/';
 80051a8:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 80051aa:	70cc      	strb	r4, [r1, #3]
 80051ac:	4620      	mov	r0, r4
 80051ae:	bd30      	pop	{r4, r5, pc}
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
 80051b0:	2001      	movs	r0, #1
    path[3] = 0;
    ret = 0;
  }
  
  return ret;
}
 80051b2:	bd30      	pop	{r4, r5, pc}
 80051b4:	2000018c 	.word	0x2000018c

080051b8 <FATFS_LinkDriver>:
  * @param  path: pointer to the logical drive path 
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
 80051b8:	2200      	movs	r2, #0
 80051ba:	f7ff bfdb 	b.w	8005174 <FATFS_LinkDriverEx>
	...

080051c0 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used 
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 80051c0:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 80051c2:	4c06      	ldr	r4, [pc, #24]	; (80051dc <SD_initialize+0x1c>)
 80051c4:	2301      	movs	r3, #1
 80051c6:	7023      	strb	r3, [r4, #0]
  
  /* Configure the uSD device */
  if(BSP_SD_Init() == MSD_OK)
 80051c8:	f7fb f828 	bl	800021c <BSP_SD_Init>
 80051cc:	4623      	mov	r3, r4
 80051ce:	b918      	cbnz	r0, 80051d8 <SD_initialize+0x18>
  {
    Stat &= ~STA_NOINIT;
 80051d0:	7822      	ldrb	r2, [r4, #0]
 80051d2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 80051d6:	7022      	strb	r2, [r4, #0]
  }

  return Stat;
 80051d8:	7818      	ldrb	r0, [r3, #0]
}
 80051da:	bd10      	pop	{r4, pc}
 80051dc:	20000058 	.word	0x20000058

080051e0 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 80051e0:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 80051e2:	4c06      	ldr	r4, [pc, #24]	; (80051fc <SD_status+0x1c>)
 80051e4:	2301      	movs	r3, #1
 80051e6:	7023      	strb	r3, [r4, #0]

  if(BSP_SD_GetStatus() == MSD_OK)
 80051e8:	f7fb f850 	bl	800028c <BSP_SD_GetStatus>
 80051ec:	4623      	mov	r3, r4
 80051ee:	b918      	cbnz	r0, 80051f8 <SD_status+0x18>
  {
    Stat &= ~STA_NOINIT;
 80051f0:	7822      	ldrb	r2, [r4, #0]
 80051f2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 80051f6:	7022      	strb	r2, [r4, #0]
  }
  
  return Stat;
 80051f8:	7818      	ldrb	r0, [r3, #0]
}
 80051fa:	bd10      	pop	{r4, pc}
 80051fc:	20000058 	.word	0x20000058

08005200 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 8005200:	b507      	push	{r0, r1, r2, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_ReadBlocks((uint32_t*)buff, 
 8005202:	9301      	str	r3, [sp, #4]
 8005204:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005208:	9300      	str	r3, [sp, #0]
 800520a:	0252      	lsls	r2, r2, #9
 800520c:	2300      	movs	r3, #0
 800520e:	4608      	mov	r0, r1
 8005210:	f7fb f818 	bl	8000244 <BSP_SD_ReadBlocks>
  {
    res = RES_ERROR;
  }
  
  return res;
}
 8005214:	3000      	adds	r0, #0
 8005216:	bf18      	it	ne
 8005218:	2001      	movne	r0, #1
 800521a:	b003      	add	sp, #12
 800521c:	f85d fb04 	ldr.w	pc, [sp], #4

08005220 <SD_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 8005220:	b507      	push	{r0, r1, r2, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_WriteBlocks((uint32_t*)buff, 
 8005222:	9301      	str	r3, [sp, #4]
 8005224:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005228:	9300      	str	r3, [sp, #0]
 800522a:	0252      	lsls	r2, r2, #9
 800522c:	2300      	movs	r3, #0
 800522e:	4608      	mov	r0, r1
 8005230:	f7fb f81a 	bl	8000268 <BSP_SD_WriteBlocks>
  {
    res = RES_ERROR;
  }
  
  return res;
}
 8005234:	3000      	adds	r0, #0
 8005236:	bf18      	it	ne
 8005238:	2001      	movne	r0, #1
 800523a:	b003      	add	sp, #12
 800523c:	f85d fb04 	ldr.w	pc, [sp], #4

08005240 <SD_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 8005240:	b510      	push	{r4, lr}
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8005242:	4b13      	ldr	r3, [pc, #76]	; (8005290 <SD_ioctl+0x50>)
 8005244:	781b      	ldrb	r3, [r3, #0]
 8005246:	07db      	lsls	r3, r3, #31
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 8005248:	b096      	sub	sp, #88	; 0x58
 800524a:	4614      	mov	r4, r2
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 800524c:	d41a      	bmi.n	8005284 <SD_ioctl+0x44>
  
  switch (cmd)
 800524e:	2903      	cmp	r1, #3
 8005250:	d803      	bhi.n	800525a <SD_ioctl+0x1a>
 8005252:	e8df f001 	tbb	[pc, r1]
 8005256:	0419      	.short	0x0419
 8005258:	120e      	.short	0x120e
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
    break;
  
  default:
    res = RES_PARERR;
 800525a:	2004      	movs	r0, #4
 800525c:	e015      	b.n	800528a <SD_ioctl+0x4a>
    res = RES_OK;
    break;
  
  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    BSP_SD_GetCardInfo(&CardInfo);
 800525e:	4668      	mov	r0, sp
 8005260:	f7fb f81a 	bl	8000298 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.CardCapacity / BLOCK_SIZE;
 8005264:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8005266:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8005268:	0a5b      	lsrs	r3, r3, #9
 800526a:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 800526e:	6023      	str	r3, [r4, #0]
 8005270:	e00a      	b.n	8005288 <SD_ioctl+0x48>
    res = RES_OK;
    break;
  
  /* Get R/W sector size (WORD) */
  case GET_SECTOR_SIZE :
    *(WORD*)buff = BLOCK_SIZE;
 8005272:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005276:	8013      	strh	r3, [r2, #0]
 8005278:	e006      	b.n	8005288 <SD_ioctl+0x48>
    res = RES_OK;
    break;
  
  /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
 800527a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800527e:	6013      	str	r3, [r2, #0]
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
 8005280:	2001      	movs	r0, #1
    break;
  
  /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
    break;
 8005282:	e002      	b.n	800528a <SD_ioctl+0x4a>
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8005284:	2003      	movs	r0, #3
 8005286:	e000      	b.n	800528a <SD_ioctl+0x4a>
  
  switch (cmd)
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC :
    res = RES_OK;
 8005288:	2000      	movs	r0, #0
  default:
    res = RES_PARERR;
  }
  
  return res;
}
 800528a:	b016      	add	sp, #88	; 0x58
 800528c:	bd10      	pop	{r4, pc}
 800528e:	bf00      	nop
 8005290:	20000058 	.word	0x20000058

08005294 <ff_memalloc>:

void* ff_memalloc (	/* Returns pointer to the allocated memory block */
	UINT msize		/* Number of bytes to allocate */
)
{
	return malloc(msize);	/* Allocate a new memory block with POSIX API */
 8005294:	f001 baf4 	b.w	8006880 <malloc>

08005298 <ff_memfree>:

void ff_memfree (
	void* mblock	/* Pointer to the memory block to free */
)
{
	free(mblock);	/* Discard the memory block with POSIX API */
 8005298:	f001 bafa 	b.w	8006890 <free>

0800529c <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 800529c:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 800529e:	b180      	cbz	r0, 80052c2 <USBD_Init+0x26>
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 80052a0:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80052a4:	b113      	cbz	r3, 80052ac <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 80052a6:	2300      	movs	r3, #0
 80052a8:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 80052ac:	b109      	cbz	r1, 80052b2 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 80052ae:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 80052b2:	2301      	movs	r3, #1
 80052b4:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 80052b8:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 80052ba:	f7fb fac7 	bl	800084c <USBD_LL_Init>
  
  return USBD_OK; 
 80052be:	2000      	movs	r0, #0
 80052c0:	bd08      	pop	{r3, pc}
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
 80052c2:	2002      	movs	r0, #2
  pdev->id = id;
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  
  return USBD_OK; 
}
 80052c4:	bd08      	pop	{r3, pc}

080052c6 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 80052c6:	b119      	cbz	r1, 80052d0 <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 80052c8:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 80052cc:	2000      	movs	r0, #0
 80052ce:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 80052d0:	2002      	movs	r0, #2
  }
  
  return status;
}
 80052d2:	4770      	bx	lr

080052d4 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 80052d4:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 80052d6:	f7fb fae9 	bl	80008ac <USBD_LL_Start>
  
  return USBD_OK;  
}
 80052da:	2000      	movs	r0, #0
 80052dc:	bd08      	pop	{r3, pc}

080052de <USBD_Stop>:
  *         Stop the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
{
 80052de:	b510      	push	{r4, lr}
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 80052e0:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80052e4:	7901      	ldrb	r1, [r0, #4]
 80052e6:	685b      	ldr	r3, [r3, #4]
  *         Stop the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
{
 80052e8:	4604      	mov	r4, r0
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 80052ea:	4798      	blx	r3

  /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
 80052ec:	4620      	mov	r0, r4
 80052ee:	f7fb fae4 	bl	80008ba <USBD_LL_Stop>
  
  return USBD_OK;  
}
 80052f2:	2000      	movs	r0, #0
 80052f4:	bd10      	pop	{r4, pc}

080052f6 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 80052f6:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 80052f8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80052fc:	b90b      	cbnz	r3, 8005302 <USBD_SetClassConfig+0xc>
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  USBD_StatusTypeDef   ret = USBD_FAIL;
 80052fe:	2002      	movs	r0, #2
 8005300:	bd08      	pop	{r3, pc}
  
  if(pdev->pClass != NULL)
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8005302:	681b      	ldr	r3, [r3, #0]
 8005304:	4798      	blx	r3
 8005306:	2800      	cmp	r0, #0
 8005308:	d1f9      	bne.n	80052fe <USBD_SetClassConfig+0x8>
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
 800530a:	bd08      	pop	{r3, pc}

0800530c <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 800530c:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 800530e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005312:	685b      	ldr	r3, [r3, #4]
 8005314:	4798      	blx	r3
  return USBD_OK;
}
 8005316:	2000      	movs	r0, #0
 8005318:	bd08      	pop	{r3, pc}

0800531a <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 800531a:	b538      	push	{r3, r4, r5, lr}
 800531c:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 800531e:	f500 7502 	add.w	r5, r0, #520	; 0x208
 8005322:	4628      	mov	r0, r5
 8005324:	f000 f8f3 	bl	800550e <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8005328:	2301      	movs	r3, #1
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
 800532a:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{

  USBD_ParseSetupRequest(&pdev->request, psetup);
  
  pdev->ep0_state = USBD_EP0_SETUP;
 800532e:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 8005332:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 8005336:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 800533a:	f001 031f 	and.w	r3, r1, #31
 800533e:	2b01      	cmp	r3, #1
 8005340:	d00c      	beq.n	800535c <USBD_LL_SetupStage+0x42>
 8005342:	d306      	bcc.n	8005352 <USBD_LL_SetupStage+0x38>
 8005344:	2b02      	cmp	r3, #2
 8005346:	d10e      	bne.n	8005366 <USBD_LL_SetupStage+0x4c>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
 8005348:	4629      	mov	r1, r5
 800534a:	4620      	mov	r0, r4
 800534c:	f000 fa26 	bl	800579c <USBD_StdEPReq>
    break;
 8005350:	e00e      	b.n	8005370 <USBD_LL_SetupStage+0x56>
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
 8005352:	4629      	mov	r1, r5
 8005354:	4620      	mov	r0, r4
 8005356:	f000 f8f9 	bl	800554c <USBD_StdDevReq>
    break;
 800535a:	e009      	b.n	8005370 <USBD_LL_SetupStage+0x56>
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
 800535c:	4629      	mov	r1, r5
 800535e:	4620      	mov	r0, r4
 8005360:	f000 fa04 	bl	800576c <USBD_StdItfReq>
    break;
 8005364:	e004      	b.n	8005370 <USBD_LL_SetupStage+0x56>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 8005366:	f001 0180 	and.w	r1, r1, #128	; 0x80
 800536a:	4620      	mov	r0, r4
 800536c:	f7fb fac4 	bl	80008f8 <USBD_LL_StallEP>
    break;
  }  
  return USBD_OK;  
}
 8005370:	2000      	movs	r0, #0
 8005372:	bd38      	pop	{r3, r4, r5, pc}

08005374 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 8005374:	b538      	push	{r3, r4, r5, lr}
 8005376:	4604      	mov	r4, r0
 8005378:	4615      	mov	r5, r2
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 800537a:	bb09      	cbnz	r1, 80053c0 <USBD_LL_DataOutStage+0x4c>
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 800537c:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
 8005380:	2b03      	cmp	r3, #3
 8005382:	d126      	bne.n	80053d2 <USBD_LL_DataOutStage+0x5e>
    {
      if(pep->rem_length > pep->maxpacket)
 8005384:	f8d0 110c 	ldr.w	r1, [r0, #268]	; 0x10c
 8005388:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 800538c:	4291      	cmp	r1, r2
 800538e:	d90a      	bls.n	80053a6 <USBD_LL_DataOutStage+0x32>
      {
        pep->rem_length -=  pep->maxpacket;
 8005390:	1a8b      	subs	r3, r1, r2
       
        USBD_CtlContinueRx (pdev, 
 8005392:	429a      	cmp	r2, r3
 8005394:	bf28      	it	cs
 8005396:	461a      	movcs	r2, r3
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
 8005398:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
       
        USBD_CtlContinueRx (pdev, 
 800539c:	b292      	uxth	r2, r2
 800539e:	4629      	mov	r1, r5
 80053a0:	f000 fa90 	bl	80058c4 <USBD_CtlContinueRx>
 80053a4:	e015      	b.n	80053d2 <USBD_LL_DataOutStage+0x5e>
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 80053a6:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80053aa:	691b      	ldr	r3, [r3, #16]
 80053ac:	b123      	cbz	r3, 80053b8 <USBD_LL_DataOutStage+0x44>
 80053ae:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80053b2:	2a03      	cmp	r2, #3
 80053b4:	d100      	bne.n	80053b8 <USBD_LL_DataOutStage+0x44>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
 80053b6:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 80053b8:	4620      	mov	r0, r4
 80053ba:	f000 fa8b 	bl	80058d4 <USBD_CtlSendStatus>
 80053be:	e008      	b.n	80053d2 <USBD_LL_DataOutStage+0x5e>
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 80053c0:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80053c4:	699b      	ldr	r3, [r3, #24]
 80053c6:	b123      	cbz	r3, 80053d2 <USBD_LL_DataOutStage+0x5e>
 80053c8:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80053cc:	2a03      	cmp	r2, #3
 80053ce:	d100      	bne.n	80053d2 <USBD_LL_DataOutStage+0x5e>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
 80053d0:	4798      	blx	r3
  }  
  return USBD_OK;
}
 80053d2:	2000      	movs	r0, #0
 80053d4:	bd38      	pop	{r3, r4, r5, pc}

080053d6 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 80053d6:	b570      	push	{r4, r5, r6, lr}
 80053d8:	4613      	mov	r3, r2
 80053da:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 80053dc:	460e      	mov	r6, r1
 80053de:	2900      	cmp	r1, #0
 80053e0:	d13c      	bne.n	800545c <USBD_LL_DataInStage+0x86>
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 80053e2:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 80053e6:	2a02      	cmp	r2, #2
 80053e8:	d130      	bne.n	800544c <USBD_LL_DataInStage+0x76>
    {
      if(pep->rem_length > pep->maxpacket)
 80053ea:	69c5      	ldr	r5, [r0, #28]
 80053ec:	6a02      	ldr	r2, [r0, #32]
 80053ee:	4295      	cmp	r5, r2
 80053f0:	d907      	bls.n	8005402 <USBD_LL_DataInStage+0x2c>
      {
        pep->rem_length -=  pep->maxpacket;
 80053f2:	1aaa      	subs	r2, r5, r2
 80053f4:	61c2      	str	r2, [r0, #28]
        
        USBD_CtlContinueSendData (pdev, 
 80053f6:	4619      	mov	r1, r3
 80053f8:	b292      	uxth	r2, r2
 80053fa:	f000 fa5b 	bl	80058b4 <USBD_CtlContinueSendData>
                                  pdata, 
                                  pep->rem_length);
        
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 80053fe:	4633      	mov	r3, r6
 8005400:	e011      	b.n	8005426 <USBD_LL_DataInStage+0x50>
                                NULL,
                                0);  
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
 8005402:	6983      	ldr	r3, [r0, #24]
 8005404:	fbb3 f5f2 	udiv	r5, r3, r2
 8005408:	fb02 3515 	mls	r5, r2, r5, r3
 800540c:	b98d      	cbnz	r5, 8005432 <USBD_LL_DataInStage+0x5c>
 800540e:	429a      	cmp	r2, r3
 8005410:	d80f      	bhi.n	8005432 <USBD_LL_DataInStage+0x5c>
           (pep->total_length >= pep->maxpacket) &&
 8005412:	f8d0 21f8 	ldr.w	r2, [r0, #504]	; 0x1f8
 8005416:	4293      	cmp	r3, r2
 8005418:	d20b      	bcs.n	8005432 <USBD_LL_DataInStage+0x5c>
             (pep->total_length < pdev->ep0_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 800541a:	462a      	mov	r2, r5
 800541c:	f000 fa4a 	bl	80058b4 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 8005420:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
          
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 8005424:	462b      	mov	r3, r5
 8005426:	461a      	mov	r2, r3
 8005428:	4619      	mov	r1, r3
 800542a:	4620      	mov	r0, r4
 800542c:	f7fb fa93 	bl	8000956 <USBD_LL_PrepareReceive>
 8005430:	e00c      	b.n	800544c <USBD_LL_DataInStage+0x76>
                                NULL,
                                0);
        }
        else
        {
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8005432:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8005436:	68db      	ldr	r3, [r3, #12]
 8005438:	b12b      	cbz	r3, 8005446 <USBD_LL_DataInStage+0x70>
 800543a:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 800543e:	2a03      	cmp	r2, #3
 8005440:	d101      	bne.n	8005446 <USBD_LL_DataInStage+0x70>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
          {
            pdev->pClass->EP0_TxSent(pdev); 
 8005442:	4620      	mov	r0, r4
 8005444:	4798      	blx	r3
          }          
          USBD_CtlReceiveStatus(pdev);
 8005446:	4620      	mov	r0, r4
 8005448:	f000 fa4f 	bl	80058ea <USBD_CtlReceiveStatus>
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 800544c:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8005450:	2b01      	cmp	r3, #1
 8005452:	d10c      	bne.n	800546e <USBD_LL_DataInStage+0x98>
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
 8005454:	2300      	movs	r3, #0
 8005456:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
 800545a:	e008      	b.n	800546e <USBD_LL_DataInStage+0x98>
    }
  }
  else if((pdev->pClass->DataIn != NULL)&& 
 800545c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005460:	695b      	ldr	r3, [r3, #20]
 8005462:	b123      	cbz	r3, 800546e <USBD_LL_DataInStage+0x98>
 8005464:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8005468:	2a03      	cmp	r2, #3
 800546a:	d100      	bne.n	800546e <USBD_LL_DataInStage+0x98>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
 800546c:	4798      	blx	r3
  }  
  return USBD_OK;
}
 800546e:	2000      	movs	r0, #0
 8005470:	bd70      	pop	{r4, r5, r6, pc}

08005472 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8005472:	b538      	push	{r3, r4, r5, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8005474:	2200      	movs	r2, #0
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8005476:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8005478:	4611      	mov	r1, r2
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800547a:	2540      	movs	r5, #64	; 0x40
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 800547c:	2340      	movs	r3, #64	; 0x40
 800547e:	f7fb fa23 	bl	80008c8 <USBD_LL_OpenEP>
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8005482:	462b      	mov	r3, r5
  USBD_LL_OpenEP(pdev,
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8005484:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8005488:	2200      	movs	r2, #0
 800548a:	2180      	movs	r1, #128	; 0x80
 800548c:	4620      	mov	r0, r4
 800548e:	f7fb fa1b 	bl	80008c8 <USBD_LL_OpenEP>
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8005492:	2301      	movs	r3, #1
 8005494:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8005498:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  USBD_LL_OpenEP(pdev,
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 800549c:	6225      	str	r5, [r4, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  
  if (pdev->pClassData) 
 800549e:	b12b      	cbz	r3, 80054ac <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 80054a0:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80054a4:	7921      	ldrb	r1, [r4, #4]
 80054a6:	685b      	ldr	r3, [r3, #4]
 80054a8:	4620      	mov	r0, r4
 80054aa:	4798      	blx	r3
 
  
  return USBD_OK;
}
 80054ac:	2000      	movs	r0, #0
 80054ae:	bd38      	pop	{r3, r4, r5, pc}

080054b0 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 80054b0:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 80054b2:	2000      	movs	r0, #0
 80054b4:	4770      	bx	lr

080054b6 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 80054b6:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80054ba:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 80054be:	2304      	movs	r3, #4
 80054c0:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 80054c4:	2000      	movs	r0, #0
 80054c6:	4770      	bx	lr

080054c8 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 80054c8:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 80054cc:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 80054d0:	2000      	movs	r0, #0
 80054d2:	4770      	bx	lr

080054d4 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 80054d4:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 80054d6:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80054da:	2a03      	cmp	r2, #3
 80054dc:	d104      	bne.n	80054e8 <USBD_LL_SOF+0x14>
  {
    if(pdev->pClass->SOF != NULL)
 80054de:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80054e2:	69db      	ldr	r3, [r3, #28]
 80054e4:	b103      	cbz	r3, 80054e8 <USBD_LL_SOF+0x14>
    {
      pdev->pClass->SOF(pdev);
 80054e6:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 80054e8:	2000      	movs	r0, #0
 80054ea:	bd08      	pop	{r3, pc}

080054ec <USBD_LL_IsoINIncomplete>:
 80054ec:	2000      	movs	r0, #0
 80054ee:	4770      	bx	lr

080054f0 <USBD_LL_IsoOUTIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 80054f0:	2000      	movs	r0, #0
 80054f2:	4770      	bx	lr

080054f4 <USBD_LL_DevConnected>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
{
  return USBD_OK;
}
 80054f4:	2000      	movs	r0, #0
 80054f6:	4770      	bx	lr

080054f8 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 80054f8:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80054fa:	2201      	movs	r2, #1
 80054fc:	f880 21fc 	strb.w	r2, [r0, #508]	; 0x1fc
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8005500:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
 8005504:	7901      	ldrb	r1, [r0, #4]
 8005506:	6852      	ldr	r2, [r2, #4]
 8005508:	4790      	blx	r2
   
  return USBD_OK;
}
 800550a:	2000      	movs	r0, #0
 800550c:	bd08      	pop	{r3, pc}

0800550e <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
 800550e:	780b      	ldrb	r3, [r1, #0]
 8005510:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8005512:	784b      	ldrb	r3, [r1, #1]
 8005514:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8005516:	78ca      	ldrb	r2, [r1, #3]
 8005518:	788b      	ldrb	r3, [r1, #2]
 800551a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800551e:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8005520:	794a      	ldrb	r2, [r1, #5]
 8005522:	790b      	ldrb	r3, [r1, #4]
 8005524:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8005528:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 800552a:	79ca      	ldrb	r2, [r1, #7]
 800552c:	798b      	ldrb	r3, [r1, #6]
 800552e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8005532:	80c3      	strh	r3, [r0, #6]
 8005534:	4770      	bx	lr

08005536 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 8005536:	b510      	push	{r4, lr}
  USBD_LL_StallEP(pdev , 0x80);
 8005538:	2180      	movs	r1, #128	; 0x80
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 800553a:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 800553c:	f7fb f9dc 	bl	80008f8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8005540:	4620      	mov	r0, r4
 8005542:	2100      	movs	r1, #0
}
 8005544:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
  USBD_LL_StallEP(pdev , 0);
 8005548:	f7fb b9d6 	b.w	80008f8 <USBD_LL_StallEP>

0800554c <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 800554c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 800554e:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8005550:	4604      	mov	r4, r0
 8005552:	460d      	mov	r5, r1
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 8005554:	2b09      	cmp	r3, #9
 8005556:	f200 80ff 	bhi.w	8005758 <USBD_StdDevReq+0x20c>
 800555a:	e8df f013 	tbh	[pc, r3, lsl #1]
 800555e:	00d1      	.short	0x00d1
 8005560:	00fd00e8 	.word	0x00fd00e8
 8005564:	00fd00e4 	.word	0x00fd00e4
 8005568:	000a007b 	.word	0x000a007b
 800556c:	00c100fd 	.word	0x00c100fd
 8005570:	0097      	.short	0x0097
{
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
 8005572:	8849      	ldrh	r1, [r1, #2]
 8005574:	0a0b      	lsrs	r3, r1, #8
 8005576:	3b01      	subs	r3, #1
 8005578:	2b06      	cmp	r3, #6
 800557a:	f200 80ed 	bhi.w	8005758 <USBD_StdDevReq+0x20c>
 800557e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005582:	0007      	.short	0x0007
 8005584:	0017000b 	.word	0x0017000b
 8005588:	00eb00eb 	.word	0x00eb00eb
 800558c:	004d0042 	.word	0x004d0042
  case USB_DESC_TYPE_BOS:
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    break;
#endif    
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8005590:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005594:	681b      	ldr	r3, [r3, #0]
 8005596:	e016      	b.n	80055c6 <USBD_StdDevReq+0x7a>
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8005598:	7c02      	ldrb	r2, [r0, #16]
 800559a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800559e:	b90a      	cbnz	r2, 80055a4 <USBD_StdDevReq+0x58>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 80055a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80055a2:	e000      	b.n	80055a6 <USBD_StdDevReq+0x5a>
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 80055a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80055a6:	f10d 0006 	add.w	r0, sp, #6
 80055aa:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80055ac:	2302      	movs	r3, #2
 80055ae:	e040      	b.n	8005632 <USBD_StdDevReq+0xe6>
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 80055b0:	b2c9      	uxtb	r1, r1
 80055b2:	2905      	cmp	r1, #5
 80055b4:	d820      	bhi.n	80055f8 <USBD_StdDevReq+0xac>
 80055b6:	e8df f001 	tbb	[pc, r1]
 80055ba:	0b03      	.short	0x0b03
 80055bc:	1b17130f 	.word	0x1b17130f
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 80055c0:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80055c4:	685b      	ldr	r3, [r3, #4]
 80055c6:	7c20      	ldrb	r0, [r4, #16]
 80055c8:	f10d 0106 	add.w	r1, sp, #6
 80055cc:	4798      	blx	r3
 80055ce:	e031      	b.n	8005634 <USBD_StdDevReq+0xe8>
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 80055d0:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80055d4:	689b      	ldr	r3, [r3, #8]
 80055d6:	e7f6      	b.n	80055c6 <USBD_StdDevReq+0x7a>
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 80055d8:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80055dc:	68db      	ldr	r3, [r3, #12]
 80055de:	e7f2      	b.n	80055c6 <USBD_StdDevReq+0x7a>
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 80055e0:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80055e4:	691b      	ldr	r3, [r3, #16]
 80055e6:	e7ee      	b.n	80055c6 <USBD_StdDevReq+0x7a>
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 80055e8:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80055ec:	695b      	ldr	r3, [r3, #20]
 80055ee:	e7ea      	b.n	80055c6 <USBD_StdDevReq+0x7a>
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 80055f0:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80055f4:	699b      	ldr	r3, [r3, #24]
 80055f6:	e7e6      	b.n	80055c6 <USBD_StdDevReq+0x7a>
      break;
      
    default:
#if (USBD_SUPPORT_USER_STRING == 1)
      pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue) , &len);
 80055f8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80055fc:	f10d 0206 	add.w	r2, sp, #6
 8005600:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005602:	4798      	blx	r3
 8005604:	e016      	b.n	8005634 <USBD_StdDevReq+0xe8>
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8005606:	7c03      	ldrb	r3, [r0, #16]
 8005608:	2b00      	cmp	r3, #0
 800560a:	f040 80a5 	bne.w	8005758 <USBD_StdDevReq+0x20c>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 800560e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005612:	f10d 0006 	add.w	r0, sp, #6
 8005616:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005618:	4798      	blx	r3
 800561a:	e00b      	b.n	8005634 <USBD_StdDevReq+0xe8>
      USBD_CtlError(pdev , req);
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 800561c:	7c03      	ldrb	r3, [r0, #16]
 800561e:	2b00      	cmp	r3, #0
 8005620:	f040 809a 	bne.w	8005758 <USBD_StdDevReq+0x20c>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8005624:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005628:	f10d 0006 	add.w	r0, sp, #6
 800562c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800562e:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8005630:	2307      	movs	r3, #7
 8005632:	7043      	strb	r3, [r0, #1]
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 8005634:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8005638:	2a00      	cmp	r2, #0
 800563a:	f000 8091 	beq.w	8005760 <USBD_StdDevReq+0x214>
 800563e:	88eb      	ldrh	r3, [r5, #6]
 8005640:	2b00      	cmp	r3, #0
 8005642:	f000 808d 	beq.w	8005760 <USBD_StdDevReq+0x214>
  {
    
    len = MIN(len , req->wLength);
 8005646:	429a      	cmp	r2, r3
 8005648:	bf28      	it	cs
 800564a:	461a      	movcs	r2, r3
 800564c:	f8ad 2006 	strh.w	r2, [sp, #6]
    
    USBD_CtlSendData (pdev, 
 8005650:	4601      	mov	r1, r0
 8005652:	e064      	b.n	800571e <USBD_StdDevReq+0x1d2>
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8005654:	888b      	ldrh	r3, [r1, #4]
 8005656:	2b00      	cmp	r3, #0
 8005658:	d17e      	bne.n	8005758 <USBD_StdDevReq+0x20c>
 800565a:	88cb      	ldrh	r3, [r1, #6]
 800565c:	2b00      	cmp	r3, #0
 800565e:	d17b      	bne.n	8005758 <USBD_StdDevReq+0x20c>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8005660:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8005664:	788e      	ldrb	r6, [r1, #2]
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8005666:	2b03      	cmp	r3, #3
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8005668:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 800566c:	d074      	beq.n	8005758 <USBD_StdDevReq+0x20c>
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev_address = dev_addr;
 800566e:	f880 61fe 	strb.w	r6, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 8005672:	4631      	mov	r1, r6
 8005674:	f7fb f961 	bl	800093a <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 8005678:	4620      	mov	r0, r4
 800567a:	f000 f92b 	bl	80058d4 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 800567e:	b10e      	cbz	r6, 8005684 <USBD_StdDevReq+0x138>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 8005680:	2302      	movs	r3, #2
 8005682:	e000      	b.n	8005686 <USBD_StdDevReq+0x13a>
      } 
      else 
      {
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8005684:	2301      	movs	r3, #1
 8005686:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
 800568a:	e069      	b.n	8005760 <USBD_StdDevReq+0x214>
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 800568c:	7889      	ldrb	r1, [r1, #2]
 800568e:	4e36      	ldr	r6, [pc, #216]	; (8005768 <USBD_StdDevReq+0x21c>)
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8005690:	2901      	cmp	r1, #1
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8005692:	7031      	strb	r1, [r6, #0]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8005694:	d860      	bhi.n	8005758 <USBD_StdDevReq+0x20c>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
 8005696:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800569a:	2b02      	cmp	r3, #2
 800569c:	d002      	beq.n	80056a4 <USBD_StdDevReq+0x158>
 800569e:	2b03      	cmp	r3, #3
 80056a0:	d008      	beq.n	80056b4 <USBD_StdDevReq+0x168>
 80056a2:	e059      	b.n	8005758 <USBD_StdDevReq+0x20c>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
 80056a4:	2900      	cmp	r1, #0
 80056a6:	d053      	beq.n	8005750 <USBD_StdDevReq+0x204>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 80056a8:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 80056aa:	2303      	movs	r3, #3
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 80056ac:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 80056ae:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
 80056b2:	e00f      	b.n	80056d4 <USBD_StdDevReq+0x188>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
 80056b4:	b931      	cbnz	r1, 80056c4 <USBD_StdDevReq+0x178>
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80056b6:	2302      	movs	r3, #2
 80056b8:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 80056bc:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 80056be:	f7ff fe25 	bl	800530c <USBD_ClrClassConfig>
 80056c2:	e045      	b.n	8005750 <USBD_StdDevReq+0x204>
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev_config) 
 80056c4:	6841      	ldr	r1, [r0, #4]
 80056c6:	2901      	cmp	r1, #1
 80056c8:	d042      	beq.n	8005750 <USBD_StdDevReq+0x204>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 80056ca:	b2c9      	uxtb	r1, r1
 80056cc:	f7ff fe1e 	bl	800530c <USBD_ClrClassConfig>
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
 80056d0:	7831      	ldrb	r1, [r6, #0]
 80056d2:	6061      	str	r1, [r4, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 80056d4:	4620      	mov	r0, r4
 80056d6:	f7ff fe0e 	bl	80052f6 <USBD_SetClassConfig>
 80056da:	2802      	cmp	r0, #2
 80056dc:	d138      	bne.n	8005750 <USBD_StdDevReq+0x204>
 80056de:	e03b      	b.n	8005758 <USBD_StdDevReq+0x20c>
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{

  if (req->wLength != 1) 
 80056e0:	88ca      	ldrh	r2, [r1, #6]
 80056e2:	2a01      	cmp	r2, #1
 80056e4:	d138      	bne.n	8005758 <USBD_StdDevReq+0x20c>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
 80056e6:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80056ea:	2b02      	cmp	r3, #2
 80056ec:	d003      	beq.n	80056f6 <USBD_StdDevReq+0x1aa>
 80056ee:	2b03      	cmp	r3, #3
 80056f0:	d132      	bne.n	8005758 <USBD_StdDevReq+0x20c>
                        1);
      break;
      
    case USBD_STATE_CONFIGURED:   
      
      USBD_CtlSendData (pdev, 
 80056f2:	1d01      	adds	r1, r0, #4
 80056f4:	e013      	b.n	800571e <USBD_StdDevReq+0x1d2>
  else 
  {
    switch (pdev->dev_state )  
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
 80056f6:	4601      	mov	r1, r0
 80056f8:	2300      	movs	r3, #0
 80056fa:	f841 3f08 	str.w	r3, [r1, #8]!
 80056fe:	e00e      	b.n	800571e <USBD_StdDevReq+0x1d2>
static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
  
    
  switch (pdev->dev_state) 
 8005700:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8005704:	3b02      	subs	r3, #2
 8005706:	2b01      	cmp	r3, #1
 8005708:	d826      	bhi.n	8005758 <USBD_StdDevReq+0x20c>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 800570a:	2301      	movs	r3, #1
 800570c:	60c3      	str	r3, [r0, #12]
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
 800570e:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 8005712:	b10b      	cbz	r3, 8005718 <USBD_StdDevReq+0x1cc>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 8005714:	2303      	movs	r3, #3
 8005716:	60c3      	str	r3, [r0, #12]
    }
    
    USBD_CtlSendData (pdev, 
 8005718:	2202      	movs	r2, #2
 800571a:	f104 010c 	add.w	r1, r4, #12
 800571e:	4620      	mov	r0, r4
 8005720:	f000 f8bb 	bl	800589a <USBD_CtlSendData>
 8005724:	e01c      	b.n	8005760 <USBD_StdDevReq+0x214>
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8005726:	884b      	ldrh	r3, [r1, #2]
 8005728:	2b01      	cmp	r3, #1
 800572a:	d119      	bne.n	8005760 <USBD_StdDevReq+0x214>
 800572c:	e008      	b.n	8005740 <USBD_StdDevReq+0x1f4>
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  switch (pdev->dev_state)
 800572e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8005732:	3b02      	subs	r3, #2
 8005734:	2b01      	cmp	r3, #1
 8005736:	d80f      	bhi.n	8005758 <USBD_StdDevReq+0x20c>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8005738:	884b      	ldrh	r3, [r1, #2]
 800573a:	2b01      	cmp	r3, #1
 800573c:	d110      	bne.n	8005760 <USBD_StdDevReq+0x214>
    {
      pdev->dev_remote_wakeup = 0; 
 800573e:	2300      	movs	r3, #0
 8005740:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 8005744:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8005748:	4629      	mov	r1, r5
 800574a:	689b      	ldr	r3, [r3, #8]
 800574c:	4620      	mov	r0, r4
 800574e:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 8005750:	4620      	mov	r0, r4
 8005752:	f000 f8bf 	bl	80058d4 <USBD_CtlSendStatus>
 8005756:	e003      	b.n	8005760 <USBD_StdDevReq+0x214>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
 8005758:	4629      	mov	r1, r5
 800575a:	4620      	mov	r0, r4
 800575c:	f7ff feeb 	bl	8005536 <USBD_CtlError>
    break;
  }
  
  return ret;
}
 8005760:	2000      	movs	r0, #0
 8005762:	b002      	add	sp, #8
 8005764:	bd70      	pop	{r4, r5, r6, pc}
 8005766:	bf00      	nop
 8005768:	20000198 	.word	0x20000198

0800576c <USBD_StdItfReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 800576c:	b538      	push	{r3, r4, r5, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 800576e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8005772:	2b03      	cmp	r3, #3
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8005774:	4604      	mov	r4, r0
 8005776:	460d      	mov	r5, r1
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 8005778:	d10c      	bne.n	8005794 <USBD_StdItfReq+0x28>
  {
  case USBD_STATE_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 800577a:	790b      	ldrb	r3, [r1, #4]
 800577c:	2b01      	cmp	r3, #1
 800577e:	d809      	bhi.n	8005794 <USBD_StdItfReq+0x28>
    {
      pdev->pClass->Setup (pdev, req); 
 8005780:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005784:	689b      	ldr	r3, [r3, #8]
 8005786:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 8005788:	88eb      	ldrh	r3, [r5, #6]
 800578a:	b92b      	cbnz	r3, 8005798 <USBD_StdItfReq+0x2c>
      {
         USBD_CtlSendStatus(pdev);
 800578c:	4620      	mov	r0, r4
 800578e:	f000 f8a1 	bl	80058d4 <USBD_CtlSendStatus>
 8005792:	e001      	b.n	8005798 <USBD_StdItfReq+0x2c>
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
 8005794:	f7ff fecf 	bl	8005536 <USBD_CtlError>
    break;
  }
  return USBD_OK;
}
 8005798:	2000      	movs	r0, #0
 800579a:	bd38      	pop	{r3, r4, r5, pc}

0800579c <USBD_StdEPReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 800579c:	b570      	push	{r4, r5, r6, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 800579e:	780a      	ldrb	r2, [r1, #0]
{
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 80057a0:	888e      	ldrh	r6, [r1, #4]
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 80057a2:	f002 0260 	and.w	r2, r2, #96	; 0x60
 80057a6:	2a20      	cmp	r2, #32
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80057a8:	4604      	mov	r4, r0
 80057aa:	460d      	mov	r5, r1
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 80057ac:	b2f3      	uxtb	r3, r6
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 80057ae:	d104      	bne.n	80057ba <USBD_StdEPReq+0x1e>
  {
    pdev->pClass->Setup (pdev, req);
 80057b0:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80057b4:	689b      	ldr	r3, [r3, #8]
 80057b6:	4798      	blx	r3
    
    return USBD_OK;
 80057b8:	e051      	b.n	800585e <USBD_StdEPReq+0xc2>
  }
  
  switch (req->bRequest) 
 80057ba:	784a      	ldrb	r2, [r1, #1]
 80057bc:	2a01      	cmp	r2, #1
 80057be:	d010      	beq.n	80057e2 <USBD_StdEPReq+0x46>
 80057c0:	d326      	bcc.n	8005810 <USBD_StdEPReq+0x74>
 80057c2:	2a03      	cmp	r2, #3
 80057c4:	d14b      	bne.n	800585e <USBD_StdEPReq+0xc2>
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev_state) 
 80057c6:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80057ca:	2a02      	cmp	r2, #2
 80057cc:	d027      	beq.n	800581e <USBD_StdEPReq+0x82>
 80057ce:	2a03      	cmp	r2, #3
 80057d0:	d143      	bne.n	800585a <USBD_StdEPReq+0xbe>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 80057d2:	884a      	ldrh	r2, [r1, #2]
 80057d4:	b992      	cbnz	r2, 80057fc <USBD_StdEPReq+0x60>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80057d6:	065e      	lsls	r6, r3, #25
 80057d8:	d010      	beq.n	80057fc <USBD_StdEPReq+0x60>
        { 
          USBD_LL_StallEP(pdev , ep_addr);
 80057da:	4619      	mov	r1, r3
 80057dc:	f7fb f88c 	bl	80008f8 <USBD_LL_StallEP>
 80057e0:	e00c      	b.n	80057fc <USBD_StdEPReq+0x60>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev_state) 
 80057e2:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80057e6:	2a02      	cmp	r2, #2
 80057e8:	d019      	beq.n	800581e <USBD_StdEPReq+0x82>
 80057ea:	2a03      	cmp	r2, #3
 80057ec:	d135      	bne.n	800585a <USBD_StdEPReq+0xbe>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 80057ee:	884a      	ldrh	r2, [r1, #2]
 80057f0:	bbaa      	cbnz	r2, 800585e <USBD_StdEPReq+0xc2>
      {
        if ((ep_addr & 0x7F) != 0x00) 
 80057f2:	0659      	lsls	r1, r3, #25
 80057f4:	d008      	beq.n	8005808 <USBD_StdEPReq+0x6c>
        {        
          USBD_LL_ClearStallEP(pdev , ep_addr);
 80057f6:	4619      	mov	r1, r3
 80057f8:	f7fb f885 	bl	8000906 <USBD_LL_ClearStallEP>
          pdev->pClass->Setup (pdev, req);
 80057fc:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8005800:	4629      	mov	r1, r5
 8005802:	689b      	ldr	r3, [r3, #8]
 8005804:	4620      	mov	r0, r4
 8005806:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 8005808:	4620      	mov	r0, r4
 800580a:	f000 f863 	bl	80058d4 <USBD_CtlSendStatus>
 800580e:	e026      	b.n	800585e <USBD_StdEPReq+0xc2>
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev_state) 
 8005810:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8005814:	2a02      	cmp	r2, #2
 8005816:	d002      	beq.n	800581e <USBD_StdEPReq+0x82>
 8005818:	2a03      	cmp	r2, #3
 800581a:	d006      	beq.n	800582a <USBD_StdEPReq+0x8e>
 800581c:	e01d      	b.n	800585a <USBD_StdEPReq+0xbe>
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr & 0x7F) != 0x00) 
 800581e:	065a      	lsls	r2, r3, #25
 8005820:	d01d      	beq.n	800585e <USBD_StdEPReq+0xc2>
      {
        USBD_LL_StallEP(pdev , ep_addr);
 8005822:	4619      	mov	r1, r3
 8005824:	f7fb f868 	bl	80008f8 <USBD_LL_StallEP>
 8005828:	e019      	b.n	800585e <USBD_StdEPReq+0xc2>
 800582a:	f003 057f 	and.w	r5, r3, #127	; 0x7f
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 800582e:	f016 0f80 	tst.w	r6, #128	; 0x80
 8005832:	eb00 1505 	add.w	r5, r0, r5, lsl #4
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8005836:	4619      	mov	r1, r3
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8005838:	bf14      	ite	ne
 800583a:	3514      	addne	r5, #20
 800583c:	f505 7582 	addeq.w	r5, r5, #260	; 0x104
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8005840:	f7fb f868 	bl	8000914 <USBD_LL_IsStallEP>
 8005844:	b110      	cbz	r0, 800584c <USBD_StdEPReq+0xb0>
      {
        pep->status = 0x0001;     
 8005846:	2301      	movs	r3, #1
 8005848:	602b      	str	r3, [r5, #0]
 800584a:	e000      	b.n	800584e <USBD_StdEPReq+0xb2>
      }
      else
      {
        pep->status = 0x0000;  
 800584c:	6028      	str	r0, [r5, #0]
      }
      
      USBD_CtlSendData (pdev,
 800584e:	2202      	movs	r2, #2
 8005850:	4629      	mov	r1, r5
 8005852:	4620      	mov	r0, r4
 8005854:	f000 f821 	bl	800589a <USBD_CtlSendData>
                        (uint8_t *)&pep->status,
                        2);
      break;
 8005858:	e001      	b.n	800585e <USBD_StdEPReq+0xc2>
      
    default:                         
      USBD_CtlError(pdev , req);
 800585a:	f7ff fe6c 	bl	8005536 <USBD_CtlError>
    
  default:
    break;
  }
  return ret;
}
 800585e:	2000      	movs	r0, #0
 8005860:	bd70      	pop	{r4, r5, r6, pc}

08005862 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8005862:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8005864:	b1c0      	cbz	r0, 8005898 <USBD_GetString+0x36>
 8005866:	4605      	mov	r5, r0
 8005868:	1a2b      	subs	r3, r5, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 800586a:	f815 4b01 	ldrb.w	r4, [r5], #1
 800586e:	b2db      	uxtb	r3, r3
 8005870:	2c00      	cmp	r4, #0
 8005872:	d1f9      	bne.n	8005868 <USBD_GetString+0x6>
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8005874:	005b      	lsls	r3, r3, #1
 8005876:	3302      	adds	r3, #2
 8005878:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 800587a:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 800587c:	2303      	movs	r3, #3
 800587e:	704b      	strb	r3, [r1, #1]
 8005880:	3801      	subs	r0, #1
 8005882:	2302      	movs	r3, #2
    
    while (*desc != '\0') 
 8005884:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8005888:	b135      	cbz	r5, 8005898 <USBD_GetString+0x36>
    {
      unicode[idx++] = *desc++;
 800588a:	1c5a      	adds	r2, r3, #1
 800588c:	b2d2      	uxtb	r2, r2
 800588e:	54cd      	strb	r5, [r1, r3]
      unicode[idx++] =  0x00;
 8005890:	3302      	adds	r3, #2
 8005892:	b2db      	uxtb	r3, r3
 8005894:	548c      	strb	r4, [r1, r2]
 8005896:	e7f5      	b.n	8005884 <USBD_GetString+0x22>
 8005898:	bd30      	pop	{r4, r5, pc}

0800589a <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 800589a:	b510      	push	{r4, lr}
 800589c:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 800589e:	2202      	movs	r2, #2
 80058a0:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 80058a4:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 80058a6:	460a      	mov	r2, r1
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 80058a8:	61c3      	str	r3, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 80058aa:	2100      	movs	r1, #0
 80058ac:	f7fb f84c 	bl	8000948 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 80058b0:	2000      	movs	r0, #0
 80058b2:	bd10      	pop	{r4, pc}

080058b4 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 80058b4:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 80058b6:	4613      	mov	r3, r2
 80058b8:	460a      	mov	r2, r1
 80058ba:	2100      	movs	r1, #0
 80058bc:	f7fb f844 	bl	8000948 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 80058c0:	2000      	movs	r0, #0
 80058c2:	bd08      	pop	{r3, pc}

080058c4 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 80058c4:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 80058c6:	4613      	mov	r3, r2
 80058c8:	460a      	mov	r2, r1
 80058ca:	2100      	movs	r1, #0
 80058cc:	f7fb f843 	bl	8000956 <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 80058d0:	2000      	movs	r0, #0
 80058d2:	bd08      	pop	{r3, pc}

080058d4 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 80058d4:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80058d6:	2304      	movs	r3, #4
 80058d8:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 80058dc:	2300      	movs	r3, #0
 80058de:	461a      	mov	r2, r3
 80058e0:	4619      	mov	r1, r3
 80058e2:	f7fb f831 	bl	8000948 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 80058e6:	2000      	movs	r0, #0
 80058e8:	bd08      	pop	{r3, pc}

080058ea <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 80058ea:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 80058ec:	2305      	movs	r3, #5
 80058ee:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 80058f2:	2300      	movs	r3, #0
 80058f4:	461a      	mov	r2, r3
 80058f6:	4619      	mov	r1, r3
 80058f8:	f7fb f82d 	bl	8000956 <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 80058fc:	2000      	movs	r0, #0
 80058fe:	bd08      	pop	{r3, pc}

08005900 <USBD_MSC_GetHSCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MSC_CfgHSDesc);
 8005900:	2320      	movs	r3, #32
 8005902:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_CfgHSDesc;
}
 8005904:	4800      	ldr	r0, [pc, #0]	; (8005908 <USBD_MSC_GetHSCfgDesc+0x8>)
 8005906:	4770      	bx	lr
 8005908:	20000088 	.word	0x20000088

0800590c <USBD_MSC_GetFSCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MSC_CfgFSDesc);
 800590c:	2320      	movs	r3, #32
 800590e:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_CfgFSDesc;
}
 8005910:	4800      	ldr	r0, [pc, #0]	; (8005914 <USBD_MSC_GetFSCfgDesc+0x8>)
 8005912:	4770      	bx	lr
 8005914:	200000e4 	.word	0x200000e4

08005918 <USBD_MSC_GetOtherSpeedCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MSC_OtherSpeedCfgDesc);
 8005918:	2320      	movs	r3, #32
 800591a:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_OtherSpeedCfgDesc;
}
 800591c:	4800      	ldr	r0, [pc, #0]	; (8005920 <USBD_MSC_GetOtherSpeedCfgDesc+0x8>)
 800591e:	4770      	bx	lr
 8005920:	2000005c 	.word	0x2000005c

08005924 <USBD_MSC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetDeviceQualifierDescriptor (uint16_t *length)
{
  *length = sizeof (USBD_MSC_DeviceQualifierDesc);
 8005924:	230a      	movs	r3, #10
 8005926:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_DeviceQualifierDesc;
}
 8005928:	4800      	ldr	r0, [pc, #0]	; (800592c <USBD_MSC_GetDeviceQualifierDescriptor+0x8>)
 800592a:	4770      	bx	lr
 800592c:	2000007c 	.word	0x2000007c

08005930 <USBD_MSC_Init>:
uint8_t  USBD_MSC_Init (USBD_HandleTypeDef *pdev, 
                            uint8_t cfgidx)
{
  int16_t ret = 0;
   
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8005930:	7c03      	ldrb	r3, [r0, #16]
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t  USBD_MSC_Init (USBD_HandleTypeDef *pdev, 
                            uint8_t cfgidx)
{
 8005932:	b510      	push	{r4, lr}
 8005934:	4604      	mov	r4, r0
  int16_t ret = 0;
   
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8005936:	b943      	cbnz	r3, 800594a <USBD_MSC_Init+0x1a>
  {
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 8005938:	f44f 7300 	mov.w	r3, #512	; 0x200
 800593c:	2202      	movs	r2, #2
 800593e:	2101      	movs	r1, #1
 8005940:	f7fa ffc2 	bl	80008c8 <USBD_LL_OpenEP>
                   MSC_EPOUT_ADDR,
                   USBD_EP_TYPE_BULK,
                   MSC_MAX_HS_PACKET);
    
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 8005944:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005948:	e005      	b.n	8005956 <USBD_MSC_Init+0x26>
                   MSC_MAX_HS_PACKET);  
  }
  else
  {
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 800594a:	2340      	movs	r3, #64	; 0x40
 800594c:	2202      	movs	r2, #2
 800594e:	2101      	movs	r1, #1
 8005950:	f7fa ffba 	bl	80008c8 <USBD_LL_OpenEP>
                   MSC_EPOUT_ADDR,
                   USBD_EP_TYPE_BULK,
                   MSC_MAX_FS_PACKET);
    
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 8005954:	2340      	movs	r3, #64	; 0x40
 8005956:	2202      	movs	r2, #2
 8005958:	2181      	movs	r1, #129	; 0x81
 800595a:	4620      	mov	r0, r4
 800595c:	f7fa ffb4 	bl	80008c8 <USBD_LL_OpenEP>
                   MSC_EPIN_ADDR,
                   USBD_EP_TYPE_BULK,
                   MSC_MAX_FS_PACKET);  
  }
  pdev->pClassData = USBD_malloc(sizeof (USBD_MSC_BOT_HandleTypeDef));
 8005960:	f44f 701b 	mov.w	r0, #620	; 0x26c
 8005964:	f000 ff8c 	bl	8006880 <malloc>
 8005968:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
  
  if(pdev->pClassData == NULL)
 800596c:	b120      	cbz	r0, 8005978 <USBD_MSC_Init+0x48>
    ret = 1; 
  }
  else
  {
    /* Init the BOT  layer */
    MSC_BOT_Init(pdev); 
 800596e:	4620      	mov	r0, r4
 8005970:	f000 f8b6 	bl	8005ae0 <MSC_BOT_Init>
    ret = 0;
 8005974:	2000      	movs	r0, #0
 8005976:	bd10      	pop	{r4, pc}
  }
  pdev->pClassData = USBD_malloc(sizeof (USBD_MSC_BOT_HandleTypeDef));
  
  if(pdev->pClassData == NULL)
  {
    ret = 1; 
 8005978:	2001      	movs	r0, #1
    MSC_BOT_Init(pdev); 
    ret = 0;
  }
  
  return ret;
}
 800597a:	bd10      	pop	{r4, pc}

0800597c <USBD_MSC_DeInit>:
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t  USBD_MSC_DeInit (USBD_HandleTypeDef *pdev, 
                              uint8_t cfgidx)
{
 800597c:	b510      	push	{r4, lr}
  /* Close MSC EPs */
  USBD_LL_CloseEP(pdev,
 800597e:	2101      	movs	r1, #1
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t  USBD_MSC_DeInit (USBD_HandleTypeDef *pdev, 
                              uint8_t cfgidx)
{
 8005980:	4604      	mov	r4, r0
  /* Close MSC EPs */
  USBD_LL_CloseEP(pdev,
 8005982:	f7fa ffab 	bl	80008dc <USBD_LL_CloseEP>
                  MSC_EPOUT_ADDR);
  
  /* Open EP IN */
  USBD_LL_CloseEP(pdev,
 8005986:	2181      	movs	r1, #129	; 0x81
 8005988:	4620      	mov	r0, r4
 800598a:	f7fa ffa7 	bl	80008dc <USBD_LL_CloseEP>
                  MSC_EPIN_ADDR);
  
  
    /* De-Init the BOT layer */
  MSC_BOT_DeInit(pdev);
 800598e:	4620      	mov	r0, r4
 8005990:	f000 f8d1 	bl	8005b36 <MSC_BOT_DeInit>
  
  /* Free MSC Class Resources */
  if(pdev->pClassData != NULL)
 8005994:	f8d4 0218 	ldr.w	r0, [r4, #536]	; 0x218
 8005998:	b120      	cbz	r0, 80059a4 <USBD_MSC_DeInit+0x28>
  {
    USBD_free(pdev->pClassData);
 800599a:	f000 ff79 	bl	8006890 <free>
    pdev->pClassData  = NULL; 
 800599e:	2300      	movs	r3, #0
 80059a0:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
  }
  return 0;
}
 80059a4:	2000      	movs	r0, #0
 80059a6:	bd10      	pop	{r4, pc}

080059a8 <USBD_MSC_Setup>:
* @param  pdev: device instance
* @param  req: USB request
* @retval status
*/
uint8_t  USBD_MSC_Setup (USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80059a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  USBD_MSC_BOT_HandleTypeDef     *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80059ac:	780b      	ldrb	r3, [r1, #0]
* @param  req: USB request
* @retval status
*/
uint8_t  USBD_MSC_Setup (USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
  USBD_MSC_BOT_HandleTypeDef     *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
 80059ae:	f8d0 8218 	ldr.w	r8, [r0, #536]	; 0x218
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80059b2:	f013 0460 	ands.w	r4, r3, #96	; 0x60
* @param  pdev: device instance
* @param  req: USB request
* @retval status
*/
uint8_t  USBD_MSC_Setup (USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80059b6:	4607      	mov	r7, r0
 80059b8:	460e      	mov	r6, r1
  USBD_MSC_BOT_HandleTypeDef     *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80059ba:	d029      	beq.n	8005a10 <USBD_MSC_Setup+0x68>
 80059bc:	2c20      	cmp	r4, #32
 80059be:	d15c      	bne.n	8005a7a <USBD_MSC_Setup+0xd2>
  {

  /* Class request */
  case USB_REQ_TYPE_CLASS :
    switch (req->bRequest)
 80059c0:	784a      	ldrb	r2, [r1, #1]
 80059c2:	2afe      	cmp	r2, #254	; 0xfe
 80059c4:	d002      	beq.n	80059cc <USBD_MSC_Setup+0x24>
 80059c6:	2aff      	cmp	r2, #255	; 0xff
 80059c8:	d011      	beq.n	80059ee <USBD_MSC_Setup+0x46>
 80059ca:	e01d      	b.n	8005a08 <USBD_MSC_Setup+0x60>
    {
    case BOT_GET_MAX_LUN :

      if((req->wValue  == 0) && 
 80059cc:	884c      	ldrh	r4, [r1, #2]
 80059ce:	b984      	cbnz	r4, 80059f2 <USBD_MSC_Setup+0x4a>
 80059d0:	88cd      	ldrh	r5, [r1, #6]
 80059d2:	2d01      	cmp	r5, #1
 80059d4:	d10d      	bne.n	80059f2 <USBD_MSC_Setup+0x4a>
         (req->wLength == 1) &&
 80059d6:	061a      	lsls	r2, r3, #24
 80059d8:	d50b      	bpl.n	80059f2 <USBD_MSC_Setup+0x4a>
         ((req->bmRequest & 0x80) == 0x80))
      {
        hmsc->max_lun = ((USBD_StorageTypeDef *)pdev->pUserData)->GetMaxLun();
 80059da:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 80059de:	699b      	ldr	r3, [r3, #24]
 80059e0:	4798      	blx	r3
        USBD_CtlSendData (pdev,
 80059e2:	462a      	mov	r2, r5

      if((req->wValue  == 0) && 
         (req->wLength == 1) &&
         ((req->bmRequest & 0x80) == 0x80))
      {
        hmsc->max_lun = ((USBD_StorageTypeDef *)pdev->pUserData)->GetMaxLun();
 80059e4:	f8c8 0000 	str.w	r0, [r8]
        USBD_CtlSendData (pdev,
 80059e8:	4641      	mov	r1, r8
 80059ea:	4638      	mov	r0, r7
 80059ec:	e01b      	b.n	8005a26 <USBD_MSC_Setup+0x7e>
         return USBD_FAIL; 
      }
      break;
      
    case BOT_RESET :
      if((req->wValue  == 0) && 
 80059ee:	884a      	ldrh	r2, [r1, #2]
 80059f0:	b112      	cbz	r2, 80059f8 <USBD_MSC_Setup+0x50>
                          (uint8_t *)&hmsc->max_lun,
                          1);
      }
      else
      {
         USBD_CtlError(pdev , req);
 80059f2:	4631      	mov	r1, r6
 80059f4:	4638      	mov	r0, r7
 80059f6:	e007      	b.n	8005a08 <USBD_MSC_Setup+0x60>
         return USBD_FAIL; 
      }
      break;
      
    case BOT_RESET :
      if((req->wValue  == 0) && 
 80059f8:	88cc      	ldrh	r4, [r1, #6]
 80059fa:	2c00      	cmp	r4, #0
 80059fc:	d1f9      	bne.n	80059f2 <USBD_MSC_Setup+0x4a>
         (req->wLength == 0) &&
 80059fe:	061b      	lsls	r3, r3, #24
 8005a00:	d4f7      	bmi.n	80059f2 <USBD_MSC_Setup+0x4a>
        ((req->bmRequest & 0x80) != 0x80))
      {      
         MSC_BOT_Reset(pdev);
 8005a02:	f000 f88d 	bl	8005b20 <MSC_BOT_Reset>
      else
      {
         USBD_CtlError(pdev , req);
         return USBD_FAIL; 
      }
      break;
 8005a06:	e039      	b.n	8005a7c <USBD_MSC_Setup+0xd4>

    default:
       USBD_CtlError(pdev , req);
 8005a08:	f7ff fd95 	bl	8005536 <USBD_CtlError>
       return USBD_FAIL; 
 8005a0c:	2402      	movs	r4, #2
 8005a0e:	e035      	b.n	8005a7c <USBD_MSC_Setup+0xd4>
    }
    break;
  /* Interface & Endpoint request */
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 8005a10:	784d      	ldrb	r5, [r1, #1]
 8005a12:	2d0a      	cmp	r5, #10
 8005a14:	d004      	beq.n	8005a20 <USBD_MSC_Setup+0x78>
 8005a16:	2d0b      	cmp	r5, #11
 8005a18:	d008      	beq.n	8005a2c <USBD_MSC_Setup+0x84>
 8005a1a:	2d01      	cmp	r5, #1
 8005a1c:	d12e      	bne.n	8005a7c <USBD_MSC_Setup+0xd4>
 8005a1e:	e009      	b.n	8005a34 <USBD_MSC_Setup+0x8c>
    {
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 8005a20:	2201      	movs	r2, #1
 8005a22:	f108 0104 	add.w	r1, r8, #4
 8005a26:	f7ff ff38 	bl	800589a <USBD_CtlSendData>
                        (uint8_t *)&hmsc->interface,
                        1);
      break;
 8005a2a:	e027      	b.n	8005a7c <USBD_MSC_Setup+0xd4>
      
    case USB_REQ_SET_INTERFACE :
      hmsc->interface = (uint8_t)(req->wValue);
 8005a2c:	788b      	ldrb	r3, [r1, #2]
 8005a2e:	f8c8 3004 	str.w	r3, [r8, #4]
      break;
 8005a32:	e023      	b.n	8005a7c <USBD_MSC_Setup+0xd4>
    
    case USB_REQ_CLEAR_FEATURE:  
      
      /* Flush the FIFO and Clear the stall status */    
      USBD_LL_FlushEP(pdev, (uint8_t)req->wIndex);
 8005a34:	7909      	ldrb	r1, [r1, #4]
 8005a36:	f7fa ff58 	bl	80008ea <USBD_LL_FlushEP>
      
      /* Reactivate the EP */      
      USBD_LL_CloseEP (pdev , (uint8_t)req->wIndex);
 8005a3a:	7931      	ldrb	r1, [r6, #4]
 8005a3c:	4638      	mov	r0, r7
 8005a3e:	f7fa ff4d 	bl	80008dc <USBD_LL_CloseEP>
      if((((uint8_t)req->wIndex) & 0x80) == 0x80)
 8005a42:	f996 3004 	ldrsb.w	r3, [r6, #4]
 8005a46:	2b00      	cmp	r3, #0
 8005a48:	7c3b      	ldrb	r3, [r7, #16]
 8005a4a:	da07      	bge.n	8005a5c <USBD_MSC_Setup+0xb4>
      {
        if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8005a4c:	b913      	cbnz	r3, 8005a54 <USBD_MSC_Setup+0xac>
        {
          /* Open EP IN */
          USBD_LL_OpenEP(pdev,
 8005a4e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005a52:	e000      	b.n	8005a56 <USBD_MSC_Setup+0xae>
                         MSC_MAX_HS_PACKET);  
        }
        else
        {   
          /* Open EP IN */
          USBD_LL_OpenEP(pdev,
 8005a54:	2340      	movs	r3, #64	; 0x40
 8005a56:	2202      	movs	r2, #2
 8005a58:	2181      	movs	r1, #129	; 0x81
 8005a5a:	e006      	b.n	8005a6a <USBD_MSC_Setup+0xc2>
                         MSC_MAX_FS_PACKET);  
        }
      }
      else
      {
        if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8005a5c:	b913      	cbnz	r3, 8005a64 <USBD_MSC_Setup+0xbc>
        {
          /* Open EP IN */
          USBD_LL_OpenEP(pdev,
 8005a5e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005a62:	e000      	b.n	8005a66 <USBD_MSC_Setup+0xbe>
                         MSC_MAX_HS_PACKET);  
        }
        else
        {   
          /* Open EP IN */
          USBD_LL_OpenEP(pdev,
 8005a64:	2340      	movs	r3, #64	; 0x40
 8005a66:	2202      	movs	r2, #2
 8005a68:	4629      	mov	r1, r5
 8005a6a:	4638      	mov	r0, r7
 8005a6c:	f7fa ff2c 	bl	80008c8 <USBD_LL_OpenEP>
                         MSC_MAX_FS_PACKET);  
        }
      }
      
      /* Handle BOT error */
      MSC_BOT_CplClrFeature(pdev, (uint8_t)req->wIndex);
 8005a70:	7931      	ldrb	r1, [r6, #4]
 8005a72:	4638      	mov	r0, r7
 8005a74:	f000 f908 	bl	8005c88 <MSC_BOT_CplClrFeature>
      break;
 8005a78:	e000      	b.n	8005a7c <USBD_MSC_Setup+0xd4>
    break;
   
  default:
    break;
  }
  return 0;
 8005a7a:	2400      	movs	r4, #0
}
 8005a7c:	4620      	mov	r0, r4
 8005a7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005a82 <USBD_MSC_DataIn>:
* @param  epnum: endpoint index
* @retval status
*/
uint8_t  USBD_MSC_DataIn (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
 8005a82:	b508      	push	{r3, lr}
  MSC_BOT_DataIn(pdev , epnum);
 8005a84:	f000 f878 	bl	8005b78 <MSC_BOT_DataIn>
  return 0;
}
 8005a88:	2000      	movs	r0, #0
 8005a8a:	bd08      	pop	{r3, pc}

08005a8c <USBD_MSC_DataOut>:
* @param  epnum: endpoint index
* @retval status
*/
uint8_t  USBD_MSC_DataOut (USBD_HandleTypeDef *pdev, 
                               uint8_t epnum)
{
 8005a8c:	b508      	push	{r3, lr}
  MSC_BOT_DataOut(pdev , epnum);
 8005a8e:	f000 f88f 	bl	8005bb0 <MSC_BOT_DataOut>
  return 0;
}
 8005a92:	2000      	movs	r0, #0
 8005a94:	bd08      	pop	{r3, pc}

08005a96 <USBD_MSC_RegisterStorage>:
* @retval status
*/
uint8_t  USBD_MSC_RegisterStorage  (USBD_HandleTypeDef   *pdev, 
                                    USBD_StorageTypeDef *fops)
{
  if(fops != NULL)
 8005a96:	b109      	cbz	r1, 8005a9c <USBD_MSC_RegisterStorage+0x6>
  {
    pdev->pUserData= fops;
 8005a98:	f8c0 121c 	str.w	r1, [r0, #540]	; 0x21c
  }
  return 0;
}
 8005a9c:	2000      	movs	r0, #0
 8005a9e:	4770      	bx	lr

08005aa0 <MSC_BOT_Abort>:
* @param  pdev: device instance
* @retval status
*/

static void  MSC_BOT_Abort (USBD_HandleTypeDef  *pdev)
{
 8005aa0:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005aa2:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if ((hmsc->cbw.bmFlags == 0) && 
 8005aa6:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
* @param  pdev: device instance
* @retval status
*/

static void  MSC_BOT_Abort (USBD_HandleTypeDef  *pdev)
{
 8005aaa:	4605      	mov	r5, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  if ((hmsc->cbw.bmFlags == 0) && 
 8005aac:	b93b      	cbnz	r3, 8005abe <MSC_BOT_Abort+0x1e>
 8005aae:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8005ab2:	b123      	cbz	r3, 8005abe <MSC_BOT_Abort+0x1e>
      (hmsc->cbw.dDataLength != 0) &&
 8005ab4:	7a63      	ldrb	r3, [r4, #9]
 8005ab6:	b913      	cbnz	r3, 8005abe <MSC_BOT_Abort+0x1e>
      (hmsc->bot_status == USBD_BOT_STATUS_NORMAL) )
  {
    USBD_LL_StallEP(pdev, MSC_EPOUT_ADDR );
 8005ab8:	2101      	movs	r1, #1
 8005aba:	f7fa ff1d 	bl	80008f8 <USBD_LL_StallEP>
  }
  USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 8005abe:	2181      	movs	r1, #129	; 0x81
 8005ac0:	4628      	mov	r0, r5
 8005ac2:	f7fa ff19 	bl	80008f8 <USBD_LL_StallEP>
  
  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR)
 8005ac6:	7a63      	ldrb	r3, [r4, #9]
 8005ac8:	2b02      	cmp	r3, #2
 8005aca:	d108      	bne.n	8005ade <MSC_BOT_Abort+0x3e>
  {
    USBD_LL_PrepareReceive (pdev,
 8005acc:	f504 7203 	add.w	r2, r4, #524	; 0x20c
 8005ad0:	4628      	mov	r0, r5
 8005ad2:	231f      	movs	r3, #31
 8005ad4:	2101      	movs	r1, #1
                      MSC_EPOUT_ADDR,
                      (uint8_t *)&hmsc->cbw, 
                      USBD_BOT_CBW_LENGTH);    
  }
}
 8005ad6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }
  USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
  
  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR)
  {
    USBD_LL_PrepareReceive (pdev,
 8005ada:	f7fa bf3c 	b.w	8000956 <USBD_LL_PrepareReceive>
 8005ade:	bd70      	pop	{r4, r5, r6, pc}

08005ae0 <MSC_BOT_Init>:
*         Initialize the BOT Process
* @param  pdev: device instance
* @retval None
*/
void MSC_BOT_Init (USBD_HandleTypeDef  *pdev)
{
 8005ae0:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 8005ae2:	f8d0 5218 	ldr.w	r5, [r0, #536]	; 0x218
*         Initialize the BOT Process
* @param  pdev: device instance
* @retval None
*/
void MSC_BOT_Init (USBD_HandleTypeDef  *pdev)
{
 8005ae6:	4604      	mov	r4, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
    
  hmsc->bot_state  = USBD_BOT_IDLE;
 8005ae8:	2000      	movs	r0, #0
 8005aea:	7228      	strb	r0, [r5, #8]
  hmsc->bot_status = USBD_BOT_STATUS_NORMAL;
 8005aec:	7268      	strb	r0, [r5, #9]
  
  hmsc->scsi_sense_tail = 0;
 8005aee:	f885 025d 	strb.w	r0, [r5, #605]	; 0x25d
  hmsc->scsi_sense_head = 0;
 8005af2:	f885 025c 	strb.w	r0, [r5, #604]	; 0x25c
  
  ((USBD_StorageTypeDef *)pdev->pUserData)->Init(0);
 8005af6:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 8005afa:	681b      	ldr	r3, [r3, #0]
 8005afc:	4798      	blx	r3
  
  USBD_LL_FlushEP(pdev, MSC_EPOUT_ADDR);
 8005afe:	2101      	movs	r1, #1
 8005b00:	4620      	mov	r0, r4
 8005b02:	f7fa fef2 	bl	80008ea <USBD_LL_FlushEP>
  USBD_LL_FlushEP(pdev, MSC_EPIN_ADDR);
 8005b06:	2181      	movs	r1, #129	; 0x81
 8005b08:	4620      	mov	r0, r4
 8005b0a:	f7fa feee 	bl	80008ea <USBD_LL_FlushEP>
  
  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005b0e:	f505 7203 	add.w	r2, r5, #524	; 0x20c
 8005b12:	4620      	mov	r0, r4
 8005b14:	231f      	movs	r3, #31
 8005b16:	2101      	movs	r1, #1
                          MSC_EPOUT_ADDR,
                          (uint8_t *)&hmsc->cbw,
                          USBD_BOT_CBW_LENGTH);    
}
 8005b18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  
  USBD_LL_FlushEP(pdev, MSC_EPOUT_ADDR);
  USBD_LL_FlushEP(pdev, MSC_EPIN_ADDR);
  
  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005b1c:	f7fa bf1b 	b.w	8000956 <USBD_LL_PrepareReceive>

08005b20 <MSC_BOT_Reset>:
* @param  pdev: device instance
* @retval  None
*/
void MSC_BOT_Reset (USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 8005b20:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
    
  hmsc->bot_state  = USBD_BOT_IDLE;
 8005b24:	2300      	movs	r3, #0
  hmsc->bot_status = USBD_BOT_STATUS_RECOVERY;  
 8005b26:	2101      	movs	r1, #1
*/
void MSC_BOT_Reset (USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
    
  hmsc->bot_state  = USBD_BOT_IDLE;
 8005b28:	7213      	strb	r3, [r2, #8]
  hmsc->bot_status = USBD_BOT_STATUS_RECOVERY;  
 8005b2a:	7251      	strb	r1, [r2, #9]
  
  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005b2c:	231f      	movs	r3, #31
 8005b2e:	f502 7203 	add.w	r2, r2, #524	; 0x20c
 8005b32:	f7fa bf10 	b.w	8000956 <USBD_LL_PrepareReceive>

08005b36 <MSC_BOT_DeInit>:
* @param  pdev: device instance
* @retval None
*/
void MSC_BOT_DeInit (USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 8005b36:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  hmsc->bot_state  = USBD_BOT_IDLE;
 8005b3a:	2200      	movs	r2, #0
 8005b3c:	721a      	strb	r2, [r3, #8]
 8005b3e:	4770      	bx	lr

08005b40 <MSC_BOT_SendCSW>:
* @param  status : CSW status
* @retval None
*/
void  MSC_BOT_SendCSW (USBD_HandleTypeDef  *pdev,
                              uint8_t CSW_Status)
{
 8005b40:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005b42:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 8005b46:	4b0b      	ldr	r3, [pc, #44]	; (8005b74 <MSC_BOT_SendCSW+0x34>)
 8005b48:	f8c4 322c 	str.w	r3, [r4, #556]	; 0x22c
  hmsc->csw.bStatus = CSW_Status;
  hmsc->bot_state = USBD_BOT_IDLE;
 8005b4c:	2300      	movs	r3, #0
* @param  status : CSW status
* @retval None
*/
void  MSC_BOT_SendCSW (USBD_HandleTypeDef  *pdev,
                              uint8_t CSW_Status)
{
 8005b4e:	4605      	mov	r5, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
  hmsc->csw.bStatus = CSW_Status;
 8005b50:	f884 1238 	strb.w	r1, [r4, #568]	; 0x238
  hmsc->bot_state = USBD_BOT_IDLE;
 8005b54:	7223      	strb	r3, [r4, #8]
  
  USBD_LL_Transmit (pdev, 
 8005b56:	f504 720b 	add.w	r2, r4, #556	; 0x22c
 8005b5a:	230d      	movs	r3, #13
 8005b5c:	2181      	movs	r1, #129	; 0x81
 8005b5e:	f7fa fef3 	bl	8000948 <USBD_LL_Transmit>
             MSC_EPIN_ADDR, 
             (uint8_t *)&hmsc->csw, 
             USBD_BOT_CSW_LENGTH);
  
  /* Prepare EP to Receive next Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005b62:	f504 7203 	add.w	r2, r4, #524	; 0x20c
 8005b66:	4628      	mov	r0, r5
 8005b68:	231f      	movs	r3, #31
 8005b6a:	2101      	movs	r1, #1
                    MSC_EPOUT_ADDR,
                    (uint8_t *)&hmsc->cbw, 
                    USBD_BOT_CBW_LENGTH);  
  
}
 8005b6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             MSC_EPIN_ADDR, 
             (uint8_t *)&hmsc->csw, 
             USBD_BOT_CSW_LENGTH);
  
  /* Prepare EP to Receive next Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005b70:	f7fa bef1 	b.w	8000956 <USBD_LL_PrepareReceive>
 8005b74:	53425355 	.word	0x53425355

08005b78 <MSC_BOT_DataIn>:
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataIn (USBD_HandleTypeDef  *pdev, 
                     uint8_t epnum)
{
 8005b78:	b510      	push	{r4, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 8005b7a:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  switch (hmsc->bot_state)
 8005b7e:	7a1a      	ldrb	r2, [r3, #8]
 8005b80:	2a02      	cmp	r2, #2
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataIn (USBD_HandleTypeDef  *pdev, 
                     uint8_t epnum)
{
 8005b82:	4604      	mov	r4, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
  
  switch (hmsc->bot_state)
 8005b84:	d003      	beq.n	8005b8e <MSC_BOT_DataIn+0x16>
 8005b86:	d312      	bcc.n	8005bae <MSC_BOT_DataIn+0x36>
 8005b88:	2a04      	cmp	r2, #4
 8005b8a:	d90b      	bls.n	8005ba4 <MSC_BOT_DataIn+0x2c>
 8005b8c:	bd10      	pop	{r4, pc}
  {
  case USBD_BOT_DATA_IN:
    if(SCSI_ProcessCmd(pdev,
 8005b8e:	f203 221b 	addw	r2, r3, #539	; 0x21b
 8005b92:	f893 1219 	ldrb.w	r1, [r3, #537]	; 0x219
 8005b96:	f000 f8a5 	bl	8005ce4 <SCSI_ProcessCmd>
 8005b9a:	2800      	cmp	r0, #0
 8005b9c:	da07      	bge.n	8005bae <MSC_BOT_DataIn+0x36>
                        hmsc->cbw.bLUN,
                        &hmsc->cbw.CB[0]) < 0)
    {
      MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
 8005b9e:	2101      	movs	r1, #1
 8005ba0:	4620      	mov	r0, r4
 8005ba2:	e000      	b.n	8005ba6 <MSC_BOT_DataIn+0x2e>
    }
    break;
    
  case USBD_BOT_SEND_DATA:
  case USBD_BOT_LAST_DATA_IN:
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED);
 8005ba4:	2100      	movs	r1, #0
    break;
    
  default:
    break;
  }
}
 8005ba6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    }
    break;
    
  case USBD_BOT_SEND_DATA:
  case USBD_BOT_LAST_DATA_IN:
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED);
 8005baa:	f7ff bfc9 	b.w	8005b40 <MSC_BOT_SendCSW>
 8005bae:	bd10      	pop	{r4, pc}

08005bb0 <MSC_BOT_DataOut>:
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataOut (USBD_HandleTypeDef  *pdev, 
                      uint8_t epnum)
{
 8005bb0:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 8005bb2:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  switch (hmsc->bot_state)
 8005bb6:	7a26      	ldrb	r6, [r4, #8]
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataOut (USBD_HandleTypeDef  *pdev, 
                      uint8_t epnum)
{
 8005bb8:	4605      	mov	r5, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
  
  switch (hmsc->bot_state)
 8005bba:	b116      	cbz	r6, 8005bc2 <MSC_BOT_DataOut+0x12>
 8005bbc:	2e01      	cmp	r6, #1
 8005bbe:	d057      	beq.n	8005c70 <MSC_BOT_DataOut+0xc0>
 8005bc0:	bd70      	pop	{r4, r5, r6, pc}
*/
static void  MSC_BOT_CBW_Decode (USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
  
  hmsc->csw.dTag = hmsc->cbw.dTag;
 8005bc2:	f8d4 3210 	ldr.w	r3, [r4, #528]	; 0x210
 8005bc6:	f8c4 3230 	str.w	r3, [r4, #560]	; 0x230
  hmsc->csw.dDataResidue = hmsc->cbw.dDataLength;
 8005bca:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8005bce:	f8c4 3234 	str.w	r3, [r4, #564]	; 0x234
  
  if ((USBD_LL_GetRxDataSize (pdev ,MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 8005bd2:	2101      	movs	r1, #1
 8005bd4:	f7fa fec6 	bl	8000964 <USBD_LL_GetRxDataSize>
 8005bd8:	281f      	cmp	r0, #31
 8005bda:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
 8005bde:	d10b      	bne.n	8005bf8 <MSC_BOT_DataOut+0x48>
 8005be0:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
 8005be4:	4b27      	ldr	r3, [pc, #156]	; (8005c84 <MSC_BOT_DataOut+0xd4>)
 8005be6:	429a      	cmp	r2, r3
 8005be8:	d106      	bne.n	8005bf8 <MSC_BOT_DataOut+0x48>
      (hmsc->cbw.dSignature != USBD_BOT_CBW_SIGNATURE)||
 8005bea:	2901      	cmp	r1, #1
 8005bec:	d804      	bhi.n	8005bf8 <MSC_BOT_DataOut+0x48>
        (hmsc->cbw.bLUN > 1) || 
 8005bee:	f894 321a 	ldrb.w	r3, [r4, #538]	; 0x21a
 8005bf2:	3b01      	subs	r3, #1
 8005bf4:	2b0f      	cmp	r3, #15
 8005bf6:	d907      	bls.n	8005c08 <MSC_BOT_DataOut+0x58>
          (hmsc->cbw.bCBLength < 1) || 
            (hmsc->cbw.bCBLength > 16))
  {
    
    SCSI_SenseCode(pdev,
 8005bf8:	2320      	movs	r3, #32
 8005bfa:	2205      	movs	r2, #5
 8005bfc:	4628      	mov	r0, r5
 8005bfe:	f000 f859 	bl	8005cb4 <SCSI_SenseCode>
                   hmsc->cbw.bLUN, 
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);
    
    hmsc->bot_status = USBD_BOT_STATUS_ERROR;   
 8005c02:	2302      	movs	r3, #2
 8005c04:	7263      	strb	r3, [r4, #9]
 8005c06:	e00b      	b.n	8005c20 <MSC_BOT_DataOut+0x70>
    MSC_BOT_Abort(pdev);
 
  }
  else
  {
    if(SCSI_ProcessCmd(pdev,
 8005c08:	f204 221b 	addw	r2, r4, #539	; 0x21b
 8005c0c:	4628      	mov	r0, r5
 8005c0e:	f000 f869 	bl	8005ce4 <SCSI_ProcessCmd>
 8005c12:	2800      	cmp	r0, #0
 8005c14:	7a23      	ldrb	r3, [r4, #8]
 8005c16:	da08      	bge.n	8005c2a <MSC_BOT_DataOut+0x7a>
                       hmsc->cbw.bLUN,
                       &hmsc->cbw.CB[0]) < 0)
    {
      if(hmsc->bot_state == USBD_BOT_NO_DATA)
 8005c18:	2b05      	cmp	r3, #5
 8005c1a:	d101      	bne.n	8005c20 <MSC_BOT_DataOut+0x70>
      {
       MSC_BOT_SendCSW (pdev,
 8005c1c:	2101      	movs	r1, #1
 8005c1e:	e022      	b.n	8005c66 <MSC_BOT_DataOut+0xb6>
                         USBD_CSW_CMD_FAILED); 
      }
      else
      {
        MSC_BOT_Abort(pdev);
 8005c20:	4628      	mov	r0, r5
    break;
    
  default:
    break;
  }
}
 8005c22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
       MSC_BOT_SendCSW (pdev,
                         USBD_CSW_CMD_FAILED); 
      }
      else
      {
        MSC_BOT_Abort(pdev);
 8005c26:	f7ff bf3b 	b.w	8005aa0 <MSC_BOT_Abort>
      }
    }
    /*Burst xfer handled internally*/
    else if ((hmsc->bot_state != USBD_BOT_DATA_IN) && 
 8005c2a:	3b01      	subs	r3, #1
 8005c2c:	2b02      	cmp	r3, #2
 8005c2e:	d927      	bls.n	8005c80 <MSC_BOT_DataOut+0xd0>
             (hmsc->bot_state != USBD_BOT_DATA_OUT) &&
             (hmsc->bot_state != USBD_BOT_LAST_DATA_IN)) 
    {
      if (hmsc->bot_data_length > 0)
 8005c30:	8961      	ldrh	r1, [r4, #10]
 8005c32:	b1c1      	cbz	r1, 8005c66 <MSC_BOT_DataOut+0xb6>
*/
static void  MSC_BOT_SendData(USBD_HandleTypeDef  *pdev,
                              uint8_t* buf, 
                              uint16_t len)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005c34:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
  
  len = MIN (hmsc->cbw.dDataLength, len);
 8005c38:	f8d2 3214 	ldr.w	r3, [r2, #532]	; 0x214
  hmsc->csw.dDataResidue -= len;
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
 8005c3c:	f882 6238 	strb.w	r6, [r2, #568]	; 0x238
                              uint8_t* buf, 
                              uint16_t len)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  len = MIN (hmsc->cbw.dDataLength, len);
 8005c40:	4299      	cmp	r1, r3
 8005c42:	bf28      	it	cs
 8005c44:	4619      	movcs	r1, r3
  hmsc->csw.dDataResidue -= len;
 8005c46:	f8d2 3234 	ldr.w	r3, [r2, #564]	; 0x234
 8005c4a:	1a5b      	subs	r3, r3, r1
 8005c4c:	f8c2 3234 	str.w	r3, [r2, #564]	; 0x234
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
  hmsc->bot_state = USBD_BOT_SEND_DATA;
 8005c50:	2304      	movs	r3, #4
 8005c52:	7213      	strb	r3, [r2, #8]
  
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, buf, len);  
 8005c54:	4628      	mov	r0, r5
 8005c56:	b28b      	uxth	r3, r1
 8005c58:	f104 020c 	add.w	r2, r4, #12
 8005c5c:	2181      	movs	r1, #129	; 0x81
    break;
    
  default:
    break;
  }
}
 8005c5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  len = MIN (hmsc->cbw.dDataLength, len);
  hmsc->csw.dDataResidue -= len;
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
  hmsc->bot_state = USBD_BOT_SEND_DATA;
  
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, buf, len);  
 8005c62:	f7fa be71 	b.w	8000948 <USBD_LL_Transmit>
                         hmsc->bot_data, 
                         hmsc->bot_data_length);
      }
      else if (hmsc->bot_data_length == 0) 
      {
        MSC_BOT_SendCSW (pdev,
 8005c66:	4628      	mov	r0, r5
    break;
    
  default:
    break;
  }
}
 8005c68:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                         hmsc->bot_data, 
                         hmsc->bot_data_length);
      }
      else if (hmsc->bot_data_length == 0) 
      {
        MSC_BOT_SendCSW (pdev,
 8005c6c:	f7ff bf68 	b.w	8005b40 <MSC_BOT_SendCSW>
    MSC_BOT_CBW_Decode(pdev);
    break;
    
  case USBD_BOT_DATA_OUT:
    
    if(SCSI_ProcessCmd(pdev,
 8005c70:	f204 221b 	addw	r2, r4, #539	; 0x21b
 8005c74:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
 8005c78:	f000 f834 	bl	8005ce4 <SCSI_ProcessCmd>
 8005c7c:	2800      	cmp	r0, #0
 8005c7e:	dbcd      	blt.n	8005c1c <MSC_BOT_DataOut+0x6c>
 8005c80:	bd70      	pop	{r4, r5, r6, pc}
 8005c82:	bf00      	nop
 8005c84:	43425355 	.word	0x43425355

08005c88 <MSC_BOT_CplClrFeature>:
* @param  epnum: endpoint index
* @retval None
*/

void  MSC_BOT_CplClrFeature (USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
 8005c88:	b510      	push	{r4, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005c8a:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR )/* Bad CBW Signature */
 8005c8e:	7a63      	ldrb	r3, [r4, #9]
 8005c90:	2b02      	cmp	r3, #2
 8005c92:	d105      	bne.n	8005ca0 <MSC_BOT_CplClrFeature+0x18>
  {
    USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 8005c94:	2181      	movs	r1, #129	; 0x81
 8005c96:	f7fa fe2f 	bl	80008f8 <USBD_LL_StallEP>
    hmsc->bot_status = USBD_BOT_STATUS_NORMAL;    
 8005c9a:	2300      	movs	r3, #0
 8005c9c:	7263      	strb	r3, [r4, #9]
 8005c9e:	bd10      	pop	{r4, pc}
  }
  else if(((epnum & 0x80) == 0x80) && ( hmsc->bot_status != USBD_BOT_STATUS_RECOVERY))
 8005ca0:	060a      	lsls	r2, r1, #24
 8005ca2:	d506      	bpl.n	8005cb2 <MSC_BOT_CplClrFeature+0x2a>
 8005ca4:	2b01      	cmp	r3, #1
 8005ca6:	d004      	beq.n	8005cb2 <MSC_BOT_CplClrFeature+0x2a>
  {
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
 8005ca8:	2101      	movs	r1, #1
  }
  
}
 8005caa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
    hmsc->bot_status = USBD_BOT_STATUS_NORMAL;    
  }
  else if(((epnum & 0x80) == 0x80) && ( hmsc->bot_status != USBD_BOT_STATUS_RECOVERY))
  {
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
 8005cae:	f7ff bf47 	b.w	8005b40 <MSC_BOT_SendCSW>
 8005cb2:	bd10      	pop	{r4, pc}

08005cb4 <SCSI_SenseCode>:
* @param  ASC: Additional Sense Key
* @retval none

*/
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
 8005cb4:	b510      	push	{r4, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005cb6:	f8d0 0218 	ldr.w	r0, [r0, #536]	; 0x218
  
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8005cba:	f890 125d 	ldrb.w	r1, [r0, #605]	; 0x25d
 8005cbe:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
  hmsc->scsi_sense_tail++;
 8005cc2:	3101      	adds	r1, #1
 8005cc4:	b2c9      	uxtb	r1, r1
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8005cc6:	021b      	lsls	r3, r3, #8
  hmsc->scsi_sense_tail++;
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8005cc8:	2904      	cmp	r1, #4
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8005cca:	f8c4 3240 	str.w	r3, [r4, #576]	; 0x240
  hmsc->scsi_sense_tail++;
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
  {
    hmsc->scsi_sense_tail = 0;
 8005cce:	bf08      	it	eq
 8005cd0:	2300      	moveq	r3, #0
*/
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8005cd2:	f884 223c 	strb.w	r2, [r4, #572]	; 0x23c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
  hmsc->scsi_sense_tail++;
 8005cd6:	bf14      	ite	ne
 8005cd8:	f880 125d 	strbne.w	r1, [r0, #605]	; 0x25d
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
  {
    hmsc->scsi_sense_tail = 0;
 8005cdc:	f880 325d 	strbeq.w	r3, [r0, #605]	; 0x25d
 8005ce0:	bd10      	pop	{r4, pc}
	...

08005ce4 <SCSI_ProcessCmd>:
* @retval status
*/
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef  *pdev,
                           uint8_t lun, 
                           uint8_t *params)
{
 8005ce4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  
  switch (params[0])
 8005ce8:	7813      	ldrb	r3, [r2, #0]
 8005cea:	2b1e      	cmp	r3, #30
* @retval status
*/
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef  *pdev,
                           uint8_t lun, 
                           uint8_t *params)
{
 8005cec:	4605      	mov	r5, r0
 8005cee:	460f      	mov	r7, r1
 8005cf0:	4690      	mov	r8, r2
  
  switch (params[0])
 8005cf2:	f000 8089 	beq.w	8005e08 <SCSI_ProcessCmd+0x124>
 8005cf6:	d813      	bhi.n	8005d20 <SCSI_ProcessCmd+0x3c>
 8005cf8:	2b12      	cmp	r3, #18
 8005cfa:	d066      	beq.n	8005dca <SCSI_ProcessCmd+0xe6>
 8005cfc:	d80b      	bhi.n	8005d16 <SCSI_ProcessCmd+0x32>
 8005cfe:	b31b      	cbz	r3, 8005d48 <SCSI_ProcessCmd+0x64>
 8005d00:	2b03      	cmp	r3, #3
 8005d02:	f040 81f8 	bne.w	80060f6 <SCSI_ProcessCmd+0x412>
 8005d06:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  uint8_t i;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  for(i=0 ; i < REQUEST_SENSE_DATA_LEN ; i++) 
  {
    hmsc->bot_data[i] = 0;
 8005d0a:	2000      	movs	r0, #0
 8005d0c:	f103 020b 	add.w	r2, r3, #11
 8005d10:	f103 011d 	add.w	r1, r3, #29
 8005d14:	e031      	b.n	8005d7a <SCSI_ProcessCmd+0x96>
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef  *pdev,
                           uint8_t lun, 
                           uint8_t *params)
{
  
  switch (params[0])
 8005d16:	2b1a      	cmp	r3, #26
 8005d18:	d07a      	beq.n	8005e10 <SCSI_ProcessCmd+0x12c>
 8005d1a:	2b1b      	cmp	r3, #27
 8005d1c:	d074      	beq.n	8005e08 <SCSI_ProcessCmd+0x124>
 8005d1e:	e1ea      	b.n	80060f6 <SCSI_ProcessCmd+0x412>
 8005d20:	2b28      	cmp	r3, #40	; 0x28
 8005d22:	f000 80dc 	beq.w	8005ede <SCSI_ProcessCmd+0x1fa>
 8005d26:	d806      	bhi.n	8005d36 <SCSI_ProcessCmd+0x52>
 8005d28:	2b23      	cmp	r3, #35	; 0x23
 8005d2a:	f000 808b 	beq.w	8005e44 <SCSI_ProcessCmd+0x160>
 8005d2e:	2b25      	cmp	r3, #37	; 0x25
 8005d30:	f000 80b2 	beq.w	8005e98 <SCSI_ProcessCmd+0x1b4>
 8005d34:	e1df      	b.n	80060f6 <SCSI_ProcessCmd+0x412>
 8005d36:	2b2f      	cmp	r3, #47	; 0x2f
 8005d38:	f000 81c8 	beq.w	80060cc <SCSI_ProcessCmd+0x3e8>
 8005d3c:	2b5a      	cmp	r3, #90	; 0x5a
 8005d3e:	d074      	beq.n	8005e2a <SCSI_ProcessCmd+0x146>
 8005d40:	2b2a      	cmp	r3, #42	; 0x2a
 8005d42:	f040 81d8 	bne.w	80060f6 <SCSI_ProcessCmd+0x412>
 8005d46:	e141      	b.n	8005fcc <SCSI_ProcessCmd+0x2e8>
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_TestUnitReady(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 8005d48:	f8d0 6218 	ldr.w	r6, [r0, #536]	; 0x218
    
  /* case 9 : Hi > D0 */
  if (hmsc->cbw.dDataLength != 0)
 8005d4c:	f8d6 3214 	ldr.w	r3, [r6, #532]	; 0x214
 8005d50:	2b00      	cmp	r3, #0
 8005d52:	f040 8144 	bne.w	8005fde <SCSI_ProcessCmd+0x2fa>
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);
    return -1;
  }  
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) !=0 )
 8005d56:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8005d5a:	4608      	mov	r0, r1
 8005d5c:	689b      	ldr	r3, [r3, #8]
 8005d5e:	4798      	blx	r3
 8005d60:	4604      	mov	r4, r0
 8005d62:	b140      	cbz	r0, 8005d76 <SCSI_ProcessCmd+0x92>
  {
    SCSI_SenseCode(pdev,
 8005d64:	233a      	movs	r3, #58	; 0x3a
 8005d66:	2202      	movs	r2, #2
 8005d68:	4639      	mov	r1, r7
 8005d6a:	4628      	mov	r0, r5
 8005d6c:	f7ff ffa2 	bl	8005cb4 <SCSI_SenseCode>
                   lun,
                   NOT_READY, 
                   MEDIUM_NOT_PRESENT);
    
    hmsc->bot_state = USBD_BOT_NO_DATA;
 8005d70:	2305      	movs	r3, #5
 8005d72:	7233      	strb	r3, [r6, #8]
 8005d74:	e1c5      	b.n	8006102 <SCSI_ProcessCmd+0x41e>
    return -1;
  } 
  hmsc->bot_data_length = 0;
 8005d76:	8170      	strh	r0, [r6, #10]
 8005d78:	e203      	b.n	8006182 <SCSI_ProcessCmd+0x49e>
  uint8_t i;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  for(i=0 ; i < REQUEST_SENSE_DATA_LEN ; i++) 
  {
    hmsc->bot_data[i] = 0;
 8005d7a:	f802 0f01 	strb.w	r0, [r2, #1]!
static int8_t SCSI_RequestSense (USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  uint8_t i;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  for(i=0 ; i < REQUEST_SENSE_DATA_LEN ; i++) 
 8005d7e:	4291      	cmp	r1, r2
 8005d80:	d1fb      	bne.n	8005d7a <SCSI_ProcessCmd+0x96>
  {
    hmsc->bot_data[i] = 0;
  }
  
  hmsc->bot_data[0]	= 0x70;		
 8005d82:	2270      	movs	r2, #112	; 0x70
 8005d84:	731a      	strb	r2, [r3, #12]
  hmsc->bot_data[7]	= REQUEST_SENSE_DATA_LEN - 6;	
 8005d86:	220c      	movs	r2, #12
 8005d88:	74da      	strb	r2, [r3, #19]
  
  if((hmsc->scsi_sense_head != hmsc->scsi_sense_tail)) {
 8005d8a:	f893 125d 	ldrb.w	r1, [r3, #605]	; 0x25d
 8005d8e:	f893 225c 	ldrb.w	r2, [r3, #604]	; 0x25c
 8005d92:	4291      	cmp	r1, r2
 8005d94:	d011      	beq.n	8005dba <SCSI_ProcessCmd+0xd6>
 8005d96:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
    
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;		
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;	
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;	
    hmsc->scsi_sense_head++;
 8005d9a:	3201      	adds	r2, #1
  hmsc->bot_data[0]	= 0x70;		
  hmsc->bot_data[7]	= REQUEST_SENSE_DATA_LEN - 6;	
  
  if((hmsc->scsi_sense_head != hmsc->scsi_sense_tail)) {
    
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;		
 8005d9c:	f891 023c 	ldrb.w	r0, [r1, #572]	; 0x23c
 8005da0:	7398      	strb	r0, [r3, #14]
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;	
 8005da2:	f891 0241 	ldrb.w	r0, [r1, #577]	; 0x241
 8005da6:	7618      	strb	r0, [r3, #24]
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;	
    hmsc->scsi_sense_head++;
 8005da8:	b2d2      	uxtb	r2, r2
    
    if (hmsc->scsi_sense_head == SENSE_LIST_DEEPTH)
 8005daa:	2a04      	cmp	r2, #4
  
  if((hmsc->scsi_sense_head != hmsc->scsi_sense_tail)) {
    
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;		
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;	
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;	
 8005dac:	f891 1240 	ldrb.w	r1, [r1, #576]	; 0x240
 8005db0:	7659      	strb	r1, [r3, #25]
    hmsc->scsi_sense_head++;
    
    if (hmsc->scsi_sense_head == SENSE_LIST_DEEPTH)
    {
      hmsc->scsi_sense_head = 0;
 8005db2:	bf08      	it	eq
 8005db4:	2200      	moveq	r2, #0
 8005db6:	f883 225c 	strb.w	r2, [r3, #604]	; 0x25c
    }
  }
  hmsc->bot_data_length = REQUEST_SENSE_DATA_LEN;  
 8005dba:	2212      	movs	r2, #18
 8005dbc:	815a      	strh	r2, [r3, #10]
  
  if (params[4] <= REQUEST_SENSE_DATA_LEN)
 8005dbe:	f898 2004 	ldrb.w	r2, [r8, #4]
 8005dc2:	2a12      	cmp	r2, #18
  {
    hmsc->bot_data_length = params[4];
 8005dc4:	bf98      	it	ls
 8005dc6:	815a      	strhls	r2, [r3, #10]
 8005dc8:	e17e      	b.n	80060c8 <SCSI_ProcessCmd+0x3e4>
{
  uint8_t* pPage;
  uint16_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  if (params[1] & 0x01)/*Evpd is set*/
 8005dca:	7853      	ldrb	r3, [r2, #1]
*/
static int8_t  SCSI_Inquiry(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  uint8_t* pPage;
  uint16_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005dcc:	f8d0 1218 	ldr.w	r1, [r0, #536]	; 0x218
  
  if (params[1] & 0x01)/*Evpd is set*/
 8005dd0:	07db      	lsls	r3, r3, #31
 8005dd2:	d40d      	bmi.n	8005df0 <SCSI_ProcessCmd+0x10c>
    len = LENGTH_INQUIRY_PAGE00;
  }
  else
  {
    
    pPage = (uint8_t *)&((USBD_StorageTypeDef *)pdev->pUserData)->pInquiry[lun * STANDARD_INQUIRY_DATA_LEN];
 8005dd4:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
    len = pPage[4] + 5;
    
    if (params[4] <= len)
 8005dd8:	7912      	ldrb	r2, [r2, #4]
    len = LENGTH_INQUIRY_PAGE00;
  }
  else
  {
    
    pPage = (uint8_t *)&((USBD_StorageTypeDef *)pdev->pUserData)->pInquiry[lun * STANDARD_INQUIRY_DATA_LEN];
 8005dda:	69db      	ldr	r3, [r3, #28]
 8005ddc:	eb07 07c7 	add.w	r7, r7, r7, lsl #3
 8005de0:	eb03 0787 	add.w	r7, r3, r7, lsl #2
    len = pPage[4] + 5;
 8005de4:	793b      	ldrb	r3, [r7, #4]
 8005de6:	3305      	adds	r3, #5
 8005de8:	4293      	cmp	r3, r2
 8005dea:	bf28      	it	cs
 8005dec:	4613      	movcs	r3, r2
 8005dee:	e001      	b.n	8005df4 <SCSI_ProcessCmd+0x110>
  uint16_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  if (params[1] & 0x01)/*Evpd is set*/
  {
    pPage = (uint8_t *)MSC_Page00_Inquiry_Data;
 8005df0:	4fd0      	ldr	r7, [pc, #832]	; (8006134 <SCSI_ProcessCmd+0x450>)
    len = LENGTH_INQUIRY_PAGE00;
 8005df2:	2307      	movs	r3, #7
    if (params[4] <= len)
    {
      len = params[4];
    }
  }
  hmsc->bot_data_length = len;
 8005df4:	814b      	strh	r3, [r1, #10]
  
  while (len) 
 8005df6:	2b00      	cmp	r3, #0
 8005df8:	f000 8166 	beq.w	80060c8 <SCSI_ProcessCmd+0x3e4>
  {
    len--;
 8005dfc:	3b01      	subs	r3, #1
 8005dfe:	b29b      	uxth	r3, r3
    hmsc->bot_data[len] = pPage[len];
 8005e00:	18ca      	adds	r2, r1, r3
 8005e02:	5cf8      	ldrb	r0, [r7, r3]
 8005e04:	7310      	strb	r0, [r2, #12]
 8005e06:	e7f6      	b.n	8005df6 <SCSI_ProcessCmd+0x112>
* @retval status
*/
static int8_t SCSI_StartStopUnit(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;   
  hmsc->bot_data_length = 0;
 8005e08:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8005e0c:	2400      	movs	r4, #0
 8005e0e:	e1b7      	b.n	8006180 <SCSI_ProcessCmd+0x49c>
 8005e10:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
  hmsc->bot_data_length = len;
  
  while (len) 
  {
    len--;
    hmsc->bot_data[len] = MSC_Mode_Sense6_data[len];
 8005e14:	4cc8      	ldr	r4, [pc, #800]	; (8006138 <SCSI_ProcessCmd+0x454>)
*/
static int8_t SCSI_ModeSense6 (USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  uint16_t len = 8 ;
  hmsc->bot_data_length = len;
 8005e16:	2308      	movs	r3, #8
 8005e18:	8153      	strh	r3, [r2, #10]
  
  while (len) 
  {
    len--;
 8005e1a:	3b01      	subs	r3, #1
 8005e1c:	b29b      	uxth	r3, r3
    hmsc->bot_data[len] = MSC_Mode_Sense6_data[len];
 8005e1e:	18d1      	adds	r1, r2, r3
 8005e20:	5ce0      	ldrb	r0, [r4, r3]
 8005e22:	7308      	strb	r0, [r1, #12]
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  uint16_t len = 8 ;
  hmsc->bot_data_length = len;
  
  while (len) 
 8005e24:	2b00      	cmp	r3, #0
 8005e26:	d1f8      	bne.n	8005e1a <SCSI_ProcessCmd+0x136>
 8005e28:	e14e      	b.n	80060c8 <SCSI_ProcessCmd+0x3e4>
 8005e2a:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
  hmsc->bot_data_length = len;

  while (len) 
  {
    len--;
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 8005e2e:	4cc3      	ldr	r4, [pc, #780]	; (800613c <SCSI_ProcessCmd+0x458>)
static int8_t SCSI_ModeSense10 (USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  uint16_t len = 8;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->bot_data_length = len;
 8005e30:	2308      	movs	r3, #8
 8005e32:	8153      	strh	r3, [r2, #10]

  while (len) 
  {
    len--;
 8005e34:	3b01      	subs	r3, #1
 8005e36:	b29b      	uxth	r3, r3
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 8005e38:	18d1      	adds	r1, r2, r3
 8005e3a:	5ce0      	ldrb	r0, [r4, r3]
 8005e3c:	7308      	strb	r0, [r1, #12]
  uint16_t len = 8;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->bot_data_length = len;

  while (len) 
 8005e3e:	2b00      	cmp	r3, #0
 8005e40:	d1f8      	bne.n	8005e34 <SCSI_ProcessCmd+0x150>
 8005e42:	e141      	b.n	80060c8 <SCSI_ProcessCmd+0x3e4>
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_ReadFormatCapacity(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005e44:	f8d0 6218 	ldr.w	r6, [r0, #536]	; 0x218
  uint32_t blk_nbr;
  uint16_t i;
  
  for(i=0 ; i < 12 ; i++) 
  {
    hmsc->bot_data[i] = 0;
 8005e48:	2100      	movs	r1, #0
 8005e4a:	f106 030b 	add.w	r3, r6, #11
 8005e4e:	f106 0217 	add.w	r2, r6, #23
 8005e52:	f803 1f01 	strb.w	r1, [r3, #1]!
  
  uint16_t blk_size;
  uint32_t blk_nbr;
  uint16_t i;
  
  for(i=0 ; i < 12 ; i++) 
 8005e56:	429a      	cmp	r2, r3
 8005e58:	d1fb      	bne.n	8005e52 <SCSI_ProcessCmd+0x16e>
  {
    hmsc->bot_data[i] = 0;
  }
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &blk_nbr, &blk_size) != 0)
 8005e5a:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
 8005e5e:	f10d 0202 	add.w	r2, sp, #2
 8005e62:	685b      	ldr	r3, [r3, #4]
 8005e64:	a901      	add	r1, sp, #4
 8005e66:	4638      	mov	r0, r7
 8005e68:	4798      	blx	r3
 8005e6a:	4604      	mov	r4, r0
 8005e6c:	bb08      	cbnz	r0, 8005eb2 <SCSI_ProcessCmd+0x1ce>
                   MEDIUM_NOT_PRESENT);
    return -1;
  } 
  else
  {
    hmsc->bot_data[3] = 0x08;
 8005e6e:	2308      	movs	r3, #8
 8005e70:	73f3      	strb	r3, [r6, #15]
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1) >> 24);
 8005e72:	9b01      	ldr	r3, [sp, #4]
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1) >> 16);
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
    
    hmsc->bot_data[8] = 0x02;
    hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
 8005e74:	7570      	strb	r0, [r6, #21]
    return -1;
  } 
  else
  {
    hmsc->bot_data[3] = 0x08;
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1) >> 24);
 8005e76:	3b01      	subs	r3, #1
 8005e78:	0e1a      	lsrs	r2, r3, #24
 8005e7a:	7432      	strb	r2, [r6, #16]
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1) >> 16);
 8005e7c:	0c1a      	lsrs	r2, r3, #16
 8005e7e:	7472      	strb	r2, [r6, #17]
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
 8005e80:	74f3      	strb	r3, [r6, #19]
  else
  {
    hmsc->bot_data[3] = 0x08;
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1) >> 24);
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1) >> 16);
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
 8005e82:	0a1a      	lsrs	r2, r3, #8
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
    
    hmsc->bot_data[8] = 0x02;
 8005e84:	2302      	movs	r3, #2
 8005e86:	7533      	strb	r3, [r6, #20]
    hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
 8005e88:	f8bd 3002 	ldrh.w	r3, [sp, #2]
  else
  {
    hmsc->bot_data[3] = 0x08;
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1) >> 24);
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1) >> 16);
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
 8005e8c:	74b2      	strb	r2, [r6, #18]
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
    
    hmsc->bot_data[8] = 0x02;
    hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
    hmsc->bot_data[10] = (uint8_t)(blk_size >>  8);
 8005e8e:	0a1a      	lsrs	r2, r3, #8
    hmsc->bot_data[11] = (uint8_t)(blk_size);
 8005e90:	75f3      	strb	r3, [r6, #23]
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
    
    hmsc->bot_data[8] = 0x02;
    hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
    hmsc->bot_data[10] = (uint8_t)(blk_size >>  8);
 8005e92:	75b2      	strb	r2, [r6, #22]
    hmsc->bot_data[11] = (uint8_t)(blk_size);
    
    hmsc->bot_data_length = 12;
 8005e94:	230c      	movs	r3, #12
 8005e96:	e020      	b.n	8005eda <SCSI_ProcessCmd+0x1f6>
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_ReadCapacity10(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005e98:	f8d0 6218 	ldr.w	r6, [r0, #536]	; 0x218
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &hmsc->scsi_blk_nbr, &hmsc->scsi_blk_size) != 0)
 8005e9c:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8005ea0:	f206 225e 	addw	r2, r6, #606	; 0x25e
 8005ea4:	685b      	ldr	r3, [r3, #4]
 8005ea6:	f506 7118 	add.w	r1, r6, #608	; 0x260
 8005eaa:	4638      	mov	r0, r7
 8005eac:	4798      	blx	r3
 8005eae:	4604      	mov	r4, r0
 8005eb0:	b108      	cbz	r0, 8005eb6 <SCSI_ProcessCmd+0x1d2>
  {
    SCSI_SenseCode(pdev,
 8005eb2:	233a      	movs	r3, #58	; 0x3a
 8005eb4:	e0a8      	b.n	8006008 <SCSI_ProcessCmd+0x324>
    return -1;
  } 
  else
  {
    
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 24);
 8005eb6:	f8d6 3260 	ldr.w	r3, [r6, #608]	; 0x260
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
    
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
 8005eba:	7430      	strb	r0, [r6, #16]
    return -1;
  } 
  else
  {
    
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 24);
 8005ebc:	3b01      	subs	r3, #1
 8005ebe:	0e1a      	lsrs	r2, r3, #24
 8005ec0:	7332      	strb	r2, [r6, #12]
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
 8005ec2:	0c1a      	lsrs	r2, r3, #16
 8005ec4:	7372      	strb	r2, [r6, #13]
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
 8005ec6:	73f3      	strb	r3, [r6, #15]
  else
  {
    
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 24);
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
 8005ec8:	0a1a      	lsrs	r2, r3, #8
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
    
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
 8005eca:	f8b6 325e 	ldrh.w	r3, [r6, #606]	; 0x25e
  else
  {
    
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 24);
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
 8005ece:	73b2      	strb	r2, [r6, #14]
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
    
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
    hmsc->bot_data[5] = (uint8_t)(hmsc->scsi_blk_size >>  16);
    hmsc->bot_data[6] = (uint8_t)(hmsc->scsi_blk_size >>  8);
 8005ed0:	0a1a      	lsrs	r2, r3, #8
    hmsc->bot_data[7] = (uint8_t)(hmsc->scsi_blk_size);
 8005ed2:	74f3      	strb	r3, [r6, #19]
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
    
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
    hmsc->bot_data[5] = (uint8_t)(hmsc->scsi_blk_size >>  16);
 8005ed4:	7470      	strb	r0, [r6, #17]
    hmsc->bot_data[6] = (uint8_t)(hmsc->scsi_blk_size >>  8);
 8005ed6:	74b2      	strb	r2, [r6, #18]
    hmsc->bot_data[7] = (uint8_t)(hmsc->scsi_blk_size);
    
    hmsc->bot_data_length = 8;
 8005ed8:	2308      	movs	r3, #8
 8005eda:	8173      	strh	r3, [r6, #10]
 8005edc:	e151      	b.n	8006182 <SCSI_ProcessCmd+0x49e>
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_Read10(USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 8005ede:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if(hmsc->bot_state == USBD_BOT_IDLE)  /* Idle */
 8005ee2:	7a23      	ldrb	r3, [r4, #8]
 8005ee4:	bb8b      	cbnz	r3, 8005f4a <SCSI_ProcessCmd+0x266>
  {
    
    /* case 10 : Ho <> Di */
    
    if ((hmsc->cbw.bmFlags & 0x80) != 0x80)
 8005ee6:	f994 3218 	ldrsb.w	r3, [r4, #536]	; 0x218
 8005eea:	2b00      	cmp	r3, #0
 8005eec:	db04      	blt.n	8005ef8 <SCSI_ProcessCmd+0x214>
    {
      SCSI_SenseCode(pdev,
 8005eee:	2320      	movs	r3, #32
 8005ef0:	2205      	movs	r2, #5
 8005ef2:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
 8005ef6:	e102      	b.n	80060fe <SCSI_ProcessCmd+0x41a>
                     ILLEGAL_REQUEST, 
                     INVALID_CDB);
      return -1;
    }    
    
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) !=0 )
 8005ef8:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8005efc:	4608      	mov	r0, r1
 8005efe:	689b      	ldr	r3, [r3, #8]
 8005f00:	4798      	blx	r3
 8005f02:	2800      	cmp	r0, #0
 8005f04:	d1d5      	bne.n	8005eb2 <SCSI_ProcessCmd+0x1ce>
                     NOT_READY, 
                     MEDIUM_NOT_PRESENT);
      return -1;
    } 
    
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 8005f06:	f898 3003 	ldrb.w	r3, [r8, #3]
 8005f0a:	f898 2002 	ldrb.w	r2, [r8, #2]
 8005f0e:	041b      	lsls	r3, r3, #16
 8005f10:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8005f14:	f898 2005 	ldrb.w	r2, [r8, #5]
 8005f18:	4313      	orrs	r3, r2
 8005f1a:	f898 2004 	ldrb.w	r2, [r8, #4]
 8005f1e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005f22:	f8c4 3264 	str.w	r3, [r4, #612]	; 0x264
      (params[3] << 16) | \
        (params[4] <<  8) | \
          params[5];
    
    hmsc->scsi_blk_len =  (params[7] <<  8) | \
 8005f26:	f898 2008 	ldrb.w	r2, [r8, #8]
 8005f2a:	f898 1007 	ldrb.w	r1, [r8, #7]
 8005f2e:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 8005f32:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
    hmsc->scsi_blk_addr = (params[2] << 24) | \
      (params[3] << 16) | \
        (params[4] <<  8) | \
          params[5];
    
    hmsc->scsi_blk_len =  (params[7] <<  8) | \
 8005f36:	f8c4 1268 	str.w	r1, [r4, #616]	; 0x268
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 8005f3a:	f8d2 2260 	ldr.w	r2, [r2, #608]	; 0x260
 8005f3e:	1858      	adds	r0, r3, r1
 8005f40:	4290      	cmp	r0, r2
 8005f42:	f240 80e1 	bls.w	8006108 <SCSI_ProcessCmd+0x424>
  {
    SCSI_SenseCode(pdev,
 8005f46:	2321      	movs	r3, #33	; 0x21
 8005f48:	e0d6      	b.n	80060f8 <SCSI_ProcessCmd+0x414>
* @param  lun: Logical unit number
* @retval status
*/
static int8_t SCSI_ProcessRead (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;   
 8005f4a:	f8d5 6218 	ldr.w	r6, [r5, #536]	; 0x218
  uint32_t len;
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
  
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun ,
 8005f4e:	f8d5 021c 	ldr.w	r0, [r5, #540]	; 0x21c
 8005f52:	f8b6 225e 	ldrh.w	r2, [r6, #606]	; 0x25e
 8005f56:	f8d6 1264 	ldr.w	r1, [r6, #612]	; 0x264
 8005f5a:	f8d0 9010 	ldr.w	r9, [r0, #16]
                     ILLEGAL_REQUEST, 
                     INVALID_CDB);
      return -1;
    }
  }
  hmsc->bot_data_length = MSC_MEDIA_PACKET;  
 8005f5e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005f62:	8163      	strh	r3, [r4, #10]
static int8_t SCSI_ProcessRead (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;   
  uint32_t len;
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 8005f64:	f8d6 3268 	ldr.w	r3, [r6, #616]	; 0x268
 8005f68:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005f6c:	bf28      	it	cs
 8005f6e:	f44f 7300 	movcs.w	r3, #512	; 0x200
  
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun ,
                              hmsc->bot_data, 
 8005f72:	f106 040c 	add.w	r4, r6, #12
static int8_t SCSI_ProcessRead (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;   
  uint32_t len;
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 8005f76:	4698      	mov	r8, r3
  
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun ,
 8005f78:	4638      	mov	r0, r7
 8005f7a:	fbb3 f3f2 	udiv	r3, r3, r2
 8005f7e:	fbb1 f2f2 	udiv	r2, r1, r2
 8005f82:	b29b      	uxth	r3, r3
 8005f84:	4621      	mov	r1, r4
 8005f86:	47c8      	blx	r9
 8005f88:	2800      	cmp	r0, #0
 8005f8a:	da01      	bge.n	8005f90 <SCSI_ProcessCmd+0x2ac>
                              hmsc->bot_data, 
                              hmsc->scsi_blk_addr / hmsc->scsi_blk_size, 
                              len / hmsc->scsi_blk_size) < 0)
  {
    
    SCSI_SenseCode(pdev,
 8005f8c:	2311      	movs	r3, #17
 8005f8e:	e079      	b.n	8006084 <SCSI_ProcessCmd+0x3a0>
                   UNRECOVERED_READ_ERROR);
    return -1; 
  }
  
  
  USBD_LL_Transmit (pdev, 
 8005f90:	fa1f f388 	uxth.w	r3, r8
 8005f94:	4622      	mov	r2, r4
 8005f96:	2181      	movs	r1, #129	; 0x81
 8005f98:	4628      	mov	r0, r5
 8005f9a:	f7fa fcd5 	bl	8000948 <USBD_LL_Transmit>
             MSC_EPIN_ADDR,
             hmsc->bot_data,
             len);
  
  
  hmsc->scsi_blk_addr   += len; 
 8005f9e:	f8d6 3264 	ldr.w	r3, [r6, #612]	; 0x264
  hmsc->scsi_blk_len    -= len;  
 8005fa2:	f8d6 4268 	ldr.w	r4, [r6, #616]	; 0x268
             MSC_EPIN_ADDR,
             hmsc->bot_data,
             len);
  
  
  hmsc->scsi_blk_addr   += len; 
 8005fa6:	4443      	add	r3, r8
 8005fa8:	f8c6 3264 	str.w	r3, [r6, #612]	; 0x264
  hmsc->scsi_blk_len    -= len;  
  
  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
 8005fac:	f8d6 3234 	ldr.w	r3, [r6, #564]	; 0x234
             hmsc->bot_data,
             len);
  
  
  hmsc->scsi_blk_addr   += len; 
  hmsc->scsi_blk_len    -= len;  
 8005fb0:	ebc8 0404 	rsb	r4, r8, r4
  
  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
 8005fb4:	ebc8 0303 	rsb	r3, r8, r3
             hmsc->bot_data,
             len);
  
  
  hmsc->scsi_blk_addr   += len; 
  hmsc->scsi_blk_len    -= len;  
 8005fb8:	f8c6 4268 	str.w	r4, [r6, #616]	; 0x268
  
  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
 8005fbc:	f8c6 3234 	str.w	r3, [r6, #564]	; 0x234
  
  if (hmsc->scsi_blk_len == 0)
 8005fc0:	2c00      	cmp	r4, #0
 8005fc2:	f040 8081 	bne.w	80060c8 <SCSI_ProcessCmd+0x3e4>
  {
    hmsc->bot_state = USBD_BOT_LAST_DATA_IN;
 8005fc6:	2303      	movs	r3, #3
 8005fc8:	7233      	strb	r3, [r6, #8]
 8005fca:	e0da      	b.n	8006182 <SCSI_ProcessCmd+0x49e>
* @retval status
*/

static int8_t SCSI_Write10 (USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 8005fcc:	f8d0 6218 	ldr.w	r6, [r0, #536]	; 0x218
  
  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
 8005fd0:	7a33      	ldrb	r3, [r6, #8]
 8005fd2:	2b00      	cmp	r3, #0
 8005fd4:	d13a      	bne.n	800604c <SCSI_ProcessCmd+0x368>
  {
    
    /* case 8 : Hi <> Do */
    
    if ((hmsc->cbw.bmFlags & 0x80) == 0x80)
 8005fd6:	f996 3218 	ldrsb.w	r3, [r6, #536]	; 0x218
 8005fda:	2b00      	cmp	r3, #0
 8005fdc:	da04      	bge.n	8005fe8 <SCSI_ProcessCmd+0x304>
    {
      SCSI_SenseCode(pdev,
 8005fde:	2320      	movs	r3, #32
 8005fe0:	2205      	movs	r2, #5
 8005fe2:	f896 1219 	ldrb.w	r1, [r6, #537]	; 0x219
 8005fe6:	e08a      	b.n	80060fe <SCSI_ProcessCmd+0x41a>
                     INVALID_CDB);
      return -1;
    }
    
    /* Check whether Media is ready */
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) !=0 )
 8005fe8:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8005fec:	4608      	mov	r0, r1
 8005fee:	689b      	ldr	r3, [r3, #8]
 8005ff0:	4798      	blx	r3
 8005ff2:	2800      	cmp	r0, #0
 8005ff4:	f47f af5d 	bne.w	8005eb2 <SCSI_ProcessCmd+0x1ce>
                     MEDIUM_NOT_PRESENT);
      return -1;
    } 
    
    /* Check If media is write-protected */
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsWriteProtected(lun) !=0 )
 8005ff8:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
 8005ffc:	4638      	mov	r0, r7
 8005ffe:	68db      	ldr	r3, [r3, #12]
 8006000:	4798      	blx	r3
 8006002:	4604      	mov	r4, r0
 8006004:	b110      	cbz	r0, 800600c <SCSI_ProcessCmd+0x328>
    {
      SCSI_SenseCode(pdev,
 8006006:	2327      	movs	r3, #39	; 0x27
 8006008:	2202      	movs	r2, #2
 800600a:	e076      	b.n	80060fa <SCSI_ProcessCmd+0x416>
                     WRITE_PROTECTED);
      return -1;
    } 
    
    
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 800600c:	f898 3003 	ldrb.w	r3, [r8, #3]
 8006010:	f898 2002 	ldrb.w	r2, [r8, #2]
 8006014:	041b      	lsls	r3, r3, #16
 8006016:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
 800601a:	f898 3005 	ldrb.w	r3, [r8, #5]
 800601e:	4313      	orrs	r3, r2
 8006020:	f898 2004 	ldrb.w	r2, [r8, #4]
 8006024:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 8006028:	f8c6 2264 	str.w	r2, [r6, #612]	; 0x264
      (params[3] << 16) | \
        (params[4] <<  8) | \
          params[5];
    hmsc->scsi_blk_len = (params[7] <<  8) | \
 800602c:	f898 1007 	ldrb.w	r1, [r8, #7]
 8006030:	f898 3008 	ldrb.w	r3, [r8, #8]
 8006034:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 8006038:	f8d5 1218 	ldr.w	r1, [r5, #536]	; 0x218
    
    hmsc->scsi_blk_addr = (params[2] << 24) | \
      (params[3] << 16) | \
        (params[4] <<  8) | \
          params[5];
    hmsc->scsi_blk_len = (params[7] <<  8) | \
 800603c:	f8c6 3268 	str.w	r3, [r6, #616]	; 0x268
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 8006040:	f8d1 1260 	ldr.w	r1, [r1, #608]	; 0x260
 8006044:	18d0      	adds	r0, r2, r3
 8006046:	4288      	cmp	r0, r1
 8006048:	d97a      	bls.n	8006140 <SCSI_ProcessCmd+0x45c>
 800604a:	e77c      	b.n	8005f46 <SCSI_ProcessCmd+0x262>
static int8_t SCSI_ProcessWrite (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  uint32_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 800604c:	f8d6 4268 	ldr.w	r4, [r6, #616]	; 0x268
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun ,
 8006050:	f8d0 021c 	ldr.w	r0, [r0, #540]	; 0x21c
 8006054:	f8b6 225e 	ldrh.w	r2, [r6, #606]	; 0x25e
 8006058:	f8d6 1264 	ldr.w	r1, [r6, #612]	; 0x264
 800605c:	f8d0 9014 	ldr.w	r9, [r0, #20]
static int8_t SCSI_ProcessWrite (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  uint32_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 8006060:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun ,
                              hmsc->bot_data, 
 8006064:	f106 080c 	add.w	r8, r6, #12
static int8_t SCSI_ProcessWrite (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  uint32_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 8006068:	bf28      	it	cs
 800606a:	f44f 7400 	movcs.w	r4, #512	; 0x200
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun ,
 800606e:	4638      	mov	r0, r7
 8006070:	fbb4 f3f2 	udiv	r3, r4, r2
 8006074:	fbb1 f2f2 	udiv	r2, r1, r2
 8006078:	b29b      	uxth	r3, r3
 800607a:	4641      	mov	r1, r8
 800607c:	47c8      	blx	r9
 800607e:	2800      	cmp	r0, #0
 8006080:	da02      	bge.n	8006088 <SCSI_ProcessCmd+0x3a4>
                              hmsc->bot_data, 
                              hmsc->scsi_blk_addr / hmsc->scsi_blk_size, 
                              len / hmsc->scsi_blk_size) < 0)
  {
    SCSI_SenseCode(pdev,
 8006082:	2303      	movs	r3, #3
 8006084:	2204      	movs	r2, #4
 8006086:	e038      	b.n	80060fa <SCSI_ProcessCmd+0x416>
                   WRITE_FAULT);     
    return -1; 
  }
  
  
  hmsc->scsi_blk_addr  += len; 
 8006088:	f8d6 3264 	ldr.w	r3, [r6, #612]	; 0x264
  hmsc->scsi_blk_len   -= len; 
  
  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
 800608c:	f8d6 2234 	ldr.w	r2, [r6, #564]	; 0x234
                   WRITE_FAULT);     
    return -1; 
  }
  
  
  hmsc->scsi_blk_addr  += len; 
 8006090:	4423      	add	r3, r4
 8006092:	f8c6 3264 	str.w	r3, [r6, #612]	; 0x264
  hmsc->scsi_blk_len   -= len; 
 8006096:	f8d6 3268 	ldr.w	r3, [r6, #616]	; 0x268
 800609a:	1b1b      	subs	r3, r3, r4
  
  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
 800609c:	1b14      	subs	r4, r2, r4
    return -1; 
  }
  
  
  hmsc->scsi_blk_addr  += len; 
  hmsc->scsi_blk_len   -= len; 
 800609e:	f8c6 3268 	str.w	r3, [r6, #616]	; 0x268
  
  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
 80060a2:	f8c6 4234 	str.w	r4, [r6, #564]	; 0x234
  
  if (hmsc->scsi_blk_len == 0)
 80060a6:	b923      	cbnz	r3, 80060b2 <SCSI_ProcessCmd+0x3ce>
  {
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED);
 80060a8:	2100      	movs	r1, #0
 80060aa:	4628      	mov	r0, r5
 80060ac:	f7ff fd48 	bl	8005b40 <MSC_BOT_SendCSW>
 80060b0:	e00a      	b.n	80060c8 <SCSI_ProcessCmd+0x3e4>
  }
  else
  {
    /* Prepare EP to Receive next packet */
    USBD_LL_PrepareReceive (pdev,
 80060b2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80060b6:	bf28      	it	cs
 80060b8:	f44f 7300 	movcs.w	r3, #512	; 0x200
 80060bc:	b29b      	uxth	r3, r3
 80060be:	4642      	mov	r2, r8
 80060c0:	2101      	movs	r1, #1
 80060c2:	4628      	mov	r0, r5
 80060c4:	f7fa fc47 	bl	8000956 <USBD_LL_PrepareReceive>
                            MSC_EPOUT_ADDR,
                            hmsc->bot_data, 
                            MIN (hmsc->scsi_blk_len, MSC_MEDIA_PACKET)); 
  }
  
  return 0;
 80060c8:	2400      	movs	r4, #0
 80060ca:	e05a      	b.n	8006182 <SCSI_ProcessCmd+0x49e>

static int8_t SCSI_Verify10(USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((params[1]& 0x02) == 0x02) 
 80060cc:	7852      	ldrb	r2, [r2, #1]
* @retval status
*/

static int8_t SCSI_Verify10(USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 80060ce:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  if ((params[1]& 0x02) == 0x02) 
 80060d2:	f002 0202 	and.w	r2, r2, #2
 80060d6:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 80060da:	b112      	cbz	r2, 80060e2 <SCSI_ProcessCmd+0x3fe>
  {
    SCSI_SenseCode (pdev,
 80060dc:	2324      	movs	r3, #36	; 0x24
 80060de:	2205      	movs	r2, #5
 80060e0:	e00d      	b.n	80060fe <SCSI_ProcessCmd+0x41a>
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 80060e2:	f8b3 1268 	ldrh.w	r1, [r3, #616]	; 0x268
 80060e6:	f8d3 2264 	ldr.w	r2, [r3, #612]	; 0x264
 80060ea:	440a      	add	r2, r1
 80060ec:	f8d3 1260 	ldr.w	r1, [r3, #608]	; 0x260
 80060f0:	428a      	cmp	r2, r1
 80060f2:	d945      	bls.n	8006180 <SCSI_ProcessCmd+0x49c>
 80060f4:	e727      	b.n	8005f46 <SCSI_ProcessCmd+0x262>
    
  case SCSI_VERIFY10:
    return SCSI_Verify10(pdev, lun, params);
    
  default:
    SCSI_SenseCode(pdev, 
 80060f6:	2320      	movs	r3, #32
 80060f8:	2205      	movs	r2, #5
 80060fa:	4639      	mov	r1, r7
 80060fc:	4628      	mov	r0, r5
 80060fe:	f7ff fdd9 	bl	8005cb4 <SCSI_SenseCode>
                   lun,
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);    
    return -1;
 8006102:	f04f 34ff 	mov.w	r4, #4294967295
 8006106:	e03c      	b.n	8006182 <SCSI_ProcessCmd+0x49e>
    if( SCSI_CheckAddressRange(pdev, lun, hmsc->scsi_blk_addr, hmsc->scsi_blk_len) < 0)
    {
      return -1; /* error */
    }
    
    hmsc->bot_state = USBD_BOT_DATA_IN;
 8006108:	2202      	movs	r2, #2
 800610a:	7222      	strb	r2, [r4, #8]
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
 800610c:	f8b4 225e 	ldrh.w	r2, [r4, #606]	; 0x25e
 8006110:	4353      	muls	r3, r2
 8006112:	f8c4 3264 	str.w	r3, [r4, #612]	; 0x264
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 8006116:	fb02 f301 	mul.w	r3, r2, r1
    
    /* cases 4,5 : Hi <> Dn */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 800611a:	f8d4 2214 	ldr.w	r2, [r4, #532]	; 0x214
      return -1; /* error */
    }
    
    hmsc->bot_state = USBD_BOT_DATA_IN;
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 800611e:	f8c4 3268 	str.w	r3, [r4, #616]	; 0x268
    
    /* cases 4,5 : Hi <> Dn */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 8006122:	4293      	cmp	r3, r2
 8006124:	f43f af11 	beq.w	8005f4a <SCSI_ProcessCmd+0x266>
    {
      SCSI_SenseCode(pdev,
 8006128:	2320      	movs	r3, #32
 800612a:	2205      	movs	r2, #5
 800612c:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
 8006130:	e7e4      	b.n	80060fc <SCSI_ProcessCmd+0x418>
 8006132:	bf00      	nop
 8006134:	080070ac 	.word	0x080070ac
 8006138:	080070bb 	.word	0x080070bb
 800613c:	080070b3 	.word	0x080070b3
                              hmsc->scsi_blk_len) < 0)
    {
      return -1; /* error */      
    }
    
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
 8006140:	f8b6 125e 	ldrh.w	r1, [r6, #606]	; 0x25e
 8006144:	434a      	muls	r2, r1
 8006146:	f8c6 2264 	str.w	r2, [r6, #612]	; 0x264
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
    
    /* cases 3,11,13 : Hn,Ho <> D0 */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 800614a:	f8d6 2214 	ldr.w	r2, [r6, #532]	; 0x214
    {
      return -1; /* error */      
    }
    
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 800614e:	434b      	muls	r3, r1
    
    /* cases 3,11,13 : Hn,Ho <> D0 */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 8006150:	4293      	cmp	r3, r2
    {
      return -1; /* error */      
    }
    
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 8006152:	f8c6 3268 	str.w	r3, [r6, #616]	; 0x268
    
    /* cases 3,11,13 : Hn,Ho <> D0 */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 8006156:	d004      	beq.n	8006162 <SCSI_ProcessCmd+0x47e>
    {
      SCSI_SenseCode(pdev,
 8006158:	2320      	movs	r3, #32
 800615a:	2205      	movs	r2, #5
 800615c:	f896 1219 	ldrb.w	r1, [r6, #537]	; 0x219
 8006160:	e7cc      	b.n	80060fc <SCSI_ProcessCmd+0x418>
      return -1;
    }
    
    /* Prepare EP to receive first data packet */
    hmsc->bot_state = USBD_BOT_DATA_OUT;  
    USBD_LL_PrepareReceive (pdev,
 8006162:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
                     INVALID_CDB);
      return -1;
    }
    
    /* Prepare EP to receive first data packet */
    hmsc->bot_state = USBD_BOT_DATA_OUT;  
 8006166:	f04f 0101 	mov.w	r1, #1
    USBD_LL_PrepareReceive (pdev,
 800616a:	bf28      	it	cs
 800616c:	f44f 7300 	movcs.w	r3, #512	; 0x200
                     INVALID_CDB);
      return -1;
    }
    
    /* Prepare EP to receive first data packet */
    hmsc->bot_state = USBD_BOT_DATA_OUT;  
 8006170:	7231      	strb	r1, [r6, #8]
    USBD_LL_PrepareReceive (pdev,
 8006172:	b29b      	uxth	r3, r3
 8006174:	f106 020c 	add.w	r2, r6, #12
 8006178:	4628      	mov	r0, r5
 800617a:	f7fa fbec 	bl	8000956 <USBD_LL_PrepareReceive>
 800617e:	e000      	b.n	8006182 <SCSI_ProcessCmd+0x49e>
                            hmsc->scsi_blk_addr, 
                            hmsc->scsi_blk_len) < 0)
  {
    return -1; /* error */      
  }
  hmsc->bot_data_length = 0;
 8006180:	815c      	strh	r4, [r3, #10]
                   lun,
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);    
    return -1;
  }
}
 8006182:	4620      	mov	r0, r4
 8006184:	b003      	add	sp, #12
 8006186:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800618a:	bf00      	nop

0800618c <ControlNull>:
	  UART_RX();
  }
}*/
//==============================================================================
void ControlNull()
{
 800618c:	b508      	push	{r3, lr}

   if(strstr(Buf,"PacketPath"))
 800618e:	490a      	ldr	r1, [pc, #40]	; (80061b8 <ControlNull+0x2c>)
 8006190:	480a      	ldr	r0, [pc, #40]	; (80061bc <ControlNull+0x30>)
 8006192:	f000 fc41 	bl	8006a18 <strstr>
 8006196:	b128      	cbz	r0, 80061a4 <ControlNull+0x18>
     {
        state_t = control_packet_path;
 8006198:	4b09      	ldr	r3, [pc, #36]	; (80061c0 <ControlNull+0x34>)
        USBD_Stop(&hUsbDeviceFS);
 800619a:	480a      	ldr	r0, [pc, #40]	; (80061c4 <ControlNull+0x38>)
void ControlNull()
{

   if(strstr(Buf,"PacketPath"))
     {
        state_t = control_packet_path;
 800619c:	2205      	movs	r2, #5
 800619e:	601a      	str	r2, [r3, #0]
        USBD_Stop(&hUsbDeviceFS);
 80061a0:	f7ff f89d 	bl	80052de <USBD_Stop>
     }
   if(strstr(Buf,"FileTransfer"))
 80061a4:	4908      	ldr	r1, [pc, #32]	; (80061c8 <ControlNull+0x3c>)
 80061a6:	4805      	ldr	r0, [pc, #20]	; (80061bc <ControlNull+0x30>)
 80061a8:	f000 fc36 	bl	8006a18 <strstr>
 80061ac:	b110      	cbz	r0, 80061b4 <ControlNull+0x28>
     {
        state_t = control_packet_file;
 80061ae:	4b04      	ldr	r3, [pc, #16]	; (80061c0 <ControlNull+0x34>)
 80061b0:	2206      	movs	r2, #6
 80061b2:	601a      	str	r2, [r3, #0]
 80061b4:	bd08      	pop	{r3, pc}
 80061b6:	bf00      	nop
 80061b8:	080070c3 	.word	0x080070c3
 80061bc:	2000135c 	.word	0x2000135c
 80061c0:	20001778 	.word	0x20001778
 80061c4:	200002f0 	.word	0x200002f0
 80061c8:	080070ce 	.word	0x080070ce

080061cc <seek>:
         res++;
       }
 }
//==============================================================================
char seek(unsigned char* Buf, unsigned char* Text,char lenword,unsigned int array_size)
{
 80061cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80061ce:	4d0e      	ldr	r5, [pc, #56]	; (8006208 <seek+0x3c>)
 80061d0:	782c      	ldrb	r4, [r5, #0]
 80061d2:	4403      	add	r3, r0
  unsigned char* pBuf   = Buf;
  unsigned char* pText  = Text;
  static char size_b = 0;
  unsigned int size = 0;
  for(size=0;size<array_size;size++)
 80061d4:	2600      	movs	r6, #0
 80061d6:	4298      	cmp	r0, r3
 80061d8:	d012      	beq.n	8006200 <seek+0x34>
   {
     if((*pBuf)==(*pText))
 80061da:	f810 6b01 	ldrb.w	r6, [r0], #1
 80061de:	780f      	ldrb	r7, [r1, #0]
 80061e0:	42b7      	cmp	r7, r6
 80061e2:	d108      	bne.n	80061f6 <seek+0x2a>
       {
         pText++;
         size_b++;
 80061e4:	3401      	adds	r4, #1
 80061e6:	b2e4      	uxtb	r4, r4
         if(size_b>=lenword)
 80061e8:	4294      	cmp	r4, r2
  unsigned int size = 0;
  for(size=0;size<array_size;size++)
   {
     if((*pBuf)==(*pText))
       {
         pText++;
 80061ea:	f101 0101 	add.w	r1, r1, #1
         size_b++;
         if(size_b>=lenword)
 80061ee:	d305      	bcc.n	80061fc <seek+0x30>
 80061f0:	702c      	strb	r4, [r5, #0]
          {
            return 1;
 80061f2:	2001      	movs	r0, #1
 80061f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
          }
       }
        else
         {
           if(size_b>0)
 80061f6:	b104      	cbz	r4, 80061fa <seek+0x2e>
            {
              pText--;
 80061f8:	3901      	subs	r1, #1
            }
           size_b = 0;
 80061fa:	2400      	movs	r4, #0
 80061fc:	2601      	movs	r6, #1
 80061fe:	e7ea      	b.n	80061d6 <seek+0xa>
 8006200:	b106      	cbz	r6, 8006204 <seek+0x38>
 8006202:	702c      	strb	r4, [r5, #0]

         }
     pBuf++;

   }
  return 0;
 8006204:	2000      	movs	r0, #0
}
 8006206:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006208:	20000199 	.word	0x20000199

0800620c <resetBuffer>:

      }
}
//==============================================================================
void resetBuffer(unsigned char* Buf,unsigned int len )
{
 800620c:	4401      	add	r1, r0
  unsigned int i = 0;
  for(i = 0;i < len;i++)
   {
      Buf[i] = 0;
 800620e:	2300      	movs	r3, #0
}
//==============================================================================
void resetBuffer(unsigned char* Buf,unsigned int len )
{
  unsigned int i = 0;
  for(i = 0;i < len;i++)
 8006210:	4288      	cmp	r0, r1
 8006212:	d002      	beq.n	800621a <resetBuffer+0xe>
   {
      Buf[i] = 0;
 8006214:	f800 3b01 	strb.w	r3, [r0], #1
 8006218:	e7fa      	b.n	8006210 <resetBuffer+0x4>
   }
}
 800621a:	4770      	bx	lr

0800621c <decoder>:


}
//==============================================================================
void decoder(char* Buf,const unsigned char len)
{
 800621c:	b570      	push	{r4, r5, r6, lr}
 static char str_len = 0;
 static char count = 0;
 //static char sub_dir_created= 0;
 //-----------------------------------------------------------------------------
      temp_buf = Buf;
      resetBuffer(DirName,LOCAL_BUF_SIZE);
 800621e:	211e      	movs	r1, #30


}
//==============================================================================
void decoder(char* Buf,const unsigned char len)
{
 8006220:	4605      	mov	r5, r0
 static char str_len = 0;
 static char count = 0;
 //static char sub_dir_created= 0;
 //-----------------------------------------------------------------------------
      temp_buf = Buf;
      resetBuffer(DirName,LOCAL_BUF_SIZE);
 8006222:	4822      	ldr	r0, [pc, #136]	; (80062ac <decoder+0x90>)
      resetBuffer(FileName,LOCAL_BUF_SIZE);
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "DirName");
      str_len = strlen("DirName");
      res+=str_len;
      count = 0;
 8006224:	4c22      	ldr	r4, [pc, #136]	; (80062b0 <decoder+0x94>)
      while((*res)!=STAR)
       {
         DirName[count++]  = (*res);
 8006226:	4e21      	ldr	r6, [pc, #132]	; (80062ac <decoder+0x90>)
 static char str_len = 0;
 static char count = 0;
 //static char sub_dir_created= 0;
 //-----------------------------------------------------------------------------
      temp_buf = Buf;
      resetBuffer(DirName,LOCAL_BUF_SIZE);
 8006228:	f7ff fff0 	bl	800620c <resetBuffer>
      resetBuffer(SubDirName,LOCAL_BUF_SIZE);
 800622c:	211e      	movs	r1, #30
 800622e:	4821      	ldr	r0, [pc, #132]	; (80062b4 <decoder+0x98>)
 8006230:	f7ff ffec 	bl	800620c <resetBuffer>
      resetBuffer(FileName,LOCAL_BUF_SIZE);
 8006234:	211e      	movs	r1, #30
 8006236:	4820      	ldr	r0, [pc, #128]	; (80062b8 <decoder+0x9c>)
 8006238:	f7ff ffe8 	bl	800620c <resetBuffer>
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "DirName");
 800623c:	491f      	ldr	r1, [pc, #124]	; (80062bc <decoder+0xa0>)
 800623e:	4628      	mov	r0, r5
 8006240:	f000 fbea 	bl	8006a18 <strstr>
      str_len = strlen("DirName");
      res+=str_len;
      count = 0;
 8006244:	2300      	movs	r3, #0
 8006246:	7023      	strb	r3, [r4, #0]
 8006248:	3006      	adds	r0, #6
      while((*res)!=STAR)
 800624a:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 800624e:	1c5a      	adds	r2, r3, #1
 8006250:	292a      	cmp	r1, #42	; 0x2a
 8006252:	b2d2      	uxtb	r2, r2
 8006254:	d002      	beq.n	800625c <decoder+0x40>
       {
         DirName[count++]  = (*res);
 8006256:	54f1      	strb	r1, [r6, r3]
 8006258:	4613      	mov	r3, r2
 800625a:	e7f6      	b.n	800624a <decoder+0x2e>
         res++;
       }
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "SubDirName");
 800625c:	4918      	ldr	r1, [pc, #96]	; (80062c0 <decoder+0xa4>)
      str_len = strlen("SubDirName");
      res+=str_len;
      count = 0;
       while((*res)!=STAR)
       {
         SubDirName[count++] = (*res);
 800625e:	4e15      	ldr	r6, [pc, #84]	; (80062b4 <decoder+0x98>)
       {
         DirName[count++]  = (*res);
         res++;
       }
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "SubDirName");
 8006260:	4628      	mov	r0, r5
 8006262:	f000 fbd9 	bl	8006a18 <strstr>
      str_len = strlen("SubDirName");
      res+=str_len;
      count = 0;
 8006266:	2300      	movs	r3, #0
 8006268:	7023      	strb	r3, [r4, #0]
 800626a:	3009      	adds	r0, #9
       while((*res)!=STAR)
 800626c:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 8006270:	1c5a      	adds	r2, r3, #1
 8006272:	292a      	cmp	r1, #42	; 0x2a
 8006274:	b2d2      	uxtb	r2, r2
 8006276:	d002      	beq.n	800627e <decoder+0x62>
       {
         SubDirName[count++] = (*res);
 8006278:	54f1      	strb	r1, [r6, r3]
 800627a:	4613      	mov	r3, r2
 800627c:	e7f6      	b.n	800626c <decoder+0x50>
         res++;
       }
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "FileName");
 800627e:	4911      	ldr	r1, [pc, #68]	; (80062c4 <decoder+0xa8>)
      str_len = strlen("FileName");
      res+=str_len;
      count = 0;
       while((*res)!=STAR)
       {
         FileName[count++] = (*res);
 8006280:	4e0d      	ldr	r6, [pc, #52]	; (80062b8 <decoder+0x9c>)
       {
         SubDirName[count++] = (*res);
         res++;
       }
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "FileName");
 8006282:	4628      	mov	r0, r5
 8006284:	f000 fbc8 	bl	8006a18 <strstr>
      str_len = strlen("FileName");
      res+=str_len;
      count = 0;
 8006288:	2300      	movs	r3, #0
 800628a:	7023      	strb	r3, [r4, #0]
 800628c:	3007      	adds	r0, #7
       while((*res)!=STAR)
 800628e:	4619      	mov	r1, r3
 8006290:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8006294:	1c5a      	adds	r2, r3, #1
 8006296:	2d2a      	cmp	r5, #42	; 0x2a
 8006298:	b2d2      	uxtb	r2, r2
 800629a:	d003      	beq.n	80062a4 <decoder+0x88>
       {
         FileName[count++] = (*res);
 800629c:	54f5      	strb	r5, [r6, r3]
 800629e:	2101      	movs	r1, #1
 80062a0:	4613      	mov	r3, r2
 80062a2:	e7f5      	b.n	8006290 <decoder+0x74>
 80062a4:	b101      	cbz	r1, 80062a8 <decoder+0x8c>
 80062a6:	7023      	strb	r3, [r4, #0]
 80062a8:	bd70      	pop	{r4, r5, r6, pc}
 80062aa:	bf00      	nop
 80062ac:	20001110 	.word	0x20001110
 80062b0:	2000019a 	.word	0x2000019a
 80062b4:	200019b4 	.word	0x200019b4
 80062b8:	20001c04 	.word	0x20001c04
 80062bc:	080070f5 	.word	0x080070f5
 80062c0:	080070f2 	.word	0x080070f2
 80062c4:	080070db 	.word	0x080070db

080062c8 <controlPacketFile>:
      Buf[i] = 0;
   }
}
//==============================================================================
void controlPacketFile()
{
 80062c8:	b508      	push	{r3, lr}
  if(seek(Buf,"End",3,GLOBAL_BUFFER_SIZE))
 80062ca:	2203      	movs	r2, #3
 80062cc:	f44f 6383 	mov.w	r3, #1048	; 0x418
 80062d0:	4909      	ldr	r1, [pc, #36]	; (80062f8 <controlPacketFile+0x30>)
 80062d2:	480a      	ldr	r0, [pc, #40]	; (80062fc <controlPacketFile+0x34>)
 80062d4:	f7ff ff7a 	bl	80061cc <seek>
 80062d8:	b110      	cbz	r0, 80062e0 <controlPacketFile+0x18>
    {
       state_t = file_packet_full;
 80062da:	4b09      	ldr	r3, [pc, #36]	; (8006300 <controlPacketFile+0x38>)
 80062dc:	2204      	movs	r2, #4
 80062de:	601a      	str	r2, [r3, #0]
    }
  if(seek(Buf,"Stop",4,GLOBAL_BUFFER_SIZE))
 80062e0:	f44f 6383 	mov.w	r3, #1048	; 0x418
 80062e4:	2204      	movs	r2, #4
 80062e6:	4907      	ldr	r1, [pc, #28]	; (8006304 <controlPacketFile+0x3c>)
 80062e8:	4804      	ldr	r0, [pc, #16]	; (80062fc <controlPacketFile+0x34>)
 80062ea:	f7ff ff6f 	bl	80061cc <seek>
 80062ee:	b110      	cbz	r0, 80062f6 <controlPacketFile+0x2e>
    {
       state_t =  end_file_packet;
 80062f0:	4b03      	ldr	r3, [pc, #12]	; (8006300 <controlPacketFile+0x38>)
 80062f2:	2203      	movs	r2, #3
 80062f4:	601a      	str	r2, [r3, #0]
 80062f6:	bd08      	pop	{r3, pc}
 80062f8:	08007128 	.word	0x08007128
 80062fc:	2000135c 	.word	0x2000135c
 8006300:	20001778 	.word	0x20001778
 8006304:	080070e4 	.word	0x080070e4

08006308 <send_to_uart>:
  UART3_Write_Text("ACK");
  state_t = null;
}
//==============================================================================
void send_to_uart(uint8_t data)  {
while(!(USART3->SR & USART_SR_TC));
 8006308:	4a03      	ldr	r2, [pc, #12]	; (8006318 <send_to_uart+0x10>)
 800630a:	6813      	ldr	r3, [r2, #0]
 800630c:	065b      	lsls	r3, r3, #25
 800630e:	d5fc      	bpl.n	800630a <send_to_uart+0x2>
USART3->DR=data;
 8006310:	4b01      	ldr	r3, [pc, #4]	; (8006318 <send_to_uart+0x10>)
 8006312:	6058      	str	r0, [r3, #4]
 8006314:	4770      	bx	lr
 8006316:	bf00      	nop
 8006318:	40004800 	.word	0x40004800

0800631c <UART3_Write_Text>:
}
//==============================================================================
void UART3_Write_Text(char * text)
{
 800631c:	b510      	push	{r4, lr}
	uint8_t i = 0;
	while(text[i])
 800631e:	2100      	movs	r1, #0
while(!(USART3->SR & USART_SR_TC));
USART3->DR=data;
}
//==============================================================================
void UART3_Write_Text(char * text)
{
 8006320:	4604      	mov	r4, r0
	uint8_t i = 0;
	while(text[i])
 8006322:	b2cb      	uxtb	r3, r1
 8006324:	3101      	adds	r1, #1
 8006326:	5ce0      	ldrb	r0, [r4, r3]
 8006328:	b110      	cbz	r0, 8006330 <UART3_Write_Text+0x14>
	{
		send_to_uart(text[i]);
 800632a:	f7ff ffed 	bl	8006308 <send_to_uart>
 800632e:	e7f8      	b.n	8006322 <UART3_Write_Text+0x6>
		i++;
		//HAL_Delay(100);
	}
	//send_to_uart('\0');
}
 8006330:	bd10      	pop	{r4, pc}
	...

08006334 <UART2_Write_Text>:
void UART2_Write_Text(char * text)
{
	uint8_t i = 0;
	while(text[i])
	{
		while(!(USART2->SR & USART_SR_TC));
 8006334:	490a      	ldr	r1, [pc, #40]	; (8006360 <UART2_Write_Text+0x2c>)
	}
	//send_to_uart('\0');
}
//==============================================================================
void UART2_Write_Text(char * text)
{
 8006336:	b538      	push	{r3, r4, r5, lr}
	uint8_t i = 0;
	while(text[i])
 8006338:	2300      	movs	r3, #0
	{
		while(!(USART2->SR & USART_SR_TC));
 800633a:	460c      	mov	r4, r1
}
//==============================================================================
void UART2_Write_Text(char * text)
{
	uint8_t i = 0;
	while(text[i])
 800633c:	b2da      	uxtb	r2, r3
 800633e:	5c82      	ldrb	r2, [r0, r2]
 8006340:	b12a      	cbz	r2, 800634e <UART2_Write_Text+0x1a>
	{
		while(!(USART2->SR & USART_SR_TC));
 8006342:	680d      	ldr	r5, [r1, #0]
 8006344:	066d      	lsls	r5, r5, #25
 8006346:	d5fc      	bpl.n	8006342 <UART2_Write_Text+0xe>
		USART2->DR=text[i];
 8006348:	6062      	str	r2, [r4, #4]
 800634a:	3301      	adds	r3, #1
 800634c:	e7f6      	b.n	800633c <UART2_Write_Text+0x8>
		i++;

	}
	send_to_uart('\r');
 800634e:	200d      	movs	r0, #13
 8006350:	f7ff ffda 	bl	8006308 <send_to_uart>
	send_to_uart('\n');
 8006354:	200a      	movs	r0, #10
}
 8006356:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		USART2->DR=text[i];
		i++;

	}
	send_to_uart('\r');
	send_to_uart('\n');
 800635a:	f7ff bfd5 	b.w	8006308 <send_to_uart>
 800635e:	bf00      	nop
 8006360:	40004400 	.word	0x40004400

08006364 <createDir>:
        state_t = control_packet_file;
     }
}
//==============================================================================
void createDir()
{
 8006364:	b538      	push	{r3, r4, r5, lr}
	res = FR_OK;
 8006366:	4c1f      	ldr	r4, [pc, #124]	; (80063e4 <createDir+0x80>)
	res = f_mkdir (DirName);
 8006368:	481f      	ldr	r0, [pc, #124]	; (80063e8 <createDir+0x84>)
     }
}
//==============================================================================
void createDir()
{
	res = FR_OK;
 800636a:	2300      	movs	r3, #0
 800636c:	7023      	strb	r3, [r4, #0]
	res = f_mkdir (DirName);
 800636e:	f7fe fe04 	bl	8004f7a <f_mkdir>
 8006372:	4605      	mov	r5, r0
 8006374:	7020      	strb	r0, [r4, #0]
		if(res==FR_OK)
 8006376:	b9b0      	cbnz	r0, 80063a6 <createDir+0x42>
				  {
					res=f_chdir(DirName);
 8006378:	481b      	ldr	r0, [pc, #108]	; (80063e8 <createDir+0x84>)
 800637a:	f7fe fd03 	bl	8004d84 <f_chdir>
 800637e:	7020      	strb	r0, [r4, #0]
					if(res==FR_OK)
 8006380:	b930      	cbnz	r0, 8006390 <createDir+0x2c>
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_SET);
 8006382:	2201      	movs	r2, #1
 8006384:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8006388:	4818      	ldr	r0, [pc, #96]	; (80063ec <createDir+0x88>)
 800638a:	f7fa fd67 	bl	8000e5c <HAL_GPIO_WritePin>
 800638e:	e00a      	b.n	80063a6 <createDir+0x42>
					 }
					 else
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
 8006390:	462a      	mov	r2, r5
 8006392:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8006396:	4815      	ldr	r0, [pc, #84]	; (80063ec <createDir+0x88>)
 8006398:	f7fa fd60 	bl	8000e5c <HAL_GPIO_WritePin>
						 UART2_Write_Text("Error in SubDirName");
 800639c:	4814      	ldr	r0, [pc, #80]	; (80063f0 <createDir+0x8c>)
 800639e:	f7ff ffc9 	bl	8006334 <UART2_Write_Text>
						 Error_Handler();
 80063a2:	f7f9 ff8f 	bl	80002c4 <Error_Handler>
					 }
				  }
		if(res==FR_EXIST)
 80063a6:	7823      	ldrb	r3, [r4, #0]
 80063a8:	2b08      	cmp	r3, #8
 80063aa:	d11a      	bne.n	80063e2 <createDir+0x7e>
		  {
			res=f_chdir(DirName);
 80063ac:	480e      	ldr	r0, [pc, #56]	; (80063e8 <createDir+0x84>)
 80063ae:	f7fe fce9 	bl	8004d84 <f_chdir>
 80063b2:	4b0c      	ldr	r3, [pc, #48]	; (80063e4 <createDir+0x80>)
 80063b4:	7018      	strb	r0, [r3, #0]
					if(res==FR_OK)
 80063b6:	b938      	cbnz	r0, 80063c8 <createDir+0x64>
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_SET);
 80063b8:	2201      	movs	r2, #1
 80063ba:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80063be:	480b      	ldr	r0, [pc, #44]	; (80063ec <createDir+0x88>)
						 UART2_Write_Text("Error in SubDirName");
						 Error_Handler();
					 }
		  }

}
 80063c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if(res==FR_EXIST)
		  {
			res=f_chdir(DirName);
					if(res==FR_OK)
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_SET);
 80063c4:	f7fa bd4a 	b.w	8000e5c <HAL_GPIO_WritePin>
					 }
					 else
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
 80063c8:	2200      	movs	r2, #0
 80063ca:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80063ce:	4807      	ldr	r0, [pc, #28]	; (80063ec <createDir+0x88>)
 80063d0:	f7fa fd44 	bl	8000e5c <HAL_GPIO_WritePin>
						 UART2_Write_Text("Error in SubDirName");
 80063d4:	4806      	ldr	r0, [pc, #24]	; (80063f0 <createDir+0x8c>)
 80063d6:	f7ff ffad 	bl	8006334 <UART2_Write_Text>
						 Error_Handler();
					 }
		  }

}
 80063da:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
					 }
					 else
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
						 UART2_Write_Text("Error in SubDirName");
						 Error_Handler();
 80063de:	f7f9 bf71 	b.w	80002c4 <Error_Handler>
 80063e2:	bd38      	pop	{r3, r4, r5, pc}
 80063e4:	20001c02 	.word	0x20001c02
 80063e8:	20001110 	.word	0x20001110
 80063ec:	40020c00 	.word	0x40020c00
 80063f0:	080070e9 	.word	0x080070e9

080063f4 <createSubDir>:
}
  //«десь далее пишу любую другую операцию
  //FATFS_UnLinkDriver(SD_Path);
//==============================================================================
void createSubDir()
{
 80063f4:	b538      	push	{r3, r4, r5, lr}
	res = FR_OK;
 80063f6:	4c1f      	ldr	r4, [pc, #124]	; (8006474 <createSubDir+0x80>)
	res = f_mkdir (SubDirName);
 80063f8:	481f      	ldr	r0, [pc, #124]	; (8006478 <createSubDir+0x84>)
  //«десь далее пишу любую другую операцию
  //FATFS_UnLinkDriver(SD_Path);
//==============================================================================
void createSubDir()
{
	res = FR_OK;
 80063fa:	2300      	movs	r3, #0
 80063fc:	7023      	strb	r3, [r4, #0]
	res = f_mkdir (SubDirName);
 80063fe:	f7fe fdbc 	bl	8004f7a <f_mkdir>
 8006402:	4605      	mov	r5, r0
 8006404:	7020      	strb	r0, [r4, #0]
	if(res==FR_OK)
 8006406:	b9b0      	cbnz	r0, 8006436 <createSubDir+0x42>
			  {
				res=f_chdir(SubDirName);
 8006408:	481b      	ldr	r0, [pc, #108]	; (8006478 <createSubDir+0x84>)
 800640a:	f7fe fcbb 	bl	8004d84 <f_chdir>
 800640e:	7020      	strb	r0, [r4, #0]
				if(res==FR_OK)
 8006410:	b930      	cbnz	r0, 8006420 <createSubDir+0x2c>
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_SET);
 8006412:	2201      	movs	r2, #1
 8006414:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8006418:	4818      	ldr	r0, [pc, #96]	; (800647c <createSubDir+0x88>)
 800641a:	f7fa fd1f 	bl	8000e5c <HAL_GPIO_WritePin>
 800641e:	e00a      	b.n	8006436 <createSubDir+0x42>
				 }
				 else
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
 8006420:	462a      	mov	r2, r5
 8006422:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8006426:	4815      	ldr	r0, [pc, #84]	; (800647c <createSubDir+0x88>)
 8006428:	f7fa fd18 	bl	8000e5c <HAL_GPIO_WritePin>
					 UART2_Write_Text("Error in SubDirName");
 800642c:	4814      	ldr	r0, [pc, #80]	; (8006480 <createSubDir+0x8c>)
 800642e:	f7ff ff81 	bl	8006334 <UART2_Write_Text>
					 Error_Handler();
 8006432:	f7f9 ff47 	bl	80002c4 <Error_Handler>
				 }
			  }
	if(res==FR_EXIST)
 8006436:	7823      	ldrb	r3, [r4, #0]
 8006438:	2b08      	cmp	r3, #8
 800643a:	d11a      	bne.n	8006472 <createSubDir+0x7e>
	  {
		res=f_chdir(SubDirName);
 800643c:	480e      	ldr	r0, [pc, #56]	; (8006478 <createSubDir+0x84>)
 800643e:	f7fe fca1 	bl	8004d84 <f_chdir>
 8006442:	4b0c      	ldr	r3, [pc, #48]	; (8006474 <createSubDir+0x80>)
 8006444:	7018      	strb	r0, [r3, #0]
				if(res==FR_OK)
 8006446:	b938      	cbnz	r0, 8006458 <createSubDir+0x64>
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_SET);
 8006448:	2201      	movs	r2, #1
 800644a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800644e:	480b      	ldr	r0, [pc, #44]	; (800647c <createSubDir+0x88>)
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
					 UART2_Write_Text("Error in SubDirName");
					 Error_Handler();
				 }
	  }
}
 8006450:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	if(res==FR_EXIST)
	  {
		res=f_chdir(SubDirName);
				if(res==FR_OK)
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_SET);
 8006454:	f7fa bd02 	b.w	8000e5c <HAL_GPIO_WritePin>
				 }
				 else
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
 8006458:	2200      	movs	r2, #0
 800645a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800645e:	4807      	ldr	r0, [pc, #28]	; (800647c <createSubDir+0x88>)
 8006460:	f7fa fcfc 	bl	8000e5c <HAL_GPIO_WritePin>
					 UART2_Write_Text("Error in SubDirName");
 8006464:	4806      	ldr	r0, [pc, #24]	; (8006480 <createSubDir+0x8c>)
 8006466:	f7ff ff65 	bl	8006334 <UART2_Write_Text>
					 Error_Handler();
				 }
	  }
}
 800646a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				 }
				 else
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
					 UART2_Write_Text("Error in SubDirName");
					 Error_Handler();
 800646e:	f7f9 bf29 	b.w	80002c4 <Error_Handler>
 8006472:	bd38      	pop	{r3, r4, r5, pc}
 8006474:	20001c02 	.word	0x20001c02
 8006478:	200019b4 	.word	0x200019b4
 800647c:	40020c00 	.word	0x40020c00
 8006480:	080070e9 	.word	0x080070e9

08006484 <openFile>:
				 }
	  }
}
//==============================================================================
void openFile()
{
 8006484:	b508      	push	{r3, lr}
 res = f_open(&fdst, FileName, FA_CREATE_ALWAYS | FA_WRITE);
 8006486:	220a      	movs	r2, #10
 8006488:	490d      	ldr	r1, [pc, #52]	; (80064c0 <openFile+0x3c>)
 800648a:	480e      	ldr	r0, [pc, #56]	; (80064c4 <openFile+0x40>)
 800648c:	f7fe fcb5 	bl	8004dfa <f_open>
 8006490:	4b0d      	ldr	r3, [pc, #52]	; (80064c8 <openFile+0x44>)
 8006492:	7018      	strb	r0, [r3, #0]
 if(res==FR_OK)
 8006494:	b938      	cbnz	r0, 80064a6 <openFile+0x22>
 {
	 HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_SET);
 8006496:	2201      	movs	r2, #1
 8006498:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800649c:	480b      	ldr	r0, [pc, #44]	; (80064cc <openFile+0x48>)
	 UART2_Write_Text("Error open file");
	 Error_Handler();
 }


}
 800649e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
void openFile()
{
 res = f_open(&fdst, FileName, FA_CREATE_ALWAYS | FA_WRITE);
 if(res==FR_OK)
 {
	 HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_SET);
 80064a2:	f7fa bcdb 	b.w	8000e5c <HAL_GPIO_WritePin>
 }
 else
 {
	 HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_RESET);
 80064a6:	2200      	movs	r2, #0
 80064a8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80064ac:	4807      	ldr	r0, [pc, #28]	; (80064cc <openFile+0x48>)
 80064ae:	f7fa fcd5 	bl	8000e5c <HAL_GPIO_WritePin>
	 UART2_Write_Text("Error open file");
 80064b2:	4807      	ldr	r0, [pc, #28]	; (80064d0 <openFile+0x4c>)
 80064b4:	f7ff ff3e 	bl	8006334 <UART2_Write_Text>
	 Error_Handler();
 }


}
 80064b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 }
 else
 {
	 HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_RESET);
	 UART2_Write_Text("Error open file");
	 Error_Handler();
 80064bc:	f7f9 bf02 	b.w	80002c4 <Error_Handler>
 80064c0:	20001c04 	.word	0x20001c04
 80064c4:	20000ee8 	.word	0x20000ee8
 80064c8:	20001c02 	.word	0x20001c02
 80064cc:	40020c00 	.word	0x40020c00
 80064d0:	080070fd 	.word	0x080070fd

080064d4 <Disk_Init>:
   }
  return 0;
}
//==============================================================================
void Disk_Init()
{
 80064d4:	b508      	push	{r3, lr}
	if( disk_initialize(0)==RES_OK)
 80064d6:	2000      	movs	r0, #0
 80064d8:	f7fd fa48 	bl	800396c <disk_initialize>
 80064dc:	b970      	cbnz	r0, 80064fc <Disk_Init+0x28>
	  {
		res = f_mount(&SDFatFs, (TCHAR const*)SDPath, 1);
 80064de:	2201      	movs	r2, #1
 80064e0:	4907      	ldr	r1, [pc, #28]	; (8006500 <Disk_Init+0x2c>)
 80064e2:	4808      	ldr	r0, [pc, #32]	; (8006504 <Disk_Init+0x30>)
 80064e4:	f7fd ff58 	bl	8004398 <f_mount>
 80064e8:	4b07      	ldr	r3, [pc, #28]	; (8006508 <Disk_Init+0x34>)
 80064ea:	7018      	strb	r0, [r3, #0]
		if( res!= FR_OK)
 80064ec:	b130      	cbz	r0, 80064fc <Disk_Init+0x28>
		  	      {
		  	         //FatFs Initialization Error
				   UART2_Write_Text("Error mount disk");
 80064ee:	4807      	ldr	r0, [pc, #28]	; (800650c <Disk_Init+0x38>)
 80064f0:	f7ff ff20 	bl	8006334 <UART2_Write_Text>
				  else
				  {
					  //HAL_GPIO_WritePin(GPIOD, LD4_Pin, GPIO_PIN_SET);
				  }
	  }
}
 80064f4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		res = f_mount(&SDFatFs, (TCHAR const*)SDPath, 1);
		if( res!= FR_OK)
		  	      {
		  	         //FatFs Initialization Error
				   UART2_Write_Text("Error mount disk");
				   Error_Handler();
 80064f8:	f7f9 bee4 	b.w	80002c4 <Error_Handler>
 80064fc:	bd08      	pop	{r3, pc}
 80064fe:	bf00      	nop
 8006500:	20001774 	.word	0x20001774
 8006504:	2000177c 	.word	0x2000177c
 8006508:	20001c02 	.word	0x20001c02
 800650c:	0800710d 	.word	0x0800710d

08006510 <resetLeds>:

  //SystemReset();
}
//==============================================================================
void resetLeds()
{
 8006510:	b510      	push	{r4, lr}
	HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_RESET);
 8006512:	4c0d      	ldr	r4, [pc, #52]	; (8006548 <resetLeds+0x38>)
 8006514:	2200      	movs	r2, #0
 8006516:	4620      	mov	r0, r4
 8006518:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800651c:	f7fa fc9e 	bl	8000e5c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOD, LD4_Pin, GPIO_PIN_RESET);
 8006520:	4620      	mov	r0, r4
 8006522:	2200      	movs	r2, #0
 8006524:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8006528:	f7fa fc98 	bl	8000e5c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
 800652c:	4620      	mov	r0, r4
 800652e:	2200      	movs	r2, #0
 8006530:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8006534:	f7fa fc92 	bl	8000e5c <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
 8006538:	4620      	mov	r0, r4
 800653a:	2200      	movs	r2, #0
 800653c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
}
 8006540:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void resetLeds()
{
	HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOD, LD4_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
 8006544:	f7fa bc8a 	b.w	8000e5c <HAL_GPIO_WritePin>
 8006548:	40020c00 	.word	0x40020c00

0800654c <controlPacketPath>:
}
//==============================================================================
void controlPacketPath()
{
 800654c:	b508      	push	{r3, lr}
  if(strstr(Buf,"PacketPathEnd"))
 800654e:	4904      	ldr	r1, [pc, #16]	; (8006560 <controlPacketPath+0x14>)
 8006550:	4804      	ldr	r0, [pc, #16]	; (8006564 <controlPacketPath+0x18>)
 8006552:	f000 fa61 	bl	8006a18 <strstr>
 8006556:	b110      	cbz	r0, 800655e <controlPacketPath+0x12>
     {
       state_t = path_packet_full;
 8006558:	4b03      	ldr	r3, [pc, #12]	; (8006568 <controlPacketPath+0x1c>)
 800655a:	2201      	movs	r2, #1
 800655c:	601a      	str	r2, [r3, #0]
 800655e:	bd08      	pop	{r3, pc}
 8006560:	0800711e 	.word	0x0800711e
 8006564:	2000135c 	.word	0x2000135c
 8006568:	20001778 	.word	0x20001778

0800656c <clearBuf>:
 }
//==============================================================================
void clearBuf()
{
   unsigned int i = 0;
   count_buf = 0;
 800656c:	4a05      	ldr	r2, [pc, #20]	; (8006584 <clearBuf+0x18>)
 800656e:	2300      	movs	r3, #0
 8006570:	6013      	str	r3, [r2, #0]
   for(i = 0;i<GLOBAL_BUFFER_SIZE;i++)
    {
      Buf[i] = 0;
 8006572:	4a05      	ldr	r2, [pc, #20]	; (8006588 <clearBuf+0x1c>)
 8006574:	4619      	mov	r1, r3
 8006576:	5499      	strb	r1, [r3, r2]
//==============================================================================
void clearBuf()
{
   unsigned int i = 0;
   count_buf = 0;
   for(i = 0;i<GLOBAL_BUFFER_SIZE;i++)
 8006578:	3301      	adds	r3, #1
 800657a:	f5b3 6f83 	cmp.w	r3, #1048	; 0x418
 800657e:	d1fa      	bne.n	8006576 <clearBuf+0xa>
    {
      Buf[i] = 0;
    }
}
 8006580:	4770      	bx	lr
 8006582:	bf00      	nop
 8006584:	2000019c 	.word	0x2000019c
 8006588:	2000135c 	.word	0x2000135c

0800658c <readFilePacket>:
       state_t =  end_file_packet;
    }
}
//==============================================================================
void readFilePacket()
{
 800658c:	b570      	push	{r4, r5, r6, lr}
 unsigned int str_len = 0,length = 0;
 unsigned char* res;
 unsigned int size_array = 0;

  resetBuffer(writeBuffer,GLOBAL_BUFFER_SIZE);
 800658e:	f44f 6183 	mov.w	r1, #1048	; 0x418
 8006592:	4818      	ldr	r0, [pc, #96]	; (80065f4 <readFilePacket+0x68>)
  res = strstr(Buf, "FileTransfer");
  str_len = strlen("FileTransfer");
  res+=str_len;
     while(TRUE)
      {
         if(seek(writeBuffer,"End",3,GLOBAL_BUFFER_SIZE))
 8006594:	4e17      	ldr	r6, [pc, #92]	; (80065f4 <readFilePacket+0x68>)
{
 unsigned int str_len = 0,length = 0;
 unsigned char* res;
 unsigned int size_array = 0;

  resetBuffer(writeBuffer,GLOBAL_BUFFER_SIZE);
 8006596:	f7ff fe39 	bl	800620c <resetBuffer>
  //resetBuffer(readBuffer,GLOBAL_BUFFER_SIZE);
  res = strstr(Buf, "FileTransfer");
 800659a:	4917      	ldr	r1, [pc, #92]	; (80065f8 <readFilePacket+0x6c>)
 800659c:	4817      	ldr	r0, [pc, #92]	; (80065fc <readFilePacket+0x70>)
 800659e:	f000 fa3b 	bl	8006a18 <strstr>
    }
}
//==============================================================================
void readFilePacket()
{
 unsigned int str_len = 0,length = 0;
 80065a2:	2400      	movs	r4, #0
 80065a4:	f100 050b 	add.w	r5, r0, #11
  res = strstr(Buf, "FileTransfer");
  str_len = strlen("FileTransfer");
  res+=str_len;
     while(TRUE)
      {
         if(seek(writeBuffer,"End",3,GLOBAL_BUFFER_SIZE))
 80065a8:	f44f 6383 	mov.w	r3, #1048	; 0x418
 80065ac:	2203      	movs	r2, #3
 80065ae:	4914      	ldr	r1, [pc, #80]	; (8006600 <readFilePacket+0x74>)
 80065b0:	4810      	ldr	r0, [pc, #64]	; (80065f4 <readFilePacket+0x68>)
 80065b2:	f7ff fe0b 	bl	80061cc <seek>
 80065b6:	b920      	cbnz	r0, 80065c2 <readFilePacket+0x36>
          {
            break;
          }
          else
           {
             writeBuffer[length] = *res;
 80065b8:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80065bc:	55a3      	strb	r3, [r4, r6]
             length++;
 80065be:	3401      	adds	r4, #1
             res++;
           }
      }
 80065c0:	e7f2      	b.n	80065a8 <readFilePacket+0x1c>
  size_array = length -  strlen("End");
  //uint8_t * buffer = (uint8_t*) malloc(size_array);
  //memcpy (buffer, writeBuffer,size_array);

  fileRes = FR_OK;
 80065c2:	4d10      	ldr	r5, [pc, #64]	; (8006604 <readFilePacket+0x78>)
  fileRes = f_write(&fdst, writeBuffer, size_array, &bw);
 80065c4:	490b      	ldr	r1, [pc, #44]	; (80065f4 <readFilePacket+0x68>)
 80065c6:	4810      	ldr	r0, [pc, #64]	; (8006608 <readFilePacket+0x7c>)
      }
  size_array = length -  strlen("End");
  //uint8_t * buffer = (uint8_t*) malloc(size_array);
  //memcpy (buffer, writeBuffer,size_array);

  fileRes = FR_OK;
 80065c8:	2300      	movs	r3, #0
 80065ca:	702b      	strb	r3, [r5, #0]
  fileRes = f_write(&fdst, writeBuffer, size_array, &bw);
 80065cc:	1ee2      	subs	r2, r4, #3
 80065ce:	4b0f      	ldr	r3, [pc, #60]	; (800660c <readFilePacket+0x80>)
 80065d0:	f7fd ff0c 	bl	80043ec <f_write>
 80065d4:	7028      	strb	r0, [r5, #0]
  if(fileRes!=FR_OK)
 80065d6:	b120      	cbz	r0, 80065e2 <readFilePacket+0x56>
  {
	  UART2_Write_Text("Error write file");
 80065d8:	480d      	ldr	r0, [pc, #52]	; (8006610 <readFilePacket+0x84>)
 80065da:	f7ff feab 	bl	8006334 <UART2_Write_Text>
	  Error_Handler();
 80065de:	f7f9 fe71 	bl	80002c4 <Error_Handler>
  }
  //free(buffer);
  clearBuf();
 80065e2:	f7ff ffc3 	bl	800656c <clearBuf>
  UART3_Write_Text("ACK");
 80065e6:	480b      	ldr	r0, [pc, #44]	; (8006614 <readFilePacket+0x88>)
 80065e8:	f7ff fe98 	bl	800631c <UART3_Write_Text>
  state_t = null;
 80065ec:	4b0a      	ldr	r3, [pc, #40]	; (8006618 <readFilePacket+0x8c>)
 80065ee:	2200      	movs	r2, #0
 80065f0:	601a      	str	r2, [r3, #0]
 80065f2:	bd70      	pop	{r4, r5, r6, pc}
 80065f4:	20000ad0 	.word	0x20000ad0
 80065f8:	080070ce 	.word	0x080070ce
 80065fc:	2000135c 	.word	0x2000135c
 8006600:	08007128 	.word	0x08007128
 8006604:	20001c00 	.word	0x20001c00
 8006608:	20000ee8 	.word	0x20000ee8
 800660c:	200019d4 	.word	0x200019d4
 8006610:	0800712c 	.word	0x0800712c
 8006614:	0800713d 	.word	0x0800713d
 8006618:	20001778 	.word	0x20001778

0800661c <readFilePacketEnd>:
	send_to_uart('\r');
	send_to_uart('\n');
}
//==============================================================================
void readFilePacketEnd()
{
 800661c:	b570      	push	{r4, r5, r6, lr}
 unsigned int str_len = 0,length = 0;
 unsigned char* res;
 unsigned int size_array = 0;

  resetBuffer(writeBuffer,GLOBAL_BUFFER_SIZE);
 800661e:	f44f 6183 	mov.w	r1, #1048	; 0x418
 8006622:	4828      	ldr	r0, [pc, #160]	; (80066c4 <readFilePacketEnd+0xa8>)
  res = strstr(Buf, "FileTransfer");
  str_len = strlen("FileTransfer");
  res+=str_len;
     while(TRUE)
      {
         if(seek(writeBuffer,"Stop",4,GLOBAL_BUFFER_SIZE))
 8006624:	4e27      	ldr	r6, [pc, #156]	; (80066c4 <readFilePacketEnd+0xa8>)
{
 unsigned int str_len = 0,length = 0;
 unsigned char* res;
 unsigned int size_array = 0;

  resetBuffer(writeBuffer,GLOBAL_BUFFER_SIZE);
 8006626:	f7ff fdf1 	bl	800620c <resetBuffer>
  res = strstr(Buf, "FileTransfer");
 800662a:	4927      	ldr	r1, [pc, #156]	; (80066c8 <readFilePacketEnd+0xac>)
 800662c:	4827      	ldr	r0, [pc, #156]	; (80066cc <readFilePacketEnd+0xb0>)
 800662e:	f000 f9f3 	bl	8006a18 <strstr>
	send_to_uart('\n');
}
//==============================================================================
void readFilePacketEnd()
{
 unsigned int str_len = 0,length = 0;
 8006632:	2500      	movs	r5, #0
 8006634:	f100 040b 	add.w	r4, r0, #11
  res = strstr(Buf, "FileTransfer");
  str_len = strlen("FileTransfer");
  res+=str_len;
     while(TRUE)
      {
         if(seek(writeBuffer,"Stop",4,GLOBAL_BUFFER_SIZE))
 8006638:	f44f 6383 	mov.w	r3, #1048	; 0x418
 800663c:	2204      	movs	r2, #4
 800663e:	4924      	ldr	r1, [pc, #144]	; (80066d0 <readFilePacketEnd+0xb4>)
 8006640:	4820      	ldr	r0, [pc, #128]	; (80066c4 <readFilePacketEnd+0xa8>)
 8006642:	f7ff fdc3 	bl	80061cc <seek>
 8006646:	b920      	cbnz	r0, 8006652 <readFilePacketEnd+0x36>
          {
            break;
          }
          else
           {
             writeBuffer[length] = *res;
 8006648:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 800664c:	55ab      	strb	r3, [r5, r6]
             length++;
 800664e:	3501      	adds	r5, #1
             res++;
           }
      }
 8006650:	e7f2      	b.n	8006638 <readFilePacketEnd+0x1c>
  size_array = length -  strlen("Stop");
  //uint8_t * buffer = (uint8_t*) malloc(size_array);
  //memcpy (buffer, writeBuffer,size_array+1);
  fileRes = FR_OK;
 8006652:	4c20      	ldr	r4, [pc, #128]	; (80066d4 <readFilePacketEnd+0xb8>)
  fileRes = f_write(&fdst, writeBuffer, size_array, &bw);
 8006654:	491b      	ldr	r1, [pc, #108]	; (80066c4 <readFilePacketEnd+0xa8>)
 8006656:	4820      	ldr	r0, [pc, #128]	; (80066d8 <readFilePacketEnd+0xbc>)
           }
      }
  size_array = length -  strlen("Stop");
  //uint8_t * buffer = (uint8_t*) malloc(size_array);
  //memcpy (buffer, writeBuffer,size_array+1);
  fileRes = FR_OK;
 8006658:	2300      	movs	r3, #0
 800665a:	7023      	strb	r3, [r4, #0]
  fileRes = f_write(&fdst, writeBuffer, size_array, &bw);
 800665c:	1f2a      	subs	r2, r5, #4
 800665e:	4b1f      	ldr	r3, [pc, #124]	; (80066dc <readFilePacketEnd+0xc0>)
 8006660:	f7fd fec4 	bl	80043ec <f_write>
 8006664:	7020      	strb	r0, [r4, #0]
  if(fileRes!=FR_OK)
 8006666:	b120      	cbz	r0, 8006672 <readFilePacketEnd+0x56>
    {
	  UART2_Write_Text("Error last write file");
 8006668:	481d      	ldr	r0, [pc, #116]	; (80066e0 <readFilePacketEnd+0xc4>)
 800666a:	f7ff fe63 	bl	8006334 <UART2_Write_Text>
	  Error_Handler();
 800666e:	f7f9 fe29 	bl	80002c4 <Error_Handler>
    }

  fileRes = f_close(&fdst);
 8006672:	4819      	ldr	r0, [pc, #100]	; (80066d8 <readFilePacketEnd+0xbc>)
 8006674:	f7fe f80c 	bl	8004690 <f_close>
 8006678:	7020      	strb	r0, [r4, #0]
  if(fileRes!=FR_OK)
 800667a:	b120      	cbz	r0, 8006686 <readFilePacketEnd+0x6a>
  {
	   UART2_Write_Text("Error close file");
 800667c:	4819      	ldr	r0, [pc, #100]	; (80066e4 <readFilePacketEnd+0xc8>)
 800667e:	f7ff fe59 	bl	8006334 <UART2_Write_Text>
	  Error_Handler();
 8006682:	f7f9 fe1f 	bl	80002c4 <Error_Handler>
  }
  //free(buffer);
  clearBuf();
 8006686:	f7ff ff71 	bl	800656c <clearBuf>
  fileRes=FR_OK;
 800668a:	2300      	movs	r3, #0
  fileRes = f_chdir("..");
 800668c:	4816      	ldr	r0, [pc, #88]	; (80066e8 <readFilePacketEnd+0xcc>)
	   UART2_Write_Text("Error close file");
	  Error_Handler();
  }
  //free(buffer);
  clearBuf();
  fileRes=FR_OK;
 800668e:	7023      	strb	r3, [r4, #0]
  fileRes = f_chdir("..");
 8006690:	f7fe fb78 	bl	8004d84 <f_chdir>
 8006694:	7020      	strb	r0, [r4, #0]
  if(fileRes==FR_OK)
 8006696:	b928      	cbnz	r0, 80066a4 <readFilePacketEnd+0x88>
	  {
	  fileRes = f_chdir("..");
 8006698:	4813      	ldr	r0, [pc, #76]	; (80066e8 <readFilePacketEnd+0xcc>)
 800669a:	f7fe fb73 	bl	8004d84 <f_chdir>
 800669e:	4b0d      	ldr	r3, [pc, #52]	; (80066d4 <readFilePacketEnd+0xb8>)
 80066a0:	7018      	strb	r0, [r3, #0]
	  if(fileRes==FR_OK)
 80066a2:	b120      	cbz	r0, 80066ae <readFilePacketEnd+0x92>
			  {

			  }
		  else
		  {
			   UART2_Write_Text("Error go to root dir");
 80066a4:	4811      	ldr	r0, [pc, #68]	; (80066ec <readFilePacketEnd+0xd0>)
 80066a6:	f7ff fe45 	bl	8006334 <UART2_Write_Text>
			  Error_Handler();
 80066aa:	f7f9 fe0b 	bl	80002c4 <Error_Handler>
	  {
		  UART2_Write_Text("Error go to root dir");
		  Error_Handler();
	  }

  clearBuf();
 80066ae:	f7ff ff5d 	bl	800656c <clearBuf>
  resetLeds();
 80066b2:	f7ff ff2d 	bl	8006510 <resetLeds>
  UART3_Write_Text("ACK");
 80066b6:	480e      	ldr	r0, [pc, #56]	; (80066f0 <readFilePacketEnd+0xd4>)
 80066b8:	f7ff fe30 	bl	800631c <UART3_Write_Text>
  //UART3_Write_Text("ACK");
  state_t = null;
 80066bc:	4b0d      	ldr	r3, [pc, #52]	; (80066f4 <readFilePacketEnd+0xd8>)
 80066be:	2200      	movs	r2, #0
 80066c0:	601a      	str	r2, [r3, #0]
 80066c2:	bd70      	pop	{r4, r5, r6, pc}
 80066c4:	20000ad0 	.word	0x20000ad0
 80066c8:	080070ce 	.word	0x080070ce
 80066cc:	2000135c 	.word	0x2000135c
 80066d0:	080070e4 	.word	0x080070e4
 80066d4:	20001c00 	.word	0x20001c00
 80066d8:	20000ee8 	.word	0x20000ee8
 80066dc:	200019d4 	.word	0x200019d4
 80066e0:	08007141 	.word	0x08007141
 80066e4:	08007157 	.word	0x08007157
 80066e8:	08007168 	.word	0x08007168
 80066ec:	0800716b 	.word	0x0800716b
 80066f0:	0800713d 	.word	0x0800713d
 80066f4:	20001778 	.word	0x20001778

080066f8 <readRXbuffer>:
     }
}
//==============================================================================
void readRXbuffer()
{
 Buf[count_buf] =  UART_Data;
 80066f8:	4a07      	ldr	r2, [pc, #28]	; (8006718 <readRXbuffer+0x20>)
 80066fa:	4908      	ldr	r1, [pc, #32]	; (800671c <readRXbuffer+0x24>)
 80066fc:	6813      	ldr	r3, [r2, #0]
 80066fe:	7808      	ldrb	r0, [r1, #0]
 8006700:	4907      	ldr	r1, [pc, #28]	; (8006720 <readRXbuffer+0x28>)
 8006702:	54c8      	strb	r0, [r1, r3]
   count_buf++;
 8006704:	3301      	adds	r3, #1
 8006706:	6013      	str	r3, [r2, #0]
    if(count_buf>=(GLOBAL_BUFFER_SIZE-1))
 8006708:	f240 4216 	movw	r2, #1046	; 0x416
 800670c:	4293      	cmp	r3, r2
 800670e:	d901      	bls.n	8006714 <readRXbuffer+0x1c>
      {
       clearBuf();
 8006710:	f7ff bf2c 	b.w	800656c <clearBuf>
 8006714:	4770      	bx	lr
 8006716:	bf00      	nop
 8006718:	2000019c 	.word	0x2000019c
 800671c:	20001c01 	.word	0x20001c01
 8006720:	2000135c 	.word	0x2000135c

08006724 <control_in_buf>:
      }
}
//==============================================================================
void control_in_buf()
 {
 8006724:	b508      	push	{r3, lr}
     if(seek(Buf,"RST",3,GLOBAL_BUFFER_SIZE))
 8006726:	2203      	movs	r2, #3
 8006728:	f44f 6383 	mov.w	r3, #1048	; 0x418
 800672c:	490f      	ldr	r1, [pc, #60]	; (800676c <control_in_buf+0x48>)
 800672e:	4810      	ldr	r0, [pc, #64]	; (8006770 <control_in_buf+0x4c>)
 8006730:	f7ff fd4c 	bl	80061cc <seek>
 8006734:	b160      	cbz	r0, 8006750 <control_in_buf+0x2c>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8006736:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800673a:	490e      	ldr	r1, [pc, #56]	; (8006774 <control_in_buf+0x50>)
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800673c:	4b0e      	ldr	r3, [pc, #56]	; (8006778 <control_in_buf+0x54>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800673e:	68ca      	ldr	r2, [r1, #12]
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8006740:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8006744:	4313      	orrs	r3, r2
 8006746:	60cb      	str	r3, [r1, #12]
 8006748:	f3bf 8f4f 	dsb	sy
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 800674c:	bf00      	nop
 800674e:	e7fd      	b.n	800674c <control_in_buf+0x28>
     {
    	 NVIC_SystemReset();
     }
    if(seek(Buf,"CONNECT",7,GLOBAL_BUFFER_SIZE))
 8006750:	f44f 6383 	mov.w	r3, #1048	; 0x418
 8006754:	2207      	movs	r2, #7
 8006756:	4909      	ldr	r1, [pc, #36]	; (800677c <control_in_buf+0x58>)
 8006758:	4805      	ldr	r0, [pc, #20]	; (8006770 <control_in_buf+0x4c>)
 800675a:	f7ff fd37 	bl	80061cc <seek>
 800675e:	b118      	cbz	r0, 8006768 <control_in_buf+0x44>
     {
       clearBuf();
     }

 }
 8006760:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     {
    	 NVIC_SystemReset();
     }
    if(seek(Buf,"CONNECT",7,GLOBAL_BUFFER_SIZE))
     {
       clearBuf();
 8006764:	f7ff bf02 	b.w	800656c <clearBuf>
 8006768:	bd08      	pop	{r3, pc}
 800676a:	bf00      	nop
 800676c:	08007180 	.word	0x08007180
 8006770:	2000135c 	.word	0x2000135c
 8006774:	e000ed00 	.word	0xe000ed00
 8006778:	05fa0004 	.word	0x05fa0004
 800677c:	08007184 	.word	0x08007184

08006780 <createPath>:
      Buf[i] = 0;
    }
}
//==============================================================================
void createPath()
{
 8006780:	b510      	push	{r4, lr}
 switch(path_state_t)
 8006782:	4c0c      	ldr	r4, [pc, #48]	; (80067b4 <createPath+0x34>)
 8006784:	6823      	ldr	r3, [r4, #0]
 8006786:	2b01      	cmp	r3, #1
 8006788:	d007      	beq.n	800679a <createPath+0x1a>
 800678a:	d302      	bcc.n	8006792 <createPath+0x12>
 800678c:	2b02      	cmp	r3, #2
 800678e:	d009      	beq.n	80067a4 <createPath+0x24>
 8006790:	bd10      	pop	{r4, pc}
 {
    case dir:
         createDir();
 8006792:	f7ff fde7 	bl	8006364 <createDir>
         path_state_t = sub_dir;
 8006796:	2301      	movs	r3, #1
 8006798:	e002      	b.n	80067a0 <createPath+0x20>
    break;

    case sub_dir:
         createSubDir();
 800679a:	f7ff fe2b 	bl	80063f4 <createSubDir>
         path_state_t = open_file;
 800679e:	2302      	movs	r3, #2
 80067a0:	6023      	str	r3, [r4, #0]
    break;
 80067a2:	bd10      	pop	{r4, pc}

    case open_file:
         openFile();
 80067a4:	f7ff fe6e 	bl	8006484 <openFile>
         clearBuf();
 80067a8:	f7ff fee0 	bl	800656c <clearBuf>
         state_t = null;
 80067ac:	4b02      	ldr	r3, [pc, #8]	; (80067b8 <createPath+0x38>)
 80067ae:	2200      	movs	r2, #0
 80067b0:	601a      	str	r2, [r3, #0]
 80067b2:	bd10      	pop	{r4, pc}
 80067b4:	200019b0 	.word	0x200019b0
 80067b8:	20001778 	.word	0x20001778

080067bc <stateMashin>:
	  }
}
//==============================================================================
void stateMashin()
{
   switch(state_t)
 80067bc:	4b17      	ldr	r3, [pc, #92]	; (800681c <stateMashin+0x60>)
 80067be:	681a      	ldr	r2, [r3, #0]
				  }
	  }
}
//==============================================================================
void stateMashin()
{
 80067c0:	b510      	push	{r4, lr}
 80067c2:	461c      	mov	r4, r3
   switch(state_t)
 80067c4:	2a06      	cmp	r2, #6
 80067c6:	d827      	bhi.n	8006818 <stateMashin+0x5c>
 80067c8:	e8df f002 	tbb	[pc, r2]
 80067cc:	22160c04 	.word	0x22160c04
 80067d0:	081e      	.short	0x081e
 80067d2:	1a          	.byte	0x1a
 80067d3:	00          	.byte	0x00
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 80067d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
   switch(state_t)
      {
//------------------------------------------------------------------------------
        case null:
             ControlNull();
 80067d8:	f7ff bcd8 	b.w	800618c <ControlNull>
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 80067dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        case null:
             ControlNull();
        break;
//------------------------------------------------------------------------------
        case control_packet_path:
             controlPacketPath();
 80067e0:	f7ff beb4 	b.w	800654c <controlPacketPath>
        break;
//------------------------------------------------------------------------------
        case path_packet_full:
             decoder(Buf,GLOBAL_BUFFER_SIZE);
 80067e4:	2118      	movs	r1, #24
 80067e6:	480e      	ldr	r0, [pc, #56]	; (8006820 <stateMashin+0x64>)
 80067e8:	f7ff fd18 	bl	800621c <decoder>
             state_t = create_path;
 80067ec:	2302      	movs	r3, #2
 80067ee:	6023      	str	r3, [r4, #0]
             path_state_t = dir;
 80067f0:	4b0c      	ldr	r3, [pc, #48]	; (8006824 <stateMashin+0x68>)
 80067f2:	2200      	movs	r2, #0
 80067f4:	601a      	str	r2, [r3, #0]
        break;
 80067f6:	bd10      	pop	{r4, pc}
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 80067f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
             state_t = create_path;
             path_state_t = dir;
        break;
//------------------------------------------------------------------------------
        case create_path:
             createPath();
 80067fc:	f7ff bfc0 	b.w	8006780 <createPath>
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 8006800:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        case create_path:
             createPath();
        break;
//------------------------------------------------------------------------------
        case control_packet_file:
             controlPacketFile();
 8006804:	f7ff bd60 	b.w	80062c8 <controlPacketFile>
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 8006808:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        case control_packet_file:
             controlPacketFile();
        break;
//------------------------------------------------------------------------------
        case file_packet_full:
             readFilePacket();
 800680c:	f7ff bebe 	b.w	800658c <readFilePacket>
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 8006810:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        case file_packet_full:
             readFilePacket();
        break;
//------------------------------------------------------------------------------
        case end_file_packet:
             readFilePacketEnd();
 8006814:	f7ff bf02 	b.w	800661c <readFilePacketEnd>
 8006818:	bd10      	pop	{r4, pc}
 800681a:	bf00      	nop
 800681c:	20001778 	.word	0x20001778
 8006820:	2000135c 	.word	0x2000135c
 8006824:	200019b0 	.word	0x200019b0

08006828 <InitStateMashine>:
}
//==============================================================================

void InitStateMashine()
{
   state_t = null;
 8006828:	4b01      	ldr	r3, [pc, #4]	; (8006830 <InitStateMashine+0x8>)
 800682a:	2200      	movs	r2, #0
 800682c:	601a      	str	r2, [r3, #0]
 800682e:	4770      	bx	lr
 8006830:	20001778 	.word	0x20001778

08006834 <__libc_init_array>:
 8006834:	b570      	push	{r4, r5, r6, lr}
 8006836:	4b0e      	ldr	r3, [pc, #56]	; (8006870 <__libc_init_array+0x3c>)
 8006838:	4c0e      	ldr	r4, [pc, #56]	; (8006874 <__libc_init_array+0x40>)
 800683a:	1ae4      	subs	r4, r4, r3
 800683c:	10a4      	asrs	r4, r4, #2
 800683e:	2500      	movs	r5, #0
 8006840:	461e      	mov	r6, r3
 8006842:	42a5      	cmp	r5, r4
 8006844:	d004      	beq.n	8006850 <__libc_init_array+0x1c>
 8006846:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800684a:	4798      	blx	r3
 800684c:	3501      	adds	r5, #1
 800684e:	e7f8      	b.n	8006842 <__libc_init_array+0xe>
 8006850:	f000 f90c 	bl	8006a6c <_init>
 8006854:	4c08      	ldr	r4, [pc, #32]	; (8006878 <__libc_init_array+0x44>)
 8006856:	4b09      	ldr	r3, [pc, #36]	; (800687c <__libc_init_array+0x48>)
 8006858:	1ae4      	subs	r4, r4, r3
 800685a:	10a4      	asrs	r4, r4, #2
 800685c:	2500      	movs	r5, #0
 800685e:	461e      	mov	r6, r3
 8006860:	42a5      	cmp	r5, r4
 8006862:	d004      	beq.n	800686e <__libc_init_array+0x3a>
 8006864:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8006868:	4798      	blx	r3
 800686a:	3501      	adds	r5, #1
 800686c:	e7f8      	b.n	8006860 <__libc_init_array+0x2c>
 800686e:	bd70      	pop	{r4, r5, r6, pc}
 8006870:	08007190 	.word	0x08007190
 8006874:	08007190 	.word	0x08007190
 8006878:	08007194 	.word	0x08007194
 800687c:	08007190 	.word	0x08007190

08006880 <malloc>:
 8006880:	4b02      	ldr	r3, [pc, #8]	; (800688c <malloc+0xc>)
 8006882:	4601      	mov	r1, r0
 8006884:	6818      	ldr	r0, [r3, #0]
 8006886:	f000 b859 	b.w	800693c <_malloc_r>
 800688a:	bf00      	nop
 800688c:	20000164 	.word	0x20000164

08006890 <free>:
 8006890:	4b02      	ldr	r3, [pc, #8]	; (800689c <free+0xc>)
 8006892:	4601      	mov	r1, r0
 8006894:	6818      	ldr	r0, [r3, #0]
 8006896:	f000 b803 	b.w	80068a0 <_free_r>
 800689a:	bf00      	nop
 800689c:	20000164 	.word	0x20000164

080068a0 <_free_r>:
 80068a0:	b538      	push	{r3, r4, r5, lr}
 80068a2:	4605      	mov	r5, r0
 80068a4:	2900      	cmp	r1, #0
 80068a6:	d046      	beq.n	8006936 <_free_r+0x96>
 80068a8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80068ac:	1f0c      	subs	r4, r1, #4
 80068ae:	2b00      	cmp	r3, #0
 80068b0:	bfb8      	it	lt
 80068b2:	18e4      	addlt	r4, r4, r3
 80068b4:	f000 f8ca 	bl	8006a4c <__malloc_lock>
 80068b8:	4a1f      	ldr	r2, [pc, #124]	; (8006938 <_free_r+0x98>)
 80068ba:	6813      	ldr	r3, [r2, #0]
 80068bc:	4611      	mov	r1, r2
 80068be:	b913      	cbnz	r3, 80068c6 <_free_r+0x26>
 80068c0:	6063      	str	r3, [r4, #4]
 80068c2:	6014      	str	r4, [r2, #0]
 80068c4:	e032      	b.n	800692c <_free_r+0x8c>
 80068c6:	42a3      	cmp	r3, r4
 80068c8:	d90e      	bls.n	80068e8 <_free_r+0x48>
 80068ca:	6822      	ldr	r2, [r4, #0]
 80068cc:	18a0      	adds	r0, r4, r2
 80068ce:	4283      	cmp	r3, r0
 80068d0:	bf04      	itt	eq
 80068d2:	6818      	ldreq	r0, [r3, #0]
 80068d4:	685b      	ldreq	r3, [r3, #4]
 80068d6:	6063      	str	r3, [r4, #4]
 80068d8:	bf04      	itt	eq
 80068da:	1812      	addeq	r2, r2, r0
 80068dc:	6022      	streq	r2, [r4, #0]
 80068de:	600c      	str	r4, [r1, #0]
 80068e0:	e024      	b.n	800692c <_free_r+0x8c>
 80068e2:	42a2      	cmp	r2, r4
 80068e4:	d803      	bhi.n	80068ee <_free_r+0x4e>
 80068e6:	4613      	mov	r3, r2
 80068e8:	685a      	ldr	r2, [r3, #4]
 80068ea:	2a00      	cmp	r2, #0
 80068ec:	d1f9      	bne.n	80068e2 <_free_r+0x42>
 80068ee:	6818      	ldr	r0, [r3, #0]
 80068f0:	1819      	adds	r1, r3, r0
 80068f2:	42a1      	cmp	r1, r4
 80068f4:	d10b      	bne.n	800690e <_free_r+0x6e>
 80068f6:	6821      	ldr	r1, [r4, #0]
 80068f8:	4401      	add	r1, r0
 80068fa:	1858      	adds	r0, r3, r1
 80068fc:	4282      	cmp	r2, r0
 80068fe:	6019      	str	r1, [r3, #0]
 8006900:	d114      	bne.n	800692c <_free_r+0x8c>
 8006902:	6810      	ldr	r0, [r2, #0]
 8006904:	6852      	ldr	r2, [r2, #4]
 8006906:	605a      	str	r2, [r3, #4]
 8006908:	4401      	add	r1, r0
 800690a:	6019      	str	r1, [r3, #0]
 800690c:	e00e      	b.n	800692c <_free_r+0x8c>
 800690e:	d902      	bls.n	8006916 <_free_r+0x76>
 8006910:	230c      	movs	r3, #12
 8006912:	602b      	str	r3, [r5, #0]
 8006914:	e00a      	b.n	800692c <_free_r+0x8c>
 8006916:	6821      	ldr	r1, [r4, #0]
 8006918:	1860      	adds	r0, r4, r1
 800691a:	4282      	cmp	r2, r0
 800691c:	bf04      	itt	eq
 800691e:	6810      	ldreq	r0, [r2, #0]
 8006920:	6852      	ldreq	r2, [r2, #4]
 8006922:	6062      	str	r2, [r4, #4]
 8006924:	bf04      	itt	eq
 8006926:	1809      	addeq	r1, r1, r0
 8006928:	6021      	streq	r1, [r4, #0]
 800692a:	605c      	str	r4, [r3, #4]
 800692c:	4628      	mov	r0, r5
 800692e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8006932:	f000 b88c 	b.w	8006a4e <__malloc_unlock>
 8006936:	bd38      	pop	{r3, r4, r5, pc}
 8006938:	200001a4 	.word	0x200001a4

0800693c <_malloc_r>:
 800693c:	b570      	push	{r4, r5, r6, lr}
 800693e:	1ccd      	adds	r5, r1, #3
 8006940:	f025 0503 	bic.w	r5, r5, #3
 8006944:	3508      	adds	r5, #8
 8006946:	2d0c      	cmp	r5, #12
 8006948:	bf38      	it	cc
 800694a:	250c      	movcc	r5, #12
 800694c:	2d00      	cmp	r5, #0
 800694e:	4606      	mov	r6, r0
 8006950:	db01      	blt.n	8006956 <_malloc_r+0x1a>
 8006952:	42a9      	cmp	r1, r5
 8006954:	d902      	bls.n	800695c <_malloc_r+0x20>
 8006956:	230c      	movs	r3, #12
 8006958:	6033      	str	r3, [r6, #0]
 800695a:	e046      	b.n	80069ea <_malloc_r+0xae>
 800695c:	f000 f876 	bl	8006a4c <__malloc_lock>
 8006960:	4b23      	ldr	r3, [pc, #140]	; (80069f0 <_malloc_r+0xb4>)
 8006962:	681c      	ldr	r4, [r3, #0]
 8006964:	461a      	mov	r2, r3
 8006966:	4621      	mov	r1, r4
 8006968:	b1a1      	cbz	r1, 8006994 <_malloc_r+0x58>
 800696a:	680b      	ldr	r3, [r1, #0]
 800696c:	1b5b      	subs	r3, r3, r5
 800696e:	d40e      	bmi.n	800698e <_malloc_r+0x52>
 8006970:	2b0b      	cmp	r3, #11
 8006972:	d903      	bls.n	800697c <_malloc_r+0x40>
 8006974:	600b      	str	r3, [r1, #0]
 8006976:	18cc      	adds	r4, r1, r3
 8006978:	50cd      	str	r5, [r1, r3]
 800697a:	e01e      	b.n	80069ba <_malloc_r+0x7e>
 800697c:	428c      	cmp	r4, r1
 800697e:	bf0d      	iteet	eq
 8006980:	6863      	ldreq	r3, [r4, #4]
 8006982:	684b      	ldrne	r3, [r1, #4]
 8006984:	6063      	strne	r3, [r4, #4]
 8006986:	6013      	streq	r3, [r2, #0]
 8006988:	bf18      	it	ne
 800698a:	460c      	movne	r4, r1
 800698c:	e015      	b.n	80069ba <_malloc_r+0x7e>
 800698e:	460c      	mov	r4, r1
 8006990:	6849      	ldr	r1, [r1, #4]
 8006992:	e7e9      	b.n	8006968 <_malloc_r+0x2c>
 8006994:	4c17      	ldr	r4, [pc, #92]	; (80069f4 <_malloc_r+0xb8>)
 8006996:	6823      	ldr	r3, [r4, #0]
 8006998:	b91b      	cbnz	r3, 80069a2 <_malloc_r+0x66>
 800699a:	4630      	mov	r0, r6
 800699c:	f000 f82c 	bl	80069f8 <_sbrk_r>
 80069a0:	6020      	str	r0, [r4, #0]
 80069a2:	4629      	mov	r1, r5
 80069a4:	4630      	mov	r0, r6
 80069a6:	f000 f827 	bl	80069f8 <_sbrk_r>
 80069aa:	1c43      	adds	r3, r0, #1
 80069ac:	d018      	beq.n	80069e0 <_malloc_r+0xa4>
 80069ae:	1cc4      	adds	r4, r0, #3
 80069b0:	f024 0403 	bic.w	r4, r4, #3
 80069b4:	42a0      	cmp	r0, r4
 80069b6:	d10d      	bne.n	80069d4 <_malloc_r+0x98>
 80069b8:	6025      	str	r5, [r4, #0]
 80069ba:	4630      	mov	r0, r6
 80069bc:	f000 f847 	bl	8006a4e <__malloc_unlock>
 80069c0:	f104 000b 	add.w	r0, r4, #11
 80069c4:	1d23      	adds	r3, r4, #4
 80069c6:	f020 0007 	bic.w	r0, r0, #7
 80069ca:	1ac3      	subs	r3, r0, r3
 80069cc:	d00e      	beq.n	80069ec <_malloc_r+0xb0>
 80069ce:	425a      	negs	r2, r3
 80069d0:	50e2      	str	r2, [r4, r3]
 80069d2:	bd70      	pop	{r4, r5, r6, pc}
 80069d4:	1a21      	subs	r1, r4, r0
 80069d6:	4630      	mov	r0, r6
 80069d8:	f000 f80e 	bl	80069f8 <_sbrk_r>
 80069dc:	3001      	adds	r0, #1
 80069de:	d1eb      	bne.n	80069b8 <_malloc_r+0x7c>
 80069e0:	230c      	movs	r3, #12
 80069e2:	6033      	str	r3, [r6, #0]
 80069e4:	4630      	mov	r0, r6
 80069e6:	f000 f832 	bl	8006a4e <__malloc_unlock>
 80069ea:	2000      	movs	r0, #0
 80069ec:	bd70      	pop	{r4, r5, r6, pc}
 80069ee:	bf00      	nop
 80069f0:	200001a4 	.word	0x200001a4
 80069f4:	200001a0 	.word	0x200001a0

080069f8 <_sbrk_r>:
 80069f8:	b538      	push	{r3, r4, r5, lr}
 80069fa:	4c06      	ldr	r4, [pc, #24]	; (8006a14 <_sbrk_r+0x1c>)
 80069fc:	2300      	movs	r3, #0
 80069fe:	4605      	mov	r5, r0
 8006a00:	4608      	mov	r0, r1
 8006a02:	6023      	str	r3, [r4, #0]
 8006a04:	f000 f824 	bl	8006a50 <_sbrk>
 8006a08:	1c43      	adds	r3, r0, #1
 8006a0a:	d102      	bne.n	8006a12 <_sbrk_r+0x1a>
 8006a0c:	6823      	ldr	r3, [r4, #0]
 8006a0e:	b103      	cbz	r3, 8006a12 <_sbrk_r+0x1a>
 8006a10:	602b      	str	r3, [r5, #0]
 8006a12:	bd38      	pop	{r3, r4, r5, pc}
 8006a14:	20001c24 	.word	0x20001c24

08006a18 <strstr>:
 8006a18:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006a1a:	7803      	ldrb	r3, [r0, #0]
 8006a1c:	b963      	cbnz	r3, 8006a38 <strstr+0x20>
 8006a1e:	780b      	ldrb	r3, [r1, #0]
 8006a20:	2b00      	cmp	r3, #0
 8006a22:	bf18      	it	ne
 8006a24:	2000      	movne	r0, #0
 8006a26:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006a28:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 8006a2c:	b162      	cbz	r2, 8006a48 <strstr+0x30>
 8006a2e:	f814 7f01 	ldrb.w	r7, [r4, #1]!
 8006a32:	4297      	cmp	r7, r2
 8006a34:	4630      	mov	r0, r6
 8006a36:	d0f7      	beq.n	8006a28 <strstr+0x10>
 8006a38:	4603      	mov	r3, r0
 8006a3a:	1c46      	adds	r6, r0, #1
 8006a3c:	7800      	ldrb	r0, [r0, #0]
 8006a3e:	b110      	cbz	r0, 8006a46 <strstr+0x2e>
 8006a40:	1e4d      	subs	r5, r1, #1
 8006a42:	1e5c      	subs	r4, r3, #1
 8006a44:	e7f0      	b.n	8006a28 <strstr+0x10>
 8006a46:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006a48:	4618      	mov	r0, r3
 8006a4a:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006a4c <__malloc_lock>:
 8006a4c:	4770      	bx	lr

08006a4e <__malloc_unlock>:
 8006a4e:	4770      	bx	lr

08006a50 <_sbrk>:
 8006a50:	4b04      	ldr	r3, [pc, #16]	; (8006a64 <_sbrk+0x14>)
 8006a52:	6819      	ldr	r1, [r3, #0]
 8006a54:	4602      	mov	r2, r0
 8006a56:	b909      	cbnz	r1, 8006a5c <_sbrk+0xc>
 8006a58:	4903      	ldr	r1, [pc, #12]	; (8006a68 <_sbrk+0x18>)
 8006a5a:	6019      	str	r1, [r3, #0]
 8006a5c:	6818      	ldr	r0, [r3, #0]
 8006a5e:	4402      	add	r2, r0
 8006a60:	601a      	str	r2, [r3, #0]
 8006a62:	4770      	bx	lr
 8006a64:	200001a8 	.word	0x200001a8
 8006a68:	20001c28 	.word	0x20001c28

08006a6c <_init>:
 8006a6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006a6e:	bf00      	nop
 8006a70:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006a72:	bc08      	pop	{r3}
 8006a74:	469e      	mov	lr, r3
 8006a76:	4770      	bx	lr

08006a78 <_fini>:
 8006a78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006a7a:	bf00      	nop
 8006a7c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006a7e:	bc08      	pop	{r3}
 8006a80:	469e      	mov	lr, r3
 8006a82:	4770      	bx	lr
