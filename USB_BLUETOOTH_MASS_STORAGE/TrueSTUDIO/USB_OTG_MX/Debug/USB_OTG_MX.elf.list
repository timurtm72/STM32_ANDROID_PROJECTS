
USB_OTG_MX.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006fac  08000188  08000188  00010188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000070c  08007134  08007134  00017134  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08007840  08007840  00017840  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08007844  08007844  00017844  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000608  20000000  08007848  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  00020608  2**0
                  CONTENTS
  7 .bss          00001b0c  20000608  20000608  00020608  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  20002114  20002114  00020608  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020608  2**0
                  CONTENTS, READONLY
 10 .debug_line   00009400  00000000  00000000  00020638  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0001d9b0  00000000  00000000  00029a38  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00004d16  00000000  00000000  000473e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000010a8  00000000  00000000  0004c100  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001490  00000000  00000000  0004d1a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f6a1  00000000  00000000  0004e638  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000591c  00000000  00000000  0005dcd9  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007e  00000000  00000000  000635f5  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00002f18  00000000  00000000  00063674  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	; (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b113      	cbz	r3, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2301      	movs	r3, #1
 800019c:	7023      	strb	r3, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	20000608 	.word	0x20000608
 80001a4:	00000000 	.word	0x00000000
 80001a8:	0800711c 	.word	0x0800711c

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b03      	ldr	r3, [pc, #12]	; (80001bc <frame_dummy+0x10>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4903      	ldr	r1, [pc, #12]	; (80001c0 <frame_dummy+0x14>)
 80001b4:	4803      	ldr	r0, [pc, #12]	; (80001c4 <frame_dummy+0x18>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	bd08      	pop	{r3, pc}
 80001bc:	00000000 	.word	0x00000000
 80001c0:	2000060c 	.word	0x2000060c
 80001c4:	0800711c 	.word	0x0800711c

080001c8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80001c8:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000200 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80001cc:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80001ce:	e003      	b.n	80001d8 <LoopCopyDataInit>

080001d0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80001d0:	4b0c      	ldr	r3, [pc, #48]	; (8000204 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80001d2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80001d4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80001d6:	3104      	adds	r1, #4

080001d8 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80001d8:	480b      	ldr	r0, [pc, #44]	; (8000208 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80001da:	4b0c      	ldr	r3, [pc, #48]	; (800020c <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80001dc:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80001de:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80001e0:	d3f6      	bcc.n	80001d0 <CopyDataInit>
  ldr  r2, =_sbss
 80001e2:	4a0b      	ldr	r2, [pc, #44]	; (8000210 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80001e4:	e002      	b.n	80001ec <LoopFillZerobss>

080001e6 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80001e6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80001e8:	f842 3b04 	str.w	r3, [r2], #4

080001ec <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80001ec:	4b09      	ldr	r3, [pc, #36]	; (8000214 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80001ee:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80001f0:	d3f9      	bcc.n	80001e6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80001f2:	f000 fc33 	bl	8000a5c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80001f6:	f006 fbed 	bl	80069d4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80001fa:	f000 f8c9 	bl	8000390 <main>
  bx  lr    
 80001fe:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8000200:	20020000 	.word	0x20020000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8000204:	08007848 	.word	0x08007848
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8000208:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800020c:	20000608 	.word	0x20000608
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8000210:	20000608 	.word	0x20000608
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000214:	20002114 	.word	0x20002114

08000218 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000218:	e7fe      	b.n	8000218 <ADC_IRQHandler>
	...

0800021c <BSP_SD_Init>:
/**
  * @brief  Initializes the SD card device.
  * @retval SD status
  */
uint8_t BSP_SD_Init(void)
{
 800021c:	b507      	push	{r0, r1, r2, lr}
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @retval Returns if SD is detected or not
 */
uint8_t BSP_SD_IsDetected(void)
{
  __IO uint8_t status = SD_PRESENT;
 800021e:	2001      	movs	r0, #1
 8000220:	f88d 0007 	strb.w	r0, [sp, #7]

  /* USER CODE BEGIN 1 */
  /* user code can be inserted here */
  /* USER CODE END 1 */    	

  return status;
 8000224:	f89d 3007 	ldrb.w	r3, [sp, #7]
  */
uint8_t BSP_SD_Init(void)
{
  uint8_t sd_state = MSD_OK;
  /* Check if the SD card is plugged in the slot */
  if (BSP_SD_IsDetected() != SD_PRESENT)
 8000228:	4283      	cmp	r3, r0
 800022a:	d103      	bne.n	8000234 <BSP_SD_Init+0x18>
  {
    return MSD_ERROR;
  }
  /* HAL SD initialization */
  sd_state = HAL_SD_Init(&hsd, &SDCardInfo);
 800022c:	4903      	ldr	r1, [pc, #12]	; (800023c <BSP_SD_Init+0x20>)
 800022e:	4804      	ldr	r0, [pc, #16]	; (8000240 <BSP_SD_Init+0x24>)
 8000230:	f001 ff90 	bl	8002154 <HAL_SD_Init>
    }
  }
#endif
*/
  return sd_state;
}
 8000234:	b003      	add	sp, #12
 8000236:	f85d fb04 	ldr.w	pc, [sp], #4
 800023a:	bf00      	nop
 800023c:	200006d8 	.word	0x200006d8
 8000240:	20000730 	.word	0x20000730

08000244 <BSP_SD_ReadBlocks>:
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to read 
  * @retval SD status
  */
uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 8000244:	b507      	push	{r0, r1, r2, lr}
  uint8_t sd_state;
  if(HAL_SD_ReadBlocks(&hsd, pData, ReadAddr, BlockSize, NumOfBlocks) != SD_OK)
 8000246:	9905      	ldr	r1, [sp, #20]
 8000248:	9101      	str	r1, [sp, #4]
 800024a:	9904      	ldr	r1, [sp, #16]
 800024c:	9100      	str	r1, [sp, #0]
 800024e:	4601      	mov	r1, r0
 8000250:	4804      	ldr	r0, [pc, #16]	; (8000264 <BSP_SD_ReadBlocks+0x20>)
 8000252:	f002 f95c 	bl	800250e <HAL_SD_ReadBlocks>
  else
  {
    sd_state = MSD_OK;
  }
  return sd_state;  
}
 8000256:	3000      	adds	r0, #0
 8000258:	bf18      	it	ne
 800025a:	2001      	movne	r0, #1
 800025c:	b003      	add	sp, #12
 800025e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000262:	bf00      	nop
 8000264:	20000730 	.word	0x20000730

08000268 <BSP_SD_WriteBlocks>:
  * @param  BlockSize: SD card data block size, that should be 512
  * @param  NumOfBlocks: Number of SD blocks to write
  * @retval SD status
  */
uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumOfBlocks)
{
 8000268:	b507      	push	{r0, r1, r2, lr}
  uint8_t sd_state;
  if(HAL_SD_WriteBlocks(&hsd, pData, WriteAddr, BlockSize, NumOfBlocks) != SD_OK)  
 800026a:	9905      	ldr	r1, [sp, #20]
 800026c:	9101      	str	r1, [sp, #4]
 800026e:	9904      	ldr	r1, [sp, #16]
 8000270:	9100      	str	r1, [sp, #0]
 8000272:	4601      	mov	r1, r0
 8000274:	4804      	ldr	r0, [pc, #16]	; (8000288 <BSP_SD_WriteBlocks+0x20>)
 8000276:	f002 fa0c 	bl	8002692 <HAL_SD_WriteBlocks>
  else
  {
    sd_state = MSD_OK;
  }
  return sd_state;  
}
 800027a:	3000      	adds	r0, #0
 800027c:	bf18      	it	ne
 800027e:	2001      	movne	r0, #1
 8000280:	b003      	add	sp, #12
 8000282:	f85d fb04 	ldr.w	pc, [sp], #4
 8000286:	bf00      	nop
 8000288:	20000730 	.word	0x20000730

0800028c <BSP_SD_GetStatus>:
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  *            @arg  SD_TRANSFER_ERROR: Data transfer error 
  */
HAL_SD_TransferStateTypedef BSP_SD_GetStatus(void)
{
  return(HAL_SD_GetStatus(&hsd));
 800028c:	4801      	ldr	r0, [pc, #4]	; (8000294 <BSP_SD_GetStatus+0x8>)
 800028e:	f002 bb86 	b.w	800299e <HAL_SD_GetStatus>
 8000292:	bf00      	nop
 8000294:	20000730 	.word	0x20000730

08000298 <BSP_SD_GetCardInfo>:
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  */
void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypedef* CardInfo)
{
  /* Get SD card Information */
  HAL_SD_Get_CardInfo(&hsd, CardInfo);
 8000298:	4601      	mov	r1, r0
 800029a:	4801      	ldr	r0, [pc, #4]	; (80002a0 <BSP_SD_GetCardInfo+0x8>)
 800029c:	f001 be18 	b.w	8001ed0 <HAL_SD_Get_CardInfo>
 80002a0:	20000730 	.word	0x20000730

080002a4 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
 80002a4:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SD_Path);
 80002a6:	4903      	ldr	r1, [pc, #12]	; (80002b4 <MX_FATFS_Init+0x10>)
 80002a8:	4803      	ldr	r0, [pc, #12]	; (80002b8 <MX_FATFS_Init+0x14>)
 80002aa:	f005 f855 	bl	8005358 <FATFS_LinkDriver>
 80002ae:	4b03      	ldr	r3, [pc, #12]	; (80002bc <MX_FATFS_Init+0x18>)
 80002b0:	7018      	strb	r0, [r3, #0]
 80002b2:	bd08      	pop	{r3, pc}
 80002b4:	20000691 	.word	0x20000691
 80002b8:	08007748 	.word	0x08007748
 80002bc:	20000690 	.word	0x20000690

080002c0 <get_fattime>:
DWORD get_fattime(void)
{
  /* USER CODE BEGIN get_fattime */
  return 0;
  /* USER CODE END get_fattime */  
}
 80002c0:	2000      	movs	r0, #0
 80002c2:	4770      	bx	lr

080002c4 <Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void Error_Handler(void)
{
 80002c4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN Error_Handler */
  /* User can add his own implementation to report the HAL error return state */
  while(1) 
  {
	  HAL_GPIO_TogglePin(GPIOD, LD4_Pin);
 80002c6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80002ca:	4804      	ldr	r0, [pc, #16]	; (80002dc <Error_Handler+0x18>)
 80002cc:	f000 fda6 	bl	8000e1c <HAL_GPIO_TogglePin>
	  HAL_Delay(500);
 80002d0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80002d4:	f000 fc24 	bl	8000b20 <HAL_Delay>
 80002d8:	e7f5      	b.n	80002c6 <Error_Handler+0x2>
 80002da:	bf00      	nop
 80002dc:	40020c00 	.word	0x40020c00

080002e0 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 80002e0:	b510      	push	{r4, lr}
 80002e2:	b094      	sub	sp, #80	; 0x50

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __HAL_RCC_PWR_CLK_ENABLE();
 80002e4:	4b28      	ldr	r3, [pc, #160]	; (8000388 <SystemClock_Config+0xa8>)
 80002e6:	2100      	movs	r1, #0
 80002e8:	9101      	str	r1, [sp, #4]
 80002ea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80002ec:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80002f0:	641a      	str	r2, [r3, #64]	; 0x40
 80002f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80002f4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80002f8:	9301      	str	r3, [sp, #4]
 80002fa:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80002fc:	4b23      	ldr	r3, [pc, #140]	; (800038c <SystemClock_Config+0xac>)
 80002fe:	9102      	str	r1, [sp, #8]
 8000300:	681a      	ldr	r2, [r3, #0]
 8000302:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000306:	601a      	str	r2, [r3, #0]
 8000308:	681b      	ldr	r3, [r3, #0]
 800030a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800030e:	9302      	str	r3, [sp, #8]
 8000310:	9b02      	ldr	r3, [sp, #8]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000312:	2301      	movs	r3, #1
 8000314:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000316:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000318:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800031c:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLM = 8;
 800031e:	2308      	movs	r3, #8
 8000320:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLN = 336;
 8000322:	f44f 73a8 	mov.w	r3, #336	; 0x150

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000326:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
 8000328:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800032a:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
 800032c:	2307      	movs	r3, #7

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800032e:	940e      	str	r4, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8000330:	9412      	str	r4, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 7;
 8000332:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000334:	f001 fa0e 	bl	8001754 <HAL_RCC_OscConfig>
 8000338:	b108      	cbz	r0, 800033e <SystemClock_Config+0x5e>
  {
    Error_Handler();
 800033a:	f7ff ffc3 	bl	80002c4 <Error_Handler>
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800033e:	230f      	movs	r3, #15
 8000340:	9303      	str	r3, [sp, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8000342:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000346:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8000348:	9306      	str	r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 800034a:	2105      	movs	r1, #5
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800034c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8000350:	a803      	add	r0, sp, #12
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000352:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000354:	9307      	str	r3, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8000356:	f001 fba3 	bl	8001aa0 <HAL_RCC_ClockConfig>
 800035a:	4604      	mov	r4, r0
 800035c:	2800      	cmp	r0, #0
 800035e:	d1ec      	bne.n	800033a <SystemClock_Config+0x5a>
  {
    Error_Handler();
  }

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8000360:	f001 fc52 	bl	8001c08 <HAL_RCC_GetHCLKFreq>
 8000364:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000368:	fbb0 f0f3 	udiv	r0, r0, r3
 800036c:	f000 fc38 	bl	8000be0 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8000370:	2004      	movs	r0, #4
 8000372:	f000 fc4b 	bl	8000c0c <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8000376:	4622      	mov	r2, r4
 8000378:	4621      	mov	r1, r4
 800037a:	f04f 30ff 	mov.w	r0, #4294967295
 800037e:	f000 fbef 	bl	8000b60 <HAL_NVIC_SetPriority>
}
 8000382:	b014      	add	sp, #80	; 0x50
 8000384:	bd10      	pop	{r4, pc}
 8000386:	bf00      	nop
 8000388:	40023800 	.word	0x40023800
 800038c:	40007000 	.word	0x40007000

08000390 <main>:
/* USER CODE BEGIN 0 */
/* USER CODE END 0 */

extern volatile uint8_t TxFlag;
int main(void)
{
 8000390:	b500      	push	{lr}
 8000392:	b08b      	sub	sp, #44	; 0x2c
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000394:	2400      	movs	r4, #0
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000396:	f000 fb9b 	bl	8000ad0 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 800039a:	f7ff ffa1 	bl	80002e0 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800039e:	4b4c      	ldr	r3, [pc, #304]	; (80004d0 <main+0x140>)
 80003a0:	9400      	str	r4, [sp, #0]
 80003a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 80003a4:	484b      	ldr	r0, [pc, #300]	; (80004d4 <main+0x144>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80003a6:	f042 0204 	orr.w	r2, r2, #4
 80003aa:	631a      	str	r2, [r3, #48]	; 0x30
 80003ac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003ae:	f002 0204 	and.w	r2, r2, #4
 80003b2:	9200      	str	r2, [sp, #0]
 80003b4:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80003b6:	9401      	str	r4, [sp, #4]
 80003b8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003ba:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80003be:	631a      	str	r2, [r3, #48]	; 0x30
 80003c0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003c2:	f002 0280 	and.w	r2, r2, #128	; 0x80
 80003c6:	9201      	str	r2, [sp, #4]
 80003c8:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80003ca:	9402      	str	r4, [sp, #8]
 80003cc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003ce:	f042 0201 	orr.w	r2, r2, #1
 80003d2:	631a      	str	r2, [r3, #48]	; 0x30
 80003d4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003d6:	f002 0201 	and.w	r2, r2, #1
 80003da:	9202      	str	r2, [sp, #8]
 80003dc:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80003de:	9403      	str	r4, [sp, #12]
 80003e0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003e2:	f042 0202 	orr.w	r2, r2, #2
 80003e6:	631a      	str	r2, [r3, #48]	; 0x30
 80003e8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003ea:	f002 0202 	and.w	r2, r2, #2
 80003ee:	9203      	str	r2, [sp, #12]
 80003f0:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80003f2:	9404      	str	r4, [sp, #16]
 80003f4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003f6:	f042 0208 	orr.w	r2, r2, #8
 80003fa:	631a      	str	r2, [r3, #48]	; 0x30
 80003fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 80003fe:	2201      	movs	r2, #1
  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000400:	f003 0308 	and.w	r3, r3, #8

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 8000404:	4611      	mov	r1, r2
  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000406:	9304      	str	r3, [sp, #16]
 8000408:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 800040a:	f000 fd03 	bl	8000e14 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin, GPIO_PIN_RESET);
 800040e:	4622      	mov	r2, r4
 8000410:	f44f 4170 	mov.w	r1, #61440	; 0xf000
 8000414:	4830      	ldr	r0, [pc, #192]	; (80004d8 <main+0x148>)
 8000416:	f000 fcfd 	bl	8000e14 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 800041a:	2501      	movs	r5, #1
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 800041c:	a905      	add	r1, sp, #20
 800041e:	482d      	ldr	r0, [pc, #180]	; (80004d4 <main+0x144>)

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 8000420:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000422:	9506      	str	r5, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000424:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000426:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 8000428:	f000 fc14 	bl	8000c54 <HAL_GPIO_Init>

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 800042c:	4b2b      	ldr	r3, [pc, #172]	; (80004dc <main+0x14c>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 800042e:	482c      	ldr	r0, [pc, #176]	; (80004e0 <main+0x150>)
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 8000430:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8000432:	a905      	add	r1, sp, #20

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
 8000434:	2604      	movs	r6, #4
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
 8000436:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000438:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 800043a:	f000 fc0b 	bl	8000c54 <HAL_GPIO_Init>

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
 800043e:	a905      	add	r1, sp, #20
 8000440:	4828      	ldr	r0, [pc, #160]	; (80004e4 <main+0x154>)
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
 8000442:	9605      	str	r6, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000444:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000446:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
 8000448:	f000 fc04 	bl	8000c54 <HAL_GPIO_Init>
  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800044c:	4822      	ldr	r0, [pc, #136]	; (80004d8 <main+0x148>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800044e:	9506      	str	r5, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin;
 8000450:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8000454:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin;
 8000456:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000458:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800045a:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800045c:	f000 fbfa 	bl	8000c54 <HAL_GPIO_Init>

/* SDIO init function */
static void MX_SDIO_SD_Init(void)
{

  hsd.Instance = SDIO;
 8000460:	4b21      	ldr	r3, [pc, #132]	; (80004e8 <main+0x158>)
 8000462:	4a22      	ldr	r2, [pc, #136]	; (80004ec <main+0x15c>)
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  hsd.Init.ClockDiv = 4;
 8000464:	619e      	str	r6, [r3, #24]
/* SDIO init function */
static void MX_SDIO_SD_Init(void)
{

  hsd.Instance = SDIO;
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
 8000466:	e883 0014 	stmia.w	r3, {r2, r4}
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
 800046a:	609c      	str	r4, [r3, #8]
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
 800046c:	60dc      	str	r4, [r3, #12]
  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
 800046e:	611c      	str	r4, [r3, #16]
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 8000470:	615c      	str	r4, [r3, #20]
  SystemClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SDIO_SD_Init();
  MX_USB_DEVICE_Init();
 8000472:	f000 f90d 	bl	8000690 <MX_USB_DEVICE_Init>
  MX_FATFS_Init();
 8000476:	f7ff ff15 	bl	80002a4 <MX_FATFS_Init>

/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
 800047a:	481d      	ldr	r0, [pc, #116]	; (80004f0 <main+0x160>)
  huart2.Init.BaudRate = 115200;
 800047c:	4b1d      	ldr	r3, [pc, #116]	; (80004f4 <main+0x164>)
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800047e:	6084      	str	r4, [r0, #8]
/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
 8000480:	f44f 36e1 	mov.w	r6, #115200	; 0x1c200
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000484:	250c      	movs	r5, #12
/* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
 8000486:	e880 0048 	stmia.w	r0, {r3, r6}
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
 800048a:	60c4      	str	r4, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 800048c:	6104      	str	r4, [r0, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 800048e:	6145      	str	r5, [r0, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000490:	6184      	str	r4, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8000492:	61c4      	str	r4, [r0, #28]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000494:	f002 fc0c 	bl	8002cb0 <HAL_UART_Init>
 8000498:	b108      	cbz	r0, 800049e <main+0x10e>
  {
    Error_Handler();
 800049a:	f7ff ff13 	bl	80002c4 <Error_Handler>

/* USART3 init function */
static void MX_USART3_UART_Init(void)
{

  huart3.Instance = USART3;
 800049e:	4b16      	ldr	r3, [pc, #88]	; (80004f8 <main+0x168>)
 80004a0:	4a16      	ldr	r2, [pc, #88]	; (80004fc <main+0x16c>)
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 80004a2:	6098      	str	r0, [r3, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 80004a4:	60d8      	str	r0, [r3, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 80004a6:	6118      	str	r0, [r3, #16]
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80004a8:	6198      	str	r0, [r3, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 80004aa:	61d8      	str	r0, [r3, #28]
  if (HAL_UART_Init(&huart3) != HAL_OK)
 80004ac:	4618      	mov	r0, r3
/* USART3 init function */
static void MX_USART3_UART_Init(void)
{

  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
 80004ae:	e883 0044 	stmia.w	r3, {r2, r6}
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
 80004b2:	615d      	str	r5, [r3, #20]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
 80004b4:	f002 fbfc 	bl	8002cb0 <HAL_UART_Init>
 80004b8:	2800      	cmp	r0, #0
 80004ba:	d1ee      	bne.n	800049a <main+0x10a>
  MX_SDIO_SD_Init();
  MX_USB_DEVICE_Init();
  MX_FATFS_Init();
  MX_USART2_UART_Init();
  MX_USART3_UART_Init();
  Disk_Init();
 80004bc:	f006 f8da 	bl	8006674 <Disk_Init>
  InitStateMashine();
 80004c0:	f006 fa82 	bl	80069c8 <InitStateMashine>
  /* USER CODE BEGIN WHILE */
  //HAL_UART_Receive_IT(&huart3,&UART_Data,1);
  while (1)
  {
	//UART_RX();
	stateMashin();
 80004c4:	f006 fa4a 	bl	800695c <stateMashin>
	control_in_buf();
 80004c8:	f006 f9fc 	bl	80068c4 <control_in_buf>
 80004cc:	e7fa      	b.n	80004c4 <main+0x134>
 80004ce:	bf00      	nop
 80004d0:	40023800 	.word	0x40023800
 80004d4:	40020800 	.word	0x40020800
 80004d8:	40020c00 	.word	0x40020c00
 80004dc:	10120000 	.word	0x10120000
 80004e0:	40020000 	.word	0x40020000
 80004e4:	40020400 	.word	0x40020400
 80004e8:	20000730 	.word	0x20000730
 80004ec:	40012c00 	.word	0x40012c00
 80004f0:	20000790 	.word	0x20000790
 80004f4:	40004400 	.word	0x40004400
 80004f8:	20000698 	.word	0x20000698
 80004fc:	40004800 	.word	0x40004800

08000500 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000500:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 8000502:	2007      	movs	r0, #7
 8000504:	f000 fb1a 	bl	8000b3c <HAL_NVIC_SetPriorityGrouping>
  /* DebugMonitor_IRQn interrupt configuration */
  //HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  /* PendSV_IRQn interrupt configuration */
  //HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 8, 0);
 8000508:	2200      	movs	r2, #0
 800050a:	2108      	movs	r1, #8
 800050c:	f04f 30ff 	mov.w	r0, #4294967295

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000510:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  /* DebugMonitor_IRQn interrupt configuration */
  //HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  /* PendSV_IRQn interrupt configuration */
  //HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 8, 0);
 8000514:	f000 bb24 	b.w	8000b60 <HAL_NVIC_SetPriority>

08000518 <HAL_SD_MspInit>:

  /* USER CODE END MspInit 1 */
}

void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 8000518:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hsd->Instance==SDIO)
 800051a:	6802      	ldr	r2, [r0, #0]
 800051c:	4b15      	ldr	r3, [pc, #84]	; (8000574 <HAL_SD_MspInit+0x5c>)
 800051e:	429a      	cmp	r2, r3

  /* USER CODE END MspInit 1 */
}

void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 8000520:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hsd->Instance==SDIO)
 8000522:	d125      	bne.n	8000570 <HAL_SD_MspInit+0x58>
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */

  /* USER CODE END SDIO_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SDIO_CLK_ENABLE();
 8000524:	2300      	movs	r3, #0
 8000526:	9300      	str	r3, [sp, #0]
 8000528:	4b13      	ldr	r3, [pc, #76]	; (8000578 <HAL_SD_MspInit+0x60>)
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800052a:	4814      	ldr	r0, [pc, #80]	; (800057c <HAL_SD_MspInit+0x64>)
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */

  /* USER CODE END SDIO_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SDIO_CLK_ENABLE();
 800052c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800052e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8000532:	645a      	str	r2, [r3, #68]	; 0x44
 8000534:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000536:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800053a:	9300      	str	r3, [sp, #0]
 800053c:	9b00      	ldr	r3, [sp, #0]
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800053e:	2702      	movs	r7, #2
    PC10     ------> SDIO_D2
    PC11     ------> SDIO_D3
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
 8000540:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000544:	2601      	movs	r6, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000546:	2503      	movs	r5, #3
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 8000548:	240c      	movs	r4, #12
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800054a:	a901      	add	r1, sp, #4
    PC10     ------> SDIO_D2
    PC11     ------> SDIO_D3
    PC12     ------> SDIO_CK
    PD2     ------> SDIO_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11 
 800054c:	9301      	str	r3, [sp, #4]
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800054e:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000550:	9603      	str	r6, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000552:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 8000554:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000556:	f000 fb7d 	bl	8000c54 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 800055a:	2304      	movs	r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800055c:	eb0d 0103 	add.w	r1, sp, r3
 8000560:	4807      	ldr	r0, [pc, #28]	; (8000580 <HAL_SD_MspInit+0x68>)
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000562:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000564:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000566:	9603      	str	r6, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000568:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 800056a:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800056c:	f000 fb72 	bl	8000c54 <HAL_GPIO_Init>
  /* USER CODE BEGIN SDIO_MspInit 1 */

  /* USER CODE END SDIO_MspInit 1 */
  }

}
 8000570:	b007      	add	sp, #28
 8000572:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000574:	40012c00 	.word	0x40012c00
 8000578:	40023800 	.word	0x40023800
 800057c:	40020800 	.word	0x40020800
 8000580:	40020c00 	.word	0x40020c00

08000584 <HAL_UART_MspInit>:
  /* USER CODE END SDIO_MspDeInit 1 */

}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8000584:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 8000586:	4b2a      	ldr	r3, [pc, #168]	; (8000630 <HAL_UART_MspInit+0xac>)
 8000588:	6804      	ldr	r4, [r0, #0]
 800058a:	429c      	cmp	r4, r3
  /* USER CODE END SDIO_MspDeInit 1 */

}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 800058c:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 800058e:	d121      	bne.n	80005d4 <HAL_UART_MspInit+0x50>
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 8000590:	f503 33fa 	add.w	r3, r3, #128000	; 0x1f400
 8000594:	2400      	movs	r4, #0
 8000596:	9401      	str	r4, [sp, #4]
 8000598:	6c19      	ldr	r1, [r3, #64]	; 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800059a:	4826      	ldr	r0, [pc, #152]	; (8000634 <HAL_UART_MspInit+0xb0>)
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();
 800059c:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 80005a0:	6419      	str	r1, [r3, #64]	; 0x40
 80005a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80005a4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80005a8:	9301      	str	r3, [sp, #4]
 80005aa:	9b01      	ldr	r3, [sp, #4]

    /**USART2 GPIO Configuration    
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 80005ac:	230c      	movs	r3, #12
 80005ae:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80005b0:	2302      	movs	r3, #2
 80005b2:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80005b4:	2301      	movs	r3, #1
 80005b6:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80005b8:	2303      	movs	r3, #3
 80005ba:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80005bc:	a903      	add	r1, sp, #12
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 80005be:	2307      	movs	r3, #7
 80005c0:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80005c2:	f000 fb47 	bl	8000c54 <HAL_GPIO_Init>

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USART2_IRQn, 8, 0);
 80005c6:	2026      	movs	r0, #38	; 0x26
 80005c8:	4622      	mov	r2, r4
 80005ca:	2108      	movs	r1, #8
 80005cc:	f000 fac8 	bl	8000b60 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 80005d0:	2026      	movs	r0, #38	; 0x26
 80005d2:	e028      	b.n	8000626 <HAL_UART_MspInit+0xa2>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
  else if(huart->Instance==USART3)
 80005d4:	4b18      	ldr	r3, [pc, #96]	; (8000638 <HAL_UART_MspInit+0xb4>)
 80005d6:	429c      	cmp	r4, r3
 80005d8:	d127      	bne.n	800062a <HAL_UART_MspInit+0xa6>
  {
  /* USER CODE BEGIN USART3_MspInit 0 */

  /* USER CODE END USART3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();
 80005da:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
 80005de:	2500      	movs	r5, #0
 80005e0:	9502      	str	r5, [sp, #8]
 80005e2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80005e4:	4815      	ldr	r0, [pc, #84]	; (800063c <HAL_UART_MspInit+0xb8>)
  {
  /* USER CODE BEGIN USART3_MspInit 0 */

  /* USER CODE END USART3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();
 80005e6:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80005ea:	641a      	str	r2, [r3, #64]	; 0x40
 80005ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80005ee:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80005f2:	9302      	str	r3, [sp, #8]
 80005f4:	9b02      	ldr	r3, [sp, #8]
  
    /**USART3 GPIO Configuration    
    PB10     ------> USART3_TX
    PB11     ------> USART3_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 80005f6:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80005fa:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80005fc:	2302      	movs	r3, #2
 80005fe:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000600:	2303      	movs	r3, #3
    PB10     ------> USART3_TX
    PB11     ------> USART3_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000602:	2601      	movs	r6, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000604:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000606:	a903      	add	r1, sp, #12
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8000608:	2307      	movs	r3, #7
 800060a:	9307      	str	r3, [sp, #28]
    PB10     ------> USART3_TX
    PB11     ------> USART3_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800060c:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800060e:	f000 fb21 	bl	8000c54 <HAL_GPIO_Init>
    USART3->CR1 |= USART_CR1_RXNEIE;
 8000612:	68e3      	ldr	r3, [r4, #12]
 8000614:	f043 0320 	orr.w	r3, r3, #32

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USART3_IRQn, 0, 1);
 8000618:	2027      	movs	r0, #39	; 0x27
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    USART3->CR1 |= USART_CR1_RXNEIE;
 800061a:	60e3      	str	r3, [r4, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USART3_IRQn, 0, 1);
 800061c:	4632      	mov	r2, r6
 800061e:	4629      	mov	r1, r5
 8000620:	f000 fa9e 	bl	8000b60 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_IRQn);
 8000624:	2027      	movs	r0, #39	; 0x27
 8000626:	f000 facf 	bl	8000bc8 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 800062a:	b008      	add	sp, #32
 800062c:	bd70      	pop	{r4, r5, r6, pc}
 800062e:	bf00      	nop
 8000630:	40004400 	.word	0x40004400
 8000634:	40020000 	.word	0x40020000
 8000638:	40004800 	.word	0x40004800
 800063c:	40020400 	.word	0x40020400

08000640 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 8000640:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000642:	f000 fa5f 	bl	8000b04 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8000646:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 800064a:	f000 baec 	b.w	8000c26 <HAL_SYSTICK_IRQHandler>
	...

08000650 <USART2_IRQHandler>:
void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 8000650:	4801      	ldr	r0, [pc, #4]	; (8000658 <USART2_IRQHandler+0x8>)
 8000652:	f002 bb9b 	b.w	8002d8c <HAL_UART_IRQHandler>
 8000656:	bf00      	nop
 8000658:	20000790 	.word	0x20000790

0800065c <USART3_IRQHandler>:
{
	/* USER CODE BEGIN USART3_IRQn 0 */

  /* USER CODE END USART3_IRQn 0 */
  //HAL_UART_IRQHandler(&huart3);
 if (USART3->SR & USART_SR_RXNE) {
 800065c:	4b07      	ldr	r3, [pc, #28]	; (800067c <USART3_IRQHandler+0x20>)
 800065e:	681a      	ldr	r2, [r3, #0]
 8000660:	0692      	lsls	r2, r2, #26
 8000662:	d509      	bpl.n	8000678 <USART3_IRQHandler+0x1c>
	    // —брасываем флаг прерывани€
	    USART3->SR&=~USART_SR_RXNE;
 8000664:	681a      	ldr	r2, [r3, #0]
 8000666:	f022 0220 	bic.w	r2, r2, #32
 800066a:	601a      	str	r2, [r3, #0]
	    UART_Data  = USART3->DR;
 800066c:	685b      	ldr	r3, [r3, #4]
 800066e:	4a04      	ldr	r2, [pc, #16]	; (8000680 <USART3_IRQHandler+0x24>)
 8000670:	b2db      	uxtb	r3, r3
 8000672:	7013      	strb	r3, [r2, #0]
	readRXbuffer();
 8000674:	f006 b910 	b.w	8006898 <readRXbuffer>
 8000678:	4770      	bx	lr
 800067a:	bf00      	nop
 800067c:	40004800 	.word	0x40004800
 8000680:	200020ed 	.word	0x200020ed

08000684 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8000684:	4801      	ldr	r0, [pc, #4]	; (800068c <OTG_FS_IRQHandler+0x8>)
 8000686:	f000 bc67 	b.w	8000f58 <HAL_PCD_IRQHandler>
 800068a:	bf00      	nop
 800068c:	200009f4 	.word	0x200009f4

08000690 <MX_USB_DEVICE_Init>:
/* USB Device Core handle declaration */
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
 8000690:	b510      	push	{r4, lr}
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8000692:	4c09      	ldr	r4, [pc, #36]	; (80006b8 <MX_USB_DEVICE_Init+0x28>)
 8000694:	4909      	ldr	r1, [pc, #36]	; (80006bc <MX_USB_DEVICE_Init+0x2c>)
 8000696:	2200      	movs	r2, #0
 8000698:	4620      	mov	r0, r4
 800069a:	f004 fecf 	bl	800543c <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_MSC);
 800069e:	4908      	ldr	r1, [pc, #32]	; (80006c0 <MX_USB_DEVICE_Init+0x30>)
 80006a0:	4620      	mov	r0, r4
 80006a2:	f004 fee0 	bl	8005466 <USBD_RegisterClass>

  USBD_MSC_RegisterStorage(&hUsbDeviceFS, &USBD_Storage_Interface_fops_FS);
 80006a6:	4620      	mov	r0, r4
 80006a8:	4906      	ldr	r1, [pc, #24]	; (80006c4 <MX_USB_DEVICE_Init+0x34>)
 80006aa:	f005 fac4 	bl	8005c36 <USBD_MSC_RegisterStorage>

  USBD_Start(&hUsbDeviceFS);
 80006ae:	4620      	mov	r0, r4

}
 80006b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_MSC);

  USBD_MSC_RegisterStorage(&hUsbDeviceFS, &USBD_Storage_Interface_fops_FS);

  USBD_Start(&hUsbDeviceFS);
 80006b4:	f004 bede 	b.w	8005474 <USBD_Start>
 80006b8:	200007d0 	.word	0x200007d0
 80006bc:	20000000 	.word	0x20000000
 80006c0:	200000a8 	.word	0x200000a8
 80006c4:	20000034 	.word	0x20000034

080006c8 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 80006c8:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 80006ca:	6803      	ldr	r3, [r0, #0]
 80006cc:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 80006d0:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 80006d2:	d139      	bne.n	8000748 <HAL_PCD_MspInit+0x80>
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = VBUS_FS_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80006d4:	2400      	movs	r4, #0
    PA9     ------> USB_OTG_FS_VBUS
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = VBUS_FS_Pin;
 80006d6:	f44f 7300 	mov.w	r3, #512	; 0x200
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
 80006da:	a901      	add	r1, sp, #4
 80006dc:	481b      	ldr	r0, [pc, #108]	; (800074c <HAL_PCD_MspInit+0x84>)
    PA9     ------> USB_OTG_FS_VBUS
    PA10     ------> USB_OTG_FS_ID
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = VBUS_FS_Pin;
 80006de:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80006e0:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80006e2:	9403      	str	r4, [sp, #12]
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
 80006e4:	f000 fab6 	bl	8000c54 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
 80006e8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80006ec:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80006ee:	2602      	movs	r6, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80006f0:	2303      	movs	r3, #3
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80006f2:	250a      	movs	r5, #10
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80006f4:	a901      	add	r1, sp, #4
 80006f6:	4815      	ldr	r0, [pc, #84]	; (800074c <HAL_PCD_MspInit+0x84>)
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80006f8:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80006fa:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80006fc:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80006fe:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000700:	f000 faa8 	bl	8000c54 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = OTG_FS_DM_Pin|OTG_FS_DP_Pin;
 8000704:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000708:	a901      	add	r1, sp, #4
 800070a:	4810      	ldr	r0, [pc, #64]	; (800074c <HAL_PCD_MspInit+0x84>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = OTG_FS_DM_Pin|OTG_FS_DP_Pin;
 800070c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800070e:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000710:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000712:	9404      	str	r4, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8000714:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000716:	f000 fa9d 	bl	8000c54 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 800071a:	4b0d      	ldr	r3, [pc, #52]	; (8000750 <HAL_PCD_MspInit+0x88>)
 800071c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800071e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000722:	635a      	str	r2, [r3, #52]	; 0x34
 8000724:	9400      	str	r4, [sp, #0]
 8000726:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000728:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800072c:	645a      	str	r2, [r3, #68]	; 0x44
 800072e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000730:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000734:	9300      	str	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 6);
 8000736:	2043      	movs	r0, #67	; 0x43
 8000738:	2206      	movs	r2, #6
 800073a:	4621      	mov	r1, r4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 800073c:	9b00      	ldr	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 6);
 800073e:	f000 fa0f 	bl	8000b60 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8000742:	2043      	movs	r0, #67	; 0x43
 8000744:	f000 fa40 	bl	8000bc8 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8000748:	b006      	add	sp, #24
 800074a:	bd70      	pop	{r4, r5, r6, pc}
 800074c:	40020000 	.word	0x40020000
 8000750:	40023800 	.word	0x40023800

08000754 <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 8000754:	f500 7161 	add.w	r1, r0, #900	; 0x384
 8000758:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 800075c:	f004 bead 	b.w	80054ba <USBD_LL_SetupStage>

08000760 <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8000760:	231c      	movs	r3, #28
 8000762:	fb03 0301 	mla	r3, r3, r1, r0
 8000766:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 800076a:	f8d3 21e8 	ldr.w	r2, [r3, #488]	; 0x1e8
 800076e:	f004 bed1 	b.w	8005514 <USBD_LL_DataOutStage>

08000772 <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8000772:	231c      	movs	r3, #28
 8000774:	fb03 0301 	mla	r3, r3, r1, r0
 8000778:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 800077c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800077e:	f004 befa 	b.w	8005576 <USBD_LL_DataInStage>

08000782 <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF(hpcd->pData);
 8000782:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000786:	f004 bf75 	b.w	8005674 <USBD_LL_SOF>

0800078a <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 800078a:	b510      	push	{r4, lr}
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  /*Set USB Current Speed*/
  switch (hpcd->Init.speed)
 800078c:	68c1      	ldr	r1, [r0, #12]
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 800078e:	4604      	mov	r4, r0
	
  default:
    speed = USBD_SPEED_FULL;    
    break;    
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
 8000790:	3100      	adds	r1, #0
 8000792:	bf18      	it	ne
 8000794:	2101      	movne	r1, #1
 8000796:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 800079a:	f004 ff59 	bl	8005650 <USBD_LL_SetSpeed>
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 800079e:	f8d4 03b4 	ldr.w	r0, [r4, #948]	; 0x3b4
}
 80007a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    break;    
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 80007a6:	f004 bf34 	b.w	8005612 <USBD_LL_Reset>
	...

080007ac <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{  
 80007ac:	b510      	push	{r4, lr}
 80007ae:	4604      	mov	r4, r0
   /* Inform USB library that core enters in suspend Mode */
  USBD_LL_Suspend(hpcd->pData);
 80007b0:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007b4:	f004 ff4f 	bl	8005656 <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 80007b8:	6822      	ldr	r2, [r4, #0]
 80007ba:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 80007be:	f043 0301 	orr.w	r3, r3, #1
 80007c2:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /*Enter in STOP mode */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 80007c6:	6a23      	ldr	r3, [r4, #32]
 80007c8:	b123      	cbz	r3, 80007d4 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 80007ca:	4a03      	ldr	r2, [pc, #12]	; (80007d8 <HAL_PCD_SuspendCallback+0x2c>)
 80007cc:	6913      	ldr	r3, [r2, #16]
 80007ce:	f043 0306 	orr.w	r3, r3, #6
 80007d2:	6113      	str	r3, [r2, #16]
 80007d4:	bd10      	pop	{r4, pc}
 80007d6:	bf00      	nop
 80007d8:	e000ed00 	.word	0xe000ed00

080007dc <HAL_PCD_ResumeCallback>:
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */
  USBD_LL_Resume(hpcd->pData);
 80007dc:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007e0:	f004 bf42 	b.w	8005668 <USBD_LL_Resume>

080007e4 <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
 80007e4:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007e8:	f004 bf52 	b.w	8005690 <USBD_LL_IsoOUTIncomplete>

080007ec <HAL_PCD_ISOINIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
 80007ec:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007f0:	f004 bf4c 	b.w	800568c <USBD_LL_IsoINIncomplete>

080007f4 <HAL_PCD_ConnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevConnected(hpcd->pData);
 80007f4:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80007f8:	f004 bf4c 	b.w	8005694 <USBD_LL_DevConnected>

080007fc <HAL_PCD_DisconnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevDisconnected(hpcd->pData);
 80007fc:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000800:	f004 bf4a 	b.w	8005698 <USBD_LL_DevDisconnected>

08000804 <USBD_LL_Init>:
  * @brief  Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
 8000804:	b508      	push	{r3, lr}
  /* Init USB_IP */
  if (pdev->id == DEVICE_FS) {
 8000806:	7802      	ldrb	r2, [r0, #0]
 8000808:	bb42      	cbnz	r2, 800085c <USBD_LL_Init+0x58>
  /* Link The driver to the stack */	
  hpcd_USB_OTG_FS.pData = pdev;
 800080a:	4b15      	ldr	r3, [pc, #84]	; (8000860 <USBD_LL_Init+0x5c>)
  pdev->pData = &hpcd_USB_OTG_FS; 
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 800080c:	2104      	movs	r1, #4
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  /* Init USB_IP */
  if (pdev->id == DEVICE_FS) {
  /* Link The driver to the stack */	
  hpcd_USB_OTG_FS.pData = pdev;
 800080e:	f8c3 03b4 	str.w	r0, [r3, #948]	; 0x3b4
  pdev->pData = &hpcd_USB_OTG_FS; 
 8000812:	f8c0 3220 	str.w	r3, [r0, #544]	; 0x220
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8000816:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 800081a:	e883 0003 	stmia.w	r3, {r0, r1}
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 800081e:	2102      	movs	r1, #2
 8000820:	60d9      	str	r1, [r3, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8000822:	6199      	str	r1, [r3, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8000824:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8000826:	2101      	movs	r1, #1
  pdev->pData = &hpcd_USB_OTG_FS; 
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8000828:	611a      	str	r2, [r3, #16]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 800082a:	615a      	str	r2, [r3, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 800082c:	61da      	str	r2, [r3, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 800082e:	621a      	str	r2, [r3, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8000830:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 8000832:	62d9      	str	r1, [r3, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8000834:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8000836:	f000 faf5 	bl	8000e24 <HAL_PCD_Init>
 800083a:	b108      	cbz	r0, 8000840 <USBD_LL_Init+0x3c>
  {
    Error_Handler();
 800083c:	f7ff fd42 	bl	80002c4 <Error_Handler>
  }

  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8000840:	2180      	movs	r1, #128	; 0x80
 8000842:	4807      	ldr	r0, [pc, #28]	; (8000860 <USBD_LL_Init+0x5c>)
 8000844:	f000 ff81 	bl	800174a <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8000848:	2240      	movs	r2, #64	; 0x40
 800084a:	2100      	movs	r1, #0
 800084c:	4804      	ldr	r0, [pc, #16]	; (8000860 <USBD_LL_Init+0x5c>)
 800084e:	f000 ff5b 	bl	8001708 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8000852:	2280      	movs	r2, #128	; 0x80
 8000854:	2101      	movs	r1, #1
 8000856:	4802      	ldr	r0, [pc, #8]	; (8000860 <USBD_LL_Init+0x5c>)
 8000858:	f000 ff56 	bl	8001708 <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
}
 800085c:	2000      	movs	r0, #0
 800085e:	bd08      	pop	{r3, pc}
 8000860:	200009f4 	.word	0x200009f4

08000864 <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8000864:	b508      	push	{r3, lr}
  HAL_PCD_Start(pdev->pData);
 8000866:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800086a:	f000 fb47 	bl	8000efc <HAL_PCD_Start>
  return USBD_OK; 
}
 800086e:	2000      	movs	r0, #0
 8000870:	bd08      	pop	{r3, pc}

08000872 <USBD_LL_Stop>:
  * @brief  Stops the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Stop (USBD_HandleTypeDef *pdev)
{
 8000872:	b508      	push	{r3, lr}
  HAL_PCD_Stop(pdev->pData);
 8000874:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000878:	f000 fb55 	bl	8000f26 <HAL_PCD_Stop>
  return USBD_OK; 
}
 800087c:	2000      	movs	r0, #0
 800087e:	bd08      	pop	{r3, pc}

08000880 <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
 8000880:	b510      	push	{r4, lr}
 8000882:	461c      	mov	r4, r3

  HAL_PCD_EP_Open(pdev->pData, 
 8000884:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000888:	4613      	mov	r3, r2
 800088a:	4622      	mov	r2, r4
 800088c:	f000 fe1a 	bl	80014c4 <HAL_PCD_EP_Open>
                  ep_addr, 
                  ep_mps, 
                  ep_type);
  
  return USBD_OK; 
}
 8000890:	2000      	movs	r0, #0
 8000892:	bd10      	pop	{r4, pc}

08000894 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8000894:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8000896:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800089a:	f000 fe41 	bl	8001520 <HAL_PCD_EP_Close>
  return USBD_OK; 
}
 800089e:	2000      	movs	r0, #0
 80008a0:	bd08      	pop	{r3, pc}

080008a2 <USBD_LL_FlushEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_FlushEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 80008a2:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_Flush(pdev->pData, ep_addr);
 80008a4:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008a8:	f000 ff14 	bl	80016d4 <HAL_PCD_EP_Flush>
  return USBD_OK; 
}
 80008ac:	2000      	movs	r0, #0
 80008ae:	bd08      	pop	{r3, pc}

080008b0 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 80008b0:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 80008b2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008b6:	f000 febc 	bl	8001632 <HAL_PCD_EP_SetStall>
  return USBD_OK; 
}
 80008ba:	2000      	movs	r0, #0
 80008bc:	bd08      	pop	{r3, pc}

080008be <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 80008be:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 80008c0:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008c4:	f000 fee1 	bl	800168a <HAL_PCD_EP_ClrStall>
  return USBD_OK; 
}
 80008c8:	2000      	movs	r0, #0
 80008ca:	bd08      	pop	{r3, pc}

080008cc <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
  
  if((ep_addr & 0x80) == 0x80)
 80008cc:	f011 0f80 	tst.w	r1, #128	; 0x80
  * @param  ep_addr: Endpoint Number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
 80008d0:	f8d0 2220 	ldr.w	r2, [r0, #544]	; 0x220
  
  if((ep_addr & 0x80) == 0x80)
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 80008d4:	bf18      	it	ne
 80008d6:	f001 037f 	andne.w	r3, r1, #127	; 0x7f
 80008da:	f04f 001c 	mov.w	r0, #28
 80008de:	bf15      	itete	ne
 80008e0:	fb00 2103 	mlane	r1, r0, r3, r2
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 80008e4:	fb00 2101 	mlaeq	r1, r0, r1, r2
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
  
  if((ep_addr & 0x80) == 0x80)
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 80008e8:	f891 003a 	ldrbne.w	r0, [r1, #58]	; 0x3a
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 80008ec:	f891 01de 	ldrbeq.w	r0, [r1, #478]	; 0x1de
  }
}
 80008f0:	4770      	bx	lr

080008f2 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
 80008f2:	b508      	push	{r3, lr}
  
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 80008f4:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80008f8:	f000 fdd2 	bl	80014a0 <HAL_PCD_SetAddress>
  return USBD_OK; 
}
 80008fc:	2000      	movs	r0, #0
 80008fe:	bd08      	pop	{r3, pc}

08000900 <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
 8000900:	b508      	push	{r3, lr}

  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8000902:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000906:	f000 fe67 	bl	80015d8 <HAL_PCD_EP_Transmit>
  return USBD_OK;   
}
 800090a:	2000      	movs	r0, #0
 800090c:	bd08      	pop	{r3, pc}

0800090e <USBD_LL_PrepareReceive>:
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,                                      
                                           uint8_t  *pbuf,
                                           uint16_t  size)
{
 800090e:	b508      	push	{r3, lr}

  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8000910:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000914:	f000 fe27 	bl	8001566 <HAL_PCD_EP_Receive>
  return USBD_OK;   
}
 8000918:	2000      	movs	r0, #0
 800091a:	bd08      	pop	{r3, pc}

0800091c <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr)  
{
 800091c:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
 800091e:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000922:	f000 fe51 	bl	80015c8 <HAL_PCD_EP_GetRxCount>
}
 8000926:	bd08      	pop	{r3, pc}

08000928 <USBD_FS_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_DeviceDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 8000928:	2312      	movs	r3, #18
 800092a:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 800092c:	4800      	ldr	r0, [pc, #0]	; (8000930 <USBD_FS_DeviceDescriptor+0x8>)
 800092e:	4770      	bx	lr
 8000930:	20000020 	.word	0x20000020

08000934 <USBD_FS_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_LangIDStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 8000934:	2304      	movs	r3, #4
 8000936:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8000938:	4800      	ldr	r0, [pc, #0]	; (800093c <USBD_FS_LangIDStrDescriptor+0x8>)
 800093a:	4770      	bx	lr
 800093c:	2000001c 	.word	0x2000001c

08000940 <USBD_FS_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000940:	b510      	push	{r4, lr}
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8000942:	4c04      	ldr	r4, [pc, #16]	; (8000954 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 8000944:	4804      	ldr	r0, [pc, #16]	; (8000958 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 8000946:	460a      	mov	r2, r1
 8000948:	4621      	mov	r1, r4
 800094a:	f005 f85a 	bl	8005a02 <USBD_GetString>
  return USBD_StrDesc;
}
 800094e:	4620      	mov	r0, r4
 8000950:	bd10      	pop	{r4, pc}
 8000952:	bf00      	nop
 8000954:	20000dac 	.word	0x20000dac
 8000958:	08007134 	.word	0x08007134

0800095c <USBD_FS_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ProductStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 800095c:	b510      	push	{r4, lr}
  if(speed == 0)
  {   
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 800095e:	4c04      	ldr	r4, [pc, #16]	; (8000970 <USBD_FS_ProductStrDescriptor+0x14>)
 8000960:	4804      	ldr	r0, [pc, #16]	; (8000974 <USBD_FS_ProductStrDescriptor+0x18>)
 8000962:	460a      	mov	r2, r1
 8000964:	4621      	mov	r1, r4
 8000966:	f005 f84c 	bl	8005a02 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 800096a:	4620      	mov	r0, r4
 800096c:	bd10      	pop	{r4, pc}
 800096e:	bf00      	nop
 8000970:	20000dac 	.word	0x20000dac
 8000974:	08007147 	.word	0x08007147

08000978 <USBD_FS_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000978:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {    
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 800097a:	4c04      	ldr	r4, [pc, #16]	; (800098c <USBD_FS_SerialStrDescriptor+0x14>)
 800097c:	4804      	ldr	r0, [pc, #16]	; (8000990 <USBD_FS_SerialStrDescriptor+0x18>)
 800097e:	460a      	mov	r2, r1
 8000980:	4621      	mov	r1, r4
 8000982:	f005 f83e 	bl	8005a02 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 8000986:	4620      	mov	r0, r4
 8000988:	bd10      	pop	{r4, pc}
 800098a:	bf00      	nop
 800098c:	20000dac 	.word	0x20000dac
 8000990:	0800715a 	.word	0x0800715a

08000994 <USBD_FS_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ConfigStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000994:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {  
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8000996:	4c04      	ldr	r4, [pc, #16]	; (80009a8 <USBD_FS_ConfigStrDescriptor+0x14>)
 8000998:	4804      	ldr	r0, [pc, #16]	; (80009ac <USBD_FS_ConfigStrDescriptor+0x18>)
 800099a:	460a      	mov	r2, r1
 800099c:	4621      	mov	r1, r4
 800099e:	f005 f830 	bl	8005a02 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length); 
  }
  return USBD_StrDesc;  
}
 80009a2:	4620      	mov	r0, r4
 80009a4:	bd10      	pop	{r4, pc}
 80009a6:	bf00      	nop
 80009a8:	20000dac 	.word	0x20000dac
 80009ac:	08007167 	.word	0x08007167

080009b0 <USBD_FS_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_InterfaceStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80009b0:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80009b2:	4c04      	ldr	r4, [pc, #16]	; (80009c4 <USBD_FS_InterfaceStrDescriptor+0x14>)
 80009b4:	4804      	ldr	r0, [pc, #16]	; (80009c8 <USBD_FS_InterfaceStrDescriptor+0x18>)
 80009b6:	460a      	mov	r2, r1
 80009b8:	4621      	mov	r1, r4
 80009ba:	f005 f822 	bl	8005a02 <USBD_GetString>
  else
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;  
}
 80009be:	4620      	mov	r0, r4
 80009c0:	bd10      	pop	{r4, pc}
 80009c2:	bf00      	nop
 80009c4:	20000dac 	.word	0x20000dac
 80009c8:	08007172 	.word	0x08007172

080009cc <STORAGE_IsWriteProtected_FS>:
int8_t  STORAGE_IsWriteProtected_FS (uint8_t lun)
{
  /* USER CODE BEGIN 5 */ 
  return (USBD_OK);
  /* USER CODE END 5 */ 
}
 80009cc:	2000      	movs	r0, #0
 80009ce:	4770      	bx	lr

080009d0 <STORAGE_GetMaxLun_FS>:
int8_t STORAGE_GetMaxLun_FS (void)
{
  /* USER CODE BEGIN 8 */ 
  return (STORAGE_LUN_NBR - 1);
  /* USER CODE END 8 */ 
}
 80009d0:	2000      	movs	r0, #0
 80009d2:	4770      	bx	lr

080009d4 <STORAGE_Write_FS>:
*******************************************************************************/
int8_t STORAGE_Write_FS (uint8_t lun, 
                         uint8_t *buf, 
                         uint32_t blk_addr,
                         uint16_t blk_len)
{
 80009d4:	b513      	push	{r0, r1, r4, lr}
  /* USER CODE BEGIN 7 */ 
	 HAL_SD_WriteBlocks(&hsd, (uint32_t*)buf, (uint64_t)(blk_addr * BLOCK_SIZE), BLOCK_SIZE, blk_len);
 80009d6:	2400      	movs	r4, #0
 80009d8:	9301      	str	r3, [sp, #4]
 80009da:	f44f 7300 	mov.w	r3, #512	; 0x200
 80009de:	9300      	str	r3, [sp, #0]
 80009e0:	0252      	lsls	r2, r2, #9
 80009e2:	4623      	mov	r3, r4
 80009e4:	4802      	ldr	r0, [pc, #8]	; (80009f0 <STORAGE_Write_FS+0x1c>)
 80009e6:	f001 fe54 	bl	8002692 <HAL_SD_WriteBlocks>
  return (USBD_OK);
  /* USER CODE END 7 */ 
}
 80009ea:	4620      	mov	r0, r4
 80009ec:	b002      	add	sp, #8
 80009ee:	bd10      	pop	{r4, pc}
 80009f0:	20000730 	.word	0x20000730

080009f4 <STORAGE_Read_FS>:
*******************************************************************************/
int8_t STORAGE_Read_FS (uint8_t lun, 
                        uint8_t *buf, 
                        uint32_t blk_addr,                       
                        uint16_t blk_len)
{
 80009f4:	b513      	push	{r0, r1, r4, lr}
  /* USER CODE BEGIN 6 */ 
	 HAL_SD_ReadBlocks(&hsd, (uint32_t*)buf, (uint64_t)(blk_addr * BLOCK_SIZE), BLOCK_SIZE, blk_len);
 80009f6:	2400      	movs	r4, #0
 80009f8:	9301      	str	r3, [sp, #4]
 80009fa:	f44f 7300 	mov.w	r3, #512	; 0x200
 80009fe:	9300      	str	r3, [sp, #0]
 8000a00:	0252      	lsls	r2, r2, #9
 8000a02:	4623      	mov	r3, r4
 8000a04:	4802      	ldr	r0, [pc, #8]	; (8000a10 <STORAGE_Read_FS+0x1c>)
 8000a06:	f001 fd82 	bl	800250e <HAL_SD_ReadBlocks>
  return (USBD_OK);
  /* USER CODE END 6 */ 
}
 8000a0a:	4620      	mov	r0, r4
 8000a0c:	b002      	add	sp, #8
 8000a0e:	bd10      	pop	{r4, pc}
 8000a10:	20000730 	.word	0x20000730

08000a14 <STORAGE_IsReady_FS>:
* @brief  Checks whether the medium is ready.
  * @param  lun: Logical unit number
  * @retval Status (0: OK / -1: Error)
*******************************************************************************/
int8_t  STORAGE_IsReady_FS (uint8_t lun)
{
 8000a14:	b508      	push	{r3, lr}
  /* USER CODE BEGIN 4 */
	if(HAL_SD_GetCardStatus(&hsd,&SDCardInfo)==SD_TRANSFER_OK)
 8000a16:	4902      	ldr	r1, [pc, #8]	; (8000a20 <STORAGE_IsReady_FS+0xc>)
 8000a18:	4802      	ldr	r0, [pc, #8]	; (8000a24 <STORAGE_IsReady_FS+0x10>)
 8000a1a:	f001 ffe3 	bl	80029e4 <HAL_SD_GetCardStatus>
	{
      return (USBD_OK);
	}
  /* USER CODE END 4 */ 
}
 8000a1e:	bd08      	pop	{r3, pc}
 8000a20:	200006d8 	.word	0x200006d8
 8000a24:	20000730 	.word	0x20000730

08000a28 <STORAGE_GetCapacity_FS>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t STORAGE_GetCapacity_FS (uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
 8000a28:	b570      	push	{r4, r5, r6, lr}
  /* USER CODE BEGIN 3 */   
	HAL_SD_Get_CardInfo(&hsd, &SDCardInfo);
 8000a2a:	4c09      	ldr	r4, [pc, #36]	; (8000a50 <STORAGE_GetCapacity_FS+0x28>)
 8000a2c:	4809      	ldr	r0, [pc, #36]	; (8000a54 <STORAGE_GetCapacity_FS+0x2c>)
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t STORAGE_GetCapacity_FS (uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
 8000a2e:	460e      	mov	r6, r1
  /* USER CODE BEGIN 3 */   
	HAL_SD_Get_CardInfo(&hsd, &SDCardInfo);
 8000a30:	4621      	mov	r1, r4
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t STORAGE_GetCapacity_FS (uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
 8000a32:	4615      	mov	r5, r2
  /* USER CODE BEGIN 3 */   
	HAL_SD_Get_CardInfo(&hsd, &SDCardInfo);
 8000a34:	f001 fa4c 	bl	8001ed0 <HAL_SD_Get_CardInfo>
	  *block_num  = SDCardInfo.CardCapacity / BLOCK_SIZE;
 8000a38:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000a3a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8000a3c:	0a5b      	lsrs	r3, r3, #9
 8000a3e:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 8000a42:	6033      	str	r3, [r6, #0]
	  *block_size = BLOCK_SIZE;
 8000a44:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000a48:	802b      	strh	r3, [r5, #0]
  return (USBD_OK);
  /* USER CODE END 3 */ 
}
 8000a4a:	2000      	movs	r0, #0
 8000a4c:	bd70      	pop	{r4, r5, r6, pc}
 8000a4e:	bf00      	nop
 8000a50:	200006d8 	.word	0x200006d8
 8000a54:	20000730 	.word	0x20000730

08000a58 <STORAGE_Init_FS>:
 8000a58:	2000      	movs	r0, #0
 8000a5a:	4770      	bx	lr

08000a5c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000a5c:	490f      	ldr	r1, [pc, #60]	; (8000a9c <SystemInit+0x40>)
 8000a5e:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8000a62:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000a66:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000a6a:	4b0d      	ldr	r3, [pc, #52]	; (8000aa0 <SystemInit+0x44>)
 8000a6c:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000a6e:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000a70:	f042 0201 	orr.w	r2, r2, #1
 8000a74:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000a76:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000a78:	681a      	ldr	r2, [r3, #0]
 8000a7a:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000a7e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000a82:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000a84:	4a07      	ldr	r2, [pc, #28]	; (8000aa4 <SystemInit+0x48>)
 8000a86:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000a88:	681a      	ldr	r2, [r3, #0]
 8000a8a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000a8e:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000a90:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8000a92:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000a96:	608b      	str	r3, [r1, #8]
 8000a98:	4770      	bx	lr
 8000a9a:	bf00      	nop
 8000a9c:	e000ed00 	.word	0xe000ed00
 8000aa0:	40023800 	.word	0x40023800
 8000aa4:	24003010 	.word	0x24003010

08000aa8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000aa8:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8000aaa:	4b08      	ldr	r3, [pc, #32]	; (8000acc <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000aac:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8000aae:	6818      	ldr	r0, [r3, #0]
 8000ab0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000ab4:	fbb0 f0f3 	udiv	r0, r0, r3
 8000ab8:	f000 f892 	bl	8000be0 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8000abc:	2200      	movs	r2, #0
 8000abe:	4621      	mov	r1, r4
 8000ac0:	f04f 30ff 	mov.w	r0, #4294967295
 8000ac4:	f000 f84c 	bl	8000b60 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000ac8:	2000      	movs	r0, #0
 8000aca:	bd10      	pop	{r4, pc}
 8000acc:	20000054 	.word	0x20000054

08000ad0 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000ad0:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8000ad2:	4b0b      	ldr	r3, [pc, #44]	; (8000b00 <HAL_Init+0x30>)
 8000ad4:	681a      	ldr	r2, [r3, #0]
 8000ad6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000ada:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 8000adc:	681a      	ldr	r2, [r3, #0]
 8000ade:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000ae2:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000ae4:	681a      	ldr	r2, [r3, #0]
 8000ae6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000aea:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000aec:	2003      	movs	r0, #3
 8000aee:	f000 f825 	bl	8000b3c <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000af2:	2000      	movs	r0, #0
 8000af4:	f7ff ffd8 	bl	8000aa8 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 8000af8:	f7ff fd02 	bl	8000500 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 8000afc:	2000      	movs	r0, #0
 8000afe:	bd08      	pop	{r3, pc}
 8000b00:	40023c00 	.word	0x40023c00

08000b04 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000b04:	4a02      	ldr	r2, [pc, #8]	; (8000b10 <HAL_IncTick+0xc>)
 8000b06:	6813      	ldr	r3, [r2, #0]
 8000b08:	3301      	adds	r3, #1
 8000b0a:	6013      	str	r3, [r2, #0]
 8000b0c:	4770      	bx	lr
 8000b0e:	bf00      	nop
 8000b10:	20000fac 	.word	0x20000fac

08000b14 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000b14:	4b01      	ldr	r3, [pc, #4]	; (8000b1c <HAL_GetTick+0x8>)
 8000b16:	6818      	ldr	r0, [r3, #0]
}
 8000b18:	4770      	bx	lr
 8000b1a:	bf00      	nop
 8000b1c:	20000fac 	.word	0x20000fac

08000b20 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8000b20:	b513      	push	{r0, r1, r4, lr}
 8000b22:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0U;
  tickstart = HAL_GetTick();
 8000b24:	f7ff fff6 	bl	8000b14 <HAL_GetTick>
 8000b28:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8000b2a:	f7ff fff3 	bl	8000b14 <HAL_GetTick>
 8000b2e:	9b01      	ldr	r3, [sp, #4]
 8000b30:	1b00      	subs	r0, r0, r4
 8000b32:	4298      	cmp	r0, r3
 8000b34:	d3f9      	bcc.n	8000b2a <HAL_Delay+0xa>
  {
  }
}
 8000b36:	b002      	add	sp, #8
 8000b38:	bd10      	pop	{r4, pc}
	...

08000b3c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000b3c:	4a07      	ldr	r2, [pc, #28]	; (8000b5c <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000b3e:	68d3      	ldr	r3, [r2, #12]
 8000b40:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000b44:	041b      	lsls	r3, r3, #16
 8000b46:	0c1b      	lsrs	r3, r3, #16
 8000b48:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000b4c:	0200      	lsls	r0, r0, #8
 8000b4e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000b52:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8000b56:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000b58:	60d3      	str	r3, [r2, #12]
 8000b5a:	4770      	bx	lr
 8000b5c:	e000ed00 	.word	0xe000ed00

08000b60 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000b60:	4b17      	ldr	r3, [pc, #92]	; (8000bc0 <HAL_NVIC_SetPriority+0x60>)
 8000b62:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000b64:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000b68:	b530      	push	{r4, r5, lr}
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000b6a:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000b6e:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000b70:	2c04      	cmp	r4, #4
 8000b72:	bf28      	it	cs
 8000b74:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000b76:	2d06      	cmp	r5, #6

  return (
 8000b78:	f04f 0501 	mov.w	r5, #1
 8000b7c:	fa05 f404 	lsl.w	r4, r5, r4
 8000b80:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000b84:	bf8c      	ite	hi
 8000b86:	3b03      	subhi	r3, #3
 8000b88:	2300      	movls	r3, #0

  return (
 8000b8a:	400c      	ands	r4, r1
 8000b8c:	409c      	lsls	r4, r3
 8000b8e:	fa05 f303 	lsl.w	r3, r5, r3
 8000b92:	3b01      	subs	r3, #1
 8000b94:	401a      	ands	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000b96:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000b98:	ea42 0204 	orr.w	r2, r2, r4
 8000b9c:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ba0:	bfaf      	iteee	ge
 8000ba2:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ba6:	f000 000f 	andlt.w	r0, r0, #15
 8000baa:	4b06      	ldrlt	r3, [pc, #24]	; (8000bc4 <HAL_NVIC_SetPriority+0x64>)
 8000bac:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bae:	bfa5      	ittet	ge
 8000bb0:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8000bb4:	b2d2      	uxtbge	r2, r2
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bb6:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bb8:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8000bbc:	bd30      	pop	{r4, r5, pc}
 8000bbe:	bf00      	nop
 8000bc0:	e000ed00 	.word	0xe000ed00
 8000bc4:	e000ed14 	.word	0xe000ed14

08000bc8 <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000bc8:	0942      	lsrs	r2, r0, #5
 8000bca:	2301      	movs	r3, #1
 8000bcc:	f000 001f 	and.w	r0, r0, #31
 8000bd0:	fa03 f000 	lsl.w	r0, r3, r0
 8000bd4:	4b01      	ldr	r3, [pc, #4]	; (8000bdc <HAL_NVIC_EnableIRQ+0x14>)
 8000bd6:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8000bda:	4770      	bx	lr
 8000bdc:	e000e100 	.word	0xe000e100

08000be0 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000be0:	3801      	subs	r0, #1
 8000be2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000be6:	d20a      	bcs.n	8000bfe <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000be8:	4b06      	ldr	r3, [pc, #24]	; (8000c04 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bea:	4a07      	ldr	r2, [pc, #28]	; (8000c08 <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000bec:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bee:	21f0      	movs	r1, #240	; 0xf0
 8000bf0:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000bf4:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000bf6:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000bf8:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000bfa:	601a      	str	r2, [r3, #0]
 8000bfc:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8000bfe:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000c00:	4770      	bx	lr
 8000c02:	bf00      	nop
 8000c04:	e000e010 	.word	0xe000e010
 8000c08:	e000ed00 	.word	0xe000ed00

08000c0c <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8000c0c:	4b04      	ldr	r3, [pc, #16]	; (8000c20 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000c0e:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000c10:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000c12:	bf0c      	ite	eq
 8000c14:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000c18:	f022 0204 	bicne.w	r2, r2, #4
 8000c1c:	601a      	str	r2, [r3, #0]
 8000c1e:	4770      	bx	lr
 8000c20:	e000e010 	.word	0xe000e010

08000c24 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000c24:	4770      	bx	lr

08000c26 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8000c26:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8000c28:	f7ff fffc 	bl	8000c24 <HAL_SYSTICK_Callback>
 8000c2c:	bd08      	pop	{r3, pc}

08000c2e <HAL_DMA_Abort_IT>:
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8000c2e:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8000c32:	2b02      	cmp	r3, #2
 8000c34:	d003      	beq.n	8000c3e <HAL_DMA_Abort_IT+0x10>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000c36:	2380      	movs	r3, #128	; 0x80
 8000c38:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8000c3a:	2001      	movs	r0, #1
 8000c3c:	4770      	bx	lr
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8000c3e:	6802      	ldr	r2, [r0, #0]
    return HAL_ERROR;
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 8000c40:	2305      	movs	r3, #5
 8000c42:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8000c46:	6813      	ldr	r3, [r2, #0]
 8000c48:	f023 0301 	bic.w	r3, r3, #1
 8000c4c:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8000c4e:	2000      	movs	r0, #0
}
 8000c50:	4770      	bx	lr
	...

08000c54 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000c54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000c58:	4f6a      	ldr	r7, [pc, #424]	; (8000e04 <HAL_GPIO_Init+0x1b0>)
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000c5a:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c5c:	f8df c1ac 	ldr.w	ip, [pc, #428]	; 8000e0c <HAL_GPIO_Init+0x1b8>

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000c60:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 8000e10 <HAL_GPIO_Init+0x1bc>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000c64:	b085      	sub	sp, #20
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000c66:	2200      	movs	r2, #0
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000c68:	9301      	str	r3, [sp, #4]
 8000c6a:	46be      	mov	lr, r7

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8000c6c:	2401      	movs	r4, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8000c6e:	9b01      	ldr	r3, [sp, #4]

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8000c70:	4094      	lsls	r4, r2
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8000c72:	ea34 0303 	bics.w	r3, r4, r3
 8000c76:	f040 80bd 	bne.w	8000df4 <HAL_GPIO_Init+0x1a0>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000c7a:	684d      	ldr	r5, [r1, #4]
 8000c7c:	f025 0a10 	bic.w	sl, r5, #16
 8000c80:	f1ba 0f02 	cmp.w	sl, #2
 8000c84:	d114      	bne.n	8000cb0 <HAL_GPIO_Init+0x5c>
 8000c86:	ea4f 09d2 	mov.w	r9, r2, lsr #3
 8000c8a:	eb00 0989 	add.w	r9, r0, r9, lsl #2
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8000c8e:	f002 0b07 	and.w	fp, r2, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8000c92:	f8d9 6020 	ldr.w	r6, [r9, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8000c96:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8000c9a:	230f      	movs	r3, #15
 8000c9c:	fa03 f30b 	lsl.w	r3, r3, fp
 8000ca0:	ea26 0603 	bic.w	r6, r6, r3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 8000ca4:	690b      	ldr	r3, [r1, #16]
 8000ca6:	fa03 f30b 	lsl.w	r3, r3, fp
 8000caa:	4333      	orrs	r3, r6
        GPIOx->AFR[position >> 3U] = temp;
 8000cac:	f8c9 3020 	str.w	r3, [r9, #32]
 8000cb0:	ea4f 0b42 	mov.w	fp, r2, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000cb4:	f04f 0903 	mov.w	r9, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8000cb8:	6803      	ldr	r3, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000cba:	fa09 f90b 	lsl.w	r9, r9, fp
 8000cbe:	ea6f 0909 	mvn.w	r9, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000cc2:	f005 0603 	and.w	r6, r5, #3
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000cc6:	ea03 0309 	and.w	r3, r3, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000cca:	fa06 f60b 	lsl.w	r6, r6, fp
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000cce:	f10a 3aff 	add.w	sl, sl, #4294967295
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000cd2:	4333      	orrs	r3, r6
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000cd4:	f1ba 0f01 	cmp.w	sl, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;
 8000cd8:	6003      	str	r3, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000cda:	d80f      	bhi.n	8000cfc <HAL_GPIO_Init+0xa8>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8000cdc:	6883      	ldr	r3, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000cde:	68ce      	ldr	r6, [r1, #12]
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000ce0:	ea09 0303 	and.w	r3, r9, r3
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000ce4:	fa06 f60b 	lsl.w	r6, r6, fp
 8000ce8:	431e      	orrs	r6, r3
        GPIOx->OSPEEDR = temp;
 8000cea:	6086      	str	r6, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000cec:	6843      	ldr	r3, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000cee:	f3c5 1600 	ubfx	r6, r5, #4, #1
        temp |= (GPIO_Init->Speed << (position * 2U));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000cf2:	ea23 0304 	bic.w	r3, r3, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8000cf6:	4096      	lsls	r6, r2
 8000cf8:	4333      	orrs	r3, r6
        GPIOx->OTYPER = temp;
 8000cfa:	6043      	str	r3, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000cfc:	68c3      	ldr	r3, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8000cfe:	ea09 0903 	and.w	r9, r9, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000d02:	688b      	ldr	r3, [r1, #8]
 8000d04:	fa03 f30b 	lsl.w	r3, r3, fp
 8000d08:	ea43 0309 	orr.w	r3, r3, r9
      GPIOx->PUPDR = temp;
 8000d0c:	60c3      	str	r3, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000d0e:	00eb      	lsls	r3, r5, #3
 8000d10:	d570      	bpl.n	8000df4 <HAL_GPIO_Init+0x1a0>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d12:	2300      	movs	r3, #0
 8000d14:	9303      	str	r3, [sp, #12]
 8000d16:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000d1a:	4b3b      	ldr	r3, [pc, #236]	; (8000e08 <HAL_GPIO_Init+0x1b4>)
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d1c:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
 8000d20:	f8cc 6044 	str.w	r6, [ip, #68]	; 0x44
 8000d24:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44
 8000d28:	f022 0903 	bic.w	r9, r2, #3
 8000d2c:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
 8000d30:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8000d34:	f509 399c 	add.w	r9, r9, #79872	; 0x13800
 8000d38:	9603      	str	r6, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8000d3a:	f002 0a03 	and.w	sl, r2, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d3e:	9e03      	ldr	r6, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8000d40:	f8d9 b008 	ldr.w	fp, [r9, #8]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8000d44:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8000d48:	260f      	movs	r6, #15
 8000d4a:	fa06 f60a 	lsl.w	r6, r6, sl
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000d4e:	4298      	cmp	r0, r3
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8000d50:	ea2b 0606 	bic.w	r6, fp, r6
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000d54:	d01c      	beq.n	8000d90 <HAL_GPIO_Init+0x13c>
 8000d56:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000d5a:	4298      	cmp	r0, r3
 8000d5c:	d01a      	beq.n	8000d94 <HAL_GPIO_Init+0x140>
 8000d5e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000d62:	4298      	cmp	r0, r3
 8000d64:	d018      	beq.n	8000d98 <HAL_GPIO_Init+0x144>
 8000d66:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000d6a:	4298      	cmp	r0, r3
 8000d6c:	d016      	beq.n	8000d9c <HAL_GPIO_Init+0x148>
 8000d6e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000d72:	4298      	cmp	r0, r3
 8000d74:	d014      	beq.n	8000da0 <HAL_GPIO_Init+0x14c>
 8000d76:	4540      	cmp	r0, r8
 8000d78:	d014      	beq.n	8000da4 <HAL_GPIO_Init+0x150>
 8000d7a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8000d7e:	4298      	cmp	r0, r3
 8000d80:	d012      	beq.n	8000da8 <HAL_GPIO_Init+0x154>
 8000d82:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8000d86:	4298      	cmp	r0, r3
 8000d88:	bf14      	ite	ne
 8000d8a:	2308      	movne	r3, #8
 8000d8c:	2307      	moveq	r3, #7
 8000d8e:	e00c      	b.n	8000daa <HAL_GPIO_Init+0x156>
 8000d90:	2300      	movs	r3, #0
 8000d92:	e00a      	b.n	8000daa <HAL_GPIO_Init+0x156>
 8000d94:	2301      	movs	r3, #1
 8000d96:	e008      	b.n	8000daa <HAL_GPIO_Init+0x156>
 8000d98:	2302      	movs	r3, #2
 8000d9a:	e006      	b.n	8000daa <HAL_GPIO_Init+0x156>
 8000d9c:	2303      	movs	r3, #3
 8000d9e:	e004      	b.n	8000daa <HAL_GPIO_Init+0x156>
 8000da0:	2304      	movs	r3, #4
 8000da2:	e002      	b.n	8000daa <HAL_GPIO_Init+0x156>
 8000da4:	2305      	movs	r3, #5
 8000da6:	e000      	b.n	8000daa <HAL_GPIO_Init+0x156>
 8000da8:	2306      	movs	r3, #6
 8000daa:	fa03 f30a 	lsl.w	r3, r3, sl
 8000dae:	4333      	orrs	r3, r6
        SYSCFG->EXTICR[position >> 2U] = temp;
 8000db0:	f8c9 3008 	str.w	r3, [r9, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000db4:	683b      	ldr	r3, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 8000db6:	43e6      	mvns	r6, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000db8:	f415 3f80 	tst.w	r5, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8000dbc:	bf0c      	ite	eq
 8000dbe:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8000dc0:	4323      	orrne	r3, r4
        }
        EXTI->IMR = temp;
 8000dc2:	f8ce 3000 	str.w	r3, [lr]

        temp = EXTI->EMR;
 8000dc6:	f8de 3004 	ldr.w	r3, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000dca:	f415 3f00 	tst.w	r5, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 8000dce:	bf0c      	ite	eq
 8000dd0:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8000dd2:	4323      	orrne	r3, r4
        }
        EXTI->EMR = temp;
 8000dd4:	607b      	str	r3, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000dd6:	68bb      	ldr	r3, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000dd8:	f415 1f80 	tst.w	r5, #1048576	; 0x100000
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 8000ddc:	bf0c      	ite	eq
 8000dde:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8000de0:	4323      	orrne	r3, r4
        }
        EXTI->RTSR = temp;
 8000de2:	f8ce 3008 	str.w	r3, [lr, #8]

        temp = EXTI->FTSR;
 8000de6:	f8de 300c 	ldr.w	r3, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000dea:	02ad      	lsls	r5, r5, #10
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 8000dec:	bf54      	ite	pl
 8000dee:	4033      	andpl	r3, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8000df0:	4323      	orrmi	r3, r4
        }
        EXTI->FTSR = temp;
 8000df2:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000df4:	3201      	adds	r2, #1
 8000df6:	2a10      	cmp	r2, #16
 8000df8:	f47f af38 	bne.w	8000c6c <HAL_GPIO_Init+0x18>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8000dfc:	b005      	add	sp, #20
 8000dfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000e02:	bf00      	nop
 8000e04:	40013c00 	.word	0x40013c00
 8000e08:	40020000 	.word	0x40020000
 8000e0c:	40023800 	.word	0x40023800
 8000e10:	40021400 	.word	0x40021400

08000e14 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000e14:	b902      	cbnz	r2, 8000e18 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8000e16:	0409      	lsls	r1, r1, #16
 8000e18:	6181      	str	r1, [r0, #24]
 8000e1a:	4770      	bx	lr

08000e1c <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8000e1c:	6943      	ldr	r3, [r0, #20]
 8000e1e:	4059      	eors	r1, r3
 8000e20:	6141      	str	r1, [r0, #20]
 8000e22:	4770      	bx	lr

08000e24 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8000e24:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8000e26:	4606      	mov	r6, r0
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8000e28:	b08b      	sub	sp, #44	; 0x2c
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8000e2a:	2800      	cmp	r0, #0
 8000e2c:	d063      	beq.n	8000ef6 <HAL_PCD_Init+0xd2>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8000e2e:	2303      	movs	r3, #3
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8000e30:	4634      	mov	r4, r6
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8000e32:	f880 3381 	strb.w	r3, [r0, #897]	; 0x381
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);
 8000e36:	f7ff fc47 	bl	80006c8 <HAL_PCD_MspInit>

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8000e3a:	f854 0b10 	ldr.w	r0, [r4], #16
 8000e3e:	f002 f8ea 	bl	8003016 <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8000e42:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000e44:	466d      	mov	r5, sp
 8000e46:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000e48:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000e4a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000e4c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8000e50:	e885 0003 	stmia.w	r5, {r0, r1}
 8000e54:	1d37      	adds	r7, r6, #4
 8000e56:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8000e5a:	6830      	ldr	r0, [r6, #0]
 8000e5c:	f002 f89f 	bl	8002f9e <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8000e60:	2100      	movs	r1, #0
 8000e62:	6830      	ldr	r0, [r6, #0]
 8000e64:	f002 f8dd 	bl	8003022 <USB_SetCurrentMode>
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000e68:	2100      	movs	r1, #0
 8000e6a:	4633      	mov	r3, r6
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8000e6c:	4632      	mov	r2, r6
 8000e6e:	f106 0410 	add.w	r4, r6, #16
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8000e72:	2501      	movs	r5, #1
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000e74:	4608      	mov	r0, r1
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
   hpcd->IN_ep[i].num = i;
 8000e76:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000e7a:	87d1      	strh	r1, [r2, #62]	; 0x3e
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000e7c:	3101      	adds	r1, #1
 8000e7e:	290f      	cmp	r1, #15
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8000e80:	f882 5039 	strb.w	r5, [r2, #57]	; 0x39
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8000e84:	f882 003b 	strb.w	r0, [r2, #59]	; 0x3b
   hpcd->IN_ep[i].maxpacket = 0U;
 8000e88:	6410      	str	r0, [r2, #64]	; 0x40
   hpcd->IN_ep[i].xfer_buff = 0U;
 8000e8a:	6450      	str	r0, [r2, #68]	; 0x44
   hpcd->IN_ep[i].xfer_len = 0U;
 8000e8c:	64d0      	str	r0, [r2, #76]	; 0x4c
 8000e8e:	f102 021c 	add.w	r2, r2, #28
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8000e92:	d1f0      	bne.n	8000e76 <HAL_PCD_Init+0x52>
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000e94:	2200      	movs	r2, #0
 8000e96:	f8d6 e000 	ldr.w	lr, [r6]
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
 8000e9a:	4611      	mov	r1, r2
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000e9c:	f102 0040 	add.w	r0, r2, #64	; 0x40
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
   hpcd->OUT_ep[i].num = i;
 8000ea0:	f883 21dc 	strb.w	r2, [r3, #476]	; 0x1dc
   hpcd->IN_ep[i].tx_fifo_num = i;
 8000ea4:	87da      	strh	r2, [r3, #62]	; 0x3e
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000ea6:	eb0e 0080 	add.w	r0, lr, r0, lsl #2
   hpcd->IN_ep[i].maxpacket = 0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 8000eaa:	3201      	adds	r2, #1
 8000eac:	2a0f      	cmp	r2, #15
 {
   hpcd->OUT_ep[i].is_in = 0U;
 8000eae:	f883 11dd 	strb.w	r1, [r3, #477]	; 0x1dd
   hpcd->OUT_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8000eb2:	f883 11df 	strb.w	r1, [r3, #479]	; 0x1df
   hpcd->OUT_ep[i].maxpacket = 0U;
 8000eb6:	f8c3 11e4 	str.w	r1, [r3, #484]	; 0x1e4
   hpcd->OUT_ep[i].xfer_buff = 0U;
 8000eba:	f8c3 11e8 	str.w	r1, [r3, #488]	; 0x1e8
   hpcd->OUT_ep[i].xfer_len = 0U;
 8000ebe:	f8c3 11f0 	str.w	r1, [r3, #496]	; 0x1f0
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8000ec2:	6041      	str	r1, [r0, #4]
 8000ec4:	f103 031c 	add.w	r3, r3, #28
   hpcd->IN_ep[i].maxpacket = 0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 8000ec8:	d1e8      	bne.n	8000e9c <HAL_PCD_Init+0x78>
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 8000eca:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000ecc:	466d      	mov	r5, sp
 8000ece:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000ed0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000ed2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000ed4:	e894 0003 	ldmia.w	r4, {r0, r1}
 8000ed8:	e885 0003 	stmia.w	r5, {r0, r1}
 8000edc:	4670      	mov	r0, lr
 8000ede:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 8000ee2:	f002 f8b5 	bl	8003050 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 8000ee6:	2301      	movs	r3, #1
 8000ee8:	f886 3381 	strb.w	r3, [r6, #897]	; 0x381
 {
   HAL_PCDEx_ActivateBCD(hpcd);
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 8000eec:	6830      	ldr	r0, [r6, #0]
 8000eee:	f002 fc7a 	bl	80037e6 <USB_DevDisconnect>
 return HAL_OK;
 8000ef2:	2000      	movs	r0, #0
 8000ef4:	e000      	b.n	8000ef8 <HAL_PCD_Init+0xd4>
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
  {
    return HAL_ERROR;
 8000ef6:	2001      	movs	r0, #1
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 return HAL_OK;
}
 8000ef8:	b00b      	add	sp, #44	; 0x2c
 8000efa:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000efc <HAL_PCD_Start>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8000efc:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8000f00:	2b01      	cmp	r3, #1
  * @brief  Start The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
 8000f02:	b510      	push	{r4, lr}
 8000f04:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8000f06:	d00c      	beq.n	8000f22 <HAL_PCD_Start+0x26>
 8000f08:	2301      	movs	r3, #1
 8000f0a:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_DevConnect (hpcd->Instance);  
 8000f0e:	6800      	ldr	r0, [r0, #0]
 8000f10:	f002 fc5d 	bl	80037ce <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 8000f14:	6820      	ldr	r0, [r4, #0]
 8000f16:	f002 f878 	bl	800300a <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 8000f1a:	2000      	movs	r0, #0
 8000f1c:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8000f20:	bd10      	pop	{r4, pc}
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8000f22:	2002      	movs	r0, #2
  USB_DevConnect (hpcd->Instance);  
  __HAL_PCD_ENABLE(hpcd);
  __HAL_UNLOCK(hpcd); 
  return HAL_OK;
}
 8000f24:	bd10      	pop	{r4, pc}

08000f26 <HAL_PCD_Stop>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8000f26:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8000f2a:	2b01      	cmp	r3, #1
  * @brief  Stop The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
 8000f2c:	b510      	push	{r4, lr}
 8000f2e:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8000f30:	d00f      	beq.n	8000f52 <HAL_PCD_Stop+0x2c>
 8000f32:	2301      	movs	r3, #1
 8000f34:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  __HAL_PCD_DISABLE(hpcd);
 8000f38:	6800      	ldr	r0, [r0, #0]
 8000f3a:	f002 f86c 	bl	8003016 <USB_DisableGlobalInt>
  USB_StopDevice(hpcd->Instance);
 8000f3e:	6820      	ldr	r0, [r4, #0]
 8000f40:	f002 fc14 	bl	800376c <USB_StopDevice>
  USB_DevDisconnect(hpcd->Instance);
 8000f44:	6820      	ldr	r0, [r4, #0]
 8000f46:	f002 fc4e 	bl	80037e6 <USB_DevDisconnect>
  __HAL_UNLOCK(hpcd); 
 8000f4a:	2000      	movs	r0, #0
 8000f4c:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
 8000f50:	bd10      	pop	{r4, pc}
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8000f52:	2002      	movs	r0, #2
  __HAL_PCD_DISABLE(hpcd);
  USB_StopDevice(hpcd->Instance);
  USB_DevDisconnect(hpcd->Instance);
  __HAL_UNLOCK(hpcd); 
  return HAL_OK;
}
 8000f54:	bd10      	pop	{r4, pc}
	...

08000f58 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000f58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8000f5c:	f8d0 a000 	ldr.w	sl, [r0]
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8000f60:	b087      	sub	sp, #28
 8000f62:	4604      	mov	r4, r0
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8000f64:	4650      	mov	r0, sl
 8000f66:	f002 fc78 	bl	800385a <USB_GetMode>
 8000f6a:	2800      	cmp	r0, #0
 8000f6c:	f040 8277 	bne.w	800145e <HAL_PCD_IRQHandler+0x506>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 8000f70:	6820      	ldr	r0, [r4, #0]
 8000f72:	f002 fc44 	bl	80037fe <USB_ReadInterrupts>
 8000f76:	2800      	cmp	r0, #0
 8000f78:	f000 8271 	beq.w	800145e <HAL_PCD_IRQHandler+0x506>
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8000f7c:	6820      	ldr	r0, [r4, #0]
 8000f7e:	f002 fc3e 	bl	80037fe <USB_ReadInterrupts>
 8000f82:	0785      	lsls	r5, r0, #30
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000f84:	bf48      	it	mi
 8000f86:	6822      	ldrmi	r2, [r4, #0]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8000f88:	6820      	ldr	r0, [r4, #0]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8000f8a:	bf42      	ittt	mi
 8000f8c:	6953      	ldrmi	r3, [r2, #20]
 8000f8e:	f003 0302 	andmi.w	r3, r3, #2
 8000f92:	6153      	strmi	r3, [r2, #20]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8000f94:	f002 fc33 	bl	80037fe <USB_ReadInterrupts>
 8000f98:	f410 2000 	ands.w	r0, r0, #524288	; 0x80000
 8000f9c:	d04a      	beq.n	8001034 <HAL_PCD_IRQHandler+0xdc>
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8000f9e:	6820      	ldr	r0, [r4, #0]
 8000fa0:	f002 fc31 	bl	8003806 <USB_ReadDevAllOutEpInterrupt>
 8000fa4:	f50a 6630 	add.w	r6, sl, #2816	; 0xb00
 8000fa8:	4607      	mov	r7, r0
 8000faa:	46a1      	mov	r9, r4
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0U;
 8000fac:	2500      	movs	r5, #0
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
 8000fae:	2f00      	cmp	r7, #0
 8000fb0:	d041      	beq.n	8001036 <HAL_PCD_IRQHandler+0xde>
      {
        if (ep_intr & 0x1U)
 8000fb2:	07f8      	lsls	r0, r7, #31
 8000fb4:	d538      	bpl.n	8001028 <HAL_PCD_IRQHandler+0xd0>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8000fb6:	fa5f fb85 	uxtb.w	fp, r5
 8000fba:	4659      	mov	r1, fp
 8000fbc:	6820      	ldr	r0, [r4, #0]
 8000fbe:	f002 fc32 	bl	8003826 <USB_ReadDevOutEPInterrupt>
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000fc2:	f010 0f01 	tst.w	r0, #1
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U)
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8000fc6:	4680      	mov	r8, r0
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8000fc8:	d021      	beq.n	800100e <HAL_PCD_IRQHandler+0xb6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
            
            if(hpcd->Init.dma_enable == 1U)
 8000fca:	6921      	ldr	r1, [r4, #16]
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000fcc:	2301      	movs	r3, #1
            
            if(hpcd->Init.dma_enable == 1U)
 8000fce:	4299      	cmp	r1, r3
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8000fd0:	60b3      	str	r3, [r6, #8]
            
            if(hpcd->Init.dma_enable == 1U)
 8000fd2:	d10c      	bne.n	8000fee <HAL_PCD_IRQHandler+0x96>
            {
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 8000fd4:	6931      	ldr	r1, [r6, #16]
 8000fd6:	f8d9 01e4 	ldr.w	r0, [r9, #484]	; 0x1e4
 8000fda:	f3c1 0112 	ubfx	r1, r1, #0, #19
 8000fde:	1a41      	subs	r1, r0, r1
 8000fe0:	f8c9 11f4 	str.w	r1, [r9, #500]	; 0x1f4
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 8000fe4:	f8d9 11e8 	ldr.w	r1, [r9, #488]	; 0x1e8
 8000fe8:	4408      	add	r0, r1
 8000fea:	f8c9 01e8 	str.w	r0, [r9, #488]	; 0x1e8
            }
            
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
 8000fee:	4659      	mov	r1, fp
 8000ff0:	4620      	mov	r0, r4
 8000ff2:	f7ff fbb5 	bl	8000760 <HAL_PCD_DataOutStageCallback>
            if(hpcd->Init.dma_enable == 1U)
 8000ff6:	6921      	ldr	r1, [r4, #16]
 8000ff8:	2901      	cmp	r1, #1
 8000ffa:	d108      	bne.n	800100e <HAL_PCD_IRQHandler+0xb6>
            {
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8000ffc:	b93d      	cbnz	r5, 800100e <HAL_PCD_IRQHandler+0xb6>
 8000ffe:	f8d4 21f0 	ldr.w	r2, [r4, #496]	; 0x1f0
 8001002:	b922      	cbnz	r2, 800100e <HAL_PCD_IRQHandler+0xb6>
              {
                 /* this is ZLP, so prepare EP0 for next setup */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8001004:	f504 7261 	add.w	r2, r4, #900	; 0x384
 8001008:	6820      	ldr	r0, [r4, #0]
 800100a:	f002 fc45 	bl	8003898 <USB_EP0_OutStart>
              }              
            }
          }
          
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 800100e:	f018 0f08 	tst.w	r8, #8
 8001012:	d004      	beq.n	800101e <HAL_PCD_IRQHandler+0xc6>
          {
            /* Inform the upper layer that a setup packet is available */
            HAL_PCD_SetupStageCallback(hpcd);
 8001014:	4620      	mov	r0, r4
 8001016:	f7ff fb9d 	bl	8000754 <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 800101a:	2308      	movs	r3, #8
 800101c:	60b3      	str	r3, [r6, #8]
          }
          
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 800101e:	f018 0f10 	tst.w	r8, #16
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8001022:	bf1c      	itt	ne
 8001024:	2310      	movne	r3, #16
 8001026:	60b3      	strne	r3, [r6, #8]
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
          }
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        }
        epnum++;
 8001028:	3501      	adds	r5, #1
        ep_intr >>= 1U;
 800102a:	087f      	lsrs	r7, r7, #1
 800102c:	3620      	adds	r6, #32
 800102e:	f109 091c 	add.w	r9, r9, #28
 8001032:	e7bc      	b.n	8000fae <HAL_PCD_IRQHandler+0x56>
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
  uint32_t i = 0U, ep_intr = 0U, epint = 0U, epnum = 0U;
 8001034:	4605      	mov	r5, r0
        epnum++;
        ep_intr >>= 1U;
      }
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8001036:	6820      	ldr	r0, [r4, #0]
 8001038:	f002 fbe1 	bl	80037fe <USB_ReadInterrupts>
 800103c:	0341      	lsls	r1, r0, #13
 800103e:	f140 809b 	bpl.w	8001178 <HAL_PCD_IRQHandler+0x220>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8001042:	6820      	ldr	r0, [r4, #0]
 8001044:	f002 fbe7 	bl	8003816 <USB_ReadDevAllInEpInterrupt>
 8001048:	4626      	mov	r6, r4
 800104a:	9003      	str	r0, [sp, #12]
 800104c:	f50a 6810 	add.w	r8, sl, #2304	; 0x900
      
      epnum = 0U;
 8001050:	2500      	movs	r5, #0
      
      while ( ep_intr )
 8001052:	9b03      	ldr	r3, [sp, #12]
 8001054:	2b00      	cmp	r3, #0
 8001056:	f000 808f 	beq.w	8001178 <HAL_PCD_IRQHandler+0x220>
      {
        if (ep_intr & 0x1U) /* In ITR */
 800105a:	9b03      	ldr	r3, [sp, #12]
 800105c:	07da      	lsls	r2, r3, #31
 800105e:	f140 8083 	bpl.w	8001168 <HAL_PCD_IRQHandler+0x210>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8001062:	fa5f f985 	uxtb.w	r9, r5
 8001066:	4649      	mov	r1, r9
 8001068:	6820      	ldr	r0, [r4, #0]
 800106a:	f002 fbe6 	bl	800383a <USB_ReadDevInEPInterrupt>

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 800106e:	07c3      	lsls	r3, r0, #31
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U) /* In ITR */
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8001070:	4607      	mov	r7, r0

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8001072:	d520      	bpl.n	80010b6 <HAL_PCD_IRQHandler+0x15e>
          {
            fifoemptymsk = 0x1U << epnum;
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001074:	f8da 3834 	ldr.w	r3, [sl, #2100]	; 0x834
 8001078:	2101      	movs	r1, #1
 800107a:	40a9      	lsls	r1, r5
 800107c:	ea23 0301 	bic.w	r3, r3, r1
 8001080:	f8ca 3834 	str.w	r3, [sl, #2100]	; 0x834
            
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8001084:	2301      	movs	r3, #1
 8001086:	f8c8 3008 	str.w	r3, [r8, #8]
            
            if (hpcd->Init.dma_enable == 1U)
 800108a:	6923      	ldr	r3, [r4, #16]
 800108c:	2b01      	cmp	r3, #1
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 800108e:	bf01      	itttt	eq
 8001090:	6c72      	ldreq	r2, [r6, #68]	; 0x44
 8001092:	6c33      	ldreq	r3, [r6, #64]	; 0x40
 8001094:	189b      	addeq	r3, r3, r2
 8001096:	6473      	streq	r3, [r6, #68]	; 0x44
            }
                                      
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 8001098:	4649      	mov	r1, r9
 800109a:	4620      	mov	r0, r4
 800109c:	f7ff fb69 	bl	8000772 <HAL_PCD_DataInStageCallback>

            if (hpcd->Init.dma_enable == 1U)
 80010a0:	6921      	ldr	r1, [r4, #16]
 80010a2:	2901      	cmp	r1, #1
 80010a4:	d107      	bne.n	80010b6 <HAL_PCD_IRQHandler+0x15e>
            {
              /* this is ZLP, so prepare EP0 for next setup */
              if((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 80010a6:	b935      	cbnz	r5, 80010b6 <HAL_PCD_IRQHandler+0x15e>
 80010a8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80010aa:	b923      	cbnz	r3, 80010b6 <HAL_PCD_IRQHandler+0x15e>
              {
                /* prepare to rx more setup packets */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80010ac:	f504 7261 	add.w	r2, r4, #900	; 0x384
 80010b0:	6820      	ldr	r0, [r4, #0]
 80010b2:	f002 fbf1 	bl	8003898 <USB_EP0_OutStart>
              }
            }           
          }
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 80010b6:	0738      	lsls	r0, r7, #28
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 80010b8:	bf44      	itt	mi
 80010ba:	2308      	movmi	r3, #8
 80010bc:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 80010c0:	06f9      	lsls	r1, r7, #27
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 80010c2:	bf44      	itt	mi
 80010c4:	2310      	movmi	r3, #16
 80010c6:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 80010ca:	067a      	lsls	r2, r7, #25
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 80010cc:	bf44      	itt	mi
 80010ce:	2340      	movmi	r3, #64	; 0x40
 80010d0:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 80010d4:	07bb      	lsls	r3, r7, #30
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 80010d6:	bf44      	itt	mi
 80010d8:	2302      	movmi	r3, #2
 80010da:	f8c8 3008 	strmi.w	r3, [r8, #8]
          }       
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80010de:	063f      	lsls	r7, r7, #24
 80010e0:	d542      	bpl.n	8001168 <HAL_PCD_IRQHandler+0x210>
  * @param  epnum : endpoint number   
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 80010e2:	6823      	ldr	r3, [r4, #0]
 80010e4:	9304      	str	r3, [sp, #16]
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 80010e6:	6d37      	ldr	r7, [r6, #80]	; 0x50
 80010e8:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 80010ea:	1bdb      	subs	r3, r3, r7
  
  if (len > ep->maxpacket)
 80010ec:	6c37      	ldr	r7, [r6, #64]	; 0x40
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 80010ee:	429f      	cmp	r7, r3
 80010f0:	bf28      	it	cs
 80010f2:	461f      	movcs	r7, r3
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 80010f4:	9b04      	ldr	r3, [sp, #16]
 80010f6:	f503 6310 	add.w	r3, r3, #2304	; 0x900
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3U) / 4U;
 80010fa:	f107 0b03 	add.w	fp, r7, #3
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 80010fe:	eb03 1345 	add.w	r3, r3, r5, lsl #5
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3U) / 4U;
 8001102:	ea4f 0b9b 	mov.w	fp, fp, lsr #2
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8001106:	9305      	str	r3, [sp, #20]
 8001108:	9b05      	ldr	r3, [sp, #20]
 800110a:	699b      	ldr	r3, [r3, #24]
 800110c:	b29b      	uxth	r3, r3
 800110e:	455b      	cmp	r3, fp
 8001110:	d80c      	bhi.n	800112c <HAL_PCD_IRQHandler+0x1d4>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
  }
  
  if(len <= 0U)
 8001112:	bb4f      	cbnz	r7, 8001168 <HAL_PCD_IRQHandler+0x210>
  {
    fifoemptymsk = 0x1U << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001114:	9b04      	ldr	r3, [sp, #16]
 8001116:	2201      	movs	r2, #1
 8001118:	f503 6900 	add.w	r9, r3, #2048	; 0x800
 800111c:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
 8001120:	40aa      	lsls	r2, r5
 8001122:	ea23 0302 	bic.w	r3, r3, r2
 8001126:	f8c9 3034 	str.w	r3, [r9, #52]	; 0x34
 800112a:	e01d      	b.n	8001168 <HAL_PCD_IRQHandler+0x210>
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
          ep->xfer_count < ep->xfer_len &&
 800112c:	6d32      	ldr	r2, [r6, #80]	; 0x50
 800112e:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8001130:	4293      	cmp	r3, r2
 8001132:	d9ee      	bls.n	8001112 <HAL_PCD_IRQHandler+0x1ba>
          ep->xfer_count < ep->xfer_len &&
 8001134:	2b00      	cmp	r3, #0
 8001136:	d0ec      	beq.n	8001112 <HAL_PCD_IRQHandler+0x1ba>
            ep->xfer_len != 0U)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
    
    if (len > ep->maxpacket)
 8001138:	6c37      	ldr	r7, [r6, #64]	; 0x40
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 800113a:	9804      	ldr	r0, [sp, #16]
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0U)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 800113c:	1a9b      	subs	r3, r3, r2
 800113e:	429f      	cmp	r7, r3
 8001140:	bf28      	it	cs
 8001142:	461f      	movcs	r7, r3
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 8001144:	7c23      	ldrb	r3, [r4, #16]
 8001146:	9300      	str	r3, [sp, #0]
 8001148:	464a      	mov	r2, r9
 800114a:	b2bb      	uxth	r3, r7
 800114c:	6c71      	ldr	r1, [r6, #68]	; 0x44
 800114e:	f002 fa9b 	bl	8003688 <USB_WritePacket>
    
    ep->xfer_buff  += len;
 8001152:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8001154:	443b      	add	r3, r7
 8001156:	6473      	str	r3, [r6, #68]	; 0x44
    ep->xfer_count += len;
 8001158:	6d33      	ldr	r3, [r6, #80]	; 0x50
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 800115a:	f107 0b03 	add.w	fp, r7, #3
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 800115e:	443b      	add	r3, r7
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 8001160:	ea4f 0b9b 	mov.w	fp, fp, lsr #2
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
 8001164:	6533      	str	r3, [r6, #80]	; 0x50
 8001166:	e7cf      	b.n	8001108 <HAL_PCD_IRQHandler+0x1b0>
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
        ep_intr >>= 1U;
 8001168:	9b03      	ldr	r3, [sp, #12]
 800116a:	085b      	lsrs	r3, r3, #1
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
 800116c:	3501      	adds	r5, #1
        ep_intr >>= 1U;
 800116e:	9303      	str	r3, [sp, #12]
 8001170:	361c      	adds	r6, #28
 8001172:	f108 0820 	add.w	r8, r8, #32
 8001176:	e76c      	b.n	8001052 <HAL_PCD_IRQHandler+0xfa>
      }
    }
    
    /* Handle Resume Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8001178:	6820      	ldr	r0, [r4, #0]
 800117a:	f002 fb40 	bl	80037fe <USB_ReadInterrupts>
 800117e:	2800      	cmp	r0, #0
 8001180:	da0d      	bge.n	800119e <HAL_PCD_IRQHandler+0x246>
    {    
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8001182:	f8da 3804 	ldr.w	r3, [sl, #2052]	; 0x804
 8001186:	f023 0301 	bic.w	r3, r3, #1
 800118a:	f8ca 3804 	str.w	r3, [sl, #2052]	; 0x804
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
      }
      else
#endif /* USB_OTG_GLPMCFG_LPMEN */
      {
        HAL_PCD_ResumeCallback(hpcd);
 800118e:	4620      	mov	r0, r4
 8001190:	f7ff fb24 	bl	80007dc <HAL_PCD_ResumeCallback>
      }
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8001194:	6822      	ldr	r2, [r4, #0]
 8001196:	6953      	ldr	r3, [r2, #20]
 8001198:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 800119c:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Suspend Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 800119e:	6820      	ldr	r0, [r4, #0]
 80011a0:	f002 fb2d 	bl	80037fe <USB_ReadInterrupts>
 80011a4:	0506      	lsls	r6, r0, #20
 80011a6:	d50b      	bpl.n	80011c0 <HAL_PCD_IRQHandler+0x268>
    {
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80011a8:	f8da 3808 	ldr.w	r3, [sl, #2056]	; 0x808
 80011ac:	07d8      	lsls	r0, r3, #31
 80011ae:	d502      	bpl.n	80011b6 <HAL_PCD_IRQHandler+0x25e>
      {
        
        HAL_PCD_SuspendCallback(hpcd);
 80011b0:	4620      	mov	r0, r4
 80011b2:	f7ff fafb 	bl	80007ac <HAL_PCD_SuspendCallback>
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80011b6:	6822      	ldr	r2, [r4, #0]
 80011b8:	6953      	ldr	r3, [r2, #20]
 80011ba:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80011be:	6153      	str	r3, [r2, #20]
      }
    }
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 80011c0:	6820      	ldr	r0, [r4, #0]
 80011c2:	f002 fb1c 	bl	80037fe <USB_ReadInterrupts>
 80011c6:	04c1      	lsls	r1, r0, #19
 80011c8:	d543      	bpl.n	8001252 <HAL_PCD_IRQHandler+0x2fa>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 80011ca:	f50a 6600 	add.w	r6, sl, #2048	; 0x800
 80011ce:	6873      	ldr	r3, [r6, #4]
      USB_FlushTxFifo(hpcd->Instance , 0U);
 80011d0:	6820      	ldr	r0, [r4, #0]
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 80011d2:	f023 0301 	bic.w	r3, r3, #1
 80011d6:	6073      	str	r3, [r6, #4]
      USB_FlushTxFifo(hpcd->Instance , 0U);
 80011d8:	2100      	movs	r1, #0
 80011da:	f001 ffd3 	bl	8003184 <USB_FlushTxFifo>
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80011de:	6860      	ldr	r0, [r4, #4]
 80011e0:	f50a 6310 	add.w	r3, sl, #2304	; 0x900
 80011e4:	2200      	movs	r2, #0
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 80011e6:	21ff      	movs	r1, #255	; 0xff
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance , 0U);
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80011e8:	4282      	cmp	r2, r0
 80011ea:	d005      	beq.n	80011f8 <HAL_PCD_IRQHandler+0x2a0>
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 80011ec:	6099      	str	r1, [r3, #8]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance , 0U);
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80011ee:	3201      	adds	r2, #1
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
        USBx_OUTEP(i)->DOEPINT = 0xFFU;
 80011f0:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
 80011f4:	3320      	adds	r3, #32
 80011f6:	e7f7      	b.n	80011e8 <HAL_PCD_IRQHandler+0x290>
      }
      USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 80011f8:	f04f 33ff 	mov.w	r3, #4294967295
 80011fc:	61b3      	str	r3, [r6, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 80011fe:	69f3      	ldr	r3, [r6, #28]
 8001200:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8001204:	61f3      	str	r3, [r6, #28]
      
      if(hpcd->Init.use_dedicated_ep1)
 8001206:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001208:	b153      	cbz	r3, 8001220 <HAL_PCD_IRQHandler+0x2c8>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 800120a:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 800120e:	f043 030b 	orr.w	r3, r3, #11
 8001212:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 8001216:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8001218:	f043 030b 	orr.w	r3, r3, #11
 800121c:	6473      	str	r3, [r6, #68]	; 0x44
 800121e:	e007      	b.n	8001230 <HAL_PCD_IRQHandler+0x2d8>
      else
      {
#ifdef USB_OTG_DOEPINT_OTEPSPR
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM | USB_OTG_DOEPMSK_OTEPSPRM);
#else
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 8001220:	6973      	ldr	r3, [r6, #20]
 8001222:	f043 030b 	orr.w	r3, r3, #11
 8001226:	6173      	str	r3, [r6, #20]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8001228:	6933      	ldr	r3, [r6, #16]
 800122a:	f043 030b 	orr.w	r3, r3, #11
 800122e:	6133      	str	r3, [r6, #16]
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8001230:	f8da 3800 	ldr.w	r3, [sl, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8001234:	7c21      	ldrb	r1, [r4, #16]
 8001236:	6820      	ldr	r0, [r4, #0]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8001238:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800123c:	f8ca 3800 	str.w	r3, [sl, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8001240:	f504 7261 	add.w	r2, r4, #900	; 0x384
 8001244:	f002 fb28 	bl	8003898 <USB_EP0_OutStart>
        
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8001248:	6822      	ldr	r2, [r4, #0]
 800124a:	6953      	ldr	r3, [r2, #20]
 800124c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001250:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Enumeration done Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8001252:	6820      	ldr	r0, [r4, #0]
 8001254:	f002 fad3 	bl	80037fe <USB_ReadInterrupts>
 8001258:	0482      	lsls	r2, r0, #18
 800125a:	d57c      	bpl.n	8001356 <HAL_PCD_IRQHandler+0x3fe>
    {
      USB_ActivateSetup(hpcd->Instance);
 800125c:	6820      	ldr	r0, [r4, #0]
 800125e:	f002 fb00 	bl	8003862 <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8001262:	6820      	ldr	r0, [r4, #0]
 8001264:	68c3      	ldr	r3, [r0, #12]
 8001266:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800126a:	60c3      	str	r3, [r0, #12]
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 800126c:	f001 ffb3 	bl	80031d6 <USB_GetDevSpeed>
 8001270:	b948      	cbnz	r0, 8001286 <HAL_PCD_IRQHandler+0x32e>
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 8001272:	6822      	ldr	r2, [r4, #0]
      USB_ActivateSetup(hpcd->Instance);
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 8001274:	60e0      	str	r0, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8001276:	f44f 7300 	mov.w	r3, #512	; 0x200
 800127a:	6163      	str	r3, [r4, #20]
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 800127c:	68d3      	ldr	r3, [r2, #12]
 800127e:	f443 5310 	orr.w	r3, r3, #9216	; 0x2400
 8001282:	60d3      	str	r3, [r2, #12]
 8001284:	e05f      	b.n	8001346 <HAL_PCD_IRQHandler+0x3ee>
      }
      else
      {
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 8001286:	2303      	movs	r3, #3
 8001288:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 800128a:	2340      	movs	r3, #64	; 0x40
 800128c:	6163      	str	r3, [r4, #20]
        used by application. In the low AHB frequency range it is used to stretch enough the USB response 
        time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access 
        latency to the Data FIFO */
        
        /* Get hclk frequency value */
        hclk = HAL_RCC_GetHCLKFreq();
 800128e:	f000 fcbb 	bl	8001c08 <HAL_RCC_GetHCLKFreq>
		
        if((hclk >= 14200000)&&(hclk < 15000000))
 8001292:	4b74      	ldr	r3, [pc, #464]	; (8001464 <HAL_PCD_IRQHandler+0x50c>)
 8001294:	4a74      	ldr	r2, [pc, #464]	; (8001468 <HAL_PCD_IRQHandler+0x510>)
 8001296:	4403      	add	r3, r0
 8001298:	4293      	cmp	r3, r2
 800129a:	6823      	ldr	r3, [r4, #0]
 800129c:	d803      	bhi.n	80012a6 <HAL_PCD_IRQHandler+0x34e>
        {
          /* hclk Clock Range between 14.2-15 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xF << 10) & USB_OTG_GUSBCFG_TRDT);
 800129e:	68da      	ldr	r2, [r3, #12]
 80012a0:	f442 5270 	orr.w	r2, r2, #15360	; 0x3c00
 80012a4:	e04e      	b.n	8001344 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 15000000)&&(hclk < 16000000))
 80012a6:	4a71      	ldr	r2, [pc, #452]	; (800146c <HAL_PCD_IRQHandler+0x514>)
 80012a8:	4971      	ldr	r1, [pc, #452]	; (8001470 <HAL_PCD_IRQHandler+0x518>)
 80012aa:	4402      	add	r2, r0
 80012ac:	428a      	cmp	r2, r1
 80012ae:	d803      	bhi.n	80012b8 <HAL_PCD_IRQHandler+0x360>
        {
          /* hclk Clock Range between 15-16 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xE << 10) & USB_OTG_GUSBCFG_TRDT);
 80012b0:	68da      	ldr	r2, [r3, #12]
 80012b2:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 80012b6:	e045      	b.n	8001344 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 16000000)&&(hclk < 17200000))
 80012b8:	f5a0 0274 	sub.w	r2, r0, #15990784	; 0xf40000
 80012bc:	496d      	ldr	r1, [pc, #436]	; (8001474 <HAL_PCD_IRQHandler+0x51c>)
 80012be:	f5a2 5210 	sub.w	r2, r2, #9216	; 0x2400
 80012c2:	428a      	cmp	r2, r1
 80012c4:	d803      	bhi.n	80012ce <HAL_PCD_IRQHandler+0x376>
        {
          /* hclk Clock Range between 16-17.2 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xD << 10) & USB_OTG_GUSBCFG_TRDT);
 80012c6:	68da      	ldr	r2, [r3, #12]
 80012c8:	f442 5250 	orr.w	r2, r2, #13312	; 0x3400
 80012cc:	e03a      	b.n	8001344 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 17200000)&&(hclk < 18500000))
 80012ce:	f1a0 7283 	sub.w	r2, r0, #17170432	; 0x1060000
 80012d2:	4969      	ldr	r1, [pc, #420]	; (8001478 <HAL_PCD_IRQHandler+0x520>)
 80012d4:	f5a2 42e7 	sub.w	r2, r2, #29568	; 0x7380
 80012d8:	428a      	cmp	r2, r1
 80012da:	d803      	bhi.n	80012e4 <HAL_PCD_IRQHandler+0x38c>
        {
          /* hclk Clock Range between 17.2-18.5 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xC << 10) & USB_OTG_GUSBCFG_TRDT);
 80012dc:	68da      	ldr	r2, [r3, #12]
 80012de:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
 80012e2:	e02f      	b.n	8001344 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 18500000)&&(hclk < 20000000))
 80012e4:	4a65      	ldr	r2, [pc, #404]	; (800147c <HAL_PCD_IRQHandler+0x524>)
 80012e6:	4966      	ldr	r1, [pc, #408]	; (8001480 <HAL_PCD_IRQHandler+0x528>)
 80012e8:	4402      	add	r2, r0
 80012ea:	428a      	cmp	r2, r1
 80012ec:	d803      	bhi.n	80012f6 <HAL_PCD_IRQHandler+0x39e>
        {
          /* hclk Clock Range between 18.5-20 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xB << 10) & USB_OTG_GUSBCFG_TRDT);
 80012ee:	68da      	ldr	r2, [r3, #12]
 80012f0:	f442 5230 	orr.w	r2, r2, #11264	; 0x2c00
 80012f4:	e026      	b.n	8001344 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 20000000)&&(hclk < 21800000))
 80012f6:	4a63      	ldr	r2, [pc, #396]	; (8001484 <HAL_PCD_IRQHandler+0x52c>)
 80012f8:	4963      	ldr	r1, [pc, #396]	; (8001488 <HAL_PCD_IRQHandler+0x530>)
 80012fa:	4402      	add	r2, r0
 80012fc:	428a      	cmp	r2, r1
 80012fe:	d803      	bhi.n	8001308 <HAL_PCD_IRQHandler+0x3b0>
        {
          /* hclk Clock Range between 20-21.8 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xA << 10) & USB_OTG_GUSBCFG_TRDT);
 8001300:	68da      	ldr	r2, [r3, #12]
 8001302:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
 8001306:	e01d      	b.n	8001344 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 21800000)&&(hclk < 24000000))
 8001308:	4a60      	ldr	r2, [pc, #384]	; (800148c <HAL_PCD_IRQHandler+0x534>)
 800130a:	4961      	ldr	r1, [pc, #388]	; (8001490 <HAL_PCD_IRQHandler+0x538>)
 800130c:	4402      	add	r2, r0
 800130e:	428a      	cmp	r2, r1
 8001310:	d803      	bhi.n	800131a <HAL_PCD_IRQHandler+0x3c2>
        {
          /* hclk Clock Range between 21.8-24 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9 << 10) & USB_OTG_GUSBCFG_TRDT);
 8001312:	68da      	ldr	r2, [r3, #12]
 8001314:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
 8001318:	e014      	b.n	8001344 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 24000000)&&(hclk < 27700000))
 800131a:	f1a0 72b7 	sub.w	r2, r0, #23986176	; 0x16e0000
 800131e:	495d      	ldr	r1, [pc, #372]	; (8001494 <HAL_PCD_IRQHandler+0x53c>)
 8001320:	f5a2 5258 	sub.w	r2, r2, #13824	; 0x3600
 8001324:	428a      	cmp	r2, r1
 8001326:	d803      	bhi.n	8001330 <HAL_PCD_IRQHandler+0x3d8>
        {
          /* hclk Clock Range between 24-27.7 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8 << 10) & USB_OTG_GUSBCFG_TRDT);
 8001328:	68da      	ldr	r2, [r3, #12]
 800132a:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800132e:	e009      	b.n	8001344 <HAL_PCD_IRQHandler+0x3ec>
        }
        
        else if((hclk >= 27700000)&&(hclk < 32000000))
 8001330:	4a59      	ldr	r2, [pc, #356]	; (8001498 <HAL_PCD_IRQHandler+0x540>)
 8001332:	495a      	ldr	r1, [pc, #360]	; (800149c <HAL_PCD_IRQHandler+0x544>)
 8001334:	4402      	add	r2, r0
 8001336:	428a      	cmp	r2, r1
        {
          /* hclk Clock Range between 27.7-32 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7 << 10) & USB_OTG_GUSBCFG_TRDT);
 8001338:	68da      	ldr	r2, [r3, #12]
 800133a:	bf94      	ite	ls
 800133c:	f442 52e0 	orrls.w	r2, r2, #7168	; 0x1c00
        }
        
        else /* if(hclk >= 32000000) */
        {
          /* hclk Clock Range between 32-180 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6 << 10) & USB_OTG_GUSBCFG_TRDT);
 8001340:	f442 52c0 	orrhi.w	r2, r2, #6144	; 0x1800
 8001344:	60da      	str	r2, [r3, #12]
        }  
      }
      
      HAL_PCD_ResetCallback(hpcd);
 8001346:	4620      	mov	r0, r4
 8001348:	f7ff fa1f 	bl	800078a <HAL_PCD_ResetCallback>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 800134c:	6822      	ldr	r2, [r4, #0]
 800134e:	6953      	ldr	r3, [r2, #20]
 8001350:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8001354:	6153      	str	r3, [r2, #20]
    }

    /* Handle RxQLevel Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8001356:	6820      	ldr	r0, [r4, #0]
 8001358:	f002 fa51 	bl	80037fe <USB_ReadInterrupts>
 800135c:	06c3      	lsls	r3, r0, #27
 800135e:	d538      	bpl.n	80013d2 <HAL_PCD_IRQHandler+0x47a>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8001360:	6822      	ldr	r2, [r4, #0]
 8001362:	6993      	ldr	r3, [r2, #24]
 8001364:	f023 0310 	bic.w	r3, r3, #16
 8001368:	6193      	str	r3, [r2, #24]
      
      temp = USBx->GRXSTSP;
 800136a:	f8da 6020 	ldr.w	r6, [sl, #32]
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 800136e:	f3c6 4343 	ubfx	r3, r6, #17, #4
 8001372:	2b02      	cmp	r3, #2
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
      
      temp = USBx->GRXSTSP;
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8001374:	f006 070f 	and.w	r7, r6, #15
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 8001378:	d114      	bne.n	80013a4 <HAL_PCD_IRQHandler+0x44c>
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 800137a:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800137e:	4033      	ands	r3, r6
 8001380:	b313      	cbz	r3, 80013c8 <HAL_PCD_IRQHandler+0x470>
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
 8001382:	231c      	movs	r3, #28
 8001384:	fb03 4707 	mla	r7, r3, r7, r4
 8001388:	f3c6 160a 	ubfx	r6, r6, #4, #11
 800138c:	4632      	mov	r2, r6
 800138e:	f8d7 11e8 	ldr.w	r1, [r7, #488]	; 0x1e8
 8001392:	4650      	mov	r0, sl
 8001394:	f002 f98c 	bl	80036b0 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8001398:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 800139c:	4433      	add	r3, r6
 800139e:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
 80013a2:	e00c      	b.n	80013be <HAL_PCD_IRQHandler+0x466>
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_SETUP_UPDT)
 80013a4:	2b06      	cmp	r3, #6
 80013a6:	d10f      	bne.n	80013c8 <HAL_PCD_IRQHandler+0x470>
      {
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 80013a8:	2208      	movs	r2, #8
 80013aa:	f504 7161 	add.w	r1, r4, #900	; 0x384
 80013ae:	4650      	mov	r0, sl
 80013b0:	f002 f97e 	bl	80036b0 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 80013b4:	231c      	movs	r3, #28
 80013b6:	fb03 4707 	mla	r7, r3, r7, r4
 80013ba:	f3c6 160a 	ubfx	r6, r6, #4, #11
 80013be:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
 80013c2:	441e      	add	r6, r3
 80013c4:	f8c7 61f4 	str.w	r6, [r7, #500]	; 0x1f4
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80013c8:	6822      	ldr	r2, [r4, #0]
 80013ca:	6993      	ldr	r3, [r2, #24]
 80013cc:	f043 0310 	orr.w	r3, r3, #16
 80013d0:	6193      	str	r3, [r2, #24]
    }
    
    /* Handle SOF Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 80013d2:	6820      	ldr	r0, [r4, #0]
 80013d4:	f002 fa13 	bl	80037fe <USB_ReadInterrupts>
 80013d8:	0707      	lsls	r7, r0, #28
 80013da:	d507      	bpl.n	80013ec <HAL_PCD_IRQHandler+0x494>
    {
      HAL_PCD_SOFCallback(hpcd);
 80013dc:	4620      	mov	r0, r4
 80013de:	f7ff f9d0 	bl	8000782 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 80013e2:	6822      	ldr	r2, [r4, #0]
 80013e4:	6953      	ldr	r3, [r2, #20]
 80013e6:	f003 0308 	and.w	r3, r3, #8
 80013ea:	6153      	str	r3, [r2, #20]
    }
    
    /* Handle Incomplete ISO IN Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 80013ec:	6820      	ldr	r0, [r4, #0]
 80013ee:	f002 fa06 	bl	80037fe <USB_ReadInterrupts>
 80013f2:	02c6      	lsls	r6, r0, #11
 80013f4:	d508      	bpl.n	8001408 <HAL_PCD_IRQHandler+0x4b0>
    {
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 80013f6:	b2e9      	uxtb	r1, r5
 80013f8:	4620      	mov	r0, r4
 80013fa:	f7ff f9f7 	bl	80007ec <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 80013fe:	6822      	ldr	r2, [r4, #0]
 8001400:	6953      	ldr	r3, [r2, #20]
 8001402:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001406:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Incomplete ISO OUT Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8001408:	6820      	ldr	r0, [r4, #0]
 800140a:	f002 f9f8 	bl	80037fe <USB_ReadInterrupts>
 800140e:	0280      	lsls	r0, r0, #10
 8001410:	d508      	bpl.n	8001424 <HAL_PCD_IRQHandler+0x4cc>
    {
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 8001412:	b2e9      	uxtb	r1, r5
 8001414:	4620      	mov	r0, r4
 8001416:	f7ff f9e5 	bl	80007e4 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 800141a:	6822      	ldr	r2, [r4, #0]
 800141c:	6953      	ldr	r3, [r2, #20]
 800141e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001422:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Connection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8001424:	6820      	ldr	r0, [r4, #0]
 8001426:	f002 f9ea 	bl	80037fe <USB_ReadInterrupts>
 800142a:	0041      	lsls	r1, r0, #1
 800142c:	d507      	bpl.n	800143e <HAL_PCD_IRQHandler+0x4e6>
    {
      HAL_PCD_ConnectCallback(hpcd);
 800142e:	4620      	mov	r0, r4
 8001430:	f7ff f9e0 	bl	80007f4 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8001434:	6822      	ldr	r2, [r4, #0]
 8001436:	6953      	ldr	r3, [r2, #20]
 8001438:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 800143c:	6153      	str	r3, [r2, #20]
    } 
    
    /* Handle Disconnection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 800143e:	6820      	ldr	r0, [r4, #0]
 8001440:	f002 f9dd 	bl	80037fe <USB_ReadInterrupts>
 8001444:	0742      	lsls	r2, r0, #29
 8001446:	d50a      	bpl.n	800145e <HAL_PCD_IRQHandler+0x506>
    {
      temp = hpcd->Instance->GOTGINT;
 8001448:	6823      	ldr	r3, [r4, #0]
 800144a:	685d      	ldr	r5, [r3, #4]
      
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 800144c:	076b      	lsls	r3, r5, #29
 800144e:	d502      	bpl.n	8001456 <HAL_PCD_IRQHandler+0x4fe>
      {
        HAL_PCD_DisconnectCallback(hpcd);
 8001450:	4620      	mov	r0, r4
 8001452:	f7ff f9d3 	bl	80007fc <HAL_PCD_DisconnectCallback>
      }
      hpcd->Instance->GOTGINT |= temp;
 8001456:	6822      	ldr	r2, [r4, #0]
 8001458:	6853      	ldr	r3, [r2, #4]
 800145a:	432b      	orrs	r3, r5
 800145c:	6053      	str	r3, [r2, #4]
    }
  }
}
 800145e:	b007      	add	sp, #28
 8001460:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001464:	ff275340 	.word	0xff275340
 8001468:	000c34ff 	.word	0x000c34ff
 800146c:	ff1b1e40 	.word	0xff1b1e40
 8001470:	000f423f 	.word	0x000f423f
 8001474:	00124f7f 	.word	0x00124f7f
 8001478:	0013d61f 	.word	0x0013d61f
 800147c:	fee5b660 	.word	0xfee5b660
 8001480:	0016e35f 	.word	0x0016e35f
 8001484:	feced300 	.word	0xfeced300
 8001488:	001b773f 	.word	0x001b773f
 800148c:	feb35bc0 	.word	0xfeb35bc0
 8001490:	002191bf 	.word	0x002191bf
 8001494:	0038751f 	.word	0x0038751f
 8001498:	fe5954e0 	.word	0xfe5954e0
 800149c:	00419cdf 	.word	0x00419cdf

080014a0 <HAL_PCD_SetAddress>:
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd); 
 80014a0:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 80014a4:	2b01      	cmp	r3, #1
  * @param  hpcd: PCD handle
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 80014a6:	b510      	push	{r4, lr}
 80014a8:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80014aa:	d009      	beq.n	80014c0 <HAL_PCD_SetAddress+0x20>
 80014ac:	2301      	movs	r3, #1
 80014ae:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_SetDevAddress(hpcd->Instance, address);
 80014b2:	6800      	ldr	r0, [r0, #0]
 80014b4:	f002 f97b 	bl	80037ae <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 80014b8:	2000      	movs	r0, #0
 80014ba:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 80014be:	bd10      	pop	{r4, pc}
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd); 
 80014c0:	2002      	movs	r0, #2
  USB_SetDevAddress(hpcd->Instance, address);
  __HAL_UNLOCK(hpcd);   
  return HAL_OK;
}
 80014c2:	bd10      	pop	{r4, pc}

080014c4 <HAL_PCD_EP_Open>:
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 80014c4:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 80014c6:	b24e      	sxtb	r6, r1
 80014c8:	2e00      	cmp	r6, #0
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 80014ca:	4604      	mov	r4, r0
 80014cc:	f04f 051c 	mov.w	r5, #28
 80014d0:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 80014d4:	bfb5      	itete	lt
 80014d6:	fb05 4100 	mlalt	r1, r5, r0, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80014da:	fb05 4101 	mlage	r1, r5, r1, r4
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 80014de:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80014e0:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  }
  ep->num   = ep_addr & 0x7FU;
 80014e4:	b2c0      	uxtb	r0, r0
  
  ep->is_in = (0x80U & ep_addr) != 0U;
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
  if (ep->is_in)
 80014e6:	2e00      	cmp	r6, #0
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 80014e8:	bfb8      	it	lt
 80014ea:	80c8      	strhlt	r0, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK )
 80014ec:	2b02      	cmp	r3, #2
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
 80014ee:	70cb      	strb	r3, [r1, #3]
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 80014f0:	ea4f 75d6 	mov.w	r5, r6, lsr #31
    ep->tx_fifo_num = ep->num;
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
 80014f4:	bf04      	itt	eq
 80014f6:	2300      	moveq	r3, #0
 80014f8:	710b      	strbeq	r3, [r1, #4]
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
 80014fa:	7008      	strb	r0, [r1, #0]
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 80014fc:	704d      	strb	r5, [r1, #1]
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 80014fe:	f894 3380 	ldrb.w	r3, [r4, #896]	; 0x380
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
  ep->maxpacket = ep_mps;
 8001502:	608a      	str	r2, [r1, #8]
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 8001504:	2b01      	cmp	r3, #1
 8001506:	d009      	beq.n	800151c <HAL_PCD_EP_Open+0x58>
 8001508:	2301      	movs	r3, #1
 800150a:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  USB_ActivateEndpoint(hpcd->Instance , ep);
 800150e:	6820      	ldr	r0, [r4, #0]
 8001510:	f001 fe7c 	bl	800320c <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8001514:	2000      	movs	r0, #0
 8001516:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return ret;
 800151a:	bd70      	pop	{r4, r5, r6, pc}
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 800151c:	2002      	movs	r0, #2
  USB_ActivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return ret;
}
 800151e:	bd70      	pop	{r4, r5, r6, pc}

08001520 <HAL_PCD_EP_Close>:
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 8001520:	b24b      	sxtb	r3, r1
 8001522:	2b00      	cmp	r3, #0
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
 8001524:	b510      	push	{r4, lr}
 8001526:	f04f 021c 	mov.w	r2, #28
 800152a:	4604      	mov	r4, r0
 800152c:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001530:	bfb5      	itete	lt
 8001532:	fb02 4100 	mlalt	r1, r2, r0, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8001536:	fb02 4101 	mlage	r1, r2, r1, r4
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 800153a:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 800153c:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8001540:	0fdb      	lsrs	r3, r3, #31
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
 8001542:	7008      	strb	r0, [r1, #0]
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8001544:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 8001546:	f894 3380 	ldrb.w	r3, [r4, #896]	; 0x380
 800154a:	2b01      	cmp	r3, #1
 800154c:	d009      	beq.n	8001562 <HAL_PCD_EP_Close+0x42>
 800154e:	2301      	movs	r3, #1
 8001550:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 8001554:	6820      	ldr	r0, [r4, #0]
 8001556:	f001 fe9a 	bl	800328e <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 800155a:	2000      	movs	r0, #0
 800155c:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8001560:	bd10      	pop	{r4, pc}
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
  
  __HAL_LOCK(hpcd); 
 8001562:	2002      	movs	r0, #2
  USB_DeactivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return HAL_OK;
}
 8001564:	bd10      	pop	{r4, pc}

08001566 <HAL_PCD_EP_Receive>:
  * @param  pBuf: pointer to the reception buffer   
  * @param  len: amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8001566:	b538      	push	{r3, r4, r5, lr}
 8001568:	4604      	mov	r4, r0
 800156a:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 800156e:	201c      	movs	r0, #28
 8001570:	fb00 4005 	mla	r0, r0, r5, r4
  ep->xfer_len = len;
 8001574:	f8c0 31f0 	str.w	r3, [r0, #496]	; 0x1f0
  ep->xfer_count = 0U;
 8001578:	2300      	movs	r3, #0
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 800157a:	f8c0 21e8 	str.w	r2, [r0, #488]	; 0x1e8
  ep->xfer_len = len;
  ep->xfer_count = 0U;
 800157e:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  ep->is_in = 0U;
 8001582:	f880 31dd 	strb.w	r3, [r0, #477]	; 0x1dd
  ep->num = ep_addr & 0x7FU;
 8001586:	f880 51dc 	strb.w	r5, [r0, #476]	; 0x1dc
  
  if (hpcd->Init.dma_enable == 1U)
 800158a:	6923      	ldr	r3, [r4, #16]
 800158c:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 800158e:	bf08      	it	eq
 8001590:	f8c0 21ec 	streq.w	r2, [r0, #492]	; 0x1ec
  }
  
  __HAL_LOCK(hpcd); 
 8001594:	f894 2380 	ldrb.w	r2, [r4, #896]	; 0x380
 8001598:	2a01      	cmp	r2, #1
 800159a:	d013      	beq.n	80015c4 <HAL_PCD_EP_Receive+0x5e>
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 800159c:	211c      	movs	r1, #28
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 800159e:	2201      	movs	r2, #1
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80015a0:	fb01 4105 	mla	r1, r1, r5, r4
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 80015a4:	f884 2380 	strb.w	r2, [r4, #896]	; 0x380
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80015a8:	f501 71ee 	add.w	r1, r1, #476	; 0x1dc
 80015ac:	b2da      	uxtb	r2, r3
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7FU) == 0U)
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80015ae:	6820      	ldr	r0, [r4, #0]
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7FU) == 0U)
 80015b0:	b915      	cbnz	r5, 80015b8 <HAL_PCD_EP_Receive+0x52>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80015b2:	f001 ffbf 	bl	8003534 <USB_EP0StartXfer>
 80015b6:	e001      	b.n	80015bc <HAL_PCD_EP_Receive+0x56>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 80015b8:	f001 fea0 	bl	80032fc <USB_EPStartXfer>
  }
  __HAL_UNLOCK(hpcd); 
 80015bc:	2000      	movs	r0, #0
 80015be:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  
  return HAL_OK;
 80015c2:	bd38      	pop	{r3, r4, r5, pc}
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 80015c4:	2002      	movs	r0, #2
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 80015c6:	bd38      	pop	{r3, r4, r5, pc}

080015c8 <HAL_PCD_EP_GetRxCount>:
  * @param  ep_addr: endpoint address
  * @retval Data Size
  */
uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  return hpcd->OUT_ep[ep_addr & 0x7FU].xfer_count;
 80015c8:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80015cc:	231c      	movs	r3, #28
 80015ce:	fb03 0001 	mla	r0, r3, r1, r0
}
 80015d2:	f8b0 01f4 	ldrh.w	r0, [r0, #500]	; 0x1f4
 80015d6:	4770      	bx	lr

080015d8 <HAL_PCD_EP_Transmit>:
  * @param  pBuf: pointer to the transmission buffer   
  * @param  len: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 80015d8:	b538      	push	{r3, r4, r5, lr}
 80015da:	4604      	mov	r4, r0
 80015dc:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 80015e0:	201c      	movs	r0, #28
 80015e2:	fb00 4005 	mla	r0, r0, r5, r4
  ep->xfer_len = len;
 80015e6:	64c3      	str	r3, [r0, #76]	; 0x4c
  ep->xfer_count = 0U;
 80015e8:	2300      	movs	r3, #0
 80015ea:	6503      	str	r3, [r0, #80]	; 0x50
  ep->is_in = 1U;
 80015ec:	2301      	movs	r3, #1
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 80015ee:	6442      	str	r2, [r0, #68]	; 0x44
  ep->xfer_len = len;
  ep->xfer_count = 0U;
  ep->is_in = 1U;
 80015f0:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  ep->num = ep_addr & 0x7FU;
 80015f4:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
  
  if (hpcd->Init.dma_enable == 1U)
 80015f8:	6923      	ldr	r3, [r4, #16]
 80015fa:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 80015fc:	bf08      	it	eq
 80015fe:	6482      	streq	r2, [r0, #72]	; 0x48
  }
  
  __HAL_LOCK(hpcd); 
 8001600:	f894 2380 	ldrb.w	r2, [r4, #896]	; 0x380
 8001604:	2a01      	cmp	r2, #1
 8001606:	d012      	beq.n	800162e <HAL_PCD_EP_Transmit+0x56>
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001608:	211c      	movs	r1, #28
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 800160a:	2201      	movs	r2, #1
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 800160c:	fb01 4105 	mla	r1, r1, r5, r4
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8001610:	f884 2380 	strb.w	r2, [r4, #896]	; 0x380
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001614:	3138      	adds	r1, #56	; 0x38
 8001616:	b2da      	uxtb	r2, r3
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7FU) == 0U)
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001618:	6820      	ldr	r0, [r4, #0]
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
  
  if ((ep_addr & 0x7FU) == 0U)
 800161a:	b915      	cbnz	r5, 8001622 <HAL_PCD_EP_Transmit+0x4a>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 800161c:	f001 ff8a 	bl	8003534 <USB_EP0StartXfer>
 8001620:	e001      	b.n	8001626 <HAL_PCD_EP_Transmit+0x4e>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8001622:	f001 fe6b 	bl	80032fc <USB_EPStartXfer>
  }
  
  __HAL_UNLOCK(hpcd);
 8001626:	2000      	movs	r0, #0
 8001628:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
     
  return HAL_OK;
 800162c:	bd38      	pop	{r3, r4, r5, pc}
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 800162e:	2002      	movs	r0, #2
  }
  
  __HAL_UNLOCK(hpcd);
     
  return HAL_OK;
}
 8001630:	bd38      	pop	{r3, r4, r5, pc}

08001632 <HAL_PCD_EP_SetStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8001632:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 8001634:	b24b      	sxtb	r3, r1
 8001636:	2b00      	cmp	r3, #0
 8001638:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 800163c:	f04f 021c 	mov.w	r2, #28
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001640:	bfb5      	itete	lt
 8001642:	fb02 0105 	mlalt	r1, r2, r5, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8001646:	fb02 0101 	mlage	r1, r2, r1, r0
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 800164a:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800164c:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  }
  
  ep->is_stall = 1U;
 8001650:	2201      	movs	r2, #1
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8001652:	0fdb      	lsrs	r3, r3, #31
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7FU;
 8001654:	b2ed      	uxtb	r5, r5
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1U;
 8001656:	708a      	strb	r2, [r1, #2]
  ep->num   = ep_addr & 0x7FU;
 8001658:	700d      	strb	r5, [r1, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 800165a:	704b      	strb	r3, [r1, #1]
  
  
  __HAL_LOCK(hpcd); 
 800165c:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8001660:	4293      	cmp	r3, r2
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8001662:	4604      	mov	r4, r0
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
  
  
  __HAL_LOCK(hpcd); 
 8001664:	d00f      	beq.n	8001686 <HAL_PCD_EP_SetStall+0x54>
 8001666:	f880 2380 	strb.w	r2, [r0, #896]	; 0x380
  USB_EPSetStall(hpcd->Instance , ep);
 800166a:	6800      	ldr	r0, [r0, #0]
 800166c:	f002 f82e 	bl	80036cc <USB_EPSetStall>
  if((ep_addr & 0x7FU) == 0U)
 8001670:	b92d      	cbnz	r5, 800167e <HAL_PCD_EP_SetStall+0x4c>
  {
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8001672:	f504 7261 	add.w	r2, r4, #900	; 0x384
 8001676:	7c21      	ldrb	r1, [r4, #16]
 8001678:	6820      	ldr	r0, [r4, #0]
 800167a:	f002 f90d 	bl	8003898 <USB_EP0_OutStart>
  }
  __HAL_UNLOCK(hpcd); 
 800167e:	2000      	movs	r0, #0
 8001680:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  
  return HAL_OK;
 8001684:	bd38      	pop	{r3, r4, r5, pc}
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
  
  
  __HAL_LOCK(hpcd); 
 8001686:	2002      	movs	r0, #2
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 8001688:	bd38      	pop	{r3, r4, r5, pc}

0800168a <HAL_PCD_EP_ClrStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800168a:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 800168c:	b24b      	sxtb	r3, r1
 800168e:	2b00      	cmp	r3, #0
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8001690:	4605      	mov	r5, r0
 8001692:	f04f 021c 	mov.w	r2, #28
 8001696:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 800169a:	bfb5      	itete	lt
 800169c:	fb02 5100 	mlalt	r1, r2, r0, r5
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 80016a0:	fb02 5101 	mlage	r1, r2, r1, r5
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 80016a4:	3138      	addlt	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 80016a6:	f501 71ee 	addge.w	r1, r1, #476	; 0x1dc
  }
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80016aa:	0fdb      	lsrs	r3, r3, #31
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0U;
 80016ac:	2400      	movs	r4, #0
 80016ae:	708c      	strb	r4, [r1, #2]
  ep->num   = ep_addr & 0x7FU;
 80016b0:	7008      	strb	r0, [r1, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80016b2:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 80016b4:	f895 3380 	ldrb.w	r3, [r5, #896]	; 0x380
 80016b8:	2b01      	cmp	r3, #1
 80016ba:	d009      	beq.n	80016d0 <HAL_PCD_EP_ClrStall+0x46>
 80016bc:	2301      	movs	r3, #1
 80016be:	f885 3380 	strb.w	r3, [r5, #896]	; 0x380
  USB_EPClearStall(hpcd->Instance , ep);
 80016c2:	6828      	ldr	r0, [r5, #0]
 80016c4:	f002 f834 	bl	8003730 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 80016c8:	f885 4380 	strb.w	r4, [r5, #896]	; 0x380
    
  return HAL_OK;
 80016cc:	4620      	mov	r0, r4
 80016ce:	bd38      	pop	{r3, r4, r5, pc}
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
  
  __HAL_LOCK(hpcd); 
 80016d0:	2002      	movs	r0, #2
  USB_EPClearStall(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd); 
    
  return HAL_OK;
}
 80016d2:	bd38      	pop	{r3, r4, r5, pc}

080016d4 <HAL_PCD_EP_Flush>:
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  __HAL_LOCK(hpcd); 
 80016d4:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 80016d8:	2b01      	cmp	r3, #1
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 80016da:	b510      	push	{r4, lr}
 80016dc:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 80016de:	d011      	beq.n	8001704 <HAL_PCD_EP_Flush+0x30>
 80016e0:	2301      	movs	r3, #1
 80016e2:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  
  if ((ep_addr & 0x80U) == 0x80U)
 80016e6:	060b      	lsls	r3, r1, #24
 80016e8:	d505      	bpl.n	80016f6 <HAL_PCD_EP_Flush+0x22>
  {
    USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7FU);
 80016ea:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 80016ee:	6800      	ldr	r0, [r0, #0]
 80016f0:	f001 fd48 	bl	8003184 <USB_FlushTxFifo>
 80016f4:	e002      	b.n	80016fc <HAL_PCD_EP_Flush+0x28>
  }
  else
  {
    USB_FlushRxFifo(hpcd->Instance);
 80016f6:	6800      	ldr	r0, [r0, #0]
 80016f8:	f001 fd56 	bl	80031a8 <USB_FlushRxFifo>
  }
  
  __HAL_UNLOCK(hpcd); 
 80016fc:	2000      	movs	r0, #0
 80016fe:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
    
  return HAL_OK;
 8001702:	bd10      	pop	{r4, pc}
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  __HAL_LOCK(hpcd); 
 8001704:	2002      	movs	r0, #2
  }
  
  __HAL_UNLOCK(hpcd); 
    
  return HAL_OK;
}
 8001706:	bd10      	pop	{r4, pc}

08001708 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo: The number of Tx fifo
  * @param  size: Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8001708:	b570      	push	{r4, r5, r6, lr}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 800170a:	6804      	ldr	r4, [r0, #0]
 800170c:	6a60      	ldr	r0, [r4, #36]	; 0x24
  
  if(fifo == 0U)
 800170e:	b919      	cbnz	r1, 8001718 <HAL_PCDEx_SetTxFiFo+0x10>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
 8001710:	ea40 4302 	orr.w	r3, r0, r2, lsl #16
 8001714:	62a3      	str	r3, [r4, #40]	; 0x28
 8001716:	e016      	b.n	8001746 <HAL_PCDEx_SetTxFiFo+0x3e>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 8001718:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
 800171a:	2500      	movs	r5, #0
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 800171c:	eb00 4313 	add.w	r3, r0, r3, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8001720:	1e4e      	subs	r6, r1, #1
 8001722:	b2e8      	uxtb	r0, r5
 8001724:	4286      	cmp	r6, r0
 8001726:	f105 0501 	add.w	r5, r5, #1
 800172a:	d906      	bls.n	800173a <HAL_PCDEx_SetTxFiFo+0x32>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16U);
 800172c:	3040      	adds	r0, #64	; 0x40
 800172e:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8001732:	6840      	ldr	r0, [r0, #4]
 8001734:	eb03 4310 	add.w	r3, r3, r0, lsr #16
 8001738:	e7f3      	b.n	8001722 <HAL_PCDEx_SetTxFiFo+0x1a>
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);        
 800173a:	313f      	adds	r1, #63	; 0x3f
 800173c:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 8001740:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001744:	6063      	str	r3, [r4, #4]
  }
  
  return HAL_OK;
}
 8001746:	2000      	movs	r0, #0
 8001748:	bd70      	pop	{r4, r5, r6, pc}

0800174a <HAL_PCDEx_SetRxFiFo>:
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 800174a:	6803      	ldr	r3, [r0, #0]
  
  return HAL_OK;
}
 800174c:	2000      	movs	r0, #0
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 800174e:	6259      	str	r1, [r3, #36]	; 0x24
  
  return HAL_OK;
}
 8001750:	4770      	bx	lr
	...

08001754 <HAL_RCC_OscConfig>:
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001754:	6803      	ldr	r3, [r0, #0]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001756:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800175a:	4604      	mov	r4, r0
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800175c:	07d8      	lsls	r0, r3, #31
 800175e:	d403      	bmi.n	8001768 <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001760:	6823      	ldr	r3, [r4, #0]
 8001762:	0799      	lsls	r1, r3, #30
 8001764:	d437      	bmi.n	80017d6 <HAL_RCC_OscConfig+0x82>
 8001766:	e087      	b.n	8001878 <HAL_RCC_OscConfig+0x124>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001768:	4ba7      	ldr	r3, [pc, #668]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
 800176a:	689a      	ldr	r2, [r3, #8]
 800176c:	f002 020c 	and.w	r2, r2, #12
 8001770:	2a04      	cmp	r2, #4
 8001772:	d007      	beq.n	8001784 <HAL_RCC_OscConfig+0x30>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001774:	689a      	ldr	r2, [r3, #8]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001776:	f002 020c 	and.w	r2, r2, #12
 800177a:	2a08      	cmp	r2, #8
 800177c:	d10b      	bne.n	8001796 <HAL_RCC_OscConfig+0x42>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800177e:	685b      	ldr	r3, [r3, #4]
 8001780:	025a      	lsls	r2, r3, #9
 8001782:	d508      	bpl.n	8001796 <HAL_RCC_OscConfig+0x42>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001784:	4ba0      	ldr	r3, [pc, #640]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
 8001786:	681b      	ldr	r3, [r3, #0]
 8001788:	039b      	lsls	r3, r3, #14
 800178a:	d5e9      	bpl.n	8001760 <HAL_RCC_OscConfig+0xc>
 800178c:	6863      	ldr	r3, [r4, #4]
 800178e:	2b00      	cmp	r3, #0
 8001790:	d1e6      	bne.n	8001760 <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
 8001792:	2001      	movs	r0, #1
 8001794:	e134      	b.n	8001a00 <HAL_RCC_OscConfig+0x2ac>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001796:	4b9d      	ldr	r3, [pc, #628]	; (8001a0c <HAL_RCC_OscConfig+0x2b8>)
 8001798:	7922      	ldrb	r2, [r4, #4]
 800179a:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800179c:	6863      	ldr	r3, [r4, #4]
 800179e:	b16b      	cbz	r3, 80017bc <HAL_RCC_OscConfig+0x68>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80017a0:	f7ff f9b8 	bl	8000b14 <HAL_GetTick>
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80017a4:	4d98      	ldr	r5, [pc, #608]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80017a6:	4606      	mov	r6, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80017a8:	682b      	ldr	r3, [r5, #0]
 80017aa:	039f      	lsls	r7, r3, #14
 80017ac:	d4d8      	bmi.n	8001760 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80017ae:	f7ff f9b1 	bl	8000b14 <HAL_GetTick>
 80017b2:	1b80      	subs	r0, r0, r6
 80017b4:	2864      	cmp	r0, #100	; 0x64
 80017b6:	d9f7      	bls.n	80017a8 <HAL_RCC_OscConfig+0x54>
          {
            return HAL_TIMEOUT;
 80017b8:	2003      	movs	r0, #3
 80017ba:	e121      	b.n	8001a00 <HAL_RCC_OscConfig+0x2ac>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80017bc:	f7ff f9aa 	bl	8000b14 <HAL_GetTick>

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80017c0:	4d91      	ldr	r5, [pc, #580]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80017c2:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80017c4:	682b      	ldr	r3, [r5, #0]
 80017c6:	0398      	lsls	r0, r3, #14
 80017c8:	d5ca      	bpl.n	8001760 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80017ca:	f7ff f9a3 	bl	8000b14 <HAL_GetTick>
 80017ce:	1b80      	subs	r0, r0, r6
 80017d0:	2864      	cmp	r0, #100	; 0x64
 80017d2:	d9f7      	bls.n	80017c4 <HAL_RCC_OscConfig+0x70>
 80017d4:	e7f0      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80017d6:	4b8c      	ldr	r3, [pc, #560]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
 80017d8:	689a      	ldr	r2, [r3, #8]
 80017da:	f012 0f0c 	tst.w	r2, #12
 80017de:	d007      	beq.n	80017f0 <HAL_RCC_OscConfig+0x9c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80017e0:	689a      	ldr	r2, [r3, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80017e2:	f002 020c 	and.w	r2, r2, #12
 80017e6:	2a08      	cmp	r2, #8
 80017e8:	d117      	bne.n	800181a <HAL_RCC_OscConfig+0xc6>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80017ea:	685b      	ldr	r3, [r3, #4]
 80017ec:	0259      	lsls	r1, r3, #9
 80017ee:	d414      	bmi.n	800181a <HAL_RCC_OscConfig+0xc6>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80017f0:	4b85      	ldr	r3, [pc, #532]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
 80017f2:	681a      	ldr	r2, [r3, #0]
 80017f4:	0792      	lsls	r2, r2, #30
 80017f6:	d502      	bpl.n	80017fe <HAL_RCC_OscConfig+0xaa>
 80017f8:	68e2      	ldr	r2, [r4, #12]
 80017fa:	2a01      	cmp	r2, #1
 80017fc:	d1c9      	bne.n	8001792 <HAL_RCC_OscConfig+0x3e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80017fe:	681a      	ldr	r2, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001800:	21f8      	movs	r1, #248	; 0xf8
 8001802:	fa91 f1a1 	rbit	r1, r1
 8001806:	6920      	ldr	r0, [r4, #16]
 8001808:	fab1 f181 	clz	r1, r1
 800180c:	fa00 f101 	lsl.w	r1, r0, r1
 8001810:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8001814:	430a      	orrs	r2, r1
 8001816:	601a      	str	r2, [r3, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001818:	e02e      	b.n	8001878 <HAL_RCC_OscConfig+0x124>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800181a:	68e2      	ldr	r2, [r4, #12]
 800181c:	4b7c      	ldr	r3, [pc, #496]	; (8001a10 <HAL_RCC_OscConfig+0x2bc>)
 800181e:	b1ea      	cbz	r2, 800185c <HAL_RCC_OscConfig+0x108>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001820:	2201      	movs	r2, #1
 8001822:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001824:	f7ff f976 	bl	8000b14 <HAL_GetTick>

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001828:	4d77      	ldr	r5, [pc, #476]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800182a:	4606      	mov	r6, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800182c:	682b      	ldr	r3, [r5, #0]
 800182e:	4876      	ldr	r0, [pc, #472]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
 8001830:	079b      	lsls	r3, r3, #30
 8001832:	d405      	bmi.n	8001840 <HAL_RCC_OscConfig+0xec>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001834:	f7ff f96e 	bl	8000b14 <HAL_GetTick>
 8001838:	1b80      	subs	r0, r0, r6
 800183a:	2802      	cmp	r0, #2
 800183c:	d9f6      	bls.n	800182c <HAL_RCC_OscConfig+0xd8>
 800183e:	e7bb      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001840:	6803      	ldr	r3, [r0, #0]
 8001842:	22f8      	movs	r2, #248	; 0xf8
 8001844:	fa92 f2a2 	rbit	r2, r2
 8001848:	6921      	ldr	r1, [r4, #16]
 800184a:	fab2 f282 	clz	r2, r2
 800184e:	fa01 f202 	lsl.w	r2, r1, r2
 8001852:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001856:	4313      	orrs	r3, r2
 8001858:	6003      	str	r3, [r0, #0]
 800185a:	e00d      	b.n	8001878 <HAL_RCC_OscConfig+0x124>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800185c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800185e:	f7ff f959 	bl	8000b14 <HAL_GetTick>
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001862:	4d69      	ldr	r5, [pc, #420]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001864:	4606      	mov	r6, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001866:	682b      	ldr	r3, [r5, #0]
 8001868:	079f      	lsls	r7, r3, #30
 800186a:	d505      	bpl.n	8001878 <HAL_RCC_OscConfig+0x124>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800186c:	f7ff f952 	bl	8000b14 <HAL_GetTick>
 8001870:	1b80      	subs	r0, r0, r6
 8001872:	2802      	cmp	r0, #2
 8001874:	d9f7      	bls.n	8001866 <HAL_RCC_OscConfig+0x112>
 8001876:	e79f      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001878:	6823      	ldr	r3, [r4, #0]
 800187a:	071e      	lsls	r6, r3, #28
 800187c:	d403      	bmi.n	8001886 <HAL_RCC_OscConfig+0x132>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800187e:	6823      	ldr	r3, [r4, #0]
 8001880:	075d      	lsls	r5, r3, #29
 8001882:	d545      	bpl.n	8001910 <HAL_RCC_OscConfig+0x1bc>
 8001884:	e01f      	b.n	80018c6 <HAL_RCC_OscConfig+0x172>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001886:	6962      	ldr	r2, [r4, #20]
 8001888:	4b62      	ldr	r3, [pc, #392]	; (8001a14 <HAL_RCC_OscConfig+0x2c0>)
 800188a:	b172      	cbz	r2, 80018aa <HAL_RCC_OscConfig+0x156>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800188c:	2201      	movs	r2, #1
 800188e:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001890:	f7ff f940 	bl	8000b14 <HAL_GetTick>
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001894:	4d5c      	ldr	r5, [pc, #368]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001896:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001898:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800189a:	0798      	lsls	r0, r3, #30
 800189c:	d4ef      	bmi.n	800187e <HAL_RCC_OscConfig+0x12a>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800189e:	f7ff f939 	bl	8000b14 <HAL_GetTick>
 80018a2:	1b80      	subs	r0, r0, r6
 80018a4:	2802      	cmp	r0, #2
 80018a6:	d9f7      	bls.n	8001898 <HAL_RCC_OscConfig+0x144>
 80018a8:	e786      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80018aa:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80018ac:	f7ff f932 	bl	8000b14 <HAL_GetTick>
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80018b0:	4d55      	ldr	r5, [pc, #340]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80018b2:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80018b4:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80018b6:	0799      	lsls	r1, r3, #30
 80018b8:	d5e1      	bpl.n	800187e <HAL_RCC_OscConfig+0x12a>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80018ba:	f7ff f92b 	bl	8000b14 <HAL_GetTick>
 80018be:	1b80      	subs	r0, r0, r6
 80018c0:	2802      	cmp	r0, #2
 80018c2:	d9f7      	bls.n	80018b4 <HAL_RCC_OscConfig+0x160>
 80018c4:	e778      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80018c6:	2300      	movs	r3, #0
 80018c8:	9301      	str	r3, [sp, #4]
 80018ca:	4b4f      	ldr	r3, [pc, #316]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 80018cc:	4d52      	ldr	r5, [pc, #328]	; (8001a18 <HAL_RCC_OscConfig+0x2c4>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80018ce:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80018d0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80018d4:	641a      	str	r2, [r3, #64]	; 0x40
 80018d6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80018d8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80018dc:	9301      	str	r3, [sp, #4]
 80018de:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 80018e0:	682b      	ldr	r3, [r5, #0]
 80018e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80018e6:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 80018e8:	f7ff f914 	bl	8000b14 <HAL_GetTick>
 80018ec:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 80018ee:	682b      	ldr	r3, [r5, #0]
 80018f0:	05da      	lsls	r2, r3, #23
 80018f2:	d510      	bpl.n	8001916 <HAL_RCC_OscConfig+0x1c2>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80018f4:	4b49      	ldr	r3, [pc, #292]	; (8001a1c <HAL_RCC_OscConfig+0x2c8>)
 80018f6:	7a22      	ldrb	r2, [r4, #8]
 80018f8:	701a      	strb	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80018fa:	68a3      	ldr	r3, [r4, #8]
 80018fc:	b1bb      	cbz	r3, 800192e <HAL_RCC_OscConfig+0x1da>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80018fe:	f7ff f909 	bl	8000b14 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001902:	4d41      	ldr	r5, [pc, #260]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001904:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001906:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800190a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800190c:	079b      	lsls	r3, r3, #30
 800190e:	d508      	bpl.n	8001922 <HAL_RCC_OscConfig+0x1ce>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001910:	69a2      	ldr	r2, [r4, #24]
 8001912:	b9da      	cbnz	r2, 800194c <HAL_RCC_OscConfig+0x1f8>
 8001914:	e059      	b.n	80019ca <HAL_RCC_OscConfig+0x276>
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8001916:	f7ff f8fd 	bl	8000b14 <HAL_GetTick>
 800191a:	1b80      	subs	r0, r0, r6
 800191c:	2802      	cmp	r0, #2
 800191e:	d9e6      	bls.n	80018ee <HAL_RCC_OscConfig+0x19a>
 8001920:	e74a      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001922:	f7ff f8f7 	bl	8000b14 <HAL_GetTick>
 8001926:	1b80      	subs	r0, r0, r6
 8001928:	42b8      	cmp	r0, r7
 800192a:	d9ee      	bls.n	800190a <HAL_RCC_OscConfig+0x1b6>
 800192c:	e744      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800192e:	f7ff f8f1 	bl	8000b14 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001932:	4d35      	ldr	r5, [pc, #212]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001934:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001936:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800193a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800193c:	0798      	lsls	r0, r3, #30
 800193e:	d5e7      	bpl.n	8001910 <HAL_RCC_OscConfig+0x1bc>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001940:	f7ff f8e8 	bl	8000b14 <HAL_GetTick>
 8001944:	1b80      	subs	r0, r0, r6
 8001946:	42b8      	cmp	r0, r7
 8001948:	d9f7      	bls.n	800193a <HAL_RCC_OscConfig+0x1e6>
 800194a:	e735      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800194c:	4d2e      	ldr	r5, [pc, #184]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
 800194e:	68ab      	ldr	r3, [r5, #8]
 8001950:	f003 030c 	and.w	r3, r3, #12
 8001954:	2b08      	cmp	r3, #8
 8001956:	f43f af1c 	beq.w	8001792 <HAL_RCC_OscConfig+0x3e>
 800195a:	4e31      	ldr	r6, [pc, #196]	; (8001a20 <HAL_RCC_OscConfig+0x2cc>)
 800195c:	2300      	movs	r3, #0
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800195e:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001960:	6033      	str	r3, [r6, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001962:	d141      	bne.n	80019e8 <HAL_RCC_OscConfig+0x294>
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001964:	f7ff f8d6 	bl	8000b14 <HAL_GetTick>
 8001968:	4680      	mov	r8, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800196a:	682b      	ldr	r3, [r5, #0]
 800196c:	4f26      	ldr	r7, [pc, #152]	; (8001a08 <HAL_RCC_OscConfig+0x2b4>)
 800196e:	0199      	lsls	r1, r3, #6
 8001970:	d42d      	bmi.n	80019ce <HAL_RCC_OscConfig+0x27a>
 8001972:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8001976:	fa92 f2a2 	rbit	r2, r2
 800197a:	f44f 3340 	mov.w	r3, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800197e:	fab2 fe82 	clz	lr, r2
 8001982:	fa93 f3a3 	rbit	r3, r3
 8001986:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 800198a:	fab3 f583 	clz	r5, r3
 800198e:	fa92 f2a2 	rbit	r2, r2
 8001992:	69e0      	ldr	r0, [r4, #28]
 8001994:	6a23      	ldr	r3, [r4, #32]
 8001996:	fab2 f182 	clz	r1, r2
 800199a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800199c:	4303      	orrs	r3, r0
 800199e:	fa02 f20e 	lsl.w	r2, r2, lr
 80019a2:	ea43 0002 	orr.w	r0, r3, r2
 80019a6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80019a8:	085a      	lsrs	r2, r3, #1
 80019aa:	3a01      	subs	r2, #1
 80019ac:	fa02 f305 	lsl.w	r3, r2, r5
 80019b0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80019b2:	4303      	orrs	r3, r0
 80019b4:	408a      	lsls	r2, r1
 80019b6:	4313      	orrs	r3, r2
 80019b8:	607b      	str	r3, [r7, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 80019ba:	2301      	movs	r3, #1
 80019bc:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80019be:	f7ff f8a9 	bl	8000b14 <HAL_GetTick>
 80019c2:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80019c4:	683b      	ldr	r3, [r7, #0]
 80019c6:	019a      	lsls	r2, r3, #6
 80019c8:	d508      	bpl.n	80019dc <HAL_RCC_OscConfig+0x288>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80019ca:	2000      	movs	r0, #0
 80019cc:	e018      	b.n	8001a00 <HAL_RCC_OscConfig+0x2ac>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80019ce:	f7ff f8a1 	bl	8000b14 <HAL_GetTick>
 80019d2:	ebc8 0000 	rsb	r0, r8, r0
 80019d6:	2802      	cmp	r0, #2
 80019d8:	d9c7      	bls.n	800196a <HAL_RCC_OscConfig+0x216>
 80019da:	e6ed      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80019dc:	f7ff f89a 	bl	8000b14 <HAL_GetTick>
 80019e0:	1b00      	subs	r0, r0, r4
 80019e2:	2802      	cmp	r0, #2
 80019e4:	d9ee      	bls.n	80019c4 <HAL_RCC_OscConfig+0x270>
 80019e6:	e6e7      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80019e8:	f7ff f894 	bl	8000b14 <HAL_GetTick>
 80019ec:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80019ee:	682b      	ldr	r3, [r5, #0]
 80019f0:	019b      	lsls	r3, r3, #6
 80019f2:	d5ea      	bpl.n	80019ca <HAL_RCC_OscConfig+0x276>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80019f4:	f7ff f88e 	bl	8000b14 <HAL_GetTick>
 80019f8:	1b00      	subs	r0, r0, r4
 80019fa:	2802      	cmp	r0, #2
 80019fc:	d9f7      	bls.n	80019ee <HAL_RCC_OscConfig+0x29a>
 80019fe:	e6db      	b.n	80017b8 <HAL_RCC_OscConfig+0x64>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8001a00:	b002      	add	sp, #8
 8001a02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001a06:	bf00      	nop
 8001a08:	40023800 	.word	0x40023800
 8001a0c:	40023802 	.word	0x40023802
 8001a10:	42470000 	.word	0x42470000
 8001a14:	42470e80 	.word	0x42470e80
 8001a18:	40007000 	.word	0x40007000
 8001a1c:	40023870 	.word	0x40023870
 8001a20:	42470060 	.word	0x42470060

08001a24 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001a24:	491b      	ldr	r1, [pc, #108]	; (8001a94 <HAL_RCC_GetSysClockFreq+0x70>)
 8001a26:	688b      	ldr	r3, [r1, #8]
 8001a28:	f003 030c 	and.w	r3, r3, #12
 8001a2c:	2b04      	cmp	r3, #4
 8001a2e:	d02c      	beq.n	8001a8a <HAL_RCC_GetSysClockFreq+0x66>
 8001a30:	2b08      	cmp	r3, #8
 8001a32:	d12c      	bne.n	8001a8e <HAL_RCC_GetSysClockFreq+0x6a>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001a34:	6848      	ldr	r0, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001a36:	684b      	ldr	r3, [r1, #4]
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001a38:	f000 003f 	and.w	r0, r0, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8001a3c:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001a40:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8001a44:	684b      	ldr	r3, [r1, #4]
 8001a46:	fa92 f2a2 	rbit	r2, r2
 8001a4a:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8001a4e:	fab2 f282 	clz	r2, r2
 8001a52:	ea01 0103 	and.w	r1, r1, r3
 8001a56:	fa21 f102 	lsr.w	r1, r1, r2
 8001a5a:	bf14      	ite	ne
 8001a5c:	4a0e      	ldrne	r2, [pc, #56]	; (8001a98 <HAL_RCC_GetSysClockFreq+0x74>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8001a5e:	4a0f      	ldreq	r2, [pc, #60]	; (8001a9c <HAL_RCC_GetSysClockFreq+0x78>)
 8001a60:	fbb2 f0f0 	udiv	r0, r2, r0
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8001a64:	4a0b      	ldr	r2, [pc, #44]	; (8001a94 <HAL_RCC_GetSysClockFreq+0x70>)
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8001a66:	fb00 f301 	mul.w	r3, r0, r1
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8001a6a:	6852      	ldr	r2, [r2, #4]
 8001a6c:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8001a70:	fa90 f0a0 	rbit	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8001a74:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8001a78:	fab0 f080 	clz	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8001a7c:	fa22 f000 	lsr.w	r0, r2, r0
 8001a80:	3001      	adds	r0, #1
 8001a82:	0040      	lsls	r0, r0, #1
 8001a84:	fbb3 f0f0 	udiv	r0, r3, r0
 8001a88:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8001a8a:	4803      	ldr	r0, [pc, #12]	; (8001a98 <HAL_RCC_GetSysClockFreq+0x74>)
 8001a8c:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8001a8e:	4803      	ldr	r0, [pc, #12]	; (8001a9c <HAL_RCC_GetSysClockFreq+0x78>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001a90:	4770      	bx	lr
 8001a92:	bf00      	nop
 8001a94:	40023800 	.word	0x40023800
 8001a98:	007a1200 	.word	0x007a1200
 8001a9c:	00f42400 	.word	0x00f42400

08001aa0 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001aa0:	4b55      	ldr	r3, [pc, #340]	; (8001bf8 <HAL_RCC_ClockConfig+0x158>)
 8001aa2:	681a      	ldr	r2, [r3, #0]
 8001aa4:	f002 020f 	and.w	r2, r2, #15
 8001aa8:	428a      	cmp	r2, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001aaa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001aae:	4605      	mov	r5, r0
 8001ab0:	460e      	mov	r6, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001ab2:	d30a      	bcc.n	8001aca <HAL_RCC_ClockConfig+0x2a>
      return HAL_ERROR;
    }
  }
 
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001ab4:	6829      	ldr	r1, [r5, #0]
 8001ab6:	0788      	lsls	r0, r1, #30
 8001ab8:	d511      	bpl.n	8001ade <HAL_RCC_ClockConfig+0x3e>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001aba:	4850      	ldr	r0, [pc, #320]	; (8001bfc <HAL_RCC_ClockConfig+0x15c>)
 8001abc:	6883      	ldr	r3, [r0, #8]
 8001abe:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001ac2:	68ab      	ldr	r3, [r5, #8]
 8001ac4:	4313      	orrs	r3, r2
 8001ac6:	6083      	str	r3, [r0, #8]
 8001ac8:	e009      	b.n	8001ade <HAL_RCC_ClockConfig+0x3e>
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001aca:	b2ca      	uxtb	r2, r1
 8001acc:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001ace:	681b      	ldr	r3, [r3, #0]
 8001ad0:	f003 030f 	and.w	r3, r3, #15
 8001ad4:	4299      	cmp	r1, r3
 8001ad6:	d0ed      	beq.n	8001ab4 <HAL_RCC_ClockConfig+0x14>
    {
      return HAL_ERROR;
 8001ad8:	2001      	movs	r0, #1
 8001ada:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001ade:	07c9      	lsls	r1, r1, #31
 8001ae0:	d406      	bmi.n	8001af0 <HAL_RCC_ClockConfig+0x50>
      }
    }
  }    
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8001ae2:	4b45      	ldr	r3, [pc, #276]	; (8001bf8 <HAL_RCC_ClockConfig+0x158>)
 8001ae4:	681a      	ldr	r2, [r3, #0]
 8001ae6:	f002 020f 	and.w	r2, r2, #15
 8001aea:	4296      	cmp	r6, r2
 8001aec:	d351      	bcc.n	8001b92 <HAL_RCC_ClockConfig+0xf2>
 8001aee:	e057      	b.n	8001ba0 <HAL_RCC_ClockConfig+0x100>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001af0:	686b      	ldr	r3, [r5, #4]
 8001af2:	4a42      	ldr	r2, [pc, #264]	; (8001bfc <HAL_RCC_ClockConfig+0x15c>)
 8001af4:	2b01      	cmp	r3, #1
 8001af6:	d103      	bne.n	8001b00 <HAL_RCC_ClockConfig+0x60>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001af8:	6812      	ldr	r2, [r2, #0]
 8001afa:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8001afe:	e008      	b.n	8001b12 <HAL_RCC_ClockConfig+0x72>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8001b00:	1e99      	subs	r1, r3, #2
 8001b02:	2901      	cmp	r1, #1
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001b04:	6812      	ldr	r2, [r2, #0]
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8001b06:	d802      	bhi.n	8001b0e <HAL_RCC_ClockConfig+0x6e>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001b08:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8001b0c:	e001      	b.n	8001b12 <HAL_RCC_ClockConfig+0x72>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001b0e:	f012 0f02 	tst.w	r2, #2
 8001b12:	d0e1      	beq.n	8001ad8 <HAL_RCC_ClockConfig+0x38>
      {
        return HAL_ERROR;
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001b14:	4c39      	ldr	r4, [pc, #228]	; (8001bfc <HAL_RCC_ClockConfig+0x15c>)
 8001b16:	68a2      	ldr	r2, [r4, #8]
 8001b18:	f022 0203 	bic.w	r2, r2, #3
 8001b1c:	4313      	orrs	r3, r2
 8001b1e:	60a3      	str	r3, [r4, #8]
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001b20:	f7fe fff8 	bl	8000b14 <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001b24:	686b      	ldr	r3, [r5, #4]
 8001b26:	2b01      	cmp	r3, #1
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001b28:	4607      	mov	r7, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001b2a:	f241 3888 	movw	r8, #5000	; 0x1388
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001b2e:	d10c      	bne.n	8001b4a <HAL_RCC_ClockConfig+0xaa>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8001b30:	68a3      	ldr	r3, [r4, #8]
 8001b32:	f003 030c 	and.w	r3, r3, #12
 8001b36:	2b04      	cmp	r3, #4
 8001b38:	d0d3      	beq.n	8001ae2 <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001b3a:	f7fe ffeb 	bl	8000b14 <HAL_GetTick>
 8001b3e:	1bc0      	subs	r0, r0, r7
 8001b40:	4540      	cmp	r0, r8
 8001b42:	d9f5      	bls.n	8001b30 <HAL_RCC_ClockConfig+0x90>
        {
          return HAL_TIMEOUT;
 8001b44:	2003      	movs	r0, #3
 8001b46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001b4a:	2b02      	cmp	r3, #2
 8001b4c:	d10a      	bne.n	8001b64 <HAL_RCC_ClockConfig+0xc4>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001b4e:	68a3      	ldr	r3, [r4, #8]
 8001b50:	f003 030c 	and.w	r3, r3, #12
 8001b54:	2b08      	cmp	r3, #8
 8001b56:	d0c4      	beq.n	8001ae2 <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001b58:	f7fe ffdc 	bl	8000b14 <HAL_GetTick>
 8001b5c:	1bc0      	subs	r0, r0, r7
 8001b5e:	4540      	cmp	r0, r8
 8001b60:	d9f5      	bls.n	8001b4e <HAL_RCC_ClockConfig+0xae>
 8001b62:	e7ef      	b.n	8001b44 <HAL_RCC_ClockConfig+0xa4>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 8001b64:	2b03      	cmp	r3, #3
 8001b66:	d10f      	bne.n	8001b88 <HAL_RCC_ClockConfig+0xe8>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 8001b68:	68a3      	ldr	r3, [r4, #8]
 8001b6a:	f003 030c 	and.w	r3, r3, #12
 8001b6e:	2b0c      	cmp	r3, #12
 8001b70:	d0b7      	beq.n	8001ae2 <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001b72:	f7fe ffcf 	bl	8000b14 <HAL_GetTick>
 8001b76:	1bc0      	subs	r0, r0, r7
 8001b78:	4540      	cmp	r0, r8
 8001b7a:	d9f5      	bls.n	8001b68 <HAL_RCC_ClockConfig+0xc8>
 8001b7c:	e7e2      	b.n	8001b44 <HAL_RCC_ClockConfig+0xa4>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001b7e:	f7fe ffc9 	bl	8000b14 <HAL_GetTick>
 8001b82:	1bc0      	subs	r0, r0, r7
 8001b84:	4540      	cmp	r0, r8
 8001b86:	d8dd      	bhi.n	8001b44 <HAL_RCC_ClockConfig+0xa4>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8001b88:	68a3      	ldr	r3, [r4, #8]
 8001b8a:	f013 0f0c 	tst.w	r3, #12
 8001b8e:	d1f6      	bne.n	8001b7e <HAL_RCC_ClockConfig+0xde>
 8001b90:	e7a7      	b.n	8001ae2 <HAL_RCC_ClockConfig+0x42>
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  { 
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001b92:	b2f2      	uxtb	r2, r6
 8001b94:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8001b96:	681b      	ldr	r3, [r3, #0]
 8001b98:	f003 030f 	and.w	r3, r3, #15
 8001b9c:	429e      	cmp	r6, r3
 8001b9e:	d19b      	bne.n	8001ad8 <HAL_RCC_ClockConfig+0x38>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001ba0:	6829      	ldr	r1, [r5, #0]
 8001ba2:	074a      	lsls	r2, r1, #29
 8001ba4:	d506      	bpl.n	8001bb4 <HAL_RCC_ClockConfig+0x114>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001ba6:	4815      	ldr	r0, [pc, #84]	; (8001bfc <HAL_RCC_ClockConfig+0x15c>)
 8001ba8:	6883      	ldr	r3, [r0, #8]
 8001baa:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8001bae:	68eb      	ldr	r3, [r5, #12]
 8001bb0:	4313      	orrs	r3, r2
 8001bb2:	6083      	str	r3, [r0, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001bb4:	070b      	lsls	r3, r1, #28
 8001bb6:	d507      	bpl.n	8001bc8 <HAL_RCC_ClockConfig+0x128>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001bb8:	4a10      	ldr	r2, [pc, #64]	; (8001bfc <HAL_RCC_ClockConfig+0x15c>)
 8001bba:	6929      	ldr	r1, [r5, #16]
 8001bbc:	6893      	ldr	r3, [r2, #8]
 8001bbe:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001bc2:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001bc6:	6093      	str	r3, [r2, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8001bc8:	f7ff ff2c 	bl	8001a24 <HAL_RCC_GetSysClockFreq>
 8001bcc:	4b0b      	ldr	r3, [pc, #44]	; (8001bfc <HAL_RCC_ClockConfig+0x15c>)
 8001bce:	22f0      	movs	r2, #240	; 0xf0
 8001bd0:	689b      	ldr	r3, [r3, #8]
 8001bd2:	fa92 f2a2 	rbit	r2, r2
 8001bd6:	fab2 f282 	clz	r2, r2
 8001bda:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001bde:	40d3      	lsrs	r3, r2
 8001be0:	4a07      	ldr	r2, [pc, #28]	; (8001c00 <HAL_RCC_ClockConfig+0x160>)
 8001be2:	5cd3      	ldrb	r3, [r2, r3]
 8001be4:	40d8      	lsrs	r0, r3
 8001be6:	4b07      	ldr	r3, [pc, #28]	; (8001c04 <HAL_RCC_ClockConfig+0x164>)
 8001be8:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8001bea:	2000      	movs	r0, #0
 8001bec:	f7fe ff5c 	bl	8000aa8 <HAL_InitTick>
  
  return HAL_OK;
 8001bf0:	2000      	movs	r0, #0
}
 8001bf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001bf6:	bf00      	nop
 8001bf8:	40023c00 	.word	0x40023c00
 8001bfc:	40023800 	.word	0x40023800
 8001c00:	080071a4 	.word	0x080071a4
 8001c04:	20000054 	.word	0x20000054

08001c08 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8001c08:	4b01      	ldr	r3, [pc, #4]	; (8001c10 <HAL_RCC_GetHCLKFreq+0x8>)
 8001c0a:	6818      	ldr	r0, [r3, #0]
 8001c0c:	4770      	bx	lr
 8001c0e:	bf00      	nop
 8001c10:	20000054 	.word	0x20000054

08001c14 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8001c14:	4b08      	ldr	r3, [pc, #32]	; (8001c38 <HAL_RCC_GetPCLK1Freq+0x24>)
 8001c16:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
 8001c1a:	689b      	ldr	r3, [r3, #8]
 8001c1c:	fa92 f2a2 	rbit	r2, r2
 8001c20:	fab2 f282 	clz	r2, r2
 8001c24:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8001c28:	40d3      	lsrs	r3, r2
 8001c2a:	4a04      	ldr	r2, [pc, #16]	; (8001c3c <HAL_RCC_GetPCLK1Freq+0x28>)
 8001c2c:	5cd3      	ldrb	r3, [r2, r3]
 8001c2e:	4a04      	ldr	r2, [pc, #16]	; (8001c40 <HAL_RCC_GetPCLK1Freq+0x2c>)
 8001c30:	6810      	ldr	r0, [r2, #0]
}
 8001c32:	40d8      	lsrs	r0, r3
 8001c34:	4770      	bx	lr
 8001c36:	bf00      	nop
 8001c38:	40023800 	.word	0x40023800
 8001c3c:	080071a4 	.word	0x080071a4
 8001c40:	20000054 	.word	0x20000054

08001c44 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8001c44:	4b08      	ldr	r3, [pc, #32]	; (8001c68 <HAL_RCC_GetPCLK2Freq+0x24>)
 8001c46:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 8001c4a:	689b      	ldr	r3, [r3, #8]
 8001c4c:	fa92 f2a2 	rbit	r2, r2
 8001c50:	fab2 f282 	clz	r2, r2
 8001c54:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8001c58:	40d3      	lsrs	r3, r2
 8001c5a:	4a04      	ldr	r2, [pc, #16]	; (8001c6c <HAL_RCC_GetPCLK2Freq+0x28>)
 8001c5c:	5cd3      	ldrb	r3, [r2, r3]
 8001c5e:	4a04      	ldr	r2, [pc, #16]	; (8001c70 <HAL_RCC_GetPCLK2Freq+0x2c>)
 8001c60:	6810      	ldr	r0, [r2, #0]
} 
 8001c62:	40d8      	lsrs	r0, r3
 8001c64:	4770      	bx	lr
 8001c66:	bf00      	nop
 8001c68:	40023800 	.word	0x40023800
 8001c6c:	080071a4 	.word	0x080071a4
 8001c70:	20000054 	.word	0x20000054

08001c74 <SD_CmdResp2Error>:
  */
static HAL_SD_ErrorTypedef SD_CmdResp2Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8001c74:	6803      	ldr	r3, [r0, #0]
 8001c76:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001c78:	f012 0f45 	tst.w	r2, #69	; 0x45
 8001c7c:	d0fb      	beq.n	8001c76 <SD_CmdResp2Error+0x2>
  {
  }
    
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8001c7e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001c80:	0752      	lsls	r2, r2, #29
 8001c82:	d503      	bpl.n	8001c8c <SD_CmdResp2Error+0x18>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8001c84:	2204      	movs	r2, #4
 8001c86:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8001c88:	2003      	movs	r0, #3
 8001c8a:	4770      	bx	lr
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8001c8c:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8001c8e:	f010 0001 	ands.w	r0, r0, #1
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8001c92:	bf15      	itete	ne
 8001c94:	2001      	movne	r0, #1
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001c96:	f240 52ff 	movweq	r2, #1535	; 0x5ff
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8001c9a:	6398      	strne	r0, [r3, #56]	; 0x38
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001c9c:	639a      	streq	r2, [r3, #56]	; 0x38
  
  return errorstate;
}
 8001c9e:	4770      	bx	lr

08001ca0 <SD_IsCardProgramming>:
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8001ca0:	b570      	push	{r4, r5, r6, lr}
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001ca2:	6a43      	ldr	r3, [r0, #36]	; 0x24
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8001ca4:	b086      	sub	sp, #24
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8001ca6:	041b      	lsls	r3, r3, #16
 8001ca8:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8001caa:	230d      	movs	r3, #13
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8001cac:	4605      	mov	r5, r0
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8001cae:	9302      	str	r3, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001cb0:	2340      	movs	r3, #64	; 0x40
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
 8001cb2:	2200      	movs	r2, #0
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8001cb4:	9303      	str	r3, [sp, #12]
  * @param  hsd: SD handle
  * @param  pStatus: pointer to the variable that will contain the SD card state  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
 8001cb6:	460e      	mov	r6, r1
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001cb8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001cbc:	a901      	add	r1, sp, #4
 8001cbe:	6800      	ldr	r0, [r0, #0]
  */
static HAL_SD_ErrorTypedef SD_IsCardProgramming(SD_HandleTypeDef *hsd, uint8_t *pStatus)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  __IO uint32_t responseR1 = 0U;
 8001cc0:	9200      	str	r2, [sp, #0]
  
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8001cc2:	9204      	str	r2, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8001cc4:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8001cc6:	f001 f934 	bl	8002f32 <SDIO_SendCommand>
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8001cca:	6828      	ldr	r0, [r5, #0]
 8001ccc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001cce:	f013 0f45 	tst.w	r3, #69	; 0x45
 8001cd2:	d0fb      	beq.n	8001ccc <SD_IsCardProgramming+0x2c>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8001cd4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001cd6:	075b      	lsls	r3, r3, #29
 8001cd8:	d503      	bpl.n	8001ce2 <SD_IsCardProgramming+0x42>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8001cda:	2304      	movs	r3, #4
 8001cdc:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8001cde:	2003      	movs	r0, #3
 8001ce0:	e07c      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8001ce2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001ce4:	f013 0401 	ands.w	r4, r3, #1
 8001ce8:	d003      	beq.n	8001cf2 <SD_IsCardProgramming+0x52>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8001cea:	2301      	movs	r3, #1
 8001cec:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8001cee:	4618      	mov	r0, r3
 8001cf0:	e074      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  {
    /* No error flag set */
  }
  
  /* Check response received is of desired command */
  if((uint32_t)SDIO_GetCommandResponse(hsd->Instance) != SD_CMD_SEND_STATUS)
 8001cf2:	f001 f931 	bl	8002f58 <SDIO_GetCommandResponse>
 8001cf6:	280d      	cmp	r0, #13
 8001cf8:	d001      	beq.n	8001cfe <SD_IsCardProgramming+0x5e>
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 8001cfa:	2010      	movs	r0, #16
 8001cfc:	e06e      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001cfe:	682b      	ldr	r3, [r5, #0]
 8001d00:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001d04:	639a      	str	r2, [r3, #56]	; 0x38
  
  
  /* We have received response, retrieve it for analysis */
  responseR1 = SDIO_GetResponse(SDIO_RESP1);
 8001d06:	4620      	mov	r0, r4
 8001d08:	f001 f92a 	bl	8002f60 <SDIO_GetResponse>
 8001d0c:	9000      	str	r0, [sp, #0]
  
  /* Find out card status */
  *pStatus = (uint8_t)((responseR1 >> 9U) & 0x0000000FU);
 8001d0e:	9b00      	ldr	r3, [sp, #0]
  
  if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8001d10:	4833      	ldr	r0, [pc, #204]	; (8001de0 <SD_IsCardProgramming+0x140>)
  
  /* We have received response, retrieve it for analysis */
  responseR1 = SDIO_GetResponse(SDIO_RESP1);
  
  /* Find out card status */
  *pStatus = (uint8_t)((responseR1 >> 9U) & 0x0000000FU);
 8001d12:	f3c3 2343 	ubfx	r3, r3, #9, #4
 8001d16:	7033      	strb	r3, [r6, #0]
  
  if((responseR1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8001d18:	9b00      	ldr	r3, [sp, #0]
 8001d1a:	4018      	ands	r0, r3
 8001d1c:	2800      	cmp	r0, #0
 8001d1e:	d05d      	beq.n	8001ddc <SD_IsCardProgramming+0x13c>
  {
    return errorstate;
  }
  
  if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
 8001d20:	9b00      	ldr	r3, [sp, #0]
 8001d22:	2b00      	cmp	r3, #0
 8001d24:	db39      	blt.n	8001d9a <SD_IsCardProgramming+0xfa>
  {
    return(SD_ADDR_OUT_OF_RANGE);
  }
  
  if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
 8001d26:	9b00      	ldr	r3, [sp, #0]
 8001d28:	005d      	lsls	r5, r3, #1
 8001d2a:	d438      	bmi.n	8001d9e <SD_IsCardProgramming+0xfe>
  {
    return(SD_ADDR_MISALIGNED);
  }
  
  if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
 8001d2c:	9b00      	ldr	r3, [sp, #0]
 8001d2e:	009c      	lsls	r4, r3, #2
 8001d30:	d437      	bmi.n	8001da2 <SD_IsCardProgramming+0x102>
  {
    return(SD_BLOCK_LEN_ERR);
  }
  
  if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
 8001d32:	9b00      	ldr	r3, [sp, #0]
 8001d34:	00d9      	lsls	r1, r3, #3
 8001d36:	d436      	bmi.n	8001da6 <SD_IsCardProgramming+0x106>
  {
    return(SD_ERASE_SEQ_ERR);
  }
  
  if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
 8001d38:	9b00      	ldr	r3, [sp, #0]
 8001d3a:	011a      	lsls	r2, r3, #4
 8001d3c:	d435      	bmi.n	8001daa <SD_IsCardProgramming+0x10a>
  {
    return(SD_BAD_ERASE_PARAM);
  }
  
  if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
 8001d3e:	9b00      	ldr	r3, [sp, #0]
 8001d40:	015b      	lsls	r3, r3, #5
 8001d42:	d434      	bmi.n	8001dae <SD_IsCardProgramming+0x10e>
  {
    return(SD_WRITE_PROT_VIOLATION);
  }
  
  if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
 8001d44:	9b00      	ldr	r3, [sp, #0]
 8001d46:	01de      	lsls	r6, r3, #7
 8001d48:	d433      	bmi.n	8001db2 <SD_IsCardProgramming+0x112>
  {
    return(SD_LOCK_UNLOCK_FAILED);
  }
  
  if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
 8001d4a:	9b00      	ldr	r3, [sp, #0]
 8001d4c:	021d      	lsls	r5, r3, #8
 8001d4e:	d432      	bmi.n	8001db6 <SD_IsCardProgramming+0x116>
  {
    return(SD_COM_CRC_FAILED);
  }
  
  if((responseR1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
 8001d50:	9b00      	ldr	r3, [sp, #0]
 8001d52:	025c      	lsls	r4, r3, #9
 8001d54:	d4d1      	bmi.n	8001cfa <SD_IsCardProgramming+0x5a>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
 8001d56:	9b00      	ldr	r3, [sp, #0]
 8001d58:	0299      	lsls	r1, r3, #10
 8001d5a:	d42e      	bmi.n	8001dba <SD_IsCardProgramming+0x11a>
  {
    return(SD_CARD_ECC_FAILED);
  }
  
  if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
 8001d5c:	9b00      	ldr	r3, [sp, #0]
 8001d5e:	02da      	lsls	r2, r3, #11
 8001d60:	d42d      	bmi.n	8001dbe <SD_IsCardProgramming+0x11e>
  {
    return(SD_CC_ERROR);
  }
  
  if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
 8001d62:	9b00      	ldr	r3, [sp, #0]
 8001d64:	031b      	lsls	r3, r3, #12
 8001d66:	d42c      	bmi.n	8001dc2 <SD_IsCardProgramming+0x122>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
 8001d68:	9b00      	ldr	r3, [sp, #0]
 8001d6a:	035e      	lsls	r6, r3, #13
 8001d6c:	d42b      	bmi.n	8001dc6 <SD_IsCardProgramming+0x126>
  {
    return(SD_STREAM_READ_UNDERRUN);
  }
  
  if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
 8001d6e:	9b00      	ldr	r3, [sp, #0]
 8001d70:	039d      	lsls	r5, r3, #14
 8001d72:	d42a      	bmi.n	8001dca <SD_IsCardProgramming+0x12a>
  {
    return(SD_STREAM_WRITE_OVERRUN);
  }
  
  if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
 8001d74:	9b00      	ldr	r3, [sp, #0]
 8001d76:	03dc      	lsls	r4, r3, #15
 8001d78:	d429      	bmi.n	8001dce <SD_IsCardProgramming+0x12e>
  {
    return(SD_CID_CSD_OVERWRITE);
  }
  
  if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
 8001d7a:	9b00      	ldr	r3, [sp, #0]
 8001d7c:	0419      	lsls	r1, r3, #16
 8001d7e:	d428      	bmi.n	8001dd2 <SD_IsCardProgramming+0x132>
  {
    return(SD_WP_ERASE_SKIP);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
 8001d80:	9b00      	ldr	r3, [sp, #0]
 8001d82:	045a      	lsls	r2, r3, #17
 8001d84:	d427      	bmi.n	8001dd6 <SD_IsCardProgramming+0x136>
  {
    return(SD_CARD_ECC_DISABLED);
  }
  
  if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
 8001d86:	9b00      	ldr	r3, [sp, #0]
 8001d88:	049b      	lsls	r3, r3, #18
 8001d8a:	d426      	bmi.n	8001dda <SD_IsCardProgramming+0x13a>
  {
    return(SD_ERASE_RESET);
  }
  
  if((responseR1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
 8001d8c:	9b00      	ldr	r3, [sp, #0]
  {
    return(SD_AKE_SEQ_ERROR);
 8001d8e:	f013 0f08 	tst.w	r3, #8
 8001d92:	bf0c      	ite	eq
 8001d94:	2000      	moveq	r0, #0
 8001d96:	201a      	movne	r0, #26
 8001d98:	e020      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
    return errorstate;
  }
  
  if((responseR1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
  {
    return(SD_ADDR_OUT_OF_RANGE);
 8001d9a:	201c      	movs	r0, #28
 8001d9c:	e01e      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
  {
    return(SD_ADDR_MISALIGNED);
 8001d9e:	2009      	movs	r0, #9
 8001da0:	e01c      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
  {
    return(SD_BLOCK_LEN_ERR);
 8001da2:	200a      	movs	r0, #10
 8001da4:	e01a      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
  {
    return(SD_ERASE_SEQ_ERR);
 8001da6:	200b      	movs	r0, #11
 8001da8:	e018      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
  {
    return(SD_BAD_ERASE_PARAM);
 8001daa:	200c      	movs	r0, #12
 8001dac:	e016      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
  {
    return(SD_WRITE_PROT_VIOLATION);
 8001dae:	200d      	movs	r0, #13
 8001db0:	e014      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
  {
    return(SD_LOCK_UNLOCK_FAILED);
 8001db2:	200e      	movs	r0, #14
 8001db4:	e012      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8001db6:	200f      	movs	r0, #15
 8001db8:	e010      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
    return(SD_ILLEGAL_CMD);
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
  {
    return(SD_CARD_ECC_FAILED);
 8001dba:	2011      	movs	r0, #17
 8001dbc:	e00e      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
  {
    return(SD_CC_ERROR);
 8001dbe:	2012      	movs	r0, #18
 8001dc0:	e00c      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8001dc2:	2013      	movs	r0, #19
 8001dc4:	e00a      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
  {
    return(SD_STREAM_READ_UNDERRUN);
 8001dc6:	2014      	movs	r0, #20
 8001dc8:	e008      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
  {
    return(SD_STREAM_WRITE_OVERRUN);
 8001dca:	2015      	movs	r0, #21
 8001dcc:	e006      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
  {
    return(SD_CID_CSD_OVERWRITE);
 8001dce:	2016      	movs	r0, #22
 8001dd0:	e004      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
  {
    return(SD_WP_ERASE_SKIP);
 8001dd2:	2017      	movs	r0, #23
 8001dd4:	e002      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
  {
    return(SD_CARD_ECC_DISABLED);
 8001dd6:	2018      	movs	r0, #24
 8001dd8:	e000      	b.n	8001ddc <SD_IsCardProgramming+0x13c>
  }
  
  if((responseR1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
  {
    return(SD_ERASE_RESET);
 8001dda:	2019      	movs	r0, #25
  {
    return(SD_AKE_SEQ_ERROR);
  }
  
  return errorstate;
}   
 8001ddc:	b006      	add	sp, #24
 8001dde:	bd70      	pop	{r4, r5, r6, pc}
 8001de0:	fdffe008 	.word	0xfdffe008

08001de4 <SD_CmdResp1Error>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
{
 8001de4:	b570      	push	{r4, r5, r6, lr}
 8001de6:	4605      	mov	r5, r0
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8001de8:	6800      	ldr	r0, [r0, #0]
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
{
 8001dea:	460e      	mov	r6, r1
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8001dec:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001dee:	f013 0f45 	tst.w	r3, #69	; 0x45
 8001df2:	d0fb      	beq.n	8001dec <SD_CmdResp1Error+0x8>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8001df4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001df6:	075b      	lsls	r3, r3, #29
 8001df8:	d503      	bpl.n	8001e02 <SD_CmdResp1Error+0x1e>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8001dfa:	2304      	movs	r3, #4
 8001dfc:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8001dfe:	2003      	movs	r0, #3
 8001e00:	bd70      	pop	{r4, r5, r6, pc}
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8001e02:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001e04:	f013 0401 	ands.w	r4, r3, #1
 8001e08:	d002      	beq.n	8001e10 <SD_CmdResp1Error+0x2c>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8001e0a:	2301      	movs	r3, #1
 8001e0c:	6383      	str	r3, [r0, #56]	; 0x38
 8001e0e:	e039      	b.n	8001e84 <SD_CmdResp1Error+0xa0>
    
    return errorstate;
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 8001e10:	f001 f8a2 	bl	8002f58 <SDIO_GetCommandResponse>
 8001e14:	42b0      	cmp	r0, r6
 8001e16:	d001      	beq.n	8001e1c <SD_CmdResp1Error+0x38>
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 8001e18:	2010      	movs	r0, #16
 8001e1a:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8001e1c:	682b      	ldr	r3, [r5, #0]
 8001e1e:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8001e22:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 8001e24:	4620      	mov	r0, r4
 8001e26:	f001 f89b 	bl	8002f60 <SDIO_GetResponse>
  
  if((response_r1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8001e2a:	4b28      	ldr	r3, [pc, #160]	; (8001ecc <SD_CmdResp1Error+0xe8>)
 8001e2c:	4003      	ands	r3, r0
 8001e2e:	b34b      	cbz	r3, 8001e84 <SD_CmdResp1Error+0xa0>
  {
    return errorstate;
  }
  
  if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
 8001e30:	2800      	cmp	r0, #0
 8001e32:	db29      	blt.n	8001e88 <SD_CmdResp1Error+0xa4>
  {
    return(SD_ADDR_OUT_OF_RANGE);
  }
  
  if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
 8001e34:	0045      	lsls	r5, r0, #1
 8001e36:	d429      	bmi.n	8001e8c <SD_CmdResp1Error+0xa8>
  {
    return(SD_ADDR_MISALIGNED);
  }
  
  if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
 8001e38:	0084      	lsls	r4, r0, #2
 8001e3a:	d429      	bmi.n	8001e90 <SD_CmdResp1Error+0xac>
  {
    return(SD_BLOCK_LEN_ERR);
  }
  
  if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
 8001e3c:	00c1      	lsls	r1, r0, #3
 8001e3e:	d429      	bmi.n	8001e94 <SD_CmdResp1Error+0xb0>
  {
    return(SD_ERASE_SEQ_ERR);
  }
  
  if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
 8001e40:	0102      	lsls	r2, r0, #4
 8001e42:	d429      	bmi.n	8001e98 <SD_CmdResp1Error+0xb4>
  {
    return(SD_BAD_ERASE_PARAM);
  }
  
  if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
 8001e44:	0143      	lsls	r3, r0, #5
 8001e46:	d429      	bmi.n	8001e9c <SD_CmdResp1Error+0xb8>
  {
    return(SD_WRITE_PROT_VIOLATION);
  }
  
  if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
 8001e48:	01c6      	lsls	r6, r0, #7
 8001e4a:	d429      	bmi.n	8001ea0 <SD_CmdResp1Error+0xbc>
  {
    return(SD_LOCK_UNLOCK_FAILED);
  }
  
  if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
 8001e4c:	0205      	lsls	r5, r0, #8
 8001e4e:	d429      	bmi.n	8001ea4 <SD_CmdResp1Error+0xc0>
  {
    return(SD_COM_CRC_FAILED);
  }
  
  if((response_r1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
 8001e50:	0244      	lsls	r4, r0, #9
 8001e52:	d4e1      	bmi.n	8001e18 <SD_CmdResp1Error+0x34>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
 8001e54:	0281      	lsls	r1, r0, #10
 8001e56:	d427      	bmi.n	8001ea8 <SD_CmdResp1Error+0xc4>
  {
    return(SD_CARD_ECC_FAILED);
  }
  
  if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
 8001e58:	02c2      	lsls	r2, r0, #11
 8001e5a:	d427      	bmi.n	8001eac <SD_CmdResp1Error+0xc8>
  {
    return(SD_CC_ERROR);
  }
  
  if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
 8001e5c:	0303      	lsls	r3, r0, #12
 8001e5e:	d427      	bmi.n	8001eb0 <SD_CmdResp1Error+0xcc>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
 8001e60:	0346      	lsls	r6, r0, #13
 8001e62:	d427      	bmi.n	8001eb4 <SD_CmdResp1Error+0xd0>
  {
    return(SD_STREAM_READ_UNDERRUN);
  }
  
  if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
 8001e64:	0385      	lsls	r5, r0, #14
 8001e66:	d427      	bmi.n	8001eb8 <SD_CmdResp1Error+0xd4>
  {
    return(SD_STREAM_WRITE_OVERRUN);
  }
  
  if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
 8001e68:	03c4      	lsls	r4, r0, #15
 8001e6a:	d427      	bmi.n	8001ebc <SD_CmdResp1Error+0xd8>
  {
    return(SD_CID_CSD_OVERWRITE);
  }
  
  if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
 8001e6c:	0401      	lsls	r1, r0, #16
 8001e6e:	d427      	bmi.n	8001ec0 <SD_CmdResp1Error+0xdc>
  {
    return(SD_WP_ERASE_SKIP);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
 8001e70:	0442      	lsls	r2, r0, #17
 8001e72:	d427      	bmi.n	8001ec4 <SD_CmdResp1Error+0xe0>
  {
    return(SD_CARD_ECC_DISABLED);
  }
  
  if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
 8001e74:	0483      	lsls	r3, r0, #18
 8001e76:	d427      	bmi.n	8001ec8 <SD_CmdResp1Error+0xe4>
    return(SD_ERASE_RESET);
  }
  
  if((response_r1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
  {
    return(SD_AKE_SEQ_ERROR);
 8001e78:	f010 0f08 	tst.w	r0, #8
 8001e7c:	bf0c      	ite	eq
 8001e7e:	2000      	moveq	r0, #0
 8001e80:	201a      	movne	r0, #26
 8001e82:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  return errorstate;
 8001e84:	4618      	mov	r0, r3
 8001e86:	bd70      	pop	{r4, r5, r6, pc}
    return errorstate;
  }
  
  if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
  {
    return(SD_ADDR_OUT_OF_RANGE);
 8001e88:	201c      	movs	r0, #28
 8001e8a:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
  {
    return(SD_ADDR_MISALIGNED);
 8001e8c:	2009      	movs	r0, #9
 8001e8e:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
  {
    return(SD_BLOCK_LEN_ERR);
 8001e90:	200a      	movs	r0, #10
 8001e92:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
  {
    return(SD_ERASE_SEQ_ERR);
 8001e94:	200b      	movs	r0, #11
 8001e96:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
  {
    return(SD_BAD_ERASE_PARAM);
 8001e98:	200c      	movs	r0, #12
 8001e9a:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
  {
    return(SD_WRITE_PROT_VIOLATION);
 8001e9c:	200d      	movs	r0, #13
 8001e9e:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
  {
    return(SD_LOCK_UNLOCK_FAILED);
 8001ea0:	200e      	movs	r0, #14
 8001ea2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 8001ea4:	200f      	movs	r0, #15
 8001ea6:	bd70      	pop	{r4, r5, r6, pc}
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
  {
    return(SD_CARD_ECC_FAILED);
 8001ea8:	2011      	movs	r0, #17
 8001eaa:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
  {
    return(SD_CC_ERROR);
 8001eac:	2012      	movs	r0, #18
 8001eae:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8001eb0:	2013      	movs	r0, #19
 8001eb2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
  {
    return(SD_STREAM_READ_UNDERRUN);
 8001eb4:	2014      	movs	r0, #20
 8001eb6:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
  {
    return(SD_STREAM_WRITE_OVERRUN);
 8001eb8:	2015      	movs	r0, #21
 8001eba:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
  {
    return(SD_CID_CSD_OVERWRITE);
 8001ebc:	2016      	movs	r0, #22
 8001ebe:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
  {
    return(SD_WP_ERASE_SKIP);
 8001ec0:	2017      	movs	r0, #23
 8001ec2:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
  {
    return(SD_CARD_ECC_DISABLED);
 8001ec4:	2018      	movs	r0, #24
 8001ec6:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
  {
    return(SD_ERASE_RESET);
 8001ec8:	2019      	movs	r0, #25
  {
    return(SD_AKE_SEQ_ERROR);
  }
  
  return errorstate;
}
 8001eca:	bd70      	pop	{r4, r5, r6, pc}
 8001ecc:	fdffe008 	.word	0xfdffe008

08001ed0 <HAL_SD_Get_CardInfo>:
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t tmp = 0U;
  
  pCardInfo->CardType = (uint8_t)(hsd->CardType);
 8001ed0:	6a02      	ldr	r2, [r0, #32]
 8001ed2:	f881 2056 	strb.w	r2, [r1, #86]	; 0x56
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
 8001ed6:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001ed8:	f8a1 2054 	strh.w	r2, [r1, #84]	; 0x54
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
 8001edc:	6a82      	ldr	r2, [r0, #40]	; 0x28
  * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
  *         contains all SD cardinformation  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
 8001ede:	4603      	mov	r3, r0
  pCardInfo->CardType = (uint8_t)(hsd->CardType);
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
 8001ee0:	0f90      	lsrs	r0, r2, #30
 8001ee2:	7008      	strb	r0, [r1, #0]
  pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 8001ee4:	f3c2 6083 	ubfx	r0, r2, #26, #4
  pCardInfo->SD_csd.Reserved1      = tmp & 0x03U;
 8001ee8:	f3c2 6201 	ubfx	r2, r2, #24, #2
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
  pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 8001eec:	7048      	strb	r0, [r1, #1]
  pCardInfo->SD_csd.Reserved1      = tmp & 0x03U;
 8001eee:	708a      	strb	r2, [r1, #2]
  
  /* Byte 1 */
  tmp = (hsd->CSD[0U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.TAAC = (uint8_t)tmp;
 8001ef0:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
 8001ef4:	70ca      	strb	r2, [r1, #3]
  
  /* Byte 2 */
  tmp = (hsd->CSD[0U] & 0x0000FF00U) >> 8U;
  pCardInfo->SD_csd.NSAC = (uint8_t)tmp;
 8001ef6:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 8001efa:	710a      	strb	r2, [r1, #4]
  
  /* Byte 3 */
  tmp = hsd->CSD[0U] & 0x000000FFU;
  pCardInfo->SD_csd.MaxBusClkFrec = (uint8_t)tmp;
 8001efc:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
 8001f00:	714a      	strb	r2, [r1, #5]
  
  /* Byte 4 */
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
 8001f02:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
 8001f04:	0e10      	lsrs	r0, r2, #24
 8001f06:	0100      	lsls	r0, r0, #4
 8001f08:	80c8      	strh	r0, [r1, #6]
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8001f0a:	88c8      	ldrh	r0, [r1, #6]
  * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
  *         contains all SD cardinformation  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
 8001f0c:	b5f0      	push	{r4, r5, r6, r7, lr}
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8001f0e:	b280      	uxth	r0, r0
 8001f10:	f3c2 5403 	ubfx	r4, r2, #20, #4
 8001f14:	4320      	orrs	r0, r4
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 8001f16:	f3c2 4203 	ubfx	r2, r2, #16, #4
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8001f1a:	80c8      	strh	r0, [r1, #6]
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 8001f1c:	720a      	strb	r2, [r1, #8]
  
  /* Byte 6 */
  tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
 8001f1e:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
  pCardInfo->SD_csd.PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
 8001f22:	09d0      	lsrs	r0, r2, #7
 8001f24:	7248      	strb	r0, [r1, #9]
  pCardInfo->SD_csd.WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
 8001f26:	f3c2 1080 	ubfx	r0, r2, #6, #1
 8001f2a:	7288      	strb	r0, [r1, #10]
  pCardInfo->SD_csd.RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
 8001f2c:	f3c2 1040 	ubfx	r0, r2, #5, #1
 8001f30:	72c8      	strb	r0, [r1, #11]
  pCardInfo->SD_csd.DSRImpl         = (uint8_t)((tmp & 0x10U) >> 4U);
 8001f32:	f3c2 1000 	ubfx	r0, r2, #4, #1
 8001f36:	7308      	strb	r0, [r1, #12]
  pCardInfo->SD_csd.Reserved2       = 0U; /*!< Reserved */
 8001f38:	2000      	movs	r0, #0
 8001f3a:	7348      	strb	r0, [r1, #13]
  
  if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0))
 8001f3c:	6a1c      	ldr	r4, [r3, #32]
 8001f3e:	2c01      	cmp	r4, #1
 8001f40:	d83c      	bhi.n	8001fbc <HAL_SD_Get_CardInfo+0xec>
  {
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x03U) << 10U;
 8001f42:	0292      	lsls	r2, r2, #10
 8001f44:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 8001f48:	610a      	str	r2, [r1, #16]
    
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
 8001f4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001f4c:	690c      	ldr	r4, [r1, #16]
 8001f4e:	0092      	lsls	r2, r2, #2
 8001f50:	f402 727f 	and.w	r2, r2, #1020	; 0x3fc
 8001f54:	4322      	orrs	r2, r4
 8001f56:	610a      	str	r2, [r1, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
 8001f58:	690c      	ldr	r4, [r1, #16]
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8001f5a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
 8001f5c:	ea44 7492 	orr.w	r4, r4, r2, lsr #30
 8001f60:	610c      	str	r4, [r1, #16]
    
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8001f62:	f3c2 64c2 	ubfx	r4, r2, #27, #3
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
 8001f66:	f3c2 6202 	ubfx	r2, r2, #24, #3
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
    
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8001f6a:	750c      	strb	r4, [r1, #20]
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
 8001f6c:	754a      	strb	r2, [r1, #21]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
 8001f6e:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
 8001f70:	b2d4      	uxtb	r4, r2
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8001f72:	0052      	lsls	r2, r2, #1
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
 8001f74:	0965      	lsrs	r5, r4, #5
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8001f76:	f002 0206 	and.w	r2, r2, #6
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 8001f7a:	f3c4 0482 	ubfx	r4, r4, #2, #3
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
 8001f7e:	758d      	strb	r5, [r1, #22]
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 8001f80:	75cc      	strb	r4, [r1, #23]
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8001f82:	760a      	strb	r2, [r1, #24]
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 8001f84:	7e0c      	ldrb	r4, [r1, #24]
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 8001f86:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 8001f8a:	ea44 14d2 	orr.w	r4, r4, r2, lsr #7
 8001f8e:	760c      	strb	r4, [r1, #24]
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
 8001f90:	690c      	ldr	r4, [r1, #16]
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
 8001f92:	f891 e018 	ldrb.w	lr, [r1, #24]
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
 8001f96:	1c66      	adds	r6, r4, #1
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
    pCardInfo->CardBlockSize = 1U << (pCardInfo->SD_csd.RdBlockLen);
 8001f98:	7a0c      	ldrb	r4, [r1, #8]
 8001f9a:	2501      	movs	r5, #1
 8001f9c:	fa05 f404 	lsl.w	r4, r5, r4
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 8001fa0:	f10e 0e02 	add.w	lr, lr, #2
 8001fa4:	fa05 fe0e 	lsl.w	lr, r5, lr
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
    pCardInfo->CardBlockSize = 1U << (pCardInfo->SD_csd.RdBlockLen);
 8001fa8:	650c      	str	r4, [r1, #80]	; 0x50
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 8001faa:	fba6 4504 	umull	r4, r5, r6, r4
 8001fae:	fbae 6704 	umull	r6, r7, lr, r4
 8001fb2:	fb0e 7705 	mla	r7, lr, r5, r7
 8001fb6:	e9c1 6712 	strd	r6, r7, [r1, #72]	; 0x48
 8001fba:	e023      	b.n	8002004 <HAL_SD_Get_CardInfo+0x134>
  }
  else if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8001fbc:	2c02      	cmp	r4, #2
 8001fbe:	d120      	bne.n	8002002 <HAL_SD_Get_CardInfo+0x132>
  {
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x3FU) << 16U;
 8001fc0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001fc2:	0412      	lsls	r2, r2, #16
 8001fc4:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
 8001fc8:	610a      	str	r2, [r1, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8001fca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    
    pCardInfo->SD_csd.DeviceSize |= (tmp << 8U);
 8001fcc:	690c      	ldr	r4, [r1, #16]
 8001fce:	0e15      	lsrs	r5, r2, #24
 8001fd0:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
 8001fd4:	610c      	str	r4, [r1, #16]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
 8001fd6:	690c      	ldr	r4, [r1, #16]
 8001fd8:	f3c2 4507 	ubfx	r5, r2, #16, #8
 8001fdc:	432c      	orrs	r4, r5
 8001fde:	610c      	str	r4, [r1, #16]
    
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
    
    pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1U)) * 512U * 1024U);
 8001fe0:	690c      	ldr	r4, [r1, #16]
 8001fe2:	2500      	movs	r5, #0
 8001fe4:	3401      	adds	r4, #1
 8001fe6:	f145 0500 	adc.w	r5, r5, #0
 8001fea:	04ed      	lsls	r5, r5, #19
 8001fec:	ea45 3554 	orr.w	r5, r5, r4, lsr #13
 8001ff0:	04e4      	lsls	r4, r4, #19
 8001ff2:	648c      	str	r4, [r1, #72]	; 0x48
    pCardInfo->CardBlockSize = 512U;    
 8001ff4:	f44f 7400 	mov.w	r4, #512	; 0x200
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
    
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 8001ff8:	f3c2 2207 	ubfx	r2, r2, #8, #8
    
    pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1U)) * 512U * 1024U);
 8001ffc:	64cd      	str	r5, [r1, #76]	; 0x4c
    pCardInfo->CardBlockSize = 512U;    
 8001ffe:	650c      	str	r4, [r1, #80]	; 0x50
 8002000:	e000      	b.n	8002004 <HAL_SD_Get_CardInfo+0x134>
  }
  else
  {
    /* Not supported card type */
    errorstate = SD_ERROR;
 8002002:	2029      	movs	r0, #41	; 0x29
  }
    
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
 8002004:	f3c2 1480 	ubfx	r4, r2, #6, #1
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
 8002008:	0052      	lsls	r2, r2, #1
 800200a:	f002 027e 	and.w	r2, r2, #126	; 0x7e
  {
    /* Not supported card type */
    errorstate = SD_ERROR;
  }
    
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
 800200e:	764c      	strb	r4, [r1, #25]
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
 8002010:	768a      	strb	r2, [r1, #26]
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
 8002012:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80U) >> 7U;
 8002014:	7e8d      	ldrb	r5, [r1, #26]
 8002016:	f3c2 14c0 	ubfx	r4, r2, #7, #1
 800201a:	432c      	orrs	r4, r5
  pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7FU);
 800201c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
  pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80U) >> 7U;
 8002020:	768c      	strb	r4, [r1, #26]
  pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7FU);
 8002022:	76ca      	strb	r2, [r1, #27]
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
 8002024:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80U) >> 7U;
 8002026:	0fd4      	lsrs	r4, r2, #31
 8002028:	770c      	strb	r4, [r1, #28]
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
 800202a:	f3c2 7441 	ubfx	r4, r2, #29, #2
 800202e:	774c      	strb	r4, [r1, #29]
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 8002030:	f3c2 6482 	ubfx	r4, r2, #26, #3
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 8002034:	0d92      	lsrs	r2, r2, #22
 8002036:	f002 020c 	and.w	r2, r2, #12
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 800203a:	778c      	strb	r4, [r1, #30]
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 800203c:	77ca      	strb	r2, [r1, #31]
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
 800203e:	8eda      	ldrh	r2, [r3, #54]	; 0x36
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 8002040:	7fcd      	ldrb	r5, [r1, #31]
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
 8002042:	b2d4      	uxtb	r4, r2
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 8002044:	ea45 1594 	orr.w	r5, r5, r4, lsr #6
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
 8002048:	f3c4 1440 	ubfx	r4, r4, #5, #1
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 800204c:	77cd      	strb	r5, [r1, #31]
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.Reserved3           = 0U;
  pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01U);
 800204e:	f002 0201 	and.w	r2, r2, #1
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
 8002052:	f881 4020 	strb.w	r4, [r1, #32]
  pCardInfo->SD_csd.Reserved3           = 0U;
 8002056:	2400      	movs	r4, #0
 8002058:	f881 4021 	strb.w	r4, [r1, #33]	; 0x21
  pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01U);
 800205c:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
 8002060:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8002062:	0a24      	lsrs	r4, r4, #8
 8002064:	b2e2      	uxtb	r2, r4
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
 8002066:	09d5      	lsrs	r5, r2, #7
 8002068:	f881 5023 	strb.w	r5, [r1, #35]	; 0x23
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
 800206c:	f3c2 1580 	ubfx	r5, r2, #6, #1
 8002070:	f881 5024 	strb.w	r5, [r1, #36]	; 0x24
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
 8002074:	f3c2 1540 	ubfx	r5, r2, #5, #1
 8002078:	f881 5025 	strb.w	r5, [r1, #37]	; 0x25
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
 800207c:	f004 0403 	and.w	r4, r4, #3
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
 8002080:	f3c2 1500 	ubfx	r5, r2, #4, #1
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
 8002084:	f3c2 0281 	ubfx	r2, r2, #2, #2
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
 8002088:	f881 5026 	strb.w	r5, [r1, #38]	; 0x26
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
 800208c:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
 8002090:	f881 4028 	strb.w	r4, [r1, #40]	; 0x28
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
  pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFEU) >> 1U;
 8002094:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  pCardInfo->SD_csd.Reserved4 = 1U;
 8002096:	2401      	movs	r4, #1
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
  pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFEU) >> 1U;
 8002098:	f3c2 0246 	ubfx	r2, r2, #1, #7
 800209c:	f881 2029 	strb.w	r2, [r1, #41]	; 0x29
  pCardInfo->SD_csd.Reserved4 = 1U;
 80020a0:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
  
  /* Byte 0 */
  tmp = (uint8_t)((hsd->CID[0U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ManufacturerID = tmp;
 80020a4:	f893 203b 	ldrb.w	r2, [r3, #59]	; 0x3b
 80020a8:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
  
  /* Byte 1 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x00FF0000U) >> 16U);
 80020ac:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  pCardInfo->SD_cid.OEM_AppliID = tmp << 8U;
 80020ae:	f3c2 4507 	ubfx	r5, r2, #16, #8
 80020b2:	022d      	lsls	r5, r5, #8
 80020b4:	85cd      	strh	r5, [r1, #46]	; 0x2e
  
  /* Byte 2 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.OEM_AppliID |= tmp;
 80020b6:	8dcd      	ldrh	r5, [r1, #46]	; 0x2e
 80020b8:	b2ae      	uxth	r6, r5
 80020ba:	f3c2 2507 	ubfx	r5, r2, #8, #8
 80020be:	4335      	orrs	r5, r6
 80020c0:	0612      	lsls	r2, r2, #24
 80020c2:	85cd      	strh	r5, [r1, #46]	; 0x2e
  
  /* Byte 3 */
  tmp = (uint8_t)(hsd->CID[0U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName1 = tmp << 24U;
 80020c4:	630a      	str	r2, [r1, #48]	; 0x30
  
  /* Byte 4 */
  tmp = (uint8_t)((hsd->CID[1U] & 0xFF000000U) >> 24U);
 80020c6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  pCardInfo->SD_cid.ProdName1 |= tmp << 16U;
 80020c8:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 80020ca:	0e16      	lsrs	r6, r2, #24
 80020cc:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
 80020d0:	630d      	str	r5, [r1, #48]	; 0x30
  
  /* Byte 5 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
 80020d2:	6b0e      	ldr	r6, [r1, #48]	; 0x30
 80020d4:	0a15      	lsrs	r5, r2, #8
 80020d6:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
 80020da:	4335      	orrs	r5, r6
 80020dc:	630d      	str	r5, [r1, #48]	; 0x30
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdName1 |= tmp;
 80020de:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 80020e0:	f3c2 2607 	ubfx	r6, r2, #8, #8
 80020e4:	4335      	orrs	r5, r6
  
  /* Byte 7 */
  tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName2 = tmp;
 80020e6:	b2d2      	uxtb	r2, r2
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdName1 |= tmp;
 80020e8:	630d      	str	r5, [r1, #48]	; 0x30
  
  /* Byte 7 */
  tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdName2 = tmp;
 80020ea:	f881 2034 	strb.w	r2, [r1, #52]	; 0x34
  
  /* Byte 8 */
  tmp = (uint8_t)((hsd->CID[2U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdRev = tmp;
 80020ee:	f893 2043 	ldrb.w	r2, [r3, #67]	; 0x43
 80020f2:	f881 2035 	strb.w	r2, [r1, #53]	; 0x35
  
  /* Byte 9 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x00FF0000U) >> 16U);
 80020f6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80020f8:	0c15      	lsrs	r5, r2, #16
 80020fa:	062d      	lsls	r5, r5, #24
  pCardInfo->SD_cid.ProdSN = tmp << 24U;
 80020fc:	638d      	str	r5, [r1, #56]	; 0x38
  
  /* Byte 10 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ProdSN |= tmp << 16U;
 80020fe:	6b8e      	ldr	r6, [r1, #56]	; 0x38
 8002100:	0215      	lsls	r5, r2, #8
 8002102:	f405 057f 	and.w	r5, r5, #16711680	; 0xff0000
 8002106:	4335      	orrs	r5, r6
 8002108:	638d      	str	r5, [r1, #56]	; 0x38
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
 800210a:	6b8d      	ldr	r5, [r1, #56]	; 0x38
 800210c:	0212      	lsls	r2, r2, #8
 800210e:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8002112:	432a      	orrs	r2, r5
 8002114:	638a      	str	r2, [r1, #56]	; 0x38
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
 8002116:	6b8d      	ldr	r5, [r1, #56]	; 0x38
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
 8002118:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  pCardInfo->SD_cid.ProdSN |= tmp;
 800211a:	ea45 6512 	orr.w	r5, r5, r2, lsr #24
 800211e:	638d      	str	r5, [r1, #56]	; 0x38
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8002120:	f891 503c 	ldrb.w	r5, [r1, #60]	; 0x3c
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
 8002124:	f3c2 4207 	ubfx	r2, r2, #16, #8
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8002128:	ea45 1512 	orr.w	r5, r5, r2, lsr #4
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
 800212c:	0212      	lsls	r2, r2, #8
 800212e:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
  pCardInfo->SD_cid.ProdSN |= tmp;
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8002132:	f881 503c 	strb.w	r5, [r1, #60]	; 0x3c
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
 8002136:	87ca      	strh	r2, [r1, #62]	; 0x3e
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
 8002138:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  pCardInfo->SD_cid.ManufactDate |= tmp;
 800213a:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
 800213c:	b295      	uxth	r5, r2
 800213e:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8002142:	432a      	orrs	r2, r5
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
  pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFEU) >> 1U;
 8002144:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
  pCardInfo->SD_cid.ManufactDate |= tmp;
 8002148:	87ca      	strh	r2, [r1, #62]	; 0x3e
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
  pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFEU) >> 1U;
 800214a:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
  pCardInfo->SD_cid.Reserved2 = 1U;
 800214e:	f881 4041 	strb.w	r4, [r1, #65]	; 0x41
  
  return errorstate;
}
 8002152:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002154 <HAL_SD_Init>:
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 8002154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
 8002158:	2500      	movs	r5, #0
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 800215a:	b091      	sub	sp, #68	; 0x44
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
  SD_InitTypeDef tmpinit;
  
  /* Allocate lock resource and initialize it */
  hsd->Lock = HAL_UNLOCKED;
 800215c:	7705      	strb	r5, [r0, #28]
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 800215e:	4604      	mov	r4, r0
 8002160:	460e      	mov	r6, r1
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
 8002162:	f88d 5012 	strb.w	r5, [sp, #18]
  SD_InitTypeDef tmpinit;
  
  /* Allocate lock resource and initialize it */
  hsd->Lock = HAL_UNLOCKED;
  /* Initialize the low level hardware (MSP) */
  HAL_SD_MspInit(hsd);
 8002166:	f7fe f9d7 	bl	8000518 <HAL_SD_MspInit>
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
 800216a:	2376      	movs	r3, #118	; 0x76
 800216c:	930f      	str	r3, [sp, #60]	; 0x3c
  
  /* Default SDIO peripheral configuration for SD card initialization */
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
 800216e:	950d      	str	r5, [sp, #52]	; 0x34
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 8002170:	950e      	str	r5, [sp, #56]	; 0x38
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
 8002172:	ab10      	add	r3, sp, #64	; 0x40
 8002174:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 8002178:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
  hsd->Lock = HAL_UNLOCKED;
  /* Initialize the low level hardware (MSP) */
  HAL_SD_MspInit(hsd);
  
  /* Default SDIO peripheral configuration for SD card initialization */
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
 800217c:	950a      	str	r5, [sp, #40]	; 0x28
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
 800217e:	950b      	str	r5, [sp, #44]	; 0x2c
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
 8002180:	950c      	str	r5, [sp, #48]	; 0x30
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
  
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
 8002182:	4f9e      	ldr	r7, [pc, #632]	; (80023fc <HAL_SD_Init+0x2a8>)
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
 8002184:	6820      	ldr	r0, [r4, #0]
 8002186:	ab0a      	add	r3, sp, #40	; 0x28
 8002188:	cb0e      	ldmia	r3, {r1, r2, r3}
 800218a:	f000 fea7 	bl	8002edc <SDIO_Init>
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
 800218e:	f88d 5013 	strb.w	r5, [sp, #19]
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
  
  /* Set Power State to ON */
  SDIO_PowerState_ON(hsd->Instance);
 8002192:	6820      	ldr	r0, [r4, #0]
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
  
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
 8002194:	603d      	str	r5, [r7, #0]
  
  /* Set Power State to ON */
  SDIO_PowerState_ON(hsd->Instance);
 8002196:	f000 fec4 	bl	8002f22 <SDIO_PowerState_ON>
  
  /* 1ms: required power up waiting time before starting the SD initialization 
     sequence */
  HAL_Delay(1);
 800219a:	2001      	movs	r0, #1
 800219c:	f7fe fcc0 	bl	8000b20 <HAL_Delay>
  
  /* Enable SDIO Clock */
  __HAL_SD_SDIO_ENABLE();
 80021a0:	2301      	movs	r3, #1
 80021a2:	603b      	str	r3, [r7, #0]
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80021a4:	a905      	add	r1, sp, #20
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80021a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80021aa:	6820      	ldr	r0, [r4, #0]
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80021ac:	9309      	str	r3, [sp, #36]	; 0x24
  /* Enable SDIO Clock */
  __HAL_SD_SDIO_ENABLE();
  
  /* CMD0: GO_IDLE_STATE -----------------------------------------------------*/
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
 80021ae:	9505      	str	r5, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
 80021b0:	9506      	str	r5, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
 80021b2:	9507      	str	r5, [sp, #28]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80021b4:	9508      	str	r5, [sp, #32]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80021b6:	f000 febc 	bl	8002f32 <SDIO_SendCommand>
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t timeout, tmp;
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 80021ba:	6820      	ldr	r0, [r4, #0]
 80021bc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80021be:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80021c2:	f3c3 13c0 	ubfx	r3, r3, #7, #1
    
  while((timeout > 0U) && (!tmp))
 80021c6:	2b00      	cmp	r3, #0
 80021c8:	f040 817e 	bne.w	80024c8 <HAL_SD_Init+0x374>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 80021cc:	6b43      	ldr	r3, [r0, #52]	; 0x34
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
    
  while((timeout > 0U) && (!tmp))
 80021ce:	3a01      	subs	r2, #1
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 80021d0:	f3c3 13c0 	ubfx	r3, r3, #7, #1
  
  timeout = SDIO_CMD0TIMEOUT;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
    
  while((timeout > 0U) && (!tmp))
 80021d4:	d1f7      	bne.n	80021c6 <HAL_SD_Init+0x72>
  }
  
  if(timeout == 0U)
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    return errorstate;
 80021d6:	2303      	movs	r3, #3
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
  
  /* Check for error conditions */
  errorstate = SD_CmdError(hsd);
 80021d8:	f88d 3013 	strb.w	r3, [sp, #19]
  
  if(errorstate != SD_OK)
 80021dc:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80021e0:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80021e4:	2b00      	cmp	r3, #0
 80021e6:	f040 80a3 	bne.w	8002330 <HAL_SD_Init+0x1dc>
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
 80021ea:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 80021ee:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
 80021f0:	2308      	movs	r3, #8
 80021f2:	9306      	str	r3, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80021f4:	a905      	add	r1, sp, #20
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80021f6:	2340      	movs	r3, #64	; 0x40
 80021f8:	9307      	str	r3, [sp, #28]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80021fa:	f000 fe9a 	bl	8002f32 <SDIO_SendCommand>
static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_ERROR;
  uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
 80021fe:	6820      	ldr	r0, [r4, #0]
 8002200:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002202:	f013 0f45 	tst.w	r3, #69	; 0x45
 8002206:	bf14      	ite	ne
 8002208:	2201      	movne	r2, #1
 800220a:	2200      	moveq	r2, #0
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_ERROR;
  uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
 800220c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
  
  while((!tmp) && (timeout > 0U))
 8002210:	b942      	cbnz	r2, 8002224 <HAL_SD_Init+0xd0>
 8002212:	b13b      	cbz	r3, 8002224 <HAL_SD_Init+0xd0>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT);
 8002214:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8002216:	f012 0f45 	tst.w	r2, #69	; 0x45
 800221a:	bf14      	ite	ne
 800221c:	2201      	movne	r2, #1
 800221e:	2200      	moveq	r2, #0
    timeout--;
 8002220:	3b01      	subs	r3, #1
 8002222:	e7f5      	b.n	8002210 <HAL_SD_Init+0xbc>
  }
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT); 
 8002224:	6b42      	ldr	r2, [r0, #52]	; 0x34
  
  if((timeout == 0U) || tmp)
 8002226:	b10b      	cbz	r3, 800222c <HAL_SD_Init+0xd8>
 8002228:	0757      	lsls	r7, r2, #29
 800222a:	d503      	bpl.n	8002234 <HAL_SD_Init+0xe0>
  {
    /* Card is not V2.0 compliant or card does not support the set voltage range */
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 800222c:	2304      	movs	r3, #4
 800222e:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 8002230:	2503      	movs	r5, #3
 8002232:	e005      	b.n	8002240 <HAL_SD_Init+0xec>
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDREND))
 8002234:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002236:	0659      	lsls	r1, r3, #25
  {
    /* Card is SD V2.0 compliant */
    errorstate = SD_OK;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CMDREND);
 8002238:	bf46      	itte	mi
 800223a:	2340      	movmi	r3, #64	; 0x40
 800223c:	6383      	strmi	r3, [r0, #56]	; 0x38
    
    return errorstate;
  }
  
  return errorstate;
 800223e:	2529      	movpl	r5, #41	; 0x29
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
  
  /* Check for error conditions */ 
  errorstate = SD_CmdResp7Error(hsd);
 8002240:	f88d 5013 	strb.w	r5, [sp, #19]
  
  if (errorstate == SD_OK)
 8002244:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8002248:	2300      	movs	r3, #0
 800224a:	b922      	cbnz	r2, 8002256 <HAL_SD_Init+0x102>
  {
    /* SD Card 2.0 */
    hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
 800224c:	2201      	movs	r2, #1
 800224e:	6222      	str	r2, [r4, #32]
    sdtype        = SD_HIGH_CAPACITY;
 8002250:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8002254:	e000      	b.n	8002258 <HAL_SD_Init+0x104>
static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
  uint32_t sdtype = SD_STD_CAPACITY;
 8002256:	461d      	mov	r5, r3
    sdtype        = SD_HIGH_CAPACITY;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8002258:	2737      	movs	r7, #55	; 0x37
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800225a:	a905      	add	r1, sp, #20
    hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
    sdtype        = SD_HIGH_CAPACITY;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = 0U;
 800225c:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 800225e:	9706      	str	r7, [sp, #24]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002260:	f000 fe67 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8002264:	4639      	mov	r1, r7
 8002266:	4620      	mov	r0, r4
 8002268:	f7ff fdbc 	bl	8001de4 <SD_CmdResp1Error>
 800226c:	f88d 0013 	strb.w	r0, [sp, #19]
  
  /* If errorstate is Command Timeout, it is a MMC card */
  /* If errorstate is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  if(errorstate == SD_OK)
 8002270:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8002274:	f003 08ff 	and.w	r8, r3, #255	; 0xff
 8002278:	2b00      	cmp	r3, #0
 800227a:	d159      	bne.n	8002330 <HAL_SD_Init+0x1dc>
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 800227c:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
 8002280:	46c1      	mov	r9, r8
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 8002282:	f445 1580 	orr.w	r5, r5, #1048576	; 0x100000
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8002286:	2737      	movs	r7, #55	; 0x37
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002288:	a905      	add	r1, sp, #20
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800228a:	f04f 0b40 	mov.w	fp, #64	; 0x40
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800228e:	f44f 6a80 	mov.w	sl, #1024	; 0x400
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002292:	6820      	ldr	r0, [r4, #0]
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8002294:	9706      	str	r7, [sp, #24]
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
 8002296:	f8cd 9014 	str.w	r9, [sp, #20]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800229a:	f8cd b01c 	str.w	fp, [sp, #28]
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 800229e:	f8cd 9020 	str.w	r9, [sp, #32]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80022a2:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80022a6:	f000 fe44 	bl	8002f32 <SDIO_SendCommand>
      
      /* Check for error conditions */
      errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80022aa:	4639      	mov	r1, r7
 80022ac:	4620      	mov	r0, r4
 80022ae:	f7ff fd99 	bl	8001de4 <SD_CmdResp1Error>
 80022b2:	f88d 0013 	strb.w	r0, [sp, #19]
      
      if(errorstate != SD_OK)
 80022b6:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80022ba:	f003 07ff 	and.w	r7, r3, #255	; 0xff
 80022be:	2b00      	cmp	r3, #0
 80022c0:	d136      	bne.n	8002330 <HAL_SD_Init+0x1dc>
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
 80022c2:	2329      	movs	r3, #41	; 0x29
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80022c4:	a905      	add	r1, sp, #20
 80022c6:	6820      	ldr	r0, [r4, #0]
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
 80022c8:	9306      	str	r3, [sp, #24]
      {
        return errorstate;
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 80022ca:	9505      	str	r5, [sp, #20]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80022cc:	f8cd b01c 	str.w	fp, [sp, #28]
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80022d0:	9708      	str	r7, [sp, #32]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80022d2:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80022d6:	f000 fe2c 	bl	8002f32 <SDIO_SendCommand>
  */
static HAL_SD_ErrorTypedef SD_CmdResp3Error(SD_HandleTypeDef *hsd)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 80022da:	6823      	ldr	r3, [r4, #0]
 80022dc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80022de:	f012 0f45 	tst.w	r2, #69	; 0x45
 80022e2:	d0fb      	beq.n	80022dc <HAL_SD_Init+0x188>
  {
  }
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 80022e4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80022e6:	0752      	lsls	r2, r2, #29
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 80022e8:	bf45      	ittet	mi
 80022ea:	2204      	movmi	r2, #4
    
    return errorstate;
 80022ec:	2703      	movmi	r7, #3
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80022ee:	f240 52ff 	movwpl	r2, #1535	; 0x5ff
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 80022f2:	639a      	strmi	r2, [r3, #56]	; 0x38
    
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80022f4:	bf58      	it	pl
 80022f6:	639a      	strpl	r2, [r3, #56]	; 0x38
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
      
      /* Check for error conditions */
      errorstate = SD_CmdResp3Error(hsd);
 80022f8:	f88d 7013 	strb.w	r7, [sp, #19]
      
      if(errorstate != SD_OK)
 80022fc:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8002300:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8002304:	b9a3      	cbnz	r3, 8002330 <HAL_SD_Init+0x1dc>
      {
        return errorstate;
      }
      
      /* Get command response */
      response = SDIO_GetResponse(SDIO_RESP1);
 8002306:	f000 fe2b 	bl	8002f60 <SDIO_GetResponse>
     or SD card 1.x */
  if(errorstate == SD_OK)
  {
    /* SD CARD */
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
 800230a:	2800      	cmp	r0, #0
      response = SDIO_GetResponse(SDIO_RESP1);
      
      /* Get operating voltage*/
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
      
      count++;
 800230c:	f108 0801 	add.w	r8, r8, #1
 8002310:	f64f 73ff 	movw	r3, #65535	; 0xffff
     or SD card 1.x */
  if(errorstate == SD_OK)
  {
    /* SD CARD */
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
 8002314:	db02      	blt.n	800231c <HAL_SD_Init+0x1c8>
 8002316:	4598      	cmp	r8, r3
 8002318:	d1b5      	bne.n	8002286 <HAL_SD_Init+0x132>
 800231a:	e001      	b.n	8002320 <HAL_SD_Init+0x1cc>
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
      
      count++;
    }
    
    if(count >= SD_MAX_VOLT_TRIAL)
 800231c:	4598      	cmp	r8, r3
 800231e:	d103      	bne.n	8002328 <HAL_SD_Init+0x1d4>
    {
      errorstate = SD_INVALID_VOLTRANGE;
 8002320:	231b      	movs	r3, #27
 8002322:	f88d 3013 	strb.w	r3, [sp, #19]
 8002326:	e003      	b.n	8002330 <HAL_SD_Init+0x1dc>
      
      return errorstate;
    }
    
    if((response & SD_HIGH_CAPACITY) == SD_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 8002328:	0043      	lsls	r3, r0, #1
    {
      hsd->CardType = HIGH_CAPACITY_SD_CARD;
 800232a:	bf44      	itt	mi
 800232c:	2302      	movmi	r3, #2
 800232e:	6223      	strmi	r3, [r4, #32]
    }
    
  } /* else MMC Card */
  
  return errorstate;
 8002330:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8002334:	b2db      	uxtb	r3, r3
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
  
  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd); 
 8002336:	f88d 3012 	strb.w	r3, [sp, #18]
  
  if(errorstate != SD_OK)     
 800233a:	f89d 3012 	ldrb.w	r3, [sp, #18]
 800233e:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 8002342:	2b00      	cmp	r3, #0
 8002344:	f040 80ba 	bne.w	80024bc <HAL_SD_Init+0x368>
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint16_t sd_rca = 1U;
  
  if(SDIO_GetPowerState(hsd->Instance) == 0U) /* Power off */
 8002348:	6820      	ldr	r0, [r4, #0]
 800234a:	f000 fdee 	bl	8002f2a <SDIO_GetPowerState>
 800234e:	2800      	cmp	r0, #0
 8002350:	f000 8080 	beq.w	8002454 <HAL_SD_Init+0x300>
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
  }
  
  if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
 8002354:	6a23      	ldr	r3, [r4, #32]
 8002356:	2b04      	cmp	r3, #4
 8002358:	d020      	beq.n	800239c <HAL_SD_Init+0x248>
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
 800235a:	2302      	movs	r3, #2
 800235c:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 800235e:	23c0      	movs	r3, #192	; 0xc0
 8002360:	9307      	str	r3, [sp, #28]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002362:	a905      	add	r1, sp, #20
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8002364:	f44f 6380 	mov.w	r3, #1024	; 0x400
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002368:	6820      	ldr	r0, [r4, #0]
  }
  
  if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
 800236a:	9505      	str	r5, [sp, #20]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 800236c:	9508      	str	r5, [sp, #32]
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800236e:	9309      	str	r3, [sp, #36]	; 0x24
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002370:	f000 fddf 	bl	8002f32 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 8002374:	4620      	mov	r0, r4
 8002376:	f7ff fc7d 	bl	8001c74 <SD_CmdResp2Error>
    
    if(errorstate != SD_OK)
 800237a:	2800      	cmp	r0, #0
 800237c:	d16c      	bne.n	8002458 <HAL_SD_Init+0x304>
    {
      return errorstate;
    }
    
    /* Get Card identification number data */
    hsd->CID[0U] = SDIO_GetResponse(SDIO_RESP1);
 800237e:	f000 fdef 	bl	8002f60 <SDIO_GetResponse>
 8002382:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->CID[1U] = SDIO_GetResponse(SDIO_RESP2);
 8002384:	2004      	movs	r0, #4
 8002386:	f000 fdeb 	bl	8002f60 <SDIO_GetResponse>
 800238a:	63e0      	str	r0, [r4, #60]	; 0x3c
    hsd->CID[2U] = SDIO_GetResponse(SDIO_RESP3);
 800238c:	2008      	movs	r0, #8
 800238e:	f000 fde7 	bl	8002f60 <SDIO_GetResponse>
 8002392:	6420      	str	r0, [r4, #64]	; 0x40
    hsd->CID[3U] = SDIO_GetResponse(SDIO_RESP4);
 8002394:	200c      	movs	r0, #12
 8002396:	f000 fde3 	bl	8002f60 <SDIO_GetResponse>
 800239a:	6460      	str	r0, [r4, #68]	; 0x44
  }
  
  if((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1)    || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 800239c:	6a23      	ldr	r3, [r4, #32]
 800239e:	2b02      	cmp	r3, #2
 80023a0:	d901      	bls.n	80023a6 <HAL_SD_Init+0x252>
 80023a2:	2b06      	cmp	r3, #6
 80023a4:	d132      	bne.n	800240c <HAL_SD_Init+0x2b8>
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
 80023a6:	2303      	movs	r3, #3
 80023a8:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80023aa:	a905      	add	r1, sp, #20
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80023ac:	2340      	movs	r3, #64	; 0x40
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80023ae:	6820      	ldr	r0, [r4, #0]
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80023b0:	9307      	str	r3, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80023b2:	f000 fdbe 	bl	8002f32 <SDIO_SendCommand>
static HAL_SD_ErrorTypedef SD_CmdResp6Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD, uint16_t *pRCA)
{
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 80023b6:	6820      	ldr	r0, [r4, #0]
 80023b8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80023ba:	f013 0f45 	tst.w	r3, #69	; 0x45
 80023be:	d0fb      	beq.n	80023b8 <HAL_SD_Init+0x264>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 80023c0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80023c2:	075f      	lsls	r7, r3, #29
 80023c4:	d503      	bpl.n	80023ce <HAL_SD_Init+0x27a>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 80023c6:	2304      	movs	r3, #4
 80023c8:	6383      	str	r3, [r0, #56]	; 0x38
    
    return errorstate;
 80023ca:	2503      	movs	r5, #3
 80023cc:	e045      	b.n	800245a <HAL_SD_Init+0x306>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 80023ce:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80023d0:	f013 0701 	ands.w	r7, r3, #1
 80023d4:	d002      	beq.n	80023dc <HAL_SD_Init+0x288>
  {
    errorstate = SD_CMD_CRC_FAIL;
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 80023d6:	2501      	movs	r5, #1
 80023d8:	6385      	str	r5, [r0, #56]	; 0x38
 80023da:	e03e      	b.n	800245a <HAL_SD_Init+0x306>
  {
    /* No error flag set */
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 80023dc:	f000 fdbc 	bl	8002f58 <SDIO_GetCommandResponse>
 80023e0:	2803      	cmp	r0, #3
 80023e2:	d176      	bne.n	80024d2 <HAL_SD_Init+0x37e>
    
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80023e4:	6823      	ldr	r3, [r4, #0]
 80023e6:	f240 52ff 	movw	r2, #1535	; 0x5ff
 80023ea:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it.  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 80023ec:	4638      	mov	r0, r7
 80023ee:	f000 fdb7 	bl	8002f60 <SDIO_GetResponse>
  
  if((response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED)) == SD_ALLZERO)
 80023f2:	f410 4f60 	tst.w	r0, #57344	; 0xe000
 80023f6:	d103      	bne.n	8002400 <HAL_SD_Init+0x2ac>
  {
    *pRCA = (uint16_t) (response_r1 >> 16U);
 80023f8:	0c00      	lsrs	r0, r0, #16
 80023fa:	e008      	b.n	800240e <HAL_SD_Init+0x2ba>
 80023fc:	422580a0 	.word	0x422580a0
    
    return errorstate;
  }
  
  if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
 8002400:	0481      	lsls	r1, r0, #18
 8002402:	d468      	bmi.n	80024d6 <HAL_SD_Init+0x382>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
  }
  
  if((response_r1 & SD_R6_ILLEGAL_CMD) == SD_R6_ILLEGAL_CMD)
 8002404:	0442      	lsls	r2, r0, #17
 8002406:	d464      	bmi.n	80024d2 <HAL_SD_Init+0x37e>
  {
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
 8002408:	0403      	lsls	r3, r0, #16
 800240a:	d466      	bmi.n	80024da <HAL_SD_Init+0x386>
  */
static HAL_SD_ErrorTypedef SD_Initialize_Cards(SD_HandleTypeDef *hsd)
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint16_t sd_rca = 1U;
 800240c:	2001      	movs	r0, #1
    {
      return errorstate;
    }
  }
  
  if (hsd->CardType != SECURE_DIGITAL_IO_CARD)
 800240e:	6a23      	ldr	r3, [r4, #32]
 8002410:	2b04      	cmp	r3, #4
 8002412:	d022      	beq.n	800245a <HAL_SD_Init+0x306>
  {
    /* Get the SD card RCA */
    hsd->RCA = sd_rca;
 8002414:	6260      	str	r0, [r4, #36]	; 0x24
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
 8002416:	2309      	movs	r3, #9
  {
    /* Get the SD card RCA */
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8002418:	0400      	lsls	r0, r0, #16
 800241a:	9005      	str	r0, [sp, #20]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
 800241c:	9306      	str	r3, [sp, #24]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800241e:	a905      	add	r1, sp, #20
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 8002420:	23c0      	movs	r3, #192	; 0xc0
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002422:	6820      	ldr	r0, [r4, #0]
    hsd->RCA = sd_rca;
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 8002424:	9307      	str	r3, [sp, #28]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002426:	f000 fd84 	bl	8002f32 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 800242a:	4620      	mov	r0, r4
 800242c:	f7ff fc22 	bl	8001c74 <SD_CmdResp2Error>
    
    if(errorstate != SD_OK)
 8002430:	4605      	mov	r5, r0
 8002432:	b990      	cbnz	r0, 800245a <HAL_SD_Init+0x306>
    {
      return errorstate;
    }
    
    /* Get Card Specific Data */
    hsd->CSD[0U] = SDIO_GetResponse(SDIO_RESP1);
 8002434:	f000 fd94 	bl	8002f60 <SDIO_GetResponse>
 8002438:	62a0      	str	r0, [r4, #40]	; 0x28
    hsd->CSD[1U] = SDIO_GetResponse(SDIO_RESP2);
 800243a:	2004      	movs	r0, #4
 800243c:	f000 fd90 	bl	8002f60 <SDIO_GetResponse>
 8002440:	62e0      	str	r0, [r4, #44]	; 0x2c
    hsd->CSD[2U] = SDIO_GetResponse(SDIO_RESP3);
 8002442:	2008      	movs	r0, #8
 8002444:	f000 fd8c 	bl	8002f60 <SDIO_GetResponse>
 8002448:	6320      	str	r0, [r4, #48]	; 0x30
    hsd->CSD[3U] = SDIO_GetResponse(SDIO_RESP4);
 800244a:	200c      	movs	r0, #12
 800244c:	f000 fd88 	bl	8002f60 <SDIO_GetResponse>
 8002450:	6360      	str	r0, [r4, #52]	; 0x34
 8002452:	e002      	b.n	800245a <HAL_SD_Init+0x306>
  
  if(SDIO_GetPowerState(hsd->Instance) == 0U) /* Power off */
  {
    errorstate = SD_REQUEST_NOT_APPLICABLE;
    
    return errorstate;
 8002454:	2525      	movs	r5, #37	; 0x25
 8002456:	e000      	b.n	800245a <HAL_SD_Init+0x306>
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
    
    if(errorstate != SD_OK)
 8002458:	4605      	mov	r5, r0
  {
    return errorstate;
  }
  
  /* Initialize the present SDIO card(s) and put them in idle state */
  errorstate = SD_Initialize_Cards(hsd);
 800245a:	f88d 5012 	strb.w	r5, [sp, #18]
  
  if (errorstate != SD_OK)
 800245e:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8002462:	bb5b      	cbnz	r3, 80024bc <HAL_SD_Init+0x368>
  {
    return errorstate;
  }
  
  /* Read CSD/CID MSD registers */
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
 8002464:	4631      	mov	r1, r6
 8002466:	4620      	mov	r0, r4
 8002468:	f7ff fd32 	bl	8001ed0 <HAL_SD_Get_CardInfo>
 800246c:	f88d 0012 	strb.w	r0, [sp, #18]
  
  if (errorstate == SD_OK)
 8002470:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8002474:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002478:	b9ab      	cbnz	r3, 80024a6 <HAL_SD_Init+0x352>
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
 800247a:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800247e:	6820      	ldr	r0, [r4, #0]
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002480:	9208      	str	r2, [sp, #32]
{
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
 8002482:	041b      	lsls	r3, r3, #16
 8002484:	9305      	str	r3, [sp, #20]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8002486:	2340      	movs	r3, #64	; 0x40
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
 8002488:	2507      	movs	r5, #7
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800248a:	9307      	str	r3, [sp, #28]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800248c:	a905      	add	r1, sp, #20
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800248e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8002492:	9309      	str	r3, [sp, #36]	; 0x24
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
 8002494:	9506      	str	r5, [sp, #24]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002496:	f000 fd4c 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEL_DESEL_CARD);
 800249a:	4629      	mov	r1, r5
 800249c:	4620      	mov	r0, r4
 800249e:	f7ff fca1 	bl	8001de4 <SD_CmdResp1Error>
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
  
  if (errorstate == SD_OK)
  {
    /* Select the Card */
    errorstate = SD_Select_Deselect(hsd, (uint32_t)(((uint32_t)SDCardInfo->RCA) << 16U));
 80024a2:	f88d 0012 	strb.w	r0, [sp, #18]
  }
  
  /* Configure SDIO peripheral interface */
  SDIO_Init(hsd->Instance, hsd->Init);   
 80024a6:	f104 0310 	add.w	r3, r4, #16
 80024aa:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80024ae:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80024b2:	1d23      	adds	r3, r4, #4
 80024b4:	cb0e      	ldmia	r3, {r1, r2, r3}
 80024b6:	6820      	ldr	r0, [r4, #0]
 80024b8:	f000 fd10 	bl	8002edc <SDIO_Init>
  
  return errorstate;
 80024bc:	f89d 0012 	ldrb.w	r0, [sp, #18]
 80024c0:	b2c0      	uxtb	r0, r0
}
 80024c2:	b011      	add	sp, #68	; 0x44
 80024c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    errorstate = SD_CMD_RSP_TIMEOUT;
    return errorstate;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80024c8:	f240 53ff 	movw	r3, #1535	; 0x5ff
 80024cc:	6383      	str	r3, [r0, #56]	; 0x38
  
  return errorstate;
 80024ce:	2300      	movs	r3, #0
 80024d0:	e682      	b.n	80021d8 <HAL_SD_Init+0x84>
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
  {
    errorstate = SD_ILLEGAL_CMD;
    
    return errorstate;
 80024d2:	2510      	movs	r5, #16
 80024d4:	e7c1      	b.n	800245a <HAL_SD_Init+0x306>
    return errorstate;
  }
  
  if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 80024d6:	2513      	movs	r5, #19
 80024d8:	e7bf      	b.n	800245a <HAL_SD_Init+0x306>
    return(SD_ILLEGAL_CMD);
  }
  
  if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
  {
    return(SD_COM_CRC_FAILED);
 80024da:	250f      	movs	r5, #15
 80024dc:	e7bd      	b.n	800245a <HAL_SD_Init+0x306>
 80024de:	bf00      	nop

080024e0 <HAL_SD_StopTransfer>:
  * @brief  Aborts an ongoing data transfer.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
{
 80024e0:	b530      	push	{r4, r5, lr}
 80024e2:	b087      	sub	sp, #28
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
 80024e4:	2300      	movs	r3, #0
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80024e6:	2240      	movs	r2, #64	; 0x40
  * @brief  Aborts an ongoing data transfer.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
{
 80024e8:	4604      	mov	r4, r0
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
 80024ea:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
 80024ec:	250c      	movs	r5, #12
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80024ee:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80024f0:	a901      	add	r1, sp, #4
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80024f2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80024f6:	6800      	ldr	r0, [r0, #0]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80024f8:	9203      	str	r2, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80024fa:	9305      	str	r3, [sp, #20]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
 80024fc:	9502      	str	r5, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80024fe:	f000 fd18 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_STOP_TRANSMISSION);
 8002502:	4629      	mov	r1, r5
 8002504:	4620      	mov	r0, r4
 8002506:	f7ff fc6d 	bl	8001de4 <SD_CmdResp1Error>
  
  return errorstate;
}
 800250a:	b007      	add	sp, #28
 800250c:	bd30      	pop	{r4, r5, pc}

0800250e <HAL_SD_ReadBlocks>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800250e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002512:	4604      	mov	r4, r0
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8002514:	6800      	ldr	r0, [r0, #0]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8002516:	4617      	mov	r7, r2
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U, *tempbuff = (uint32_t *)pReadBuffer;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8002518:	2200      	movs	r2, #0
 800251a:	62c2      	str	r2, [r0, #44]	; 0x2c
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 800251c:	6a22      	ldr	r2, [r4, #32]
 800251e:	2a02      	cmp	r2, #2
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8002520:	b08d      	sub	sp, #52	; 0x34
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
    ReadAddr /= 512U;
 8002522:	bf04      	itt	eq
 8002524:	0a7f      	lsreq	r7, r7, #9
 8002526:	ea47 57c3 	orreq.w	r7, r7, r3, lsl #23
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 800252a:	f04f 0340 	mov.w	r3, #64	; 0x40
 800252e:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002530:	f04f 0300 	mov.w	r3, #0
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8002534:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002538:	9304      	str	r3, [sp, #16]
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
 800253a:	bf08      	it	eq
 800253c:	f44f 7800 	moveq.w	r8, #512	; 0x200
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8002540:	2610      	movs	r6, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8002542:	f44f 6380 	mov.w	r3, #1024	; 0x400
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8002546:	460d      	mov	r5, r1
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002548:	a901      	add	r1, sp, #4
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 800254a:	9602      	str	r6, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800254c:	9305      	str	r3, [sp, #20]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800254e:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    BlockSize = 512U;
    ReadAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t) BlockSize;
 8002552:	f8cd 8004 	str.w	r8, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002556:	f000 fcec 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 800255a:	4631      	mov	r1, r6
 800255c:	4620      	mov	r0, r4
 800255e:	f7ff fc41 	bl	8001de4 <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 8002562:	4606      	mov	r6, r0
 8002564:	2800      	cmp	r0, #0
 8002566:	f040 8090 	bne.w	800268a <HAL_SD_ReadBlocks+0x17c>
  {
    return errorstate;
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 800256a:	f04f 33ff 	mov.w	r3, #4294967295
 800256e:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
 8002570:	fb09 f308 	mul.w	r3, r9, r8
 8002574:	9307      	str	r3, [sp, #28]
  sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
 8002576:	2390      	movs	r3, #144	; 0x90
 8002578:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 800257a:	2302      	movs	r3, #2
 800257c:	9309      	str	r3, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 800257e:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8002580:	2301      	movs	r3, #1
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8002582:	a906      	add	r1, sp, #24
 8002584:	6820      	ldr	r0, [r4, #0]
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = DATA_BLOCK_SIZE;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8002586:	930b      	str	r3, [sp, #44]	; 0x2c
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8002588:	f000 fcf6 	bl	8002f78 <SDIO_DataConfig>
  
  if(NumberOfBlocks > 1U)
 800258c:	f1b9 0f01 	cmp.w	r9, #1
  {
    /* Send CMD18 READ_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
 8002590:	bf8c      	ite	hi
 8002592:	2312      	movhi	r3, #18
  }
  else
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
 8002594:	2311      	movls	r3, #17
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002596:	a901      	add	r1, sp, #4
 8002598:	6820      	ldr	r0, [r4, #0]
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
  }
  else
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;    
 800259a:	9302      	str	r3, [sp, #8]
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)ReadAddr;
 800259c:	9701      	str	r7, [sp, #4]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800259e:	f000 fcc8 	bl	8002f32 <SDIO_SendCommand>
  
  /* Read block(s) in polling mode */
  if(NumberOfBlocks > 1U)
 80025a2:	f1b9 0f01 	cmp.w	r9, #1
 80025a6:	d91a      	bls.n	80025de <HAL_SD_ReadBlocks+0xd0>
  {
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
 80025a8:	2112      	movs	r1, #18
 80025aa:	4620      	mov	r0, r4
 80025ac:	f7ff fc1a 	bl	8001de4 <SD_CmdResp1Error>
    
    if (errorstate != SD_OK)
 80025b0:	2800      	cmp	r0, #0
 80025b2:	d16b      	bne.n	800268c <HAL_SD_ReadBlocks+0x17e>
      return errorstate;
    }
    
    /* Poll on SDIO flags */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 80025b4:	6822      	ldr	r2, [r4, #0]
 80025b6:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80025b8:	f240 332a 	movw	r3, #810	; 0x32a
 80025bc:	400b      	ands	r3, r1
 80025be:	bb4b      	cbnz	r3, 8002614 <HAL_SD_ReadBlocks+0x106>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 80025c0:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80025c2:	0418      	lsls	r0, r3, #16
 80025c4:	d5f7      	bpl.n	80025b6 <HAL_SD_ReadBlocks+0xa8>
 80025c6:	1f2f      	subs	r7, r5, #4
 80025c8:	f105 081c 	add.w	r8, r5, #28
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
 80025cc:	6820      	ldr	r0, [r4, #0]
 80025ce:	f000 fca0 	bl	8002f12 <SDIO_ReadFIFO>
 80025d2:	f847 0f04 	str.w	r0, [r7, #4]!
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
 80025d6:	45b8      	cmp	r8, r7
 80025d8:	d1f8      	bne.n	80025cc <HAL_SD_ReadBlocks+0xbe>
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
        }
        
        tempbuff += 8U;
 80025da:	3520      	adds	r5, #32
 80025dc:	e7ea      	b.n	80025b4 <HAL_SD_ReadBlocks+0xa6>
    }      
  }
  else
  {
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_SINGLE_BLOCK); 
 80025de:	2111      	movs	r1, #17
 80025e0:	4620      	mov	r0, r4
 80025e2:	f7ff fbff 	bl	8001de4 <SD_CmdResp1Error>
    
    if (errorstate != SD_OK)
 80025e6:	2800      	cmp	r0, #0
 80025e8:	d150      	bne.n	800268c <HAL_SD_ReadBlocks+0x17e>
      return errorstate;
    }    
    
    /* In case of single block transfer, no need of stop transfer at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 80025ea:	6822      	ldr	r2, [r4, #0]
 80025ec:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80025ee:	f240 632a 	movw	r3, #1578	; 0x62a
 80025f2:	400b      	ands	r3, r1
 80025f4:	b973      	cbnz	r3, 8002614 <HAL_SD_ReadBlocks+0x106>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))      
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 80025f6:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80025f8:	0419      	lsls	r1, r3, #16
 80025fa:	d5f7      	bpl.n	80025ec <HAL_SD_ReadBlocks+0xde>
 80025fc:	1f2f      	subs	r7, r5, #4
 80025fe:	f105 081c 	add.w	r8, r5, #28
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
 8002602:	6820      	ldr	r0, [r4, #0]
 8002604:	f000 fc85 	bl	8002f12 <SDIO_ReadFIFO>
 8002608:	f847 0f04 	str.w	r0, [r7, #4]!
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
      {
        /* Read data from SDIO Rx FIFO */
        for (count = 0U; count < 8U; count++)
 800260c:	45b8      	cmp	r8, r7
 800260e:	d1f8      	bne.n	8002602 <HAL_SD_ReadBlocks+0xf4>
        {
          *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
        }
        
        tempbuff += 8U;
 8002610:	3520      	adds	r5, #32
 8002612:	e7ea      	b.n	80025ea <HAL_SD_ReadBlocks+0xdc>
      }
    }
  }
  
  /* Send stop transmission command in case of multiblock read */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 8002614:	6823      	ldr	r3, [r4, #0]
 8002616:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002618:	05db      	lsls	r3, r3, #23
 800261a:	d509      	bpl.n	8002630 <HAL_SD_ReadBlocks+0x122>
 800261c:	f1b9 0f01 	cmp.w	r9, #1
 8002620:	d906      	bls.n	8002630 <HAL_SD_ReadBlocks+0x122>
  {    
    if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) ||\
 8002622:	6a23      	ldr	r3, [r4, #32]
 8002624:	2b02      	cmp	r3, #2
 8002626:	d803      	bhi.n	8002630 <HAL_SD_ReadBlocks+0x122>
      (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
        (hsd->CardType == HIGH_CAPACITY_SD_CARD))
    {
      /* Send stop transmission command */
      errorstate = HAL_SD_StopTransfer(hsd);
 8002628:	4620      	mov	r0, r4
 800262a:	f7ff ff59 	bl	80024e0 <HAL_SD_StopTransfer>
 800262e:	4606      	mov	r6, r0
    }
  }
  
  /* Get error state */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8002630:	6823      	ldr	r3, [r4, #0]
 8002632:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002634:	0717      	lsls	r7, r2, #28
 8002636:	d503      	bpl.n	8002640 <HAL_SD_ReadBlocks+0x132>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8002638:	2208      	movs	r2, #8
 800263a:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 800263c:	2004      	movs	r0, #4
 800263e:	e025      	b.n	800268c <HAL_SD_ReadBlocks+0x17e>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8002640:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002642:	0790      	lsls	r0, r2, #30
 8002644:	d502      	bpl.n	800264c <HAL_SD_ReadBlocks+0x13e>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8002646:	2002      	movs	r0, #2
 8002648:	6398      	str	r0, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
 800264a:	e01f      	b.n	800268c <HAL_SD_ReadBlocks+0x17e>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 800264c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800264e:	0691      	lsls	r1, r2, #26
 8002650:	d503      	bpl.n	800265a <HAL_SD_ReadBlocks+0x14c>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 8002652:	2220      	movs	r2, #32
 8002654:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_RX_OVERRUN;
    
    return errorstate;
 8002656:	2006      	movs	r0, #6
 8002658:	e018      	b.n	800268c <HAL_SD_ReadBlocks+0x17e>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 800265a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800265c:	0592      	lsls	r2, r2, #22
 800265e:	d402      	bmi.n	8002666 <HAL_SD_ReadBlocks+0x158>
 8002660:	f04f 37ff 	mov.w	r7, #4294967295
 8002664:	e00a      	b.n	800267c <HAL_SD_ReadBlocks+0x16e>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 8002666:	f44f 7200 	mov.w	r2, #512	; 0x200
 800266a:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 800266c:	2007      	movs	r0, #7
 800266e:	e00d      	b.n	800268c <HAL_SD_ReadBlocks+0x17e>
  }
  
  count = SD_DATATIMEOUT;
  
  /* Empty FIFO if there is still any data */
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 8002670:	b147      	cbz	r7, 8002684 <HAL_SD_ReadBlocks+0x176>
  {
    *tempbuff = SDIO_ReadFIFO(hsd->Instance);
 8002672:	f000 fc4e 	bl	8002f12 <SDIO_ReadFIFO>
 8002676:	f845 0b04 	str.w	r0, [r5], #4
    tempbuff++;
    count--;
 800267a:	3f01      	subs	r7, #1
  }
  
  count = SD_DATATIMEOUT;
  
  /* Empty FIFO if there is still any data */
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 800267c:	6820      	ldr	r0, [r4, #0]
 800267e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002680:	029b      	lsls	r3, r3, #10
 8002682:	d4f5      	bmi.n	8002670 <HAL_SD_ReadBlocks+0x162>
    tempbuff++;
    count--;
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8002684:	f240 53ff 	movw	r3, #1535	; 0x5ff
 8002688:	6383      	str	r3, [r0, #56]	; 0x38
 800268a:	4630      	mov	r0, r6
  
  return errorstate;
}
 800268c:	b00d      	add	sp, #52	; 0x34
 800268e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002692 <HAL_SD_WriteBlocks>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8002692:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002696:	4605      	mov	r5, r0
 8002698:	b08c      	sub	sp, #48	; 0x30
  uint32_t totalnumberofbytes = 0U, bytestransferred = 0U, count = 0U, restwords = 0U;
  uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
  uint8_t cardstate  = 0U;
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 800269a:	6800      	ldr	r0, [r0, #0]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 800269c:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
 80026a0:	9f15      	ldr	r7, [sp, #84]	; 0x54
 80026a2:	4614      	mov	r4, r2
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t totalnumberofbytes = 0U, bytestransferred = 0U, count = 0U, restwords = 0U;
  uint32_t *tempbuff = (uint32_t *)pWriteBuffer;
  uint8_t cardstate  = 0U;
 80026a4:	2200      	movs	r2, #0
 80026a6:	f88d 2003 	strb.w	r2, [sp, #3]
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 80026aa:	62c2      	str	r2, [r0, #44]	; 0x2c
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 80026ac:	6a2a      	ldr	r2, [r5, #32]
 80026ae:	2a02      	cmp	r2, #2
  {
    BlockSize = 512U;
    WriteAddr /= 512U;
 80026b0:	bf04      	itt	eq
 80026b2:	0a64      	lsreq	r4, r4, #9
 80026b4:	ea44 54c3 	orreq.w	r4, r4, r3, lsl #23
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80026b8:	f04f 0340 	mov.w	r3, #64	; 0x40
 80026bc:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80026be:	f04f 0300 	mov.w	r3, #0
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
  {
    BlockSize = 512U;
 80026c2:	bf08      	it	eq
 80026c4:	f44f 7800 	moveq.w	r8, #512	; 0x200
    WriteAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 80026c8:	f04f 0910 	mov.w	r9, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80026cc:	9304      	str	r3, [sp, #16]
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 80026ce:	460e      	mov	r6, r1
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80026d0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80026d4:	a901      	add	r1, sp, #4
    BlockSize = 512U;
    WriteAddr /= 512U;
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
 80026d6:	f8cd 8004 	str.w	r8, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 80026da:	f8cd 9008 	str.w	r9, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80026de:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80026e0:	f000 fc27 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 80026e4:	4649      	mov	r1, r9
 80026e6:	4628      	mov	r0, r5
 80026e8:	f7ff fb7c 	bl	8001de4 <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 80026ec:	2800      	cmp	r0, #0
 80026ee:	f040 80c3 	bne.w	8002878 <HAL_SD_WriteBlocks+0x1e6>
  {
    return errorstate;
  }
  
  if(NumberOfBlocks > 1U)
 80026f2:	2f01      	cmp	r7, #1
  {
    /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
 80026f4:	bf8c      	ite	hi
 80026f6:	2319      	movhi	r3, #25
  }
  else
  {
    /* Send CMD24 WRITE_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
 80026f8:	2318      	movls	r3, #24
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80026fa:	a901      	add	r1, sp, #4
 80026fc:	6828      	ldr	r0, [r5, #0]
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
  }
  else
  {
    /* Send CMD24 WRITE_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
 80026fe:	9302      	str	r3, [sp, #8]
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
 8002700:	9401      	str	r4, [sp, #4]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002702:	f000 fc16 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  if(NumberOfBlocks > 1U)
 8002706:	2f01      	cmp	r7, #1
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_MULT_BLOCK);
 8002708:	bf8c      	ite	hi
 800270a:	2119      	movhi	r1, #25
  }
  else
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_SINGLE_BLOCK);
 800270c:	2118      	movls	r1, #24
 800270e:	4628      	mov	r0, r5
 8002710:	f7ff fb68 	bl	8001de4 <SD_CmdResp1Error>
 8002714:	4604      	mov	r4, r0
  }  
  
  if (errorstate != SD_OK)
 8002716:	2800      	cmp	r0, #0
 8002718:	f040 80ae 	bne.w	8002878 <HAL_SD_WriteBlocks+0x1e6>
  
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 800271c:	f04f 33ff 	mov.w	r3, #4294967295
 8002720:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8002722:	2390      	movs	r3, #144	; 0x90
 8002724:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
 8002726:	9009      	str	r0, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8002728:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 800272a:	2301      	movs	r3, #1
  {
    return errorstate;
  }
  
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
 800272c:	fb07 f808 	mul.w	r8, r7, r8
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8002730:	a906      	add	r1, sp, #24
 8002732:	6828      	ldr	r0, [r5, #0]
  /* Set total number of bytes to write */
  totalnumberofbytes = NumberOfBlocks * BlockSize;
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = NumberOfBlocks * BlockSize;
 8002734:	f8cd 801c 	str.w	r8, [sp, #28]
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8002738:	930b      	str	r3, [sp, #44]	; 0x2c
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 800273a:	f000 fc1d 	bl	8002f78 <SDIO_DataConfig>
  
  /* Write block(s) in polling mode */
  if(NumberOfBlocks > 1U)
 800273e:	2f01      	cmp	r7, #1
 8002740:	d940      	bls.n	80027c4 <HAL_SD_WriteBlocks+0x132>
  {
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
 8002742:	682b      	ldr	r3, [r5, #0]
 8002744:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8002746:	f240 321a 	movw	r2, #794	; 0x31a
 800274a:	400a      	ands	r2, r1
 800274c:	bb9a      	cbnz	r2, 80027b6 <HAL_SD_WriteBlocks+0x124>
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
#endif /* SDIO_STA_STBITERR */     
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
 800274e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8002750:	0449      	lsls	r1, r1, #17
 8002752:	d5f7      	bpl.n	8002744 <HAL_SD_WriteBlocks+0xb2>
      {
        if ((totalnumberofbytes - bytestransferred) < 32U)
 8002754:	ebc4 0308 	rsb	r3, r4, r8
 8002758:	2b1f      	cmp	r3, #31
 800275a:	d813      	bhi.n	8002784 <HAL_SD_WriteBlocks+0xf2>
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
 800275c:	f013 0f03 	tst.w	r3, #3
 8002760:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8002764:	bf18      	it	ne
 8002766:	3301      	addne	r3, #1
 8002768:	ea4f 0983 	mov.w	r9, r3, lsl #2
 800276c:	eb06 0a09 	add.w	sl, r6, r9
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 8002770:	4556      	cmp	r6, sl
 8002772:	d005      	beq.n	8002780 <HAL_SD_WriteBlocks+0xee>
          {
            SDIO_WriteFIFO(hsd->Instance, tempbuff);
 8002774:	4631      	mov	r1, r6
 8002776:	6828      	ldr	r0, [r5, #0]
 8002778:	f000 fbce 	bl	8002f18 <SDIO_WriteFIFO>
            tempbuff++;
 800277c:	3604      	adds	r6, #4
 800277e:	e7f7      	b.n	8002770 <HAL_SD_WriteBlocks+0xde>
 8002780:	444c      	add	r4, r9
 8002782:	e00d      	b.n	80027a0 <HAL_SD_WriteBlocks+0x10e>
 8002784:	4691      	mov	r9, r2
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
 8002786:	eb06 0109 	add.w	r1, r6, r9
 800278a:	6828      	ldr	r0, [r5, #0]
 800278c:	f109 0904 	add.w	r9, r9, #4
 8002790:	f000 fbc2 	bl	8002f18 <SDIO_WriteFIFO>
          }
        }
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
 8002794:	f1b9 0f20 	cmp.w	r9, #32
 8002798:	d1f5      	bne.n	8002786 <HAL_SD_WriteBlocks+0xf4>
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
          }
          
          tempbuff += 8U;
 800279a:	f106 0a20 	add.w	sl, r6, #32
          bytestransferred += 32U;
 800279e:	3420      	adds	r4, #32
 80027a0:	4656      	mov	r6, sl
 80027a2:	e7ce      	b.n	8002742 <HAL_SD_WriteBlocks+0xb0>
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
#else /* SDIO_STA_STBITERR not defined */
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
 80027a4:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80027a6:	0449      	lsls	r1, r1, #17
 80027a8:	d40e      	bmi.n	80027c8 <HAL_SD_WriteBlocks+0x136>
  }
  else
  {
    /* In case of single data block transfer no need of stop command at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 80027aa:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80027ac:	f240 621a 	movw	r2, #1562	; 0x61a
 80027b0:	400a      	ands	r2, r1
 80027b2:	2a00      	cmp	r2, #0
 80027b4:	d0f6      	beq.n	80027a4 <HAL_SD_WriteBlocks+0x112>
      }
    }  
  }
  
  /* Send stop transmission command in case of multiblock write */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 80027b6:	682b      	ldr	r3, [r5, #0]
 80027b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80027ba:	05d8      	lsls	r0, r3, #23
 80027bc:	d429      	bmi.n	8002812 <HAL_SD_WriteBlocks+0x180>
 80027be:	e030      	b.n	8002822 <HAL_SD_WriteBlocks+0x190>
 80027c0:	444c      	add	r4, r9
 80027c2:	4656      	mov	r6, sl
  }
  else
  {
    /* In case of single data block transfer no need of stop command at all */
#ifdef SDIO_STA_STBITERR
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 80027c4:	682b      	ldr	r3, [r5, #0]
 80027c6:	e7f0      	b.n	80027aa <HAL_SD_WriteBlocks+0x118>
    while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
    {
      if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
      {
        if ((totalnumberofbytes - bytestransferred) < 32U)
 80027c8:	ebc4 0308 	rsb	r3, r4, r8
 80027cc:	2b1f      	cmp	r3, #31
 80027ce:	d811      	bhi.n	80027f4 <HAL_SD_WriteBlocks+0x162>
        {
          restwords = ((totalnumberofbytes - bytestransferred) % 4U == 0U) ? ((totalnumberofbytes - bytestransferred) / 4U) : (( totalnumberofbytes -  bytestransferred) / 4U + 1U);
 80027d0:	f013 0f03 	tst.w	r3, #3
 80027d4:	ea4f 0393 	mov.w	r3, r3, lsr #2
 80027d8:	bf18      	it	ne
 80027da:	3301      	addne	r3, #1
 80027dc:	ea4f 0983 	mov.w	r9, r3, lsl #2
 80027e0:	eb06 0a09 	add.w	sl, r6, r9
          
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < restwords; count++)
 80027e4:	4556      	cmp	r6, sl
 80027e6:	d0eb      	beq.n	80027c0 <HAL_SD_WriteBlocks+0x12e>
          {
            SDIO_WriteFIFO(hsd->Instance, tempbuff);
 80027e8:	4631      	mov	r1, r6
 80027ea:	6828      	ldr	r0, [r5, #0]
 80027ec:	f000 fb94 	bl	8002f18 <SDIO_WriteFIFO>
            tempbuff++; 
 80027f0:	3604      	adds	r6, #4
 80027f2:	e7f7      	b.n	80027e4 <HAL_SD_WriteBlocks+0x152>
 80027f4:	4691      	mov	r9, r2
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
 80027f6:	eb06 0109 	add.w	r1, r6, r9
 80027fa:	6828      	ldr	r0, [r5, #0]
 80027fc:	f109 0904 	add.w	r9, r9, #4
 8002800:	f000 fb8a 	bl	8002f18 <SDIO_WriteFIFO>
          }
        }
        else
        {
          /* Write data to SDIO Tx FIFO */
          for (count = 0U; count < 8U; count++)
 8002804:	f1b9 0f20 	cmp.w	r9, #32
 8002808:	d1f5      	bne.n	80027f6 <HAL_SD_WriteBlocks+0x164>
          {
            SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
          }
          
          tempbuff += 8U;
 800280a:	f106 0a20 	add.w	sl, r6, #32
          bytestransferred += 32U;
 800280e:	3420      	adds	r4, #32
 8002810:	e7d7      	b.n	80027c2 <HAL_SD_WriteBlocks+0x130>
      }
    }  
  }
  
  /* Send stop transmission command in case of multiblock write */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 8002812:	2f01      	cmp	r7, #1
 8002814:	d905      	bls.n	8002822 <HAL_SD_WriteBlocks+0x190>
  {    
    if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 8002816:	6a2b      	ldr	r3, [r5, #32]
 8002818:	2b02      	cmp	r3, #2
 800281a:	d802      	bhi.n	8002822 <HAL_SD_WriteBlocks+0x190>
      (hsd->CardType == HIGH_CAPACITY_SD_CARD))
    {
      /* Send stop transmission command */
      errorstate = HAL_SD_StopTransfer(hsd);
 800281c:	4628      	mov	r0, r5
 800281e:	f7ff fe5f 	bl	80024e0 <HAL_SD_StopTransfer>
    }
  }
  
  /* Get error state */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 8002822:	682b      	ldr	r3, [r5, #0]
 8002824:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002826:	0714      	lsls	r4, r2, #28
 8002828:	d503      	bpl.n	8002832 <HAL_SD_WriteBlocks+0x1a0>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 800282a:	2208      	movs	r2, #8
 800282c:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 800282e:	2004      	movs	r0, #4
 8002830:	e022      	b.n	8002878 <HAL_SD_WriteBlocks+0x1e6>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8002832:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002834:	0790      	lsls	r0, r2, #30
 8002836:	d502      	bpl.n	800283e <HAL_SD_WriteBlocks+0x1ac>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8002838:	2002      	movs	r0, #2
 800283a:	6398      	str	r0, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
 800283c:	e01c      	b.n	8002878 <HAL_SD_WriteBlocks+0x1e6>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR))
 800283e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002840:	06d1      	lsls	r1, r2, #27
 8002842:	d503      	bpl.n	800284c <HAL_SD_WriteBlocks+0x1ba>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
 8002844:	2210      	movs	r2, #16
 8002846:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_TX_UNDERRUN;
    
    return errorstate;
 8002848:	2005      	movs	r0, #5
 800284a:	e015      	b.n	8002878 <HAL_SD_WriteBlocks+0x1e6>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 800284c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800284e:	0592      	lsls	r2, r2, #22
 8002850:	d504      	bpl.n	800285c <HAL_SD_WriteBlocks+0x1ca>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 8002852:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002856:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 8002858:	2007      	movs	r0, #7
 800285a:	e00d      	b.n	8002878 <HAL_SD_WriteBlocks+0x1e6>
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800285c:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8002860:	639a      	str	r2, [r3, #56]	; 0x38
  /* Wait till the card is in programming state */
  errorstate = SD_IsCardProgramming(hsd, &cardstate);
  
  while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
  {
    errorstate = SD_IsCardProgramming(hsd, &cardstate);
 8002862:	f10d 0103 	add.w	r1, sp, #3
 8002866:	4628      	mov	r0, r5
 8002868:	f7ff fa1a 	bl	8001ca0 <SD_IsCardProgramming>
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
  
  /* Wait till the card is in programming state */
  errorstate = SD_IsCardProgramming(hsd, &cardstate);
  
  while ((errorstate == SD_OK) && ((cardstate == SD_CARD_PROGRAMMING) || (cardstate == SD_CARD_RECEIVING)))
 800286c:	b920      	cbnz	r0, 8002878 <HAL_SD_WriteBlocks+0x1e6>
 800286e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002872:	3b06      	subs	r3, #6
 8002874:	2b01      	cmp	r3, #1
 8002876:	d9f4      	bls.n	8002862 <HAL_SD_WriteBlocks+0x1d0>
  {
    errorstate = SD_IsCardProgramming(hsd, &cardstate);
  }
  
  return errorstate;
}
 8002878:	b00c      	add	sp, #48	; 0x30
 800287a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800287e <HAL_SD_SendSDStatus>:
  * @param  pSDstatus: Pointer to the buffer that will contain the SD card status 
  *         SD Status register)
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
 800287e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002880:	4605      	mov	r5, r0
 8002882:	b08d      	sub	sp, #52	; 0x34
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U;
  
  /* Check SD response */
  if ((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 8002884:	2000      	movs	r0, #0
  * @param  pSDstatus: Pointer to the buffer that will contain the SD card status 
  *         SD Status register)
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
 8002886:	460e      	mov	r6, r1
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t count = 0U;
  
  /* Check SD response */
  if ((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 8002888:	f000 fb6a 	bl	8002f60 <SDIO_GetResponse>
 800288c:	f010 7000 	ands.w	r0, r0, #33554432	; 0x2000000
 8002890:	f040 8082 	bne.w	8002998 <HAL_SD_SendSDStatus+0x11a>
    
    return errorstate;
  }
  
  /* Set block size for card if it is not equal to current block size for card */
  sdio_cmdinitstructure.Argument         = 64U;
 8002894:	2740      	movs	r7, #64	; 0x40
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8002896:	2410      	movs	r4, #16
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8002898:	9004      	str	r0, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 800289a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 800289e:	a901      	add	r1, sp, #4
 80028a0:	6828      	ldr	r0, [r5, #0]
    
    return errorstate;
  }
  
  /* Set block size for card if it is not equal to current block size for card */
  sdio_cmdinitstructure.Argument         = 64U;
 80028a2:	9701      	str	r7, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 80028a4:	9402      	str	r4, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80028a6:	9703      	str	r7, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80028a8:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80028aa:	f000 fb42 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 80028ae:	4621      	mov	r1, r4
 80028b0:	4628      	mov	r0, r5
 80028b2:	f7ff fa97 	bl	8001de4 <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 80028b6:	2800      	cmp	r0, #0
 80028b8:	d16f      	bne.n	800299a <HAL_SD_SendSDStatus+0x11c>
  {
    return errorstate;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80028ba:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80028bc:	6828      	ldr	r0, [r5, #0]
  {
    return errorstate;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80028be:	40a3      	lsls	r3, r4
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80028c0:	a901      	add	r1, sp, #4
    return errorstate;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80028c2:	2437      	movs	r4, #55	; 0x37
  {
    return errorstate;
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80028c4:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80028c6:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80028c8:	f000 fb33 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80028cc:	4621      	mov	r1, r4
 80028ce:	4628      	mov	r0, r5
 80028d0:	f7ff fa88 	bl	8001de4 <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 80028d4:	4604      	mov	r4, r0
 80028d6:	2800      	cmp	r0, #0
 80028d8:	d15f      	bne.n	800299a <HAL_SD_SendSDStatus+0x11c>
  {
    return errorstate;
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 80028da:	f04f 33ff 	mov.w	r3, #4294967295
 80028de:	9306      	str	r3, [sp, #24]
  sdio_datainitstructure.DataLength    = 64U;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B;
 80028e0:	2360      	movs	r3, #96	; 0x60
 80028e2:	9308      	str	r3, [sp, #32]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 80028e4:	2302      	movs	r3, #2
 80028e6:	9309      	str	r3, [sp, #36]	; 0x24
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 80028e8:	900a      	str	r0, [sp, #40]	; 0x28
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 80028ea:	2301      	movs	r3, #1
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 80028ec:	a906      	add	r1, sp, #24
 80028ee:	6828      	ldr	r0, [r5, #0]
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = 64U;
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 80028f0:	930b      	str	r3, [sp, #44]	; 0x2c
    return errorstate;
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
  sdio_datainitstructure.DataLength    = 64U;
 80028f2:	9707      	str	r7, [sp, #28]
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_64B;
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 80028f4:	f000 fb40 	bl	8002f78 <SDIO_DataConfig>
  
  /* Send ACMD13 (SD_APP_STATUS)  with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = 0U;
 80028f8:	9401      	str	r4, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_STATUS;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80028fa:	a901      	add	r1, sp, #4
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
  
  /* Send ACMD13 (SD_APP_STATUS)  with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_STATUS;
 80028fc:	240d      	movs	r4, #13
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80028fe:	6828      	ldr	r0, [r5, #0]
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
  
  /* Send ACMD13 (SD_APP_STATUS)  with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = 0U;
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_STATUS;
 8002900:	9402      	str	r4, [sp, #8]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8002902:	f000 fb16 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_APP_STATUS);
 8002906:	4621      	mov	r1, r4
 8002908:	4628      	mov	r0, r5
 800290a:	f7ff fa6b 	bl	8001de4 <SD_CmdResp1Error>
  
  if (errorstate != SD_OK)
 800290e:	2800      	cmp	r0, #0
 8002910:	d143      	bne.n	800299a <HAL_SD_SendSDStatus+0x11c>
    return errorstate;
  }
  
  /* Get status data */
#ifdef SDIO_STA_STBITERR 
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 8002912:	682b      	ldr	r3, [r5, #0]
 8002914:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8002916:	f240 622a 	movw	r2, #1578	; 0x62a
 800291a:	400a      	ands	r2, r1
 800291c:	b972      	cbnz	r2, 800293c <HAL_SD_SendSDStatus+0xbe>
#else /* SDIO_STA_STBITERR not defined */
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))    
#endif /* SDIO_STA_STBITERR */
  {
    if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
 800291e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002920:	0417      	lsls	r7, r2, #16
 8002922:	d5f7      	bpl.n	8002914 <HAL_SD_SendSDStatus+0x96>
 8002924:	1f34      	subs	r4, r6, #4
 8002926:	f106 071c 	add.w	r7, r6, #28
    {
      for (count = 0U; count < 8U; count++)
      {
        *(pSDstatus + count) = SDIO_ReadFIFO(hsd->Instance);
 800292a:	6828      	ldr	r0, [r5, #0]
 800292c:	f000 faf1 	bl	8002f12 <SDIO_ReadFIFO>
 8002930:	f844 0f04 	str.w	r0, [r4, #4]!
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))    
#endif /* SDIO_STA_STBITERR */
  {
    if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
    {
      for (count = 0U; count < 8U; count++)
 8002934:	42bc      	cmp	r4, r7
 8002936:	d1f8      	bne.n	800292a <HAL_SD_SendSDStatus+0xac>
      {
        *(pSDstatus + count) = SDIO_ReadFIFO(hsd->Instance);
      }
      
      pSDstatus += 8U;
 8002938:	3620      	adds	r6, #32
 800293a:	e7ea      	b.n	8002912 <HAL_SD_SendSDStatus+0x94>
    }
  }
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 800293c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800293e:	0714      	lsls	r4, r2, #28
 8002940:	d503      	bpl.n	800294a <HAL_SD_SendSDStatus+0xcc>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8002942:	2208      	movs	r2, #8
 8002944:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
    
    return errorstate;
 8002946:	2004      	movs	r0, #4
 8002948:	e027      	b.n	800299a <HAL_SD_SendSDStatus+0x11c>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 800294a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800294c:	0790      	lsls	r0, r2, #30
 800294e:	d502      	bpl.n	8002956 <HAL_SD_SendSDStatus+0xd8>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8002950:	2002      	movs	r0, #2
 8002952:	6398      	str	r0, [r3, #56]	; 0x38
 8002954:	e021      	b.n	800299a <HAL_SD_SendSDStatus+0x11c>
    
    errorstate = SD_DATA_CRC_FAIL;
    
    return errorstate;
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 8002956:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002958:	0691      	lsls	r1, r2, #26
 800295a:	d503      	bpl.n	8002964 <HAL_SD_SendSDStatus+0xe6>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 800295c:	2220      	movs	r2, #32
 800295e:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_RX_OVERRUN;
    
    return errorstate;
 8002960:	2006      	movs	r0, #6
 8002962:	e01a      	b.n	800299a <HAL_SD_SendSDStatus+0x11c>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 8002964:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002966:	0592      	lsls	r2, r2, #22
 8002968:	d402      	bmi.n	8002970 <HAL_SD_SendSDStatus+0xf2>
 800296a:	f04f 34ff 	mov.w	r4, #4294967295
 800296e:	e00a      	b.n	8002986 <HAL_SD_SendSDStatus+0x108>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 8002970:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002974:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
    
    return errorstate;
 8002976:	2007      	movs	r0, #7
 8002978:	e00f      	b.n	800299a <HAL_SD_SendSDStatus+0x11c>
  {
    /* No error flag set */
  }  
  
  count = SD_DATATIMEOUT;
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 800297a:	b144      	cbz	r4, 800298e <HAL_SD_SendSDStatus+0x110>
  {
    *pSDstatus = SDIO_ReadFIFO(hsd->Instance);
 800297c:	f000 fac9 	bl	8002f12 <SDIO_ReadFIFO>
 8002980:	f846 0b04 	str.w	r0, [r6], #4
    pSDstatus++;
    count--;
 8002984:	3c01      	subs	r4, #1
  {
    /* No error flag set */
  }  
  
  count = SD_DATATIMEOUT;
  while ((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)) && (count > 0U))
 8002986:	6828      	ldr	r0, [r5, #0]
 8002988:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800298a:	029b      	lsls	r3, r3, #10
 800298c:	d4f5      	bmi.n	800297a <HAL_SD_SendSDStatus+0xfc>
    pSDstatus++;
    count--;
  }
  
  /* Clear all the static status flags*/
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800298e:	f240 53ff 	movw	r3, #1535	; 0x5ff
 8002992:	6383      	str	r3, [r0, #56]	; 0x38
 8002994:	2000      	movs	r0, #0
 8002996:	e000      	b.n	800299a <HAL_SD_SendSDStatus+0x11c>
  /* Check SD response */
  if ((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
  {
    errorstate = SD_LOCK_UNLOCK_FAILED;
    
    return errorstate;
 8002998:	200e      	movs	r0, #14
  
  /* Clear all the static status flags*/
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
  
  return errorstate;
}
 800299a:	b00d      	add	sp, #52	; 0x34
 800299c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800299e <HAL_SD_GetStatus>:
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 800299e:	b530      	push	{r4, r5, lr}
    
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80029a0:	6a43      	ldr	r3, [r0, #36]	; 0x24
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 80029a2:	b087      	sub	sp, #28
    
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80029a4:	041b      	lsls	r3, r3, #16
 80029a6:	9301      	str	r3, [sp, #4]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80029a8:	2340      	movs	r3, #64	; 0x40
 80029aa:	9303      	str	r3, [sp, #12]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80029ac:	2300      	movs	r3, #0
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 80029ae:	4604      	mov	r4, r0
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 80029b0:	250d      	movs	r5, #13
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80029b2:	9304      	str	r3, [sp, #16]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80029b4:	a901      	add	r1, sp, #4
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80029b6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80029ba:	6800      	ldr	r0, [r0, #0]
    return errorstate;
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 80029bc:	9502      	str	r5, [sp, #8]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80029be:	9305      	str	r3, [sp, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80029c0:	f000 fab7 	bl	8002f32 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEND_STATUS);
 80029c4:	4629      	mov	r1, r5
 80029c6:	4620      	mov	r0, r4
 80029c8:	f7ff fa0c 	bl	8001de4 <SD_CmdResp1Error>
  
  if(errorstate != SD_OK)
 80029cc:	b938      	cbnz	r0, 80029de <HAL_SD_GetStatus+0x40>
  {
    return errorstate;
  }
  
  /* Get SD card status */
  *pCardStatus = SDIO_GetResponse(SDIO_RESP1);
 80029ce:	f000 fac7 	bl	8002f60 <SDIO_GetResponse>
  cardstate = SD_GetState(hsd);
  
  /* Find SD status according to card state*/
  if (cardstate == SD_CARD_TRANSFER)
  {
    return SD_TRANSFER_OK;
 80029d2:	f3c0 2043 	ubfx	r0, r0, #9, #4
 80029d6:	3804      	subs	r0, #4
 80029d8:	bf18      	it	ne
 80029da:	2001      	movne	r0, #1
 80029dc:	e000      	b.n	80029e0 <HAL_SD_GetStatus+0x42>
  }
  else if(cardstate == SD_CARD_ERROR)
  {
    return SD_TRANSFER_ERROR;
 80029de:	2002      	movs	r0, #2
  }
  else
  {
    return SD_TRANSFER_BUSY;
  }
}
 80029e0:	b007      	add	sp, #28
 80029e2:	bd30      	pop	{r4, r5, pc}

080029e4 <HAL_SD_GetCardStatus>:
  * @param  pCardStatus: Pointer to the HAL_SD_CardStatusTypedef structure that 
  *         will contain the SD card status information 
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypedef *pCardStatus)
{
 80029e4:	b510      	push	{r4, lr}
 80029e6:	b090      	sub	sp, #64	; 0x40
 80029e8:	460c      	mov	r4, r1
  HAL_SD_ErrorTypedef errorstate = SD_OK;
  uint32_t tmp = 0U;
  uint32_t sd_status[16U];
  
  errorstate = HAL_SD_SendSDStatus(hsd, sd_status);
 80029ea:	4669      	mov	r1, sp
 80029ec:	f7ff ff47 	bl	800287e <HAL_SD_SendSDStatus>
  
  if (errorstate  != SD_OK)
 80029f0:	2800      	cmp	r0, #0
 80029f2:	d12f      	bne.n	8002a54 <HAL_SD_GetCardStatus+0x70>
  {
    return errorstate;
  }
  
  /* Byte 0 */
  tmp = (sd_status[0U] & 0xC0U) >> 6U;
 80029f4:	9b00      	ldr	r3, [sp, #0]
  pCardStatus->DAT_BUS_WIDTH = (uint8_t)tmp;
 80029f6:	f3c3 1281 	ubfx	r2, r3, #6, #2
  
  /* Byte 0 */
  tmp = (sd_status[0U] & 0x20U) >> 5U;
  pCardStatus->SECURED_MODE = (uint8_t)tmp;
 80029fa:	f3c3 1340 	ubfx	r3, r3, #5, #1
    return errorstate;
  }
  
  /* Byte 0 */
  tmp = (sd_status[0U] & 0xC0U) >> 6U;
  pCardStatus->DAT_BUS_WIDTH = (uint8_t)tmp;
 80029fe:	7022      	strb	r2, [r4, #0]
  
  /* Byte 0 */
  tmp = (sd_status[0U] & 0x20U) >> 5U;
  pCardStatus->SECURED_MODE = (uint8_t)tmp;
 8002a00:	7063      	strb	r3, [r4, #1]
  
  /* Byte 2 */
  tmp = (sd_status[2U] & 0xFFU);
  pCardStatus->SD_CARD_TYPE = (uint8_t)(tmp << 8U);
 8002a02:	8060      	strh	r0, [r4, #2]
  
  /* Byte 3 */
  tmp = (sd_status[3U] & 0xFFU);
  pCardStatus->SD_CARD_TYPE |= (uint8_t)tmp;
 8002a04:	8863      	ldrh	r3, [r4, #2]
 8002a06:	f89d 200c 	ldrb.w	r2, [sp, #12]
 8002a0a:	b29b      	uxth	r3, r3
 8002a0c:	4313      	orrs	r3, r2
 8002a0e:	8063      	strh	r3, [r4, #2]
  
  /* Byte 4 */
  tmp = (sd_status[4U] & 0xFFU);
  pCardStatus->SIZE_OF_PROTECTED_AREA = (uint8_t)(tmp << 24U);
 8002a10:	6060      	str	r0, [r4, #4]
  
  /* Byte 5 */
  tmp = (sd_status[5U] & 0xFFU);
  pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)(tmp << 16U);
 8002a12:	6863      	ldr	r3, [r4, #4]
 8002a14:	6063      	str	r3, [r4, #4]
  
  /* Byte 6 */
  tmp = (sd_status[6U] & 0xFFU);
  pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)(tmp << 8U);
 8002a16:	6863      	ldr	r3, [r4, #4]
 8002a18:	6063      	str	r3, [r4, #4]
  
  /* Byte 7 */
  tmp = (sd_status[7U] & 0xFFU);
  pCardStatus->SIZE_OF_PROTECTED_AREA |= (uint8_t)tmp;
 8002a1a:	6863      	ldr	r3, [r4, #4]
 8002a1c:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8002a20:	4313      	orrs	r3, r2
 8002a22:	6063      	str	r3, [r4, #4]
  
  /* Byte 8 */
  tmp = (sd_status[8U] & 0xFFU);
  pCardStatus->SPEED_CLASS = (uint8_t)tmp;
 8002a24:	f89d 3020 	ldrb.w	r3, [sp, #32]
 8002a28:	7223      	strb	r3, [r4, #8]
  
  /* Byte 9 */
  tmp = (sd_status[9U] & 0xFFU);
  pCardStatus->PERFORMANCE_MOVE = (uint8_t)tmp;
 8002a2a:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
 8002a2e:	7263      	strb	r3, [r4, #9]
  
  /* Byte 10 */
  tmp = (sd_status[10U] & 0xF0U) >> 4U;
  pCardStatus->AU_SIZE = (uint8_t)tmp;
 8002a30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  tmp = (sd_status[11U] & 0xFFU);
  pCardStatus->ERASE_SIZE = (uint8_t)(tmp << 8U);
  
  /* Byte 12 */
  tmp = (sd_status[12U] & 0xFFU);
  pCardStatus->ERASE_SIZE |= (uint8_t)tmp;
 8002a32:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
  tmp = (sd_status[9U] & 0xFFU);
  pCardStatus->PERFORMANCE_MOVE = (uint8_t)tmp;
  
  /* Byte 10 */
  tmp = (sd_status[10U] & 0xF0U) >> 4U;
  pCardStatus->AU_SIZE = (uint8_t)tmp;
 8002a36:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8002a3a:	72a3      	strb	r3, [r4, #10]
  
  /* Byte 11 */
  tmp = (sd_status[11U] & 0xFFU);
  pCardStatus->ERASE_SIZE = (uint8_t)(tmp << 8U);
 8002a3c:	81a0      	strh	r0, [r4, #12]
  
  /* Byte 12 */
  tmp = (sd_status[12U] & 0xFFU);
  pCardStatus->ERASE_SIZE |= (uint8_t)tmp;
 8002a3e:	89a3      	ldrh	r3, [r4, #12]
 8002a40:	b29b      	uxth	r3, r3
 8002a42:	4313      	orrs	r3, r2
 8002a44:	81a3      	strh	r3, [r4, #12]
  
  /* Byte 13 */
  tmp = (sd_status[13U] & 0xFCU) >> 2U;
 8002a46:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  pCardStatus->ERASE_TIMEOUT = (uint8_t)tmp;
 8002a48:	f3c3 0285 	ubfx	r2, r3, #2, #6
  
  /* Byte 13 */
  tmp = (sd_status[13U] & 0x3U);
  pCardStatus->ERASE_OFFSET = (uint8_t)tmp;
 8002a4c:	f003 0303 	and.w	r3, r3, #3
  tmp = (sd_status[12U] & 0xFFU);
  pCardStatus->ERASE_SIZE |= (uint8_t)tmp;
  
  /* Byte 13 */
  tmp = (sd_status[13U] & 0xFCU) >> 2U;
  pCardStatus->ERASE_TIMEOUT = (uint8_t)tmp;
 8002a50:	73a2      	strb	r2, [r4, #14]
  
  /* Byte 13 */
  tmp = (sd_status[13U] & 0x3U);
  pCardStatus->ERASE_OFFSET = (uint8_t)tmp;
 8002a52:	73e3      	strb	r3, [r4, #15]
  
  return errorstate;
}
 8002a54:	b010      	add	sp, #64	; 0x40
 8002a56:	bd10      	pop	{r4, pc}

08002a58 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8002a58:	6803      	ldr	r3, [r0, #0]
 8002a5a:	68da      	ldr	r2, [r3, #12]
 8002a5c:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8002a60:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002a62:	695a      	ldr	r2, [r3, #20]
 8002a64:	f022 0201 	bic.w	r2, r2, #1
 8002a68:	615a      	str	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8002a6a:	2320      	movs	r3, #32
 8002a6c:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
 8002a70:	4770      	bx	lr
	...

08002a74 <UART_SetConfig>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8002a74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 8002a78:	6807      	ldr	r7, [r0, #0]
 8002a7a:	693b      	ldr	r3, [r7, #16]
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8002a7c:	4604      	mov	r4, r0

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8002a7e:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8002a82:	68c3      	ldr	r3, [r0, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002a84:	68a1      	ldr	r1, [r4, #8]
 8002a86:	69c0      	ldr	r0, [r0, #28]

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8002a88:	4313      	orrs	r3, r2
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002a8a:	6922      	ldr	r2, [r4, #16]

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
  
  /* Write to USART CR2 */
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 8002a8c:	613b      	str	r3, [r7, #16]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;
 8002a8e:	68fb      	ldr	r3, [r7, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002a90:	4311      	orrs	r1, r2
 8002a92:	6962      	ldr	r2, [r4, #20]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8002a94:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002a98:	430a      	orrs	r2, r1
 8002a9a:	4302      	orrs	r2, r0

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8002a9c:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8002aa0:	4313      	orrs	r3, r2
  
  /* Write to USART CR1 */
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 8002aa2:	60fb      	str	r3, [r7, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 8002aa4:	697b      	ldr	r3, [r7, #20]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 8002aa6:	f423 7240 	bic.w	r2, r3, #768	; 0x300
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8002aaa:	69a3      	ldr	r3, [r4, #24]
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002aac:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8002ab0:	ea43 0302 	orr.w	r3, r3, r2
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 8002ab4:	617b      	str	r3, [r7, #20]
 8002ab6:	4b7c      	ldr	r3, [pc, #496]	; (8002ca8 <UART_SetConfig+0x234>)
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002ab8:	d17c      	bne.n	8002bb4 <UART_SetConfig+0x140>
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8002aba:	429f      	cmp	r7, r3
 8002abc:	d003      	beq.n	8002ac6 <UART_SetConfig+0x52>
 8002abe:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002ac2:	429f      	cmp	r7, r3
 8002ac4:	d131      	bne.n	8002b2a <UART_SetConfig+0xb6>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8002ac6:	f7ff f8bd 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002aca:	6863      	ldr	r3, [r4, #4]
 8002acc:	2519      	movs	r5, #25
 8002ace:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8002ad2:	4368      	muls	r0, r5
 8002ad4:	fbb0 f8f8 	udiv	r8, r0, r8
 8002ad8:	f7ff f8b4 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002adc:	6866      	ldr	r6, [r4, #4]
 8002ade:	4368      	muls	r0, r5
 8002ae0:	0076      	lsls	r6, r6, #1
 8002ae2:	fbb0 f6f6 	udiv	r6, r0, r6
 8002ae6:	f7ff f8ad 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002aea:	6863      	ldr	r3, [r4, #4]
 8002aec:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002af0:	005b      	lsls	r3, r3, #1
 8002af2:	4368      	muls	r0, r5
 8002af4:	fbb0 f0f3 	udiv	r0, r0, r3
 8002af8:	fbb0 f0f9 	udiv	r0, r0, r9
 8002afc:	fb09 6610 	mls	r6, r9, r0, r6
 8002b00:	f7ff f8a0 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002b04:	fbb8 f8f9 	udiv	r8, r8, r9
 8002b08:	6861      	ldr	r1, [r4, #4]
 8002b0a:	00f6      	lsls	r6, r6, #3
 8002b0c:	3632      	adds	r6, #50	; 0x32
 8002b0e:	fbb6 f6f9 	udiv	r6, r6, r9
 8002b12:	0076      	lsls	r6, r6, #1
 8002b14:	4368      	muls	r0, r5
 8002b16:	0049      	lsls	r1, r1, #1
 8002b18:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8002b1c:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 8002b20:	fbb0 faf1 	udiv	sl, r0, r1
 8002b24:	f7ff f88e 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002b28:	e030      	b.n	8002b8c <UART_SetConfig+0x118>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8002b2a:	f7ff f873 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002b2e:	6863      	ldr	r3, [r4, #4]
 8002b30:	2519      	movs	r5, #25
 8002b32:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8002b36:	4368      	muls	r0, r5
 8002b38:	fbb0 f8f8 	udiv	r8, r0, r8
 8002b3c:	f7ff f86a 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002b40:	6866      	ldr	r6, [r4, #4]
 8002b42:	4368      	muls	r0, r5
 8002b44:	0076      	lsls	r6, r6, #1
 8002b46:	fbb0 f6f6 	udiv	r6, r0, r6
 8002b4a:	f7ff f863 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002b4e:	6863      	ldr	r3, [r4, #4]
 8002b50:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002b54:	005b      	lsls	r3, r3, #1
 8002b56:	4368      	muls	r0, r5
 8002b58:	fbb0 f0f3 	udiv	r0, r0, r3
 8002b5c:	fbb0 f0f9 	udiv	r0, r0, r9
 8002b60:	fb09 6610 	mls	r6, r9, r0, r6
 8002b64:	f7ff f856 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002b68:	fbb8 f8f9 	udiv	r8, r8, r9
 8002b6c:	00f6      	lsls	r6, r6, #3
 8002b6e:	6861      	ldr	r1, [r4, #4]
 8002b70:	3632      	adds	r6, #50	; 0x32
 8002b72:	fbb6 f6f9 	udiv	r6, r6, r9
 8002b76:	0076      	lsls	r6, r6, #1
 8002b78:	4368      	muls	r0, r5
 8002b7a:	0049      	lsls	r1, r1, #1
 8002b7c:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8002b80:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 8002b84:	fbb0 faf1 	udiv	sl, r0, r1
 8002b88:	f7ff f844 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002b8c:	4345      	muls	r5, r0
 8002b8e:	6860      	ldr	r0, [r4, #4]
 8002b90:	0040      	lsls	r0, r0, #1
 8002b92:	fbb5 f0f0 	udiv	r0, r5, r0
 8002b96:	fbb0 f0f9 	udiv	r0, r0, r9
 8002b9a:	fb09 a210 	mls	r2, r9, r0, sl
 8002b9e:	00d2      	lsls	r2, r2, #3
 8002ba0:	3232      	adds	r2, #50	; 0x32
 8002ba2:	fbb2 f3f9 	udiv	r3, r2, r9
 8002ba6:	f003 0307 	and.w	r3, r3, #7
 8002baa:	4443      	add	r3, r8
 8002bac:	441e      	add	r6, r3
 8002bae:	60be      	str	r6, [r7, #8]
 8002bb0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
  }
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8002bb4:	429f      	cmp	r7, r3
 8002bb6:	d002      	beq.n	8002bbe <UART_SetConfig+0x14a>
 8002bb8:	4b3c      	ldr	r3, [pc, #240]	; (8002cac <UART_SetConfig+0x238>)
 8002bba:	429f      	cmp	r7, r3
 8002bbc:	d130      	bne.n	8002c20 <UART_SetConfig+0x1ac>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8002bbe:	f7ff f841 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002bc2:	6863      	ldr	r3, [r4, #4]
 8002bc4:	2519      	movs	r5, #25
 8002bc6:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8002bca:	4368      	muls	r0, r5
 8002bcc:	fbb0 f8f8 	udiv	r8, r0, r8
 8002bd0:	f7ff f838 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002bd4:	6866      	ldr	r6, [r4, #4]
 8002bd6:	4368      	muls	r0, r5
 8002bd8:	00b6      	lsls	r6, r6, #2
 8002bda:	fbb0 f6f6 	udiv	r6, r0, r6
 8002bde:	f7ff f831 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002be2:	6863      	ldr	r3, [r4, #4]
 8002be4:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002be8:	009b      	lsls	r3, r3, #2
 8002bea:	4368      	muls	r0, r5
 8002bec:	fbb0 f0f3 	udiv	r0, r0, r3
 8002bf0:	fbb0 f0f9 	udiv	r0, r0, r9
 8002bf4:	fb09 6610 	mls	r6, r9, r0, r6
 8002bf8:	f7ff f824 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002bfc:	fbb8 f8f9 	udiv	r8, r8, r9
 8002c00:	6861      	ldr	r1, [r4, #4]
 8002c02:	0136      	lsls	r6, r6, #4
 8002c04:	4368      	muls	r0, r5
 8002c06:	0089      	lsls	r1, r1, #2
 8002c08:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8002c0c:	3632      	adds	r6, #50	; 0x32
 8002c0e:	fbb0 faf1 	udiv	sl, r0, r1
 8002c12:	fbb6 f6f9 	udiv	r6, r6, r9
 8002c16:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 8002c1a:	f7ff f813 	bl	8001c44 <HAL_RCC_GetPCLK2Freq>
 8002c1e:	e02f      	b.n	8002c80 <UART_SetConfig+0x20c>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8002c20:	f7fe fff8 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002c24:	6863      	ldr	r3, [r4, #4]
 8002c26:	2519      	movs	r5, #25
 8002c28:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8002c2c:	4368      	muls	r0, r5
 8002c2e:	fbb0 f8f8 	udiv	r8, r0, r8
 8002c32:	f7fe ffef 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002c36:	6866      	ldr	r6, [r4, #4]
 8002c38:	4368      	muls	r0, r5
 8002c3a:	00b6      	lsls	r6, r6, #2
 8002c3c:	fbb0 f6f6 	udiv	r6, r0, r6
 8002c40:	f7fe ffe8 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002c44:	6863      	ldr	r3, [r4, #4]
 8002c46:	f04f 0964 	mov.w	r9, #100	; 0x64
 8002c4a:	009b      	lsls	r3, r3, #2
 8002c4c:	4368      	muls	r0, r5
 8002c4e:	fbb0 f0f3 	udiv	r0, r0, r3
 8002c52:	fbb0 f0f9 	udiv	r0, r0, r9
 8002c56:	fb09 6610 	mls	r6, r9, r0, r6
 8002c5a:	f7fe ffdb 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002c5e:	fbb8 f8f9 	udiv	r8, r8, r9
 8002c62:	6861      	ldr	r1, [r4, #4]
 8002c64:	0136      	lsls	r6, r6, #4
 8002c66:	3632      	adds	r6, #50	; 0x32
 8002c68:	4368      	muls	r0, r5
 8002c6a:	fbb6 f6f9 	udiv	r6, r6, r9
 8002c6e:	0089      	lsls	r1, r1, #2
 8002c70:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8002c74:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 8002c78:	fbb0 faf1 	udiv	sl, r0, r1
 8002c7c:	f7fe ffca 	bl	8001c14 <HAL_RCC_GetPCLK1Freq>
 8002c80:	4345      	muls	r5, r0
 8002c82:	6860      	ldr	r0, [r4, #4]
 8002c84:	0080      	lsls	r0, r0, #2
 8002c86:	fbb5 f0f0 	udiv	r0, r5, r0
 8002c8a:	fbb0 f0f9 	udiv	r0, r0, r9
 8002c8e:	fb09 a210 	mls	r2, r9, r0, sl
 8002c92:	0112      	lsls	r2, r2, #4
 8002c94:	3232      	adds	r2, #50	; 0x32
 8002c96:	fbb2 f3f9 	udiv	r3, r2, r9
 8002c9a:	f003 030f 	and.w	r3, r3, #15
 8002c9e:	4433      	add	r3, r6
 8002ca0:	4443      	add	r3, r8
 8002ca2:	60bb      	str	r3, [r7, #8]
 8002ca4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002ca8:	40011000 	.word	0x40011000
 8002cac:	40011400 	.word	0x40011400

08002cb0 <HAL_UART_Init>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8002cb0:	b510      	push	{r4, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 8002cb2:	4604      	mov	r4, r0
 8002cb4:	b340      	cbz	r0, 8002d08 <HAL_UART_Init+0x58>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  
  if(huart->gState == HAL_UART_STATE_RESET)
 8002cb6:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8002cba:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002cbe:	b91b      	cbnz	r3, 8002cc8 <HAL_UART_Init+0x18>
  {  
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8002cc0:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
 8002cc4:	f7fd fc5e 	bl	8000584 <HAL_UART_MspInit>
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8002cc8:	6822      	ldr	r2, [r4, #0]
    huart->Lock = HAL_UNLOCKED;
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8002cca:	2324      	movs	r3, #36	; 0x24
 8002ccc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8002cd0:	68d3      	ldr	r3, [r2, #12]
 8002cd2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002cd6:	60d3      	str	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8002cd8:	4620      	mov	r0, r4
 8002cda:	f7ff fecb 	bl	8002a74 <UART_SetConfig>
  
  /* In asynchronous mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002cde:	6823      	ldr	r3, [r4, #0]
 8002ce0:	691a      	ldr	r2, [r3, #16]
 8002ce2:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8002ce6:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8002ce8:	695a      	ldr	r2, [r3, #20]
 8002cea:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8002cee:	615a      	str	r2, [r3, #20]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8002cf0:	68da      	ldr	r2, [r3, #12]
 8002cf2:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002cf6:	60da      	str	r2, [r3, #12]
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002cf8:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
 8002cfa:	2320      	movs	r3, #32
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002cfc:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8002cfe:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8002d02:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
  
  return HAL_OK;
 8002d06:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 8002d08:	2001      	movs	r0, #1
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->gState= HAL_UART_STATE_READY;
  huart->RxState= HAL_UART_STATE_READY;
  
  return HAL_OK;
}
 8002d0a:	bd10      	pop	{r4, pc}

08002d0c <HAL_UART_TxCpltCallback>:
 8002d0c:	4770      	bx	lr

08002d0e <HAL_UART_RxCpltCallback>:
 8002d0e:	4770      	bx	lr

08002d10 <UART_Receive_IT>:
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8002d10:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8002d14:	2b22      	cmp	r3, #34	; 0x22
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 8002d16:	b510      	push	{r4, lr}
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8002d18:	d132      	bne.n	8002d80 <UART_Receive_IT+0x70>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8002d1a:	6883      	ldr	r3, [r0, #8]
 8002d1c:	6901      	ldr	r1, [r0, #16]
 8002d1e:	6802      	ldr	r2, [r0, #0]
 8002d20:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8002d24:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002d26:	d10b      	bne.n	8002d40 <UART_Receive_IT+0x30>
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FFU);
 8002d28:	6852      	ldr	r2, [r2, #4]
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
 8002d2a:	b921      	cbnz	r1, 8002d36 <UART_Receive_IT+0x26>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FFU);
 8002d2c:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8002d30:	f823 2b02 	strh.w	r2, [r3], #2
 8002d34:	e002      	b.n	8002d3c <UART_Receive_IT+0x2c>
        huart->pRxBuffPtr += 2U;
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FFU);
 8002d36:	b2d2      	uxtb	r2, r2
 8002d38:	f823 2b01 	strh.w	r2, [r3], #1
        huart->pRxBuffPtr += 1U;
 8002d3c:	6283      	str	r3, [r0, #40]	; 0x28
 8002d3e:	e00a      	b.n	8002d56 <UART_Receive_IT+0x46>
      }
    }
    else
    {
      if(huart->Init.Parity == UART_PARITY_NONE)
 8002d40:	b919      	cbnz	r1, 8002d4a <UART_Receive_IT+0x3a>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FFU);
 8002d42:	1c59      	adds	r1, r3, #1
 8002d44:	6281      	str	r1, [r0, #40]	; 0x28
 8002d46:	6852      	ldr	r2, [r2, #4]
 8002d48:	e004      	b.n	8002d54 <UART_Receive_IT+0x44>
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007FU);
 8002d4a:	6852      	ldr	r2, [r2, #4]
 8002d4c:	1c59      	adds	r1, r3, #1
 8002d4e:	6281      	str	r1, [r0, #40]	; 0x28
 8002d50:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8002d54:	701a      	strb	r2, [r3, #0]
      }
    }

    if(--huart->RxXferCount == 0U)
 8002d56:	8dc4      	ldrh	r4, [r0, #46]	; 0x2e
 8002d58:	3c01      	subs	r4, #1
 8002d5a:	b2a4      	uxth	r4, r4
 8002d5c:	85c4      	strh	r4, [r0, #46]	; 0x2e
 8002d5e:	b98c      	cbnz	r4, 8002d84 <UART_Receive_IT+0x74>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8002d60:	6803      	ldr	r3, [r0, #0]
 8002d62:	68da      	ldr	r2, [r3, #12]
 8002d64:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8002d68:	60da      	str	r2, [r3, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002d6a:	695a      	ldr	r2, [r3, #20]
 8002d6c:	f022 0201 	bic.w	r2, r2, #1
 8002d70:	615a      	str	r2, [r3, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8002d72:	2320      	movs	r3, #32
 8002d74:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
     
      HAL_UART_RxCpltCallback(huart);
 8002d78:	f7ff ffc9 	bl	8002d0e <HAL_UART_RxCpltCallback>
 8002d7c:	4620      	mov	r0, r4
 8002d7e:	bd10      	pop	{r4, pc}
    }
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8002d80:	2002      	movs	r0, #2
 8002d82:	bd10      	pop	{r4, pc}
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007FU);
      }
    }

    if(--huart->RxXferCount == 0U)
 8002d84:	2000      	movs	r0, #0
  }
  else
  {
    return HAL_BUSY;
  }
}
 8002d86:	bd10      	pop	{r4, pc}

08002d88 <HAL_UART_ErrorCallback>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
 __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8002d88:	4770      	bx	lr
	...

08002d8c <HAL_UART_IRQHandler>:
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8002d8c:	6803      	ldr	r3, [r0, #0]
 8002d8e:	681a      	ldr	r2, [r3, #0]
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8002d90:	68d9      	ldr	r1, [r3, #12]
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8002d92:	b570      	push	{r4, r5, r6, lr}
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8002d94:	0716      	lsls	r6, r2, #28
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8002d96:	4604      	mov	r4, r0
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8002d98:	695d      	ldr	r5, [r3, #20]
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8002d9a:	d107      	bne.n	8002dac <HAL_UART_IRQHandler+0x20>
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8002d9c:	0696      	lsls	r6, r2, #26
 8002d9e:	d55a      	bpl.n	8002e56 <HAL_UART_IRQHandler+0xca>
 8002da0:	068d      	lsls	r5, r1, #26
 8002da2:	d558      	bpl.n	8002e56 <HAL_UART_IRQHandler+0xca>
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8002da4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if(errorflags == RESET)
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
    {
      UART_Receive_IT(huart);
 8002da8:	f7ff bfb2 	b.w	8002d10 <UART_Receive_IT>
      return;
    }
  }

  /* If some errors occur */
  if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8002dac:	f015 0001 	ands.w	r0, r5, #1
 8002db0:	d102      	bne.n	8002db8 <HAL_UART_IRQHandler+0x2c>
 8002db2:	f411 7f90 	tst.w	r1, #288	; 0x120
 8002db6:	d04e      	beq.n	8002e56 <HAL_UART_IRQHandler+0xca>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8002db8:	07d3      	lsls	r3, r2, #31
 8002dba:	d505      	bpl.n	8002dc8 <HAL_UART_IRQHandler+0x3c>
 8002dbc:	05ce      	lsls	r6, r1, #23
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8002dbe:	bf42      	ittt	mi
 8002dc0:	6be3      	ldrmi	r3, [r4, #60]	; 0x3c
 8002dc2:	f043 0301 	orrmi.w	r3, r3, #1
 8002dc6:	63e3      	strmi	r3, [r4, #60]	; 0x3c
    }
    
    /* UART noise error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002dc8:	0755      	lsls	r5, r2, #29
 8002dca:	d504      	bpl.n	8002dd6 <HAL_UART_IRQHandler+0x4a>
 8002dcc:	b118      	cbz	r0, 8002dd6 <HAL_UART_IRQHandler+0x4a>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8002dce:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002dd0:	f043 0302 	orr.w	r3, r3, #2
 8002dd4:	63e3      	str	r3, [r4, #60]	; 0x3c
    }
    
    /* UART frame error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002dd6:	0793      	lsls	r3, r2, #30
 8002dd8:	d504      	bpl.n	8002de4 <HAL_UART_IRQHandler+0x58>
 8002dda:	b118      	cbz	r0, 8002de4 <HAL_UART_IRQHandler+0x58>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8002ddc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002dde:	f043 0304 	orr.w	r3, r3, #4
 8002de2:	63e3      	str	r3, [r4, #60]	; 0x3c
    }
    
    /* UART Over-Run interrupt occurred --------------------------------------*/
    if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002de4:	0716      	lsls	r6, r2, #28
 8002de6:	d504      	bpl.n	8002df2 <HAL_UART_IRQHandler+0x66>
 8002de8:	b118      	cbz	r0, 8002df2 <HAL_UART_IRQHandler+0x66>
    { 
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8002dea:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002dec:	f043 0308 	orr.w	r3, r3, #8
 8002df0:	63e3      	str	r3, [r4, #60]	; 0x3c
    }

    /* Call UART Error Call back function if need be --------------------------*/    
    if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 8002df2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002df4:	2b00      	cmp	r3, #0
 8002df6:	d066      	beq.n	8002ec6 <HAL_UART_IRQHandler+0x13a>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8002df8:	0695      	lsls	r5, r2, #26
 8002dfa:	d504      	bpl.n	8002e06 <HAL_UART_IRQHandler+0x7a>
 8002dfc:	0688      	lsls	r0, r1, #26
 8002dfe:	d502      	bpl.n	8002e06 <HAL_UART_IRQHandler+0x7a>
      {
        UART_Receive_IT(huart);
 8002e00:	4620      	mov	r0, r4
 8002e02:	f7ff ff85 	bl	8002d10 <UART_Receive_IT>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8002e06:	6823      	ldr	r3, [r4, #0]
 8002e08:	695b      	ldr	r3, [r3, #20]
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8002e0a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8002e0c:	0711      	lsls	r1, r2, #28
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8002e0e:	4620      	mov	r0, r4
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8002e10:	d402      	bmi.n	8002e18 <HAL_UART_IRQHandler+0x8c>
 8002e12:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 8002e16:	d01a      	beq.n	8002e4e <HAL_UART_IRQHandler+0xc2>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8002e18:	f7ff fe1e 	bl	8002a58 <UART_EndRxTransfer>
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8002e1c:	6823      	ldr	r3, [r4, #0]
 8002e1e:	695a      	ldr	r2, [r3, #20]
 8002e20:	0652      	lsls	r2, r2, #25
 8002e22:	d510      	bpl.n	8002e46 <HAL_UART_IRQHandler+0xba>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8002e24:	695a      	ldr	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8002e26:	6b60      	ldr	r0, [r4, #52]	; 0x34
        UART_EndRxTransfer(huart);
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8002e28:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002e2c:	615a      	str	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8002e2e:	b150      	cbz	r0, 8002e46 <HAL_UART_IRQHandler+0xba>
          {
            /* Set the UART DMA Abort callback : 
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8002e30:	4b25      	ldr	r3, [pc, #148]	; (8002ec8 <HAL_UART_IRQHandler+0x13c>)
 8002e32:	6503      	str	r3, [r0, #80]	; 0x50
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8002e34:	f7fd fefb 	bl	8000c2e <HAL_DMA_Abort_IT>
 8002e38:	2800      	cmp	r0, #0
 8002e3a:	d044      	beq.n	8002ec6 <HAL_UART_IRQHandler+0x13a>
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8002e3c:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8002e3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8002e42:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8002e44:	4718      	bx	r3
            }
          }
          else
          {
            /* Call user error callback */
            HAL_UART_ErrorCallback(huart);
 8002e46:	4620      	mov	r0, r4
 8002e48:	f7ff ff9e 	bl	8002d88 <HAL_UART_ErrorCallback>
 8002e4c:	bd70      	pop	{r4, r5, r6, pc}
      }
      else
      {
        /* Non Blocking error : transfer could go on. 
           Error is notified to user through user error callback */
        HAL_UART_ErrorCallback(huart);
 8002e4e:	f7ff ff9b 	bl	8002d88 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002e52:	63e5      	str	r5, [r4, #60]	; 0x3c
 8002e54:	bd70      	pop	{r4, r5, r6, pc}
    }
    return;
  } /* End if some error occurs */

  /* UART in mode Transmitter ------------------------------------------------*/
  if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8002e56:	0616      	lsls	r6, r2, #24
 8002e58:	d527      	bpl.n	8002eaa <HAL_UART_IRQHandler+0x11e>
 8002e5a:	060d      	lsls	r5, r1, #24
 8002e5c:	d525      	bpl.n	8002eaa <HAL_UART_IRQHandler+0x11e>
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Tx process is ongoing */
  if(huart->gState == HAL_UART_STATE_BUSY_TX)
 8002e5e:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8002e62:	2a21      	cmp	r2, #33	; 0x21
 8002e64:	d12f      	bne.n	8002ec6 <HAL_UART_IRQHandler+0x13a>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8002e66:	68a2      	ldr	r2, [r4, #8]
 8002e68:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8002e6c:	6a22      	ldr	r2, [r4, #32]
 8002e6e:	d10a      	bne.n	8002e86 <HAL_UART_IRQHandler+0xfa>
    {
      tmp = (uint16_t*) huart->pTxBuffPtr;
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FFU);
 8002e70:	8811      	ldrh	r1, [r2, #0]
 8002e72:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8002e76:	6059      	str	r1, [r3, #4]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8002e78:	6921      	ldr	r1, [r4, #16]
 8002e7a:	b909      	cbnz	r1, 8002e80 <HAL_UART_IRQHandler+0xf4>
      {
        huart->pTxBuffPtr += 2U;
 8002e7c:	3202      	adds	r2, #2
 8002e7e:	e000      	b.n	8002e82 <HAL_UART_IRQHandler+0xf6>
      }
      else
      {
        huart->pTxBuffPtr += 1U;
 8002e80:	3201      	adds	r2, #1
 8002e82:	6222      	str	r2, [r4, #32]
 8002e84:	e003      	b.n	8002e8e <HAL_UART_IRQHandler+0x102>
      }
    } 
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FFU);
 8002e86:	1c51      	adds	r1, r2, #1
 8002e88:	6221      	str	r1, [r4, #32]
 8002e8a:	7812      	ldrb	r2, [r2, #0]
 8002e8c:	605a      	str	r2, [r3, #4]
    }

    if(--huart->TxXferCount == 0U)
 8002e8e:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8002e90:	3a01      	subs	r2, #1
 8002e92:	b292      	uxth	r2, r2
 8002e94:	84e2      	strh	r2, [r4, #38]	; 0x26
 8002e96:	b9b2      	cbnz	r2, 8002ec6 <HAL_UART_IRQHandler+0x13a>
    {
      /* Disable the UART Transmit Complete Interrupt */
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8002e98:	68da      	ldr	r2, [r3, #12]
 8002e9a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002e9e:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */    
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8002ea0:	68da      	ldr	r2, [r3, #12]
 8002ea2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002ea6:	60da      	str	r2, [r3, #12]
 8002ea8:	bd70      	pop	{r4, r5, r6, pc}
    UART_Transmit_IT(huart);
    return;
  }
  
  /* UART in mode Transmitter end --------------------------------------------*/
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8002eaa:	0650      	lsls	r0, r2, #25
 8002eac:	d50b      	bpl.n	8002ec6 <HAL_UART_IRQHandler+0x13a>
 8002eae:	064a      	lsls	r2, r1, #25
 8002eb0:	d509      	bpl.n	8002ec6 <HAL_UART_IRQHandler+0x13a>
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8002eb2:	68da      	ldr	r2, [r3, #12]
 8002eb4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002eb8:	60da      	str	r2, [r3, #12]
  
  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8002eba:	2320      	movs	r3, #32
 8002ebc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    
  HAL_UART_TxCpltCallback(huart);
 8002ec0:	4620      	mov	r0, r4
 8002ec2:	f7ff ff23 	bl	8002d0c <HAL_UART_TxCpltCallback>
 8002ec6:	bd70      	pop	{r4, r5, r6, pc}
 8002ec8:	08002ecd 	.word	0x08002ecd

08002ecc <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8002ecc:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8002ece:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0;
 8002ed0:	2300      	movs	r3, #0
 8002ed2:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0;
 8002ed4:	84c3      	strh	r3, [r0, #38]	; 0x26

  HAL_UART_ErrorCallback(huart);
 8002ed6:	f7ff ff57 	bl	8002d88 <HAL_UART_ErrorCallback>
 8002eda:	bd08      	pop	{r3, pc}

08002edc <SDIO_Init>:
  * @param  SDIOx: Pointer to SDIO register base
  * @param  Init: SDIO initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_Init(SDIO_TypeDef *SDIOx, SDIO_InitTypeDef Init)
{
 8002edc:	b084      	sub	sp, #16
 8002ede:	b510      	push	{r4, lr}
 8002ee0:	ac03      	add	r4, sp, #12
 8002ee2:	e884 000e 	stmia.w	r4, {r1, r2, r3}
             Init.HardwareFlowControl |\
             Init.ClockDiv
             ); 
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 8002ee6:	9b04      	ldr	r3, [sp, #16]
 8002ee8:	6842      	ldr	r2, [r0, #4]
 8002eea:	4319      	orrs	r1, r3
 8002eec:	9b05      	ldr	r3, [sp, #20]
 8002eee:	4319      	orrs	r1, r3
 8002ef0:	9b06      	ldr	r3, [sp, #24]
 8002ef2:	4319      	orrs	r1, r3
 8002ef4:	9b07      	ldr	r3, [sp, #28]
 8002ef6:	4319      	orrs	r1, r3
 8002ef8:	9b08      	ldr	r3, [sp, #32]

  return HAL_OK;
}
 8002efa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
             Init.HardwareFlowControl |\
             Init.ClockDiv
             ); 
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 8002efe:	4319      	orrs	r1, r3
 8002f00:	f422 43fd 	bic.w	r3, r2, #32384	; 0x7e80
 8002f04:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8002f08:	430b      	orrs	r3, r1
 8002f0a:	6043      	str	r3, [r0, #4]

  return HAL_OK;
}
 8002f0c:	b004      	add	sp, #16
 8002f0e:	2000      	movs	r0, #0
 8002f10:	4770      	bx	lr

08002f12 <SDIO_ReadFIFO>:
 8002f12:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8002f16:	4770      	bx	lr

08002f18 <SDIO_WriteFIFO>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_WriteFIFO(SDIO_TypeDef *SDIOx, uint32_t *pWriteData)
{ 
  /* Write data to FIFO */ 
  SDIOx->FIFO = *pWriteData;
 8002f18:	680b      	ldr	r3, [r1, #0]
 8002f1a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80

  return HAL_OK;
}
 8002f1e:	2000      	movs	r0, #0
 8002f20:	4770      	bx	lr

08002f22 <SDIO_PowerState_ON>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_PowerState_ON(SDIO_TypeDef *SDIOx)
{  
  /* Set power state to ON */ 
  SDIOx->POWER = SDIO_POWER_PWRCTRL;
 8002f22:	2303      	movs	r3, #3
 8002f24:	6003      	str	r3, [r0, #0]
  
  return HAL_OK; 
}
 8002f26:	2000      	movs	r0, #0
 8002f28:	4770      	bx	lr

08002f2a <SDIO_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(SDIO_TypeDef *SDIOx)  
{
  return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
 8002f2a:	6800      	ldr	r0, [r0, #0]
}
 8002f2c:	f000 0003 	and.w	r0, r0, #3
 8002f30:	4770      	bx	lr

08002f32 <SDIO_SendCommand>:
  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->Response));
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->WaitForInterrupt));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->CPSM));

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;
 8002f32:	680b      	ldr	r3, [r1, #0]
  * @param  SDIO_CmdInitStruct: pointer to a SDIO_CmdInitTypeDef structure that contains 
  *         the configuration information for the SDIO command
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
 8002f34:	b510      	push	{r4, lr}
  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->Response));
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->WaitForInterrupt));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->CPSM));

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;
 8002f36:	6083      	str	r3, [r0, #8]
                       SDIO_CmdInitStruct->Response         |\
                       SDIO_CmdInitStruct->WaitForInterrupt |\
                       SDIO_CmdInitStruct->CPSM);
  
  /* Write to SDIO CMD register */
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8002f38:	684c      	ldr	r4, [r1, #4]
 8002f3a:	688b      	ldr	r3, [r1, #8]
 8002f3c:	68c2      	ldr	r2, [r0, #12]
 8002f3e:	431c      	orrs	r4, r3
 8002f40:	68cb      	ldr	r3, [r1, #12]
 8002f42:	6909      	ldr	r1, [r1, #16]
 8002f44:	4323      	orrs	r3, r4
 8002f46:	4319      	orrs	r1, r3
 8002f48:	f422 637f 	bic.w	r3, r2, #4080	; 0xff0
 8002f4c:	f023 030f 	bic.w	r3, r3, #15
 8002f50:	430b      	orrs	r3, r1
 8002f52:	60c3      	str	r3, [r0, #12]
  
  return HAL_OK;  
}
 8002f54:	2000      	movs	r0, #0
 8002f56:	bd10      	pop	{r4, pc}

08002f58 <SDIO_GetCommandResponse>:
  * @param  SDIOx: Pointer to SDIO register base
  * @retval Command index of the last command response received
  */
uint8_t SDIO_GetCommandResponse(SDIO_TypeDef *SDIOx)
{
  return (uint8_t)(SDIOx->RESPCMD);
 8002f58:	6900      	ldr	r0, [r0, #16]
}
 8002f5a:	b2c0      	uxtb	r0, r0
 8002f5c:	4770      	bx	lr
	...

08002f60 <SDIO_GetResponse>:
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4  
  * @retval The Corresponding response register value
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
 8002f60:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0U;
 8002f62:	2300      	movs	r3, #0
 8002f64:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));

  /* Get the response */
  tmp = SDIO_RESP_ADDR + SDIO_RESP;
 8002f66:	4b03      	ldr	r3, [pc, #12]	; (8002f74 <SDIO_GetResponse+0x14>)
 8002f68:	4403      	add	r3, r0
 8002f6a:	9301      	str	r3, [sp, #4]
  
  return (*(__IO uint32_t *) tmp);
 8002f6c:	9b01      	ldr	r3, [sp, #4]
 8002f6e:	6818      	ldr	r0, [r3, #0]
}  
 8002f70:	b002      	add	sp, #8
 8002f72:	4770      	bx	lr
 8002f74:	40012c14 	.word	0x40012c14

08002f78 <SDIO_DataConfig>:
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_DataConfig(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 8002f78:	b510      	push	{r4, lr}
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8002f7a:	68ca      	ldr	r2, [r1, #12]
 8002f7c:	688c      	ldr	r4, [r1, #8]
  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->TransferDir));
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->DPSM));

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;
 8002f7e:	680b      	ldr	r3, [r1, #0]
 8002f80:	6243      	str	r3, [r0, #36]	; 0x24
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8002f82:	4314      	orrs	r4, r2

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;
 8002f84:	684b      	ldr	r3, [r1, #4]
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8002f86:	690a      	ldr	r2, [r1, #16]

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;
 8002f88:	6283      	str	r3, [r0, #40]	; 0x28
                       SDIO_DataInitStruct->TransferDir   |\
                       SDIO_DataInitStruct->TransferMode  |\
                       SDIO_DataInitStruct->DPSM);
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8002f8a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8002f8c:	4314      	orrs	r4, r2
 8002f8e:	694a      	ldr	r2, [r1, #20]
 8002f90:	f023 03f7 	bic.w	r3, r3, #247	; 0xf7
 8002f94:	4322      	orrs	r2, r4
 8002f96:	4313      	orrs	r3, r2
 8002f98:	62c3      	str	r3, [r0, #44]	; 0x2c

  return HAL_OK;

}
 8002f9a:	2000      	movs	r0, #0
 8002f9c:	bd10      	pop	{r4, pc}

08002f9e <USB_CoreInit>:
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8002f9e:	b084      	sub	sp, #16
 8002fa0:	b538      	push	{r3, r4, r5, lr}
 8002fa2:	ad05      	add	r5, sp, #20
 8002fa4:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8002fa8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002faa:	2b01      	cmp	r3, #1
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8002fac:	4604      	mov	r4, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8002fae:	d117      	bne.n	8002fe0 <USB_CoreInit+0x42>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8002fb0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8002fb2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8002fb6:	6383      	str	r3, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8002fb8:	68c3      	ldr	r3, [r0, #12]
 8002fba:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8002fbe:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002fc2:	60c3      	str	r3, [r0, #12]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8002fc4:	68c3      	ldr	r3, [r0, #12]
 8002fc6:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8002fca:	60c3      	str	r3, [r0, #12]
    if(cfg.use_external_vbus == 1U)
 8002fcc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8002fce:	2b01      	cmp	r3, #1
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8002fd0:	bf02      	ittt	eq
 8002fd2:	68c3      	ldreq	r3, [r0, #12]
 8002fd4:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 8002fd8:	60c3      	streq	r3, [r0, #12]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
 8002fda:	f000 fc81 	bl	80038e0 <USB_CoreReset>
 8002fde:	e008      	b.n	8002ff2 <USB_CoreInit+0x54>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8002fe0:	68c3      	ldr	r3, [r0, #12]
 8002fe2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002fe6:	60c3      	str	r3, [r0, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
 8002fe8:	f000 fc7a 	bl	80038e0 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8002fec:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8002ff0:	63a3      	str	r3, [r4, #56]	; 0x38
  }
 
  if(cfg.dma_enable == ENABLE)
 8002ff2:	9b08      	ldr	r3, [sp, #32]
 8002ff4:	2b01      	cmp	r3, #1
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8002ff6:	bf02      	ittt	eq
 8002ff8:	68a3      	ldreq	r3, [r4, #8]
 8002ffa:	f043 0320 	orreq.w	r3, r3, #32
 8002ffe:	60a3      	streq	r3, [r4, #8]
  }  

  return HAL_OK;
}
 8003000:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003004:	2000      	movs	r0, #0
 8003006:	b004      	add	sp, #16
 8003008:	4770      	bx	lr

0800300a <USB_EnableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 800300a:	6883      	ldr	r3, [r0, #8]
 800300c:	f043 0301 	orr.w	r3, r3, #1
 8003010:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 8003012:	2000      	movs	r0, #0
 8003014:	4770      	bx	lr

08003016 <USB_DisableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8003016:	6883      	ldr	r3, [r0, #8]
 8003018:	f023 0301 	bic.w	r3, r3, #1
 800301c:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 800301e:	2000      	movs	r0, #0
 8003020:	4770      	bx	lr

08003022 <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 8003022:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8003024:	68c3      	ldr	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 8003026:	2901      	cmp	r1, #1
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8003028:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 800302c:	60c3      	str	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 800302e:	d104      	bne.n	800303a <USB_SetCurrentMode+0x18>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 8003030:	68c3      	ldr	r3, [r0, #12]
 8003032:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8003036:	60c3      	str	r3, [r0, #12]
 8003038:	e004      	b.n	8003044 <USB_SetCurrentMode+0x22>
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
 800303a:	b919      	cbnz	r1, 8003044 <USB_SetCurrentMode+0x22>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 800303c:	68c3      	ldr	r3, [r0, #12]
 800303e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8003042:	60c3      	str	r3, [r0, #12]
  }
  HAL_Delay(50U);
 8003044:	2032      	movs	r0, #50	; 0x32
 8003046:	f7fd fd6b 	bl	8000b20 <HAL_Delay>
  
  return HAL_OK;
}
 800304a:	2000      	movs	r0, #0
 800304c:	bd08      	pop	{r3, pc}
	...

08003050 <USB_DevInit>:
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8003050:	b084      	sub	sp, #16
 8003052:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003056:	4604      	mov	r4, r0
 8003058:	a807      	add	r0, sp, #28
 800305a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 800305e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003060:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8003062:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8003064:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003068:	4688      	mov	r8, r1
 800306a:	63a3      	str	r3, [r4, #56]	; 0x38
  
  if (cfg.vbus_sensing_enable == 0U)
 800306c:	b91e      	cbnz	r6, 8003076 <USB_DevInit+0x26>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 800306e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003070:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8003074:	63a3      	str	r3, [r4, #56]	; 0x38
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8003076:	2300      	movs	r3, #0
 8003078:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 800307c:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8003080:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8003084:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003086:	2b01      	cmp	r3, #1

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8003088:	f504 6500 	add.w	r5, r4, #2048	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 800308c:	d106      	bne.n	800309c <USB_DevInit+0x4c>
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 800308e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8003090:	b129      	cbz	r1, 800309e <USB_DevInit+0x4e>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 8003092:	4619      	mov	r1, r3
 8003094:	4620      	mov	r0, r4
 8003096:	f000 f897 	bl	80031c8 <USB_SetDevSpeed>
 800309a:	e003      	b.n	80030a4 <USB_DevInit+0x54>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 800309c:	2103      	movs	r1, #3
 800309e:	4620      	mov	r0, r4
 80030a0:	f000 f892 	bl	80031c8 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 80030a4:	2110      	movs	r1, #16
 80030a6:	4620      	mov	r0, r4
 80030a8:	f000 f86c 	bl	8003184 <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 80030ac:	4620      	mov	r0, r4
 80030ae:	f000 f87b 	bl	80031a8 <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 80030b2:	2300      	movs	r3, #0
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 80030b4:	f04f 32ff 	mov.w	r2, #4294967295
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 80030b8:	612b      	str	r3, [r5, #16]
 80030ba:	4619      	mov	r1, r3
  USBx_DEVICE->DOEPMSK = 0U;
 80030bc:	616b      	str	r3, [r5, #20]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 80030be:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 80030c2:	61aa      	str	r2, [r5, #24]
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 80030c4:	f04f 0eff 	mov.w	lr, #255	; 0xff
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
 80030c8:	61eb      	str	r3, [r5, #28]
 80030ca:	f504 6210 	add.w	r2, r4, #2304	; 0x900
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80030ce:	4543      	cmp	r3, r8
 80030d0:	d00c      	beq.n	80030ec <USB_DevInit+0x9c>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80030d2:	f8d2 c000 	ldr.w	ip, [r2]
 80030d6:	f1bc 0f00 	cmp.w	ip, #0
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 80030da:	bfb4      	ite	lt
 80030dc:	6010      	strlt	r0, [r2, #0]
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 80030de:	6011      	strge	r1, [r2, #0]
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80030e0:	3301      	adds	r3, #1
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
 80030e2:	6111      	str	r1, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 80030e4:	f8c2 e008 	str.w	lr, [r2, #8]
 80030e8:	3220      	adds	r2, #32
 80030ea:	e7f0      	b.n	80030ce <USB_DevInit+0x7e>
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80030ec:	2200      	movs	r2, #0
 80030ee:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
 80030f2:	4611      	mov	r1, r2
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 80030f4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 80030f8:	f04f 0eff 	mov.w	lr, #255	; 0xff
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80030fc:	4542      	cmp	r2, r8
 80030fe:	d00c      	beq.n	800311a <USB_DevInit+0xca>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8003100:	f8d3 c000 	ldr.w	ip, [r3]
 8003104:	f1bc 0f00 	cmp.w	ip, #0
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8003108:	bfb4      	ite	lt
 800310a:	6018      	strlt	r0, [r3, #0]
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 800310c:	6019      	strge	r1, [r3, #0]
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800310e:	3201      	adds	r2, #1
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8003110:	6119      	str	r1, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8003112:	f8c3 e008 	str.w	lr, [r3, #8]
 8003116:	3320      	adds	r3, #32
 8003118:	e7f0      	b.n	80030fc <USB_DevInit+0xac>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800311a:	692b      	ldr	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 800311c:	2f01      	cmp	r7, #1
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800311e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003122:	612b      	str	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 8003124:	d108      	bne.n	8003138 <USB_DevInit+0xe8>
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 8003126:	4b15      	ldr	r3, [pc, #84]	; (800317c <USB_DevInit+0x12c>)
 8003128:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 800312a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800312c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003130:	f043 0303 	orr.w	r3, r3, #3
 8003134:	632b      	str	r3, [r5, #48]	; 0x30
    
    i= USBx_DEVICE->DTHRCTL;
 8003136:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8003138:	2300      	movs	r3, #0
 800313a:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 800313c:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 8003140:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 8003142:	b91f      	cbnz	r7, 800314c <USB_DevInit+0xfc>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 8003144:	69a3      	ldr	r3, [r4, #24]
 8003146:	f043 0310 	orr.w	r3, r3, #16
 800314a:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 800314c:	69a2      	ldr	r2, [r4, #24]
 800314e:	4b0c      	ldr	r3, [pc, #48]	; (8003180 <USB_DevInit+0x130>)
 8003150:	4313      	orrs	r3, r2
 8003152:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 8003154:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003156:	b11b      	cbz	r3, 8003160 <USB_DevInit+0x110>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8003158:	69a3      	ldr	r3, [r4, #24]
 800315a:	f043 0308 	orr.w	r3, r3, #8
 800315e:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 8003160:	2e01      	cmp	r6, #1
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 8003162:	bf01      	itttt	eq
 8003164:	69a3      	ldreq	r3, [r4, #24]
 8003166:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 800316a:	f043 0304 	orreq.w	r3, r3, #4
 800316e:	61a3      	streq	r3, [r4, #24]
  }
  
  return HAL_OK;
}
 8003170:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8003174:	2000      	movs	r0, #0
 8003176:	b004      	add	sp, #16
 8003178:	4770      	bx	lr
 800317a:	bf00      	nop
 800317c:	00800100 	.word	0x00800100
 8003180:	803c3800 	.word	0x803c3800

08003184 <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0U;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 8003184:	0189      	lsls	r1, r1, #6
 8003186:	f041 0120 	orr.w	r1, r1, #32
 800318a:	4a06      	ldr	r2, [pc, #24]	; (80031a4 <USB_FlushTxFifo+0x20>)
 800318c:	6101      	str	r1, [r0, #16]
 
  do
  {
    if (++count > 200000U)
 800318e:	3a01      	subs	r2, #1
 8003190:	d005      	beq.n	800319e <USB_FlushTxFifo+0x1a>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8003192:	6903      	ldr	r3, [r0, #16]
 8003194:	f013 0320 	ands.w	r3, r3, #32
 8003198:	d1f9      	bne.n	800318e <USB_FlushTxFifo+0xa>
  
  return HAL_OK;
 800319a:	4618      	mov	r0, r3
 800319c:	4770      	bx	lr
 
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 800319e:	2003      	movs	r0, #3
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
  
  return HAL_OK;
}
 80031a0:	4770      	bx	lr
 80031a2:	bf00      	nop
 80031a4:	00030d41 	.word	0x00030d41

080031a8 <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0U;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80031a8:	2310      	movs	r3, #16
 80031aa:	4a06      	ldr	r2, [pc, #24]	; (80031c4 <USB_FlushRxFifo+0x1c>)
 80031ac:	6103      	str	r3, [r0, #16]
  
  do
  {
    if (++count > 200000U)
 80031ae:	3a01      	subs	r2, #1
 80031b0:	d005      	beq.n	80031be <USB_FlushRxFifo+0x16>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 80031b2:	6903      	ldr	r3, [r0, #16]
 80031b4:	f013 0310 	ands.w	r3, r3, #16
 80031b8:	d1f9      	bne.n	80031ae <USB_FlushRxFifo+0x6>
  
  return HAL_OK;
 80031ba:	4618      	mov	r0, r3
 80031bc:	4770      	bx	lr
  
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 80031be:	2003      	movs	r0, #3
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
  
  return HAL_OK;
}
 80031c0:	4770      	bx	lr
 80031c2:	bf00      	nop
 80031c4:	00030d41 	.word	0x00030d41

080031c8 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 80031c8:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80031cc:	4319      	orrs	r1, r3
 80031ce:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 80031d2:	2000      	movs	r0, #0
 80031d4:	4770      	bx	lr

080031d6 <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0U;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 80031d6:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80031da:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 80031de:	f013 0006 	ands.w	r0, r3, #6
 80031e2:	d012      	beq.n	800320a <USB_GetDevSpeed+0x34>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 80031e4:	6893      	ldr	r3, [r2, #8]
 80031e6:	f003 0306 	and.w	r3, r3, #6
 80031ea:	2b02      	cmp	r3, #2
 80031ec:	d00c      	beq.n	8003208 <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 80031ee:	6893      	ldr	r3, [r2, #8]
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 80031f0:	f003 0306 	and.w	r3, r3, #6
 80031f4:	2b06      	cmp	r3, #6
 80031f6:	d007      	beq.n	8003208 <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 80031f8:	6893      	ldr	r3, [r2, #8]
 80031fa:	f003 0306 	and.w	r3, r3, #6
 80031fe:	2b04      	cmp	r3, #4
  {
    speed = USB_OTG_SPEED_LOW;
 8003200:	bf14      	ite	ne
 8003202:	2000      	movne	r0, #0
 8003204:	2002      	moveq	r0, #2
 8003206:	4770      	bx	lr
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
 8003208:	2003      	movs	r0, #3
  {
    speed = USB_OTG_SPEED_LOW;
  }
  
  return speed;
}
 800320a:	4770      	bx	lr

0800320c <USB_ActivateEndpoint>:
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 800320c:	784b      	ldrb	r3, [r1, #1]
 800320e:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 8003212:	2b01      	cmp	r3, #1
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8003214:	b570      	push	{r4, r5, r6, lr}
 8003216:	780e      	ldrb	r6, [r1, #0]
  if (ep->is_in == 1U)
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 8003218:	69d4      	ldr	r4, [r2, #28]
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 800321a:	d11b      	bne.n	8003254 <USB_ActivateEndpoint+0x48>
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 800321c:	40b3      	lsls	r3, r6
 800321e:	b29b      	uxth	r3, r3
 8003220:	4323      	orrs	r3, r4
 8003222:	61d3      	str	r3, [r2, #28]
   
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8003224:	780e      	ldrb	r6, [r1, #0]
 8003226:	f44f 6510 	mov.w	r5, #2304	; 0x900
 800322a:	eb05 1546 	add.w	r5, r5, r6, lsl #5
 800322e:	582b      	ldr	r3, [r5, r0]
 8003230:	041a      	lsls	r2, r3, #16
 8003232:	d42a      	bmi.n	800328a <USB_ActivateEndpoint+0x7e>
    {
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8003234:	582c      	ldr	r4, [r5, r0]
 8003236:	688a      	ldr	r2, [r1, #8]
 8003238:	f044 5380 	orr.w	r3, r4, #268435456	; 0x10000000
 800323c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003240:	f3c2 020a 	ubfx	r2, r2, #0, #11
 8003244:	431a      	orrs	r2, r3
 8003246:	78cb      	ldrb	r3, [r1, #3]
 8003248:	ea42 4383 	orr.w	r3, r2, r3, lsl #18
 800324c:	ea43 5386 	orr.w	r3, r3, r6, lsl #22
 8003250:	502b      	str	r3, [r5, r0]
 8003252:	e01a      	b.n	800328a <USB_ActivateEndpoint+0x7e>
        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
    } 
  }
  else
  {
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
 8003254:	f44f 3580 	mov.w	r5, #65536	; 0x10000
 8003258:	fa05 f306 	lsl.w	r3, r5, r6
 800325c:	4323      	orrs	r3, r4
 800325e:	61d3      	str	r3, [r2, #28]
     
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8003260:	780c      	ldrb	r4, [r1, #0]
 8003262:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8003266:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 800326a:	5823      	ldr	r3, [r4, r0]
 800326c:	041b      	lsls	r3, r3, #16
 800326e:	d40c      	bmi.n	800328a <USB_ActivateEndpoint+0x7e>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8003270:	5822      	ldr	r2, [r4, r0]
 8003272:	688b      	ldr	r3, [r1, #8]
 8003274:	f3c3 050a 	ubfx	r5, r3, #0, #11
 8003278:	f042 5380 	orr.w	r3, r2, #268435456	; 0x10000000
 800327c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003280:	78ca      	ldrb	r2, [r1, #3]
 8003282:	432b      	orrs	r3, r5
 8003284:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 8003288:	5023      	str	r3, [r4, r0]
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 800328a:	2000      	movs	r0, #0
 800328c:	bd70      	pop	{r4, r5, r6, pc}

0800328e <USB_DeactivateEndpoint>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800328e:	b530      	push	{r4, r5, lr}
  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 8003290:	784c      	ldrb	r4, [r1, #1]
 8003292:	780a      	ldrb	r2, [r1, #0]
  {
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));
 8003294:	f8d0 583c 	ldr.w	r5, [r0, #2108]	; 0x83c
 8003298:	f500 6300 	add.w	r3, r0, #2048	; 0x800
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 800329c:	2c01      	cmp	r4, #1
 800329e:	d116      	bne.n	80032ce <USB_DeactivateEndpoint+0x40>
  {
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));
 80032a0:	fa04 f202 	lsl.w	r2, r4, r2
 80032a4:	b292      	uxth	r2, r2
 80032a6:	ea25 0202 	bic.w	r2, r5, r2
 80032aa:	63da      	str	r2, [r3, #60]	; 0x3c
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   
 80032ac:	780d      	ldrb	r5, [r1, #0]
 80032ae:	69da      	ldr	r2, [r3, #28]
 80032b0:	40ac      	lsls	r4, r5
 80032b2:	b2a4      	uxth	r4, r4
 80032b4:	ea22 0404 	bic.w	r4, r2, r4
 80032b8:	61dc      	str	r4, [r3, #28]
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
 80032ba:	780a      	ldrb	r2, [r1, #0]
 80032bc:	f44f 6310 	mov.w	r3, #2304	; 0x900
 80032c0:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80032c4:	581a      	ldr	r2, [r3, r0]
 80032c6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80032ca:	501a      	str	r2, [r3, r0]
 80032cc:	e014      	b.n	80032f8 <USB_DeactivateEndpoint+0x6a>
  }
  else
  {
     USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));
 80032ce:	2401      	movs	r4, #1
 80032d0:	fa04 f202 	lsl.w	r2, r4, r2
 80032d4:	ea25 4202 	bic.w	r2, r5, r2, lsl #16
 80032d8:	63da      	str	r2, [r3, #60]	; 0x3c
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));     
 80032da:	780d      	ldrb	r5, [r1, #0]
 80032dc:	69da      	ldr	r2, [r3, #28]
 80032de:	40ac      	lsls	r4, r5
 80032e0:	ea22 4404 	bic.w	r4, r2, r4, lsl #16
 80032e4:	61dc      	str	r4, [r3, #28]
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
 80032e6:	780a      	ldrb	r2, [r1, #0]
 80032e8:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 80032ec:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80032f0:	581a      	ldr	r2, [r3, r0]
 80032f2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80032f6:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 80032f8:	2000      	movs	r0, #0
 80032fa:	bd30      	pop	{r4, r5, pc}

080032fc <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 80032fc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint16_t pktcnt = 0U;
  
  /* IN endpoint */
  if (ep->is_in == 1U)
 8003300:	784b      	ldrb	r3, [r1, #1]
 8003302:	780c      	ldrb	r4, [r1, #0]
 8003304:	2b01      	cmp	r3, #1
 8003306:	f04f 0520 	mov.w	r5, #32
 800330a:	694b      	ldr	r3, [r1, #20]
 800330c:	f040 809b 	bne.w	8003446 <USB_EPStartXfer+0x14a>
 8003310:	f44f 6610 	mov.w	r6, #2304	; 0x900
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003314:	fb15 6404 	smlabb	r4, r5, r4, r6
 8003318:	4404      	add	r4, r0
 800331a:	6927      	ldr	r7, [r4, #16]
  
  /* IN endpoint */
  if (ep->is_in == 1U)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 800331c:	b9ab      	cbnz	r3, 800334a <USB_EPStartXfer+0x4e>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800331e:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 8003322:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 8003326:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8003328:	780c      	ldrb	r4, [r1, #0]
 800332a:	fb15 6404 	smlabb	r4, r5, r4, r6
 800332e:	4404      	add	r4, r0
 8003330:	6927      	ldr	r7, [r4, #16]
 8003332:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
 8003336:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8003338:	780c      	ldrb	r4, [r1, #0]
 800333a:	fb15 6504 	smlabb	r5, r5, r4, r6
 800333e:	4405      	add	r5, r0
 8003340:	692c      	ldr	r4, [r5, #16]
 8003342:	0ce4      	lsrs	r4, r4, #19
 8003344:	04e4      	lsls	r4, r4, #19
 8003346:	612c      	str	r4, [r5, #16]
 8003348:	e03f      	b.n	80033ca <USB_EPStartXfer+0xce>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800334a:	0cff      	lsrs	r7, r7, #19
 800334c:	04ff      	lsls	r7, r7, #19
 800334e:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003350:	780c      	ldrb	r4, [r1, #0]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 8003352:	f8d1 c008 	ldr.w	ip, [r1, #8]
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003356:	fb15 6404 	smlabb	r4, r5, r4, r6
 800335a:	4404      	add	r4, r0
 800335c:	6927      	ldr	r7, [r4, #16]
 800335e:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 8003362:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 8003366:	6127      	str	r7, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 8003368:	780f      	ldrb	r7, [r1, #0]
 800336a:	fb15 6707 	smlabb	r7, r5, r7, r6
 800336e:	4407      	add	r7, r0
 8003370:	eb03 040c 	add.w	r4, r3, ip
 8003374:	3c01      	subs	r4, #1
 8003376:	fbb4 f4fc 	udiv	r4, r4, ip
 800337a:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 8003530 <USB_EPStartXfer+0x234>
 800337e:	f8d7 e010 	ldr.w	lr, [r7, #16]
 8003382:	04e4      	lsls	r4, r4, #19
 8003384:	ea04 0c0c 	and.w	ip, r4, ip
 8003388:	ea4c 040e 	orr.w	r4, ip, lr
 800338c:	613c      	str	r4, [r7, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 800338e:	780c      	ldrb	r4, [r1, #0]
 8003390:	fb15 6404 	smlabb	r4, r5, r4, r6
 8003394:	4404      	add	r4, r0
 8003396:	f3c3 0e12 	ubfx	lr, r3, #0, #19
 800339a:	6927      	ldr	r7, [r4, #16]
 800339c:	ea4e 0707 	orr.w	r7, lr, r7
 80033a0:	6127      	str	r7, [r4, #16]
      
      if (ep->type == EP_TYPE_ISOC)
 80033a2:	78cc      	ldrb	r4, [r1, #3]
 80033a4:	2c01      	cmp	r4, #1
 80033a6:	f040 80ba 	bne.w	800351e <USB_EPStartXfer+0x222>
      {
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 80033aa:	780c      	ldrb	r4, [r1, #0]
 80033ac:	fb15 6404 	smlabb	r4, r5, r4, r6
 80033b0:	4404      	add	r4, r0
 80033b2:	6927      	ldr	r7, [r4, #16]
 80033b4:	f027 47c0 	bic.w	r7, r7, #1610612736	; 0x60000000
 80033b8:	6127      	str	r7, [r4, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
 80033ba:	780c      	ldrb	r4, [r1, #0]
 80033bc:	fb15 6504 	smlabb	r5, r5, r4, r6
 80033c0:	4405      	add	r5, r0
 80033c2:	692c      	ldr	r4, [r5, #16]
 80033c4:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
 80033c8:	612c      	str	r4, [r5, #16]
      }       
    }

    if (dma == 1U)
 80033ca:	2a01      	cmp	r2, #1
 80033cc:	d106      	bne.n	80033dc <USB_EPStartXfer+0xe0>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 80033ce:	780c      	ldrb	r4, [r1, #0]
 80033d0:	690d      	ldr	r5, [r1, #16]
 80033d2:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 80033d6:	f8c4 5914 	str.w	r5, [r4, #2324]	; 0x914
 80033da:	e00b      	b.n	80033f4 <USB_EPStartXfer+0xf8>
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 80033dc:	78cc      	ldrb	r4, [r1, #3]
 80033de:	2c01      	cmp	r4, #1
 80033e0:	d00b      	beq.n	80033fa <USB_EPStartXfer+0xfe>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 80033e2:	b13b      	cbz	r3, 80033f4 <USB_EPStartXfer+0xf8>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;
 80033e4:	780f      	ldrb	r7, [r1, #0]
 80033e6:	f8d0 5834 	ldr.w	r5, [r0, #2100]	; 0x834
 80033ea:	2401      	movs	r4, #1
 80033ec:	40bc      	lsls	r4, r7
 80033ee:	432c      	orrs	r4, r5
 80033f0:	f8c0 4834 	str.w	r4, [r0, #2100]	; 0x834
        }
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 80033f4:	78cc      	ldrb	r4, [r1, #3]
 80033f6:	2c01      	cmp	r4, #1
 80033f8:	d111      	bne.n	800341e <USB_EPStartXfer+0x122>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 80033fa:	f8d0 4808 	ldr.w	r4, [r0, #2056]	; 0x808
 80033fe:	f414 7f80 	tst.w	r4, #256	; 0x100
 8003402:	780c      	ldrb	r4, [r1, #0]
 8003404:	f04f 0520 	mov.w	r5, #32
 8003408:	f44f 6610 	mov.w	r6, #2304	; 0x900
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 800340c:	fb15 6404 	smlabb	r4, r5, r4, r6
 8003410:	5825      	ldr	r5, [r4, r0]
 8003412:	bf0c      	ite	eq
 8003414:	f045 5500 	orreq.w	r5, r5, #536870912	; 0x20000000
      }
      else
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8003418:	f045 5580 	orrne.w	r5, r5, #268435456	; 0x10000000
 800341c:	5025      	str	r5, [r4, r0]
      }
    } 
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800341e:	780d      	ldrb	r5, [r1, #0]
 8003420:	f44f 6410 	mov.w	r4, #2304	; 0x900
 8003424:	eb04 1445 	add.w	r4, r4, r5, lsl #5
 8003428:	5905      	ldr	r5, [r0, r4]
 800342a:	f045 4504 	orr.w	r5, r5, #2214592512	; 0x84000000
 800342e:	5105      	str	r5, [r0, r4]
    
    if (ep->type == EP_TYPE_ISOC)
 8003430:	78cc      	ldrb	r4, [r1, #3]
 8003432:	2c01      	cmp	r4, #1
 8003434:	d177      	bne.n	8003526 <USB_EPStartXfer+0x22a>
    {
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 8003436:	780c      	ldrb	r4, [r1, #0]
 8003438:	9200      	str	r2, [sp, #0]
 800343a:	b29b      	uxth	r3, r3
 800343c:	4622      	mov	r2, r4
 800343e:	68c9      	ldr	r1, [r1, #12]
 8003440:	f000 f922 	bl	8003688 <USB_WritePacket>
 8003444:	e06f      	b.n	8003526 <USB_EPStartXfer+0x22a>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8003446:	f44f 6630 	mov.w	r6, #2816	; 0xb00
 800344a:	fb15 6404 	smlabb	r4, r5, r4, r6
 800344e:	4404      	add	r4, r0
 8003450:	6927      	ldr	r7, [r4, #16]
 8003452:	0cff      	lsrs	r7, r7, #19
 8003454:	04ff      	lsls	r7, r7, #19
 8003456:	6127      	str	r7, [r4, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8003458:	780c      	ldrb	r4, [r1, #0]
 800345a:	fb15 6404 	smlabb	r4, r5, r4, r6
 800345e:	4404      	add	r4, r0
 8003460:	6927      	ldr	r7, [r4, #16]
 8003462:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 8003466:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 800346a:	6127      	str	r7, [r4, #16]
 800346c:	780c      	ldrb	r4, [r1, #0]
 800346e:	688f      	ldr	r7, [r1, #8]

    if (ep->xfer_len == 0U)
 8003470:	b983      	cbnz	r3, 8003494 <USB_EPStartXfer+0x198>
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8003472:	fb15 6404 	smlabb	r4, r5, r4, r6
 8003476:	4404      	add	r4, r0
 8003478:	f3c7 0712 	ubfx	r7, r7, #0, #19
 800347c:	6923      	ldr	r3, [r4, #16]
 800347e:	431f      	orrs	r7, r3
 8003480:	6127      	str	r7, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8003482:	780b      	ldrb	r3, [r1, #0]
 8003484:	fb15 6503 	smlabb	r5, r5, r3, r6
 8003488:	4405      	add	r5, r0
 800348a:	692b      	ldr	r3, [r5, #16]
 800348c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003490:	612b      	str	r3, [r5, #16]
 8003492:	e01d      	b.n	80034d0 <USB_EPStartXfer+0x1d4>
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 8003494:	fb15 6404 	smlabb	r4, r5, r4, r6
 8003498:	4404      	add	r4, r0
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 800349a:	443b      	add	r3, r7
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 800349c:	f8df c090 	ldr.w	ip, [pc, #144]	; 8003530 <USB_EPStartXfer+0x234>
 80034a0:	f8d4 e010 	ldr.w	lr, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 80034a4:	3b01      	subs	r3, #1
 80034a6:	fbb3 f3f7 	udiv	r3, r3, r7
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 80034aa:	ea4f 48c3 	mov.w	r8, r3, lsl #19
 80034ae:	ea08 0c0c 	and.w	ip, r8, ip
 80034b2:	ea4c 0e0e 	orr.w	lr, ip, lr
 80034b6:	f8c4 e010 	str.w	lr, [r4, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
 80034ba:	780c      	ldrb	r4, [r1, #0]
 80034bc:	fb15 6504 	smlabb	r5, r5, r4, r6
 80034c0:	4405      	add	r5, r0
 80034c2:	b29b      	uxth	r3, r3
 80034c4:	692c      	ldr	r4, [r5, #16]
 80034c6:	435f      	muls	r7, r3
 80034c8:	f3c7 0712 	ubfx	r7, r7, #0, #19
 80034cc:	4327      	orrs	r7, r4
 80034ce:	612f      	str	r7, [r5, #16]
    }

    if (dma == 1U)
 80034d0:	2a01      	cmp	r2, #1
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 80034d2:	bf01      	itttt	eq
 80034d4:	780b      	ldrbeq	r3, [r1, #0]
 80034d6:	68ca      	ldreq	r2, [r1, #12]
 80034d8:	eb00 1343 	addeq.w	r3, r0, r3, lsl #5
 80034dc:	f8c3 2b14 	streq.w	r2, [r3, #2836]	; 0xb14
    }
    
    if (ep->type == EP_TYPE_ISOC)
 80034e0:	78cb      	ldrb	r3, [r1, #3]
 80034e2:	2b01      	cmp	r3, #1
 80034e4:	d111      	bne.n	800350a <USB_EPStartXfer+0x20e>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 80034e6:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80034ea:	f413 7f80 	tst.w	r3, #256	; 0x100
 80034ee:	780b      	ldrb	r3, [r1, #0]
 80034f0:	f04f 0220 	mov.w	r2, #32
 80034f4:	f44f 6430 	mov.w	r4, #2816	; 0xb00
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 80034f8:	fb12 4303 	smlabb	r3, r2, r3, r4
 80034fc:	58c2      	ldr	r2, [r0, r3]
 80034fe:	bf0c      	ite	eq
 8003500:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
      }
      else
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8003504:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
 8003508:	50c2      	str	r2, [r0, r3]
      }
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800350a:	780a      	ldrb	r2, [r1, #0]
 800350c:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8003510:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8003514:	58c2      	ldr	r2, [r0, r3]
 8003516:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800351a:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
 800351c:	e003      	b.n	8003526 <USB_EPStartXfer+0x22a>
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
      }       
    }

    if (dma == 1U)
 800351e:	2a01      	cmp	r2, #1
 8003520:	f47f af5f 	bne.w	80033e2 <USB_EPStartXfer+0xe6>
 8003524:	e753      	b.n	80033ce <USB_EPStartXfer+0xd2>
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
  }
  return HAL_OK;
}
 8003526:	2000      	movs	r0, #0
 8003528:	b002      	add	sp, #8
 800352a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800352e:	bf00      	nop
 8003530:	1ff80000 	.word	0x1ff80000

08003534 <USB_EP0StartXfer>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
  /* IN endpoint */
  if (ep->is_in == 1U)
 8003534:	784b      	ldrb	r3, [r1, #1]
 8003536:	2b01      	cmp	r3, #1
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8003538:	b5f0      	push	{r4, r5, r6, r7, lr}
 800353a:	780b      	ldrb	r3, [r1, #0]
 800353c:	694d      	ldr	r5, [r1, #20]
 800353e:	f04f 0420 	mov.w	r4, #32
  /* IN endpoint */
  if (ep->is_in == 1U)
 8003542:	d163      	bne.n	800360c <USB_EP0StartXfer+0xd8>
 8003544:	f44f 6610 	mov.w	r6, #2304	; 0x900
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003548:	fb14 6303 	smlabb	r3, r4, r3, r6
 800354c:	4403      	add	r3, r0
{
  /* IN endpoint */
  if (ep->is_in == 1U)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 800354e:	bb05      	cbnz	r5, 8003592 <USB_EP0StartXfer+0x5e>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8003550:	691d      	ldr	r5, [r3, #16]
 8003552:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 8003556:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 800355a:	611d      	str	r5, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 800355c:	780b      	ldrb	r3, [r1, #0]
 800355e:	fb14 6303 	smlabb	r3, r4, r3, r6
 8003562:	4403      	add	r3, r0
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
    
    }
    
    if (dma == 1)
 8003564:	2a01      	cmp	r2, #1
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8003566:	691d      	ldr	r5, [r3, #16]
 8003568:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800356c:	611d      	str	r5, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 800356e:	780b      	ldrb	r3, [r1, #0]
 8003570:	fb14 6403 	smlabb	r4, r4, r3, r6
 8003574:	4404      	add	r4, r0
 8003576:	6923      	ldr	r3, [r4, #16]
 8003578:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 800357c:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 8003580:	6123      	str	r3, [r4, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
    
    }
    
    if (dma == 1)
 8003582:	d139      	bne.n	80035f8 <USB_EP0StartXfer+0xc4>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8003584:	780b      	ldrb	r3, [r1, #0]
 8003586:	690a      	ldr	r2, [r1, #16]
 8003588:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 800358c:	f8c3 2914 	str.w	r2, [r3, #2324]	; 0x914
 8003590:	e032      	b.n	80035f8 <USB_EP0StartXfer+0xc4>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8003592:	691f      	ldr	r7, [r3, #16]
 8003594:	0cff      	lsrs	r7, r7, #19
 8003596:	04ff      	lsls	r7, r7, #19
 8003598:	611f      	str	r7, [r3, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 800359a:	780b      	ldrb	r3, [r1, #0]
 800359c:	fb14 6403 	smlabb	r4, r4, r3, r6
 80035a0:	4404      	add	r4, r0
 80035a2:	6923      	ldr	r3, [r4, #16]
 80035a4:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 80035a8:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 80035ac:	6123      	str	r3, [r4, #16]
      
      if(ep->xfer_len > ep->maxpacket)
 80035ae:	688b      	ldr	r3, [r1, #8]
 80035b0:	429d      	cmp	r5, r3
      {
        ep->xfer_len = ep->maxpacket;
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 80035b2:	780d      	ldrb	r5, [r1, #0]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
      
      if(ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
 80035b4:	bf88      	it	hi
 80035b6:	614b      	strhi	r3, [r1, #20]
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 80035b8:	2420      	movs	r4, #32
 80035ba:	f44f 6310 	mov.w	r3, #2304	; 0x900
 80035be:	fb14 3505 	smlabb	r5, r4, r5, r3
 80035c2:	4405      	add	r5, r0
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
    
    }
    
    if (dma == 1)
 80035c4:	2a01      	cmp	r2, #1
      
      if(ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 80035c6:	692e      	ldr	r6, [r5, #16]
 80035c8:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 80035cc:	612e      	str	r6, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 80035ce:	780d      	ldrb	r5, [r1, #0]
 80035d0:	fb14 3305 	smlabb	r3, r4, r5, r3
 80035d4:	4403      	add	r3, r0
 80035d6:	694d      	ldr	r5, [r1, #20]
 80035d8:	691c      	ldr	r4, [r3, #16]
 80035da:	f3c5 0612 	ubfx	r6, r5, #0, #19
 80035de:	ea44 0406 	orr.w	r4, r4, r6
 80035e2:	611c      	str	r4, [r3, #16]
    
    }
    
    if (dma == 1)
 80035e4:	d0ce      	beq.n	8003584 <USB_EP0StartXfer+0x50>
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
    }
    else
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0U)
 80035e6:	b13d      	cbz	r5, 80035f8 <USB_EP0StartXfer+0xc4>
      {
        USBx_DEVICE->DIEPEMPMSK |= 1U << (ep->num);
 80035e8:	780d      	ldrb	r5, [r1, #0]
 80035ea:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 80035ee:	2301      	movs	r3, #1
 80035f0:	40ab      	lsls	r3, r5
 80035f2:	4313      	orrs	r3, r2
 80035f4:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
      }
    }
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
 80035f8:	780a      	ldrb	r2, [r1, #0]
 80035fa:	f44f 6310 	mov.w	r3, #2304	; 0x900
 80035fe:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8003602:	58c2      	ldr	r2, [r0, r3]
 8003604:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8003608:	50c2      	str	r2, [r0, r3]
 800360a:	e03b      	b.n	8003684 <USB_EP0StartXfer+0x150>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 800360c:	f44f 6730 	mov.w	r7, #2816	; 0xb00
 8003610:	fb14 7303 	smlabb	r3, r4, r3, r7
 8003614:	4403      	add	r3, r0
 8003616:	691e      	ldr	r6, [r3, #16]
 8003618:	0cf6      	lsrs	r6, r6, #19
 800361a:	04f6      	lsls	r6, r6, #19
 800361c:	611e      	str	r6, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 800361e:	780b      	ldrb	r3, [r1, #0]
 8003620:	fb14 7303 	smlabb	r3, r4, r3, r7
 8003624:	4403      	add	r3, r0
 8003626:	691e      	ldr	r6, [r3, #16]
 8003628:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
 800362c:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
 8003630:	611e      	str	r6, [r3, #16]
 8003632:	688e      	ldr	r6, [r1, #8]
      
    if (ep->xfer_len > 0U)
 8003634:	b105      	cbz	r5, 8003638 <USB_EP0StartXfer+0x104>
    {
      ep->xfer_len = ep->maxpacket;
 8003636:	614e      	str	r6, [r1, #20]
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8003638:	780b      	ldrb	r3, [r1, #0]
 800363a:	f44f 6530 	mov.w	r5, #2816	; 0xb00
 800363e:	fb14 5303 	smlabb	r3, r4, r3, r5
 8003642:	4403      	add	r3, r0
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 8003644:	f3c6 0612 	ubfx	r6, r6, #0, #19
    if (ep->xfer_len > 0U)
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8003648:	691f      	ldr	r7, [r3, #16]
 800364a:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
 800364e:	611f      	str	r7, [r3, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 8003650:	780b      	ldrb	r3, [r1, #0]
 8003652:	fb14 5403 	smlabb	r4, r4, r3, r5
 8003656:	4404      	add	r4, r0
    

    if (dma == 1U)
 8003658:	2a01      	cmp	r2, #1
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 800365a:	6923      	ldr	r3, [r4, #16]
 800365c:	ea46 0603 	orr.w	r6, r6, r3
 8003660:	6126      	str	r6, [r4, #16]
    

    if (dma == 1U)
 8003662:	d106      	bne.n	8003672 <USB_EP0StartXfer+0x13e>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 8003664:	780b      	ldrb	r3, [r1, #0]
 8003666:	2220      	movs	r2, #32
 8003668:	fb12 5303 	smlabb	r3, r2, r3, r5
 800366c:	4403      	add	r3, r0
 800366e:	68ca      	ldr	r2, [r1, #12]
 8003670:	615a      	str	r2, [r3, #20]
    }
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 8003672:	780a      	ldrb	r2, [r1, #0]
 8003674:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8003678:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 800367c:	58c2      	ldr	r2, [r0, r3]
 800367e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8003682:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 8003684:	2000      	movs	r0, #0
 8003686:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003688 <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8003688:	b510      	push	{r4, lr}
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
 800368a:	f89d 4008 	ldrb.w	r4, [sp, #8]
 800368e:	b96c      	cbnz	r4, 80036ac <USB_WritePacket+0x24>
 8003690:	3303      	adds	r3, #3
  {
    count32b =  (len + 3U) / 4U;
    for (i = 0U; i < count32b; i++, src += 4U)
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 8003692:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 8003696:	f023 0303 	bic.w	r3, r3, #3
 800369a:	eb00 3202 	add.w	r2, r0, r2, lsl #12
 800369e:	440b      	add	r3, r1
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
  {
    count32b =  (len + 3U) / 4U;
    for (i = 0U; i < count32b; i++, src += 4U)
 80036a0:	4299      	cmp	r1, r3
 80036a2:	d003      	beq.n	80036ac <USB_WritePacket+0x24>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 80036a4:	f851 0b04 	ldr.w	r0, [r1], #4
 80036a8:	6010      	str	r0, [r2, #0]
 80036aa:	e7f9      	b.n	80036a0 <USB_WritePacket+0x18>
    }
  }
  return HAL_OK;
}
 80036ac:	2000      	movs	r0, #0
 80036ae:	bd10      	pop	{r4, pc}

080036b0 <USB_ReadPacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 80036b0:	3203      	adds	r2, #3
 80036b2:	f022 0203 	bic.w	r2, r2, #3
 80036b6:	440a      	add	r2, r1
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 80036b8:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
 80036bc:	4291      	cmp	r1, r2
 80036be:	d003      	beq.n	80036c8 <USB_ReadPacket+0x18>
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 80036c0:	6803      	ldr	r3, [r0, #0]
 80036c2:	f841 3b04 	str.w	r3, [r1], #4
 80036c6:	e7f9      	b.n	80036bc <USB_ReadPacket+0xc>
    
  }
  return ((void *)dest);
}
 80036c8:	4608      	mov	r0, r1
 80036ca:	4770      	bx	lr

080036cc <USB_EPSetStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 80036cc:	784b      	ldrb	r3, [r1, #1]
 80036ce:	2b01      	cmp	r3, #1
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
 80036d0:	b510      	push	{r4, lr}
 80036d2:	f04f 0220 	mov.w	r2, #32
 80036d6:	780c      	ldrb	r4, [r1, #0]
  if (ep->is_in == 1U)
 80036d8:	d114      	bne.n	8003704 <USB_EPSetStall+0x38>
  {
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0U)
 80036da:	f44f 6310 	mov.w	r3, #2304	; 0x900
 80036de:	fb12 3304 	smlabb	r3, r2, r4, r3
 80036e2:	58c2      	ldr	r2, [r0, r3]
 80036e4:	2a00      	cmp	r2, #0
    {
      USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
 80036e6:	bfa2      	ittt	ge
 80036e8:	58c2      	ldrge	r2, [r0, r3]
 80036ea:	f022 4280 	bicge.w	r2, r2, #1073741824	; 0x40000000
 80036ee:	50c2      	strge	r2, [r0, r3]
    } 
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 80036f0:	780a      	ldrb	r2, [r1, #0]
 80036f2:	f44f 6310 	mov.w	r3, #2304	; 0x900
 80036f6:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80036fa:	58c2      	ldr	r2, [r0, r3]
 80036fc:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8003700:	50c2      	str	r2, [r0, r3]
 8003702:	e013      	b.n	800372c <USB_EPSetStall+0x60>
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0U)
 8003704:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8003708:	fb12 3304 	smlabb	r3, r2, r4, r3
 800370c:	58c2      	ldr	r2, [r0, r3]
 800370e:	2a00      	cmp	r2, #0
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 8003710:	bfa2      	ittt	ge
 8003712:	58c2      	ldrge	r2, [r0, r3]
 8003714:	f022 4280 	bicge.w	r2, r2, #1073741824	; 0x40000000
 8003718:	50c2      	strge	r2, [r0, r3]
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 800371a:	780a      	ldrb	r2, [r1, #0]
 800371c:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8003720:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8003724:	58c2      	ldr	r2, [r0, r3]
 8003726:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800372a:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 800372c:	2000      	movs	r0, #0
 800372e:	bd10      	pop	{r4, pc}

08003730 <USB_EPClearStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8003730:	784b      	ldrb	r3, [r1, #1]
 8003732:	2b01      	cmp	r3, #1
 8003734:	780b      	ldrb	r3, [r1, #0]
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8003736:	b530      	push	{r4, r5, lr}
 8003738:	f04f 0220 	mov.w	r2, #32
  if (ep->is_in == 1U)
  {
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800373c:	bf0c      	ite	eq
 800373e:	f44f 6510 	moveq.w	r5, #2304	; 0x900
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8003742:	f44f 6530 	movne.w	r5, #2816	; 0xb00
 8003746:	fb12 5303 	smlabb	r3, r2, r3, r5
 800374a:	581c      	ldr	r4, [r3, r0]
 800374c:	f424 1400 	bic.w	r4, r4, #2097152	; 0x200000
 8003750:	501c      	str	r4, [r3, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8003752:	78cb      	ldrb	r3, [r1, #3]
 8003754:	3b02      	subs	r3, #2
 8003756:	2b01      	cmp	r3, #1
 8003758:	d806      	bhi.n	8003768 <USB_EPClearStall+0x38>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800375a:	780b      	ldrb	r3, [r1, #0]
 800375c:	fb12 5203 	smlabb	r2, r2, r3, r5
 8003760:	5813      	ldr	r3, [r2, r0]
 8003762:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8003766:	5013      	str	r3, [r2, r0]
    }    
  }
  return HAL_OK;
}
 8003768:	2000      	movs	r0, #0
 800376a:	bd30      	pop	{r4, r5, pc}

0800376c <USB_StopDevice>:
  * @brief  USB_StopDevice : Stop the usb device mode
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
{
 800376c:	b538      	push	{r3, r4, r5, lr}
 800376e:	f500 612e 	add.w	r1, r0, #2784	; 0xae0
 8003772:	4604      	mov	r4, r0
 8003774:	f500 6310 	add.w	r3, r0, #2304	; 0x900
  uint32_t i;
  
  /* Clear Pending interrupt */
  for (i = 0U; i < 15U ; i++)
  {
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8003778:	22ff      	movs	r2, #255	; 0xff
 800377a:	609a      	str	r2, [r3, #8]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 800377c:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
 8003780:	3320      	adds	r3, #32
HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t i;
  
  /* Clear Pending interrupt */
  for (i = 0U; i < 15U ; i++)
 8003782:	428b      	cmp	r3, r1
 8003784:	d1f9      	bne.n	800377a <USB_StopDevice+0xe>
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  
  /* Clear interrupt masks */
  USBx_DEVICE->DIEPMSK  = 0U;
 8003786:	2500      	movs	r5, #0
  for (i = 0U; i < 15U ; i++)
  {
    USBx_INEP(i)->DIEPINT  = 0xFFU;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8003788:	f04f 32ff 	mov.w	r2, #4294967295
 800378c:	f8c4 2818 	str.w	r2, [r4, #2072]	; 0x818
  USBx_DEVICE->DIEPMSK  = 0U;
  USBx_DEVICE->DOEPMSK  = 0U;
  USBx_DEVICE->DAINTMSK = 0U;
  
  /* Flush the FIFO */
  USB_FlushRxFifo(USBx);
 8003790:	4620      	mov	r0, r4
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  
  /* Clear interrupt masks */
  USBx_DEVICE->DIEPMSK  = 0U;
 8003792:	f8c4 5810 	str.w	r5, [r4, #2064]	; 0x810
  USBx_DEVICE->DOEPMSK  = 0U;
 8003796:	f8c4 5814 	str.w	r5, [r4, #2068]	; 0x814
  USBx_DEVICE->DAINTMSK = 0U;
 800379a:	f8c4 581c 	str.w	r5, [r4, #2076]	; 0x81c
  
  /* Flush the FIFO */
  USB_FlushRxFifo(USBx);
 800379e:	f7ff fd03 	bl	80031a8 <USB_FlushRxFifo>
  USB_FlushTxFifo(USBx ,  0x10U);  
 80037a2:	2110      	movs	r1, #16
 80037a4:	4620      	mov	r0, r4
 80037a6:	f7ff fced 	bl	8003184 <USB_FlushTxFifo>
  
  return HAL_OK;
}
 80037aa:	4628      	mov	r0, r5
 80037ac:	bd38      	pop	{r3, r4, r5, pc}

080037ae <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 80037ae:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80037b2:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80037b6:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= (address << 4U) & USB_OTG_DCFG_DAD ;
 80037ba:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80037be:	0109      	lsls	r1, r1, #4
 80037c0:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 80037c4:	430b      	orrs	r3, r1
 80037c6:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  
  return HAL_OK;  
}
 80037ca:	2000      	movs	r0, #0
 80037cc:	4770      	bx	lr

080037ce <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 80037ce:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
 80037d0:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80037d4:	f023 0302 	bic.w	r3, r3, #2
 80037d8:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 80037dc:	2003      	movs	r0, #3
 80037de:	f7fd f99f 	bl	8000b20 <HAL_Delay>
  
  return HAL_OK;  
}
 80037e2:	2000      	movs	r0, #0
 80037e4:	bd08      	pop	{r3, pc}

080037e6 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 80037e6:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 80037e8:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80037ec:	f043 0302 	orr.w	r3, r3, #2
 80037f0:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 80037f4:	2003      	movs	r0, #3
 80037f6:	f7fd f993 	bl	8000b20 <HAL_Delay>
  
  return HAL_OK;  
}
 80037fa:	2000      	movs	r0, #0
 80037fc:	bd08      	pop	{r3, pc}

080037fe <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v = 0U;
  
  v = USBx->GINTSTS;
 80037fe:	6942      	ldr	r2, [r0, #20]
  v &= USBx->GINTMSK;
 8003800:	6980      	ldr	r0, [r0, #24]
  return v;  
}
 8003802:	4010      	ands	r0, r2
 8003804:	4770      	bx	lr

08003806 <USB_ReadDevAllOutEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8003806:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 800380a:	f8d0 0818 	ldr.w	r0, [r0, #2072]	; 0x818
  v &= USBx_DEVICE->DAINTMSK;
 800380e:	69db      	ldr	r3, [r3, #28]
  return ((v & 0xffff0000U) >> 16U);
 8003810:	4018      	ands	r0, r3
}
 8003812:	0c00      	lsrs	r0, r0, #16
 8003814:	4770      	bx	lr

08003816 <USB_ReadDevAllInEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8003816:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 800381a:	f8d0 0818 	ldr.w	r0, [r0, #2072]	; 0x818
  v &= USBx_DEVICE->DAINTMSK;
 800381e:	69db      	ldr	r3, [r3, #28]
  return ((v & 0xFFFFU));
 8003820:	4018      	ands	r0, r3
}
 8003822:	b280      	uxth	r0, r0
 8003824:	4770      	bx	lr

08003826 <USB_ReadDevOutEPInterrupt>:
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 8003826:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 800382a:	eb03 1141 	add.w	r1, r3, r1, lsl #5
  v &= USBx_DEVICE->DOEPMSK;
 800382e:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 8003832:	688a      	ldr	r2, [r1, #8]
  v &= USBx_DEVICE->DOEPMSK;
 8003834:	6940      	ldr	r0, [r0, #20]
  return v;
}
 8003836:	4010      	ands	r0, r2
 8003838:	4770      	bx	lr

0800383a <USB_ReadDevInEPInterrupt>:
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 800383a:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 800383e:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 8003842:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 8003846:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  return v;
 800384a:	fa23 f101 	lsr.w	r1, r3, r1
 800384e:	01c9      	lsls	r1, r1, #7
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
  emp = USBx_DEVICE->DIEPEMPMSK;
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 8003850:	6880      	ldr	r0, [r0, #8]
  return v;
 8003852:	b2c9      	uxtb	r1, r1
 8003854:	4311      	orrs	r1, r2
}
 8003856:	4008      	ands	r0, r1
 8003858:	4770      	bx	lr

0800385a <USB_GetMode>:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS ) & 0x1U);
 800385a:	6940      	ldr	r0, [r0, #20]
}
 800385c:	f000 0001 	and.w	r0, r0, #1
 8003860:	4770      	bx	lr

08003862 <USB_ActivateSetup>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8003862:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8003866:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 800386a:	f023 0307 	bic.w	r3, r3, #7
 800386e:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8003872:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8003876:	689a      	ldr	r2, [r3, #8]
 8003878:	f002 0206 	and.w	r2, r2, #6
 800387c:	2a04      	cmp	r2, #4
  {
    USBx_INEP(0U)->DIEPCTL |= 3U;
 800387e:	bf02      	ittt	eq
 8003880:	f8d0 2900 	ldreq.w	r2, [r0, #2304]	; 0x900
 8003884:	f042 0203 	orreq.w	r2, r2, #3
 8003888:	f8c0 2900 	streq.w	r2, [r0, #2304]	; 0x900
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 800388c:	685a      	ldr	r2, [r3, #4]
 800388e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003892:	605a      	str	r2, [r3, #4]

  return HAL_OK;
}
 8003894:	2000      	movs	r0, #0
 8003896:	4770      	bx	lr

08003898 <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup : pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 8003898:	b510      	push	{r4, lr}
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 800389a:	2400      	movs	r4, #0
 800389c:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
 80038a0:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80038a4:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80038a8:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 80038ac:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 80038b0:	f044 0418 	orr.w	r4, r4, #24
 80038b4:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 80038b8:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
 80038bc:	2901      	cmp	r1, #1
  * @param  psetup : pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 80038be:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 80038c2:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
  
  if (dma == 1U)
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 80038c6:	bf08      	it	eq
 80038c8:	f04f 2380 	moveq.w	r3, #2147516416	; 0x80008000
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 80038cc:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 80038d0:	bf04      	itt	eq
 80038d2:	f8c0 2b14 	streq.w	r2, [r0, #2836]	; 0xb14
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 80038d6:	f8c0 3b00 	streq.w	r3, [r0, #2816]	; 0xb00
  }
  
  return HAL_OK;  
}
 80038da:	2000      	movs	r0, #0
 80038dc:	bd10      	pop	{r4, pc}
	...

080038e0 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx : Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80038e0:	4b0a      	ldr	r3, [pc, #40]	; (800390c <USB_CoreReset+0x2c>)
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 80038e2:	3b01      	subs	r3, #1
 80038e4:	d101      	bne.n	80038ea <USB_CoreReset+0xa>
    {
      return HAL_TIMEOUT;
 80038e6:	2003      	movs	r0, #3
 80038e8:	4770      	bx	lr
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80038ea:	6902      	ldr	r2, [r0, #16]
 80038ec:	2a00      	cmp	r2, #0
 80038ee:	daf8      	bge.n	80038e2 <USB_CoreReset+0x2>
  
  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80038f0:	6903      	ldr	r3, [r0, #16]
 80038f2:	4a06      	ldr	r2, [pc, #24]	; (800390c <USB_CoreReset+0x2c>)
 80038f4:	f043 0301 	orr.w	r3, r3, #1
 80038f8:	6103      	str	r3, [r0, #16]

  do
  {
    if (++count > 200000U)
 80038fa:	3a01      	subs	r2, #1
 80038fc:	d0f3      	beq.n	80038e6 <USB_CoreReset+0x6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80038fe:	6903      	ldr	r3, [r0, #16]
 8003900:	f013 0301 	ands.w	r3, r3, #1
 8003904:	d1f9      	bne.n	80038fa <USB_CoreReset+0x1a>
  
  return HAL_OK;
 8003906:	4618      	mov	r0, r3
}
 8003908:	4770      	bx	lr
 800390a:	bf00      	nop
 800390c:	00030d41 	.word	0x00030d41

08003910 <disk_status>:
	BYTE pdrv		/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat;
  
  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 8003910:	4b03      	ldr	r3, [pc, #12]	; (8003920 <disk_status+0x10>)
 8003912:	181a      	adds	r2, r3, r0
 8003914:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8003918:	7a10      	ldrb	r0, [r2, #8]
 800391a:	685b      	ldr	r3, [r3, #4]
 800391c:	685b      	ldr	r3, [r3, #4]
 800391e:	4718      	bx	r3
 8003920:	20000644 	.word	0x20000644

08003924 <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;
  
  if(disk.is_initialized[pdrv] == 0)
 8003924:	4b06      	ldr	r3, [pc, #24]	; (8003940 <disk_initialize+0x1c>)
 8003926:	5c1a      	ldrb	r2, [r3, r0]
 8003928:	b942      	cbnz	r2, 800393c <disk_initialize+0x18>
  { 
    disk.is_initialized[pdrv] = 1;
 800392a:	2201      	movs	r2, #1
 800392c:	541a      	strb	r2, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 800392e:	181a      	adds	r2, r3, r0
 8003930:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8003934:	7a10      	ldrb	r0, [r2, #8]
 8003936:	685b      	ldr	r3, [r3, #4]
 8003938:	681b      	ldr	r3, [r3, #0]
 800393a:	4718      	bx	r3
  }
  return stat;
}
 800393c:	2000      	movs	r0, #0
 800393e:	4770      	bx	lr
 8003940:	20000644 	.word	0x20000644

08003944 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 8003944:	b430      	push	{r4, r5}
  DRESULT res;
 
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 8003946:	4c05      	ldr	r4, [pc, #20]	; (800395c <disk_read+0x18>)
 8003948:	1825      	adds	r5, r4, r0
 800394a:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 800394e:	6860      	ldr	r0, [r4, #4]
 8003950:	6884      	ldr	r4, [r0, #8]
 8003952:	7a28      	ldrb	r0, [r5, #8]
 8003954:	46a4      	mov	ip, r4
  return res;
}
 8003956:	bc30      	pop	{r4, r5}
	UINT count		/* Number of sectors to read */
)
{
  DRESULT res;
 
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 8003958:	4760      	bx	ip
 800395a:	bf00      	nop
 800395c:	20000644 	.word	0x20000644

08003960 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 8003960:	b430      	push	{r4, r5}
  DRESULT res;
  
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 8003962:	4c05      	ldr	r4, [pc, #20]	; (8003978 <disk_write+0x18>)
 8003964:	1825      	adds	r5, r4, r0
 8003966:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 800396a:	6860      	ldr	r0, [r4, #4]
 800396c:	68c4      	ldr	r4, [r0, #12]
 800396e:	7a28      	ldrb	r0, [r5, #8]
 8003970:	46a4      	mov	ip, r4
  return res;
}
 8003972:	bc30      	pop	{r4, r5}
	UINT count        	/* Number of sectors to write */
)
{
  DRESULT res;
  
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 8003974:	4760      	bx	ip
 8003976:	bf00      	nop
 8003978:	20000644 	.word	0x20000644

0800397c <disk_ioctl>:
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 800397c:	4b05      	ldr	r3, [pc, #20]	; (8003994 <disk_ioctl+0x18>)
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 800397e:	b410      	push	{r4}
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8003980:	181c      	adds	r4, r3, r0
 8003982:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8003986:	7a20      	ldrb	r0, [r4, #8]
 8003988:	685b      	ldr	r3, [r3, #4]
  return res;
}
 800398a:	f85d 4b04 	ldr.w	r4, [sp], #4
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 800398e:	691b      	ldr	r3, [r3, #16]
 8003990:	4718      	bx	r3
 8003992:	bf00      	nop
 8003994:	20000644 	.word	0x20000644

08003998 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
 8003998:	3801      	subs	r0, #1
 800399a:	440a      	add	r2, r1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 800399c:	4291      	cmp	r1, r2
 800399e:	d004      	beq.n	80039aa <mem_cpy+0x12>
		*d++ = *s++;
 80039a0:	f811 3b01 	ldrb.w	r3, [r1], #1
 80039a4:	f800 3f01 	strb.w	r3, [r0, #1]!
 80039a8:	e7f8      	b.n	800399c <mem_cpy+0x4>
}
 80039aa:	4770      	bx	lr

080039ac <mem_set>:

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
 80039ac:	4402      	add	r2, r0
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80039ae:	4290      	cmp	r0, r2
 80039b0:	d002      	beq.n	80039b8 <mem_set+0xc>
		*d++ = (BYTE)val;
 80039b2:	f800 1b01 	strb.w	r1, [r0], #1
 80039b6:	e7fa      	b.n	80039ae <mem_set+0x2>
}
 80039b8:	4770      	bx	lr
	...

080039bc <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dp,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 80039bc:	b570      	push	{r4, r5, r6, lr}
 80039be:	4a19      	ldr	r2, [pc, #100]	; (8003a24 <chk_lock+0x68>)
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 80039c0:	2400      	movs	r4, #0
 80039c2:	4623      	mov	r3, r4
		if (Files[i].fs) {	/* Existing entry */
 80039c4:	f852 5c04 	ldr.w	r5, [r2, #-4]
 80039c8:	b175      	cbz	r5, 80039e8 <chk_lock+0x2c>
			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
 80039ca:	f8d0 6200 	ldr.w	r6, [r0, #512]	; 0x200
 80039ce:	42b5      	cmp	r5, r6
 80039d0:	d10b      	bne.n	80039ea <chk_lock+0x2e>
 80039d2:	6816      	ldr	r6, [r2, #0]
 80039d4:	f8d0 5208 	ldr.w	r5, [r0, #520]	; 0x208
 80039d8:	42ae      	cmp	r6, r5
 80039da:	d106      	bne.n	80039ea <chk_lock+0x2e>
				Files[i].clu == dp->sclust &&
 80039dc:	8896      	ldrh	r6, [r2, #4]
 80039de:	f8b0 5206 	ldrh.w	r5, [r0, #518]	; 0x206
 80039e2:	42ae      	cmp	r6, r5
 80039e4:	d101      	bne.n	80039ea <chk_lock+0x2e>
 80039e6:	e006      	b.n	80039f6 <chk_lock+0x3a>
				Files[i].idx == dp->index) break;
		} else {			/* Blank entry */
			be = 1;
 80039e8:	2401      	movs	r4, #1
)
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 80039ea:	3301      	adds	r3, #1
 80039ec:	2b02      	cmp	r3, #2
 80039ee:	f102 020c 	add.w	r2, r2, #12
 80039f2:	d00e      	beq.n	8003a12 <chk_lock+0x56>
 80039f4:	e7e6      	b.n	80039c4 <chk_lock+0x8>
	}
	if (i == _FS_LOCK)	/* The object is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 80039f6:	b951      	cbnz	r1, 8003a0e <chk_lock+0x52>
 80039f8:	4a0b      	ldr	r2, [pc, #44]	; (8003a28 <chk_lock+0x6c>)
 80039fa:	210c      	movs	r1, #12
 80039fc:	fb01 2303 	mla	r3, r1, r3, r2
 8003a00:	895b      	ldrh	r3, [r3, #10]
 8003a02:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003a06:	bf14      	ite	ne
 8003a08:	2000      	movne	r0, #0
 8003a0a:	2010      	moveq	r0, #16
 8003a0c:	bd70      	pop	{r4, r5, r6, pc}
 8003a0e:	2010      	movs	r0, #16
 8003a10:	bd70      	pop	{r4, r5, r6, pc}
		} else {			/* Blank entry */
			be = 1;
		}
	}
	if (i == _FS_LOCK)	/* The object is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 8003a12:	b924      	cbnz	r4, 8003a1e <chk_lock+0x62>
 8003a14:	2902      	cmp	r1, #2
 8003a16:	bf0c      	ite	eq
 8003a18:	2000      	moveq	r0, #0
 8003a1a:	2012      	movne	r0, #18
 8003a1c:	bd70      	pop	{r4, r5, r6, pc}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8003a1e:	2000      	movs	r0, #0
 8003a20:	bd70      	pop	{r4, r5, r6, pc}
 8003a22:	bf00      	nop
 8003a24:	2000062c 	.word	0x2000062c
 8003a28:	20000628 	.word	0x20000628

08003a2c <inc_lock>:
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 8003a2c:	b570      	push	{r4, r5, r6, lr}
 8003a2e:	4a23      	ldr	r2, [pc, #140]	; (8003abc <inc_lock+0x90>)
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
		if (Files[i].fs == dp->fs &&
 8003a30:	f8d0 6200 	ldr.w	r6, [r0, #512]	; 0x200
)
{
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8003a34:	2300      	movs	r3, #0
		if (Files[i].fs == dp->fs &&
 8003a36:	f852 4c04 	ldr.w	r4, [r2, #-4]
 8003a3a:	42b4      	cmp	r4, r6
 8003a3c:	d109      	bne.n	8003a52 <inc_lock+0x26>
 8003a3e:	6815      	ldr	r5, [r2, #0]
 8003a40:	f8d0 4208 	ldr.w	r4, [r0, #520]	; 0x208
 8003a44:	42a5      	cmp	r5, r4
 8003a46:	d104      	bne.n	8003a52 <inc_lock+0x26>
			Files[i].clu == dp->sclust &&
 8003a48:	8895      	ldrh	r5, [r2, #4]
 8003a4a:	f8b0 4206 	ldrh.w	r4, [r0, #518]	; 0x206
 8003a4e:	42a5      	cmp	r5, r4
 8003a50:	d005      	beq.n	8003a5e <inc_lock+0x32>
)
{
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8003a52:	3301      	adds	r3, #1
 8003a54:	2b02      	cmp	r3, #2
 8003a56:	f102 020c 	add.w	r2, r2, #12
 8003a5a:	d008      	beq.n	8003a6e <inc_lock+0x42>
 8003a5c:	e7eb      	b.n	8003a36 <inc_lock+0xa>
		Files[i].clu = dp->sclust;
		Files[i].idx = dp->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8003a5e:	b1c9      	cbz	r1, 8003a94 <inc_lock+0x68>
 8003a60:	4917      	ldr	r1, [pc, #92]	; (8003ac0 <inc_lock+0x94>)
 8003a62:	220c      	movs	r2, #12
 8003a64:	fb02 1203 	mla	r2, r2, r3, r1
 8003a68:	8952      	ldrh	r2, [r2, #10]
 8003a6a:	bb22      	cbnz	r2, 8003ab6 <inc_lock+0x8a>
 8003a6c:	e01a      	b.n	8003aa4 <inc_lock+0x78>
			Files[i].clu == dp->sclust &&
			Files[i].idx == dp->index) break;
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8003a6e:	4a14      	ldr	r2, [pc, #80]	; (8003ac0 <inc_lock+0x94>)
 8003a70:	6813      	ldr	r3, [r2, #0]
 8003a72:	b113      	cbz	r3, 8003a7a <inc_lock+0x4e>
 8003a74:	68d3      	ldr	r3, [r2, #12]
 8003a76:	b9f3      	cbnz	r3, 8003ab6 <inc_lock+0x8a>
 8003a78:	2301      	movs	r3, #1
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
		Files[i].fs = dp->fs;
 8003a7a:	240c      	movs	r4, #12
 8003a7c:	435c      	muls	r4, r3
 8003a7e:	1915      	adds	r5, r2, r4
 8003a80:	5116      	str	r6, [r2, r4]
		Files[i].clu = dp->sclust;
 8003a82:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
 8003a86:	606a      	str	r2, [r5, #4]
		Files[i].idx = dp->index;
 8003a88:	f8b0 2206 	ldrh.w	r2, [r0, #518]	; 0x206
 8003a8c:	812a      	strh	r2, [r5, #8]
		Files[i].ctr = 0;
 8003a8e:	2200      	movs	r2, #0
 8003a90:	816a      	strh	r2, [r5, #10]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8003a92:	b939      	cbnz	r1, 8003aa4 <inc_lock+0x78>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8003a94:	490a      	ldr	r1, [pc, #40]	; (8003ac0 <inc_lock+0x94>)
 8003a96:	220c      	movs	r2, #12
 8003a98:	fb02 1203 	mla	r2, r2, r3, r1
 8003a9c:	8952      	ldrh	r2, [r2, #10]
 8003a9e:	3201      	adds	r2, #1
 8003aa0:	b292      	uxth	r2, r2
 8003aa2:	e001      	b.n	8003aa8 <inc_lock+0x7c>
 8003aa4:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003aa8:	4805      	ldr	r0, [pc, #20]	; (8003ac0 <inc_lock+0x94>)
 8003aaa:	210c      	movs	r1, #12
 8003aac:	fb01 0103 	mla	r1, r1, r3, r0

	return i + 1;
 8003ab0:	1c58      	adds	r0, r3, #1
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 8003ab2:	814a      	strh	r2, [r1, #10]

	return i + 1;
 8003ab4:	bd70      	pop	{r4, r5, r6, pc}
			Files[i].idx == dp->index) break;
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 8003ab6:	2000      	movs	r0, #0
 8003ab8:	bd70      	pop	{r4, r5, r6, pc}
 8003aba:	bf00      	nop
 8003abc:	2000062c 	.word	0x2000062c
 8003ac0:	20000628 	.word	0x20000628

08003ac4 <dec_lock>:

static
FRESULT dec_lock (	/* Decrement object open counter */
	UINT i			/* Semaphore index (1..) */
)
{
 8003ac4:	b510      	push	{r4, lr}
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8003ac6:	1e44      	subs	r4, r0, #1
 8003ac8:	2c01      	cmp	r4, #1
 8003aca:	d811      	bhi.n	8003af0 <dec_lock+0x2c>
		n = Files[i].ctr;
 8003acc:	4a0a      	ldr	r2, [pc, #40]	; (8003af8 <dec_lock+0x34>)
 8003ace:	230c      	movs	r3, #12
 8003ad0:	fb03 2104 	mla	r1, r3, r4, r2
 8003ad4:	8949      	ldrh	r1, [r1, #10]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
		if (n) n--;					/* Decrement read mode open count */
 8003ad6:	f421 7080 	bic.w	r0, r1, #256	; 0x100
 8003ada:	b280      	uxth	r0, r0
 8003adc:	b108      	cbz	r0, 8003ae2 <dec_lock+0x1e>
 8003ade:	3901      	subs	r1, #1
 8003ae0:	b288      	uxth	r0, r1
		Files[i].ctr = n;
 8003ae2:	4363      	muls	r3, r4
 8003ae4:	441a      	add	r2, r3
 8003ae6:	8150      	strh	r0, [r2, #10]
		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8003ae8:	b920      	cbnz	r0, 8003af4 <dec_lock+0x30>
 8003aea:	4a03      	ldr	r2, [pc, #12]	; (8003af8 <dec_lock+0x34>)
 8003aec:	50d0      	str	r0, [r2, r3]
 8003aee:	bd10      	pop	{r4, pc}
		res = FR_OK;
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
 8003af0:	2002      	movs	r0, #2
 8003af2:	bd10      	pop	{r4, pc}
		n = Files[i].ctr;
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
		if (n) n--;					/* Decrement read mode open count */
		Files[i].ctr = n;
		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
		res = FR_OK;
 8003af4:	2000      	movs	r0, #0
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
	}
	return res;
}
 8003af6:	bd10      	pop	{r4, pc}
 8003af8:	20000628 	.word	0x20000628

08003afc <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8003afc:	f8d0 3224 	ldr.w	r3, [r0, #548]	; 0x224
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
 8003b00:	f8d0 2200 	ldr.w	r2, [r0, #512]	; 0x200
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8003b04:	3304      	adds	r3, #4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
 8003b06:	0a49      	lsrs	r1, r1, #9
 8003b08:	f892 0202 	ldrb.w	r0, [r2, #514]	; 0x202
 8003b0c:	fbb1 f1f0 	udiv	r1, r1, r0
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8003b10:	6818      	ldr	r0, [r3, #0]
		if (!ncl) return 0;		/* End of table? (error) */
 8003b12:	b130      	cbz	r0, 8003b22 <clmt_clust+0x26>
		if (cl < ncl) break;	/* In this fragment? */
 8003b14:	4281      	cmp	r1, r0
 8003b16:	d302      	bcc.n	8003b1e <clmt_clust+0x22>
		cl -= ncl; tbl++;		/* Next fragment */
 8003b18:	1a09      	subs	r1, r1, r0
 8003b1a:	3308      	adds	r3, #8
	}
 8003b1c:	e7f8      	b.n	8003b10 <clmt_clust+0x14>
	return cl + *tbl;	/* Return the cluster number */
 8003b1e:	685b      	ldr	r3, [r3, #4]
 8003b20:	18c8      	adds	r0, r1, r3
}
 8003b22:	4770      	bx	lr

08003b24 <sum_sfn>:
#if _USE_LFN
static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 8003b24:	f100 010b 	add.w	r1, r0, #11
	BYTE sum = 0;
 8003b28:	2300      	movs	r3, #0
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 8003b2a:	01da      	lsls	r2, r3, #7
 8003b2c:	ea42 0353 	orr.w	r3, r2, r3, lsr #1
 8003b30:	f810 2b01 	ldrb.w	r2, [r0], #1
 8003b34:	fa52 f383 	uxtab	r3, r2, r3
 8003b38:	4288      	cmp	r0, r1
 8003b3a:	b2db      	uxtb	r3, r3
 8003b3c:	d1f5      	bne.n	8003b2a <sum_sfn+0x6>
	return sum;
}
 8003b3e:	4618      	mov	r0, r3
 8003b40:	4770      	bx	lr

08003b42 <get_ldnumber>:
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 8003b42:	6802      	ldr	r2, [r0, #0]

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 8003b44:	b510      	push	{r4, lr}
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 8003b46:	b18a      	cbz	r2, 8003b6c <get_ldnumber+0x2a>
 8003b48:	4611      	mov	r1, r2
 8003b4a:	460b      	mov	r3, r1
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8003b4c:	f811 4b01 	ldrb.w	r4, [r1], #1
 8003b50:	2c1f      	cmp	r4, #31
 8003b52:	d909      	bls.n	8003b68 <get_ldnumber+0x26>
 8003b54:	2c3a      	cmp	r4, #58	; 0x3a
 8003b56:	d1f8      	bne.n	8003b4a <get_ldnumber+0x8>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8003b58:	1c51      	adds	r1, r2, #1
 8003b5a:	428b      	cmp	r3, r1
 8003b5c:	d106      	bne.n	8003b6c <get_ldnumber+0x2a>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 8003b5e:	7812      	ldrb	r2, [r2, #0]
 8003b60:	2a30      	cmp	r2, #48	; 0x30
 8003b62:	d103      	bne.n	8003b6c <get_ldnumber+0x2a>
					vol = (int)i;
					*path = ++tt;
 8003b64:	3301      	adds	r3, #1
 8003b66:	6003      	str	r3, [r0, #0]
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 8003b68:	2000      	movs	r0, #0
 8003b6a:	bd10      	pop	{r4, pc}
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 8003b6c:	f04f 30ff 	mov.w	r0, #4294967295
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8003b70:	bd10      	pop	{r4, pc}

08003b72 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
 8003b72:	b508      	push	{r3, lr}
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
 8003b74:	b190      	cbz	r0, 8003b9c <validate+0x2a>
 8003b76:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 8003b7a:	b17b      	cbz	r3, 8003b9c <validate+0x2a>
 8003b7c:	f893 2200 	ldrb.w	r2, [r3, #512]	; 0x200
 8003b80:	b162      	cbz	r2, 8003b9c <validate+0x2a>
 8003b82:	f8b3 1206 	ldrh.w	r1, [r3, #518]	; 0x206
 8003b86:	f8b0 2204 	ldrh.w	r2, [r0, #516]	; 0x204
 8003b8a:	4291      	cmp	r1, r2
 8003b8c:	d106      	bne.n	8003b9c <validate+0x2a>
 8003b8e:	f893 0201 	ldrb.w	r0, [r3, #513]	; 0x201
 8003b92:	f7ff febd 	bl	8003910 <disk_status>
 8003b96:	f010 0001 	ands.w	r0, r0, #1
 8003b9a:	d000      	beq.n	8003b9e <validate+0x2c>
		return FR_INVALID_OBJECT;
 8003b9c:	2009      	movs	r0, #9

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
 8003b9e:	bd08      	pop	{r3, pc}

08003ba0 <ld_clust.isra.0>:
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
 8003ba0:	7eca      	ldrb	r2, [r1, #27]
 8003ba2:	7e8b      	ldrb	r3, [r1, #26]
	if (fs->fs_type == FS_FAT32)
 8003ba4:	2803      	cmp	r0, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
 8003ba6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (fs->fs_type == FS_FAT32)
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
 8003baa:	bf01      	itttt	eq
 8003bac:	7d48      	ldrbeq	r0, [r1, #21]
 8003bae:	7d0a      	ldrbeq	r2, [r1, #20]
 8003bb0:	ea42 2200 	orreq.w	r2, r2, r0, lsl #8
 8003bb4:	ea43 4302 	orreq.w	r3, r3, r2, lsl #16

	return cl;
}
 8003bb8:	4618      	mov	r0, r3
 8003bba:	4770      	bx	lr

08003bbc <sync_window.part.1>:
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 8003bbc:	b570      	push	{r4, r5, r6, lr}
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
 8003bbe:	f8d0 5230 	ldr.w	r5, [r0, #560]	; 0x230
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 8003bc2:	4604      	mov	r4, r0
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
 8003bc4:	4601      	mov	r1, r0
 8003bc6:	2301      	movs	r3, #1
 8003bc8:	462a      	mov	r2, r5
 8003bca:	f890 0201 	ldrb.w	r0, [r0, #513]	; 0x201
 8003bce:	f7ff fec7 	bl	8003960 <disk_write>
 8003bd2:	b9d0      	cbnz	r0, 8003c0a <sync_window.part.1+0x4e>
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003bd4:	f8d4 3224 	ldr.w	r3, [r4, #548]	; 0x224
 8003bd8:	f8d4 221c 	ldr.w	r2, [r4, #540]	; 0x21c
	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
 8003bdc:	f884 0204 	strb.w	r0, [r4, #516]	; 0x204
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003be0:	1aeb      	subs	r3, r5, r3
 8003be2:	4293      	cmp	r3, r2
 8003be4:	d301      	bcc.n	8003bea <sync_window.part.1+0x2e>
	FATFS* fs		/* File system object */
)
{
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
 8003be6:	2000      	movs	r0, #0
 8003be8:	bd70      	pop	{r4, r5, r6, pc}
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003bea:	f894 6203 	ldrb.w	r6, [r4, #515]	; 0x203
 8003bee:	2e01      	cmp	r6, #1
 8003bf0:	d9f9      	bls.n	8003be6 <sync_window.part.1+0x2a>
					wsect += fs->fsize;
 8003bf2:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
					disk_write(fs->drv, fs->win.d8, wsect, 1);
 8003bf6:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
 8003bfa:	441d      	add	r5, r3
					disk_write(fs->drv, fs->win.d8, wsect, 1);
 8003bfc:	462a      	mov	r2, r5
 8003bfe:	2301      	movs	r3, #1
 8003c00:	4621      	mov	r1, r4
 8003c02:	f7ff fead 	bl	8003960 <disk_write>
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003c06:	3e01      	subs	r6, #1
 8003c08:	e7f1      	b.n	8003bee <sync_window.part.1+0x32>


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win.d8, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
 8003c0a:	2001      	movs	r0, #1
				}
			}
		}
	}
	return res;
}
 8003c0c:	bd70      	pop	{r4, r5, r6, pc}

08003c0e <sync_window>:
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003c0e:	f890 3204 	ldrb.w	r3, [r0, #516]	; 0x204
 8003c12:	b10b      	cbz	r3, 8003c18 <sync_window+0xa>
 8003c14:	f7ff bfd2 	b.w	8003bbc <sync_window.part.1>
				}
			}
		}
	}
	return res;
}
 8003c18:	4618      	mov	r0, r3
 8003c1a:	4770      	bx	lr

08003c1c <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS* fs		/* File system object */
)
{
 8003c1c:	b538      	push	{r3, r4, r5, lr}
 8003c1e:	4604      	mov	r4, r0
	FRESULT res;


	res = sync_window(fs);
 8003c20:	f7ff fff5 	bl	8003c0e <sync_window>
 8003c24:	4605      	mov	r5, r0
	if (res == FR_OK) {
 8003c26:	2800      	cmp	r0, #0
 8003c28:	d152      	bne.n	8003cd0 <sync_fs+0xb4>
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 8003c2a:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8003c2e:	2b03      	cmp	r3, #3
 8003c30:	d145      	bne.n	8003cbe <sync_fs+0xa2>
 8003c32:	f894 3205 	ldrb.w	r3, [r4, #517]	; 0x205
 8003c36:	2b01      	cmp	r3, #1
 8003c38:	d141      	bne.n	8003cbe <sync_fs+0xa2>
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
 8003c3a:	4601      	mov	r1, r0
 8003c3c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003c40:	4620      	mov	r0, r4
 8003c42:	f7ff feb3 	bl	80039ac <mem_set>
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
 8003c46:	2255      	movs	r2, #85	; 0x55
 8003c48:	f884 21fe 	strb.w	r2, [r4, #510]	; 0x1fe
 8003c4c:	22aa      	movs	r2, #170	; 0xaa
 8003c4e:	f884 21ff 	strb.w	r2, [r4, #511]	; 0x1ff
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
 8003c52:	2252      	movs	r2, #82	; 0x52
 8003c54:	7022      	strb	r2, [r4, #0]
 8003c56:	7062      	strb	r2, [r4, #1]
 8003c58:	2261      	movs	r2, #97	; 0x61
 8003c5a:	70a2      	strb	r2, [r4, #2]
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
 8003c5c:	f884 21e7 	strb.w	r2, [r4, #487]	; 0x1e7
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
 8003c60:	f8d4 2210 	ldr.w	r2, [r4, #528]	; 0x210
 8003c64:	f884 21e8 	strb.w	r2, [r4, #488]	; 0x1e8
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
 8003c68:	2141      	movs	r1, #65	; 0x41
 8003c6a:	70e1      	strb	r1, [r4, #3]
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
 8003c6c:	f884 11e6 	strb.w	r1, [r4, #486]	; 0x1e6
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
 8003c70:	1211      	asrs	r1, r2, #8
 8003c72:	f884 11e9 	strb.w	r1, [r4, #489]	; 0x1e9
 8003c76:	0c11      	lsrs	r1, r2, #16
 8003c78:	0e12      	lsrs	r2, r2, #24
 8003c7a:	f884 21eb 	strb.w	r2, [r4, #491]	; 0x1eb
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
 8003c7e:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
 8003c82:	f884 11ea 	strb.w	r1, [r4, #490]	; 0x1ea
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
 8003c86:	1211      	asrs	r1, r2, #8
 8003c88:	f884 21ec 	strb.w	r2, [r4, #492]	; 0x1ec
 8003c8c:	f884 11ed 	strb.w	r1, [r4, #493]	; 0x1ed
 8003c90:	0c11      	lsrs	r1, r2, #16
 8003c92:	0e12      	lsrs	r2, r2, #24
 8003c94:	f884 21ef 	strb.w	r2, [r4, #495]	; 0x1ef
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 8003c98:	f8d4 2220 	ldr.w	r2, [r4, #544]	; 0x220
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
 8003c9c:	f884 11ee 	strb.w	r1, [r4, #494]	; 0x1ee
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
 8003ca0:	2072      	movs	r0, #114	; 0x72
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 8003ca2:	3201      	adds	r2, #1
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win.d8, 0, SS(fs));
			ST_WORD(fs->win.d8 + BS_55AA, 0xAA55);
			ST_DWORD(fs->win.d8 + FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win.d8 + FSI_StrucSig, 0x61417272);
 8003ca4:	f884 01e4 	strb.w	r0, [r4, #484]	; 0x1e4
 8003ca8:	f884 01e5 	strb.w	r0, [r4, #485]	; 0x1e5
			ST_DWORD(fs->win.d8 + FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win.d8 + FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 8003cac:	f8c4 2230 	str.w	r2, [r4, #560]	; 0x230
			disk_write(fs->drv, fs->win.d8, fs->winsect, 1);
 8003cb0:	4621      	mov	r1, r4
 8003cb2:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
 8003cb6:	f7ff fe53 	bl	8003960 <disk_write>
			fs->fsi_flag = 0;
 8003cba:	f884 5205 	strb.w	r5, [r4, #517]	; 0x205
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 8003cbe:	2200      	movs	r2, #0
 8003cc0:	4611      	mov	r1, r2
 8003cc2:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
 8003cc6:	f7ff fe59 	bl	800397c <disk_ioctl>
 8003cca:	3000      	adds	r0, #0
 8003ccc:	bf18      	it	ne
 8003cce:	2001      	movne	r0, #1
			res = FR_DISK_ERR;
	}

	return res;
}
 8003cd0:	bd38      	pop	{r3, r4, r5, pc}

08003cd2 <move_window>:
)
{
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
 8003cd2:	f8d0 3230 	ldr.w	r3, [r0, #560]	; 0x230
 8003cd6:	428b      	cmp	r3, r1
static
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[].d8 */
)
{
 8003cd8:	b570      	push	{r4, r5, r6, lr}
 8003cda:	4606      	mov	r6, r0
 8003cdc:	460d      	mov	r5, r1
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
 8003cde:	d012      	beq.n	8003d06 <move_window+0x34>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
 8003ce0:	f7ff ff95 	bl	8003c0e <sync_window>
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
 8003ce4:	4604      	mov	r4, r0
 8003ce6:	b978      	cbnz	r0, 8003d08 <move_window+0x36>
			if (disk_read(fs->drv, fs->win.d8, sector, 1) != RES_OK) {
 8003ce8:	462a      	mov	r2, r5
 8003cea:	2301      	movs	r3, #1
 8003cec:	4631      	mov	r1, r6
 8003cee:	f896 0201 	ldrb.w	r0, [r6, #513]	; 0x201
 8003cf2:	f7ff fe27 	bl	8003944 <disk_read>
 8003cf6:	2800      	cmp	r0, #0
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
 8003cf8:	bf1c      	itt	ne
 8003cfa:	f04f 35ff 	movne.w	r5, #4294967295
 8003cfe:	2401      	movne	r4, #1
			}
			fs->winsect = sector;
 8003d00:	f8c6 5230 	str.w	r5, [r6, #560]	; 0x230
 8003d04:	e000      	b.n	8003d08 <move_window+0x36>
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[].d8 */
)
{
	FRESULT res = FR_OK;
 8003d06:	2400      	movs	r4, #0
			}
			fs->winsect = sector;
		}
	}
	return res;
}
 8003d08:	4620      	mov	r0, r4
 8003d0a:	bd70      	pop	{r4, r5, r6, pc}

08003d0c <check_fs>:
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8003d0c:	2300      	movs	r3, #0
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 8003d0e:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8003d10:	f880 3204 	strb.w	r3, [r0, #516]	; 0x204
 8003d14:	f04f 33ff 	mov.w	r3, #4294967295
 8003d18:	f8c0 3230 	str.w	r3, [r0, #560]	; 0x230
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 8003d1c:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
 8003d1e:	f7ff ffd8 	bl	8003cd2 <move_window>
 8003d22:	b9c0      	cbnz	r0, 8003d56 <check_fs+0x4a>
		return 3;

	if (LD_WORD(&fs->win.d8[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
 8003d24:	f894 21ff 	ldrb.w	r2, [r4, #511]	; 0x1ff
 8003d28:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
 8003d2c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003d30:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8003d34:	4293      	cmp	r3, r2
 8003d36:	d110      	bne.n	8003d5a <check_fs+0x4e>
		return 2;

	if ((LD_DWORD(&fs->win.d8[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
 8003d38:	f8d4 3036 	ldr.w	r3, [r4, #54]	; 0x36
 8003d3c:	4a08      	ldr	r2, [pc, #32]	; (8003d60 <check_fs+0x54>)
 8003d3e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8003d42:	4293      	cmp	r3, r2
 8003d44:	d00a      	beq.n	8003d5c <check_fs+0x50>
		return 0;
	if ((LD_DWORD(&fs->win.d8[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 8003d46:	f8d4 0052 	ldr.w	r0, [r4, #82]	; 0x52
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
		return 3;
 8003d4a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8003d4e:	1a80      	subs	r0, r0, r2
 8003d50:	bf18      	it	ne
 8003d52:	2001      	movne	r0, #1
 8003d54:	bd10      	pop	{r4, pc}
 8003d56:	2003      	movs	r0, #3
 8003d58:	bd10      	pop	{r4, pc}

	if (LD_WORD(&fs->win.d8[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
 8003d5a:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win.d8[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
 8003d5c:	bd10      	pop	{r4, pc}
 8003d5e:	bf00      	nop
 8003d60:	00544146 	.word	0x00544146

08003d64 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003d64:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
 8003d68:	2300      	movs	r3, #0
 8003d6a:	6003      	str	r3, [r0, #0]
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003d6c:	4607      	mov	r7, r0
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 8003d6e:	4608      	mov	r0, r1
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003d70:	4616      	mov	r6, r2
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 8003d72:	f7ff fee6 	bl	8003b42 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8003d76:	1e05      	subs	r5, r0, #0
 8003d78:	f2c0 8116 	blt.w	8003fa8 <find_volume+0x244>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8003d7c:	4ba2      	ldr	r3, [pc, #648]	; (8004008 <find_volume+0x2a4>)
 8003d7e:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8003d82:	2c00      	cmp	r4, #0
 8003d84:	f000 8112 	beq.w	8003fac <find_volume+0x248>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 8003d88:	603c      	str	r4, [r7, #0]

	if (fs->fs_type) {					/* If the volume has been mounted */
 8003d8a:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8003d8e:	b16b      	cbz	r3, 8003dac <find_volume+0x48>
		stat = disk_status(fs->drv);
 8003d90:	f894 0201 	ldrb.w	r0, [r4, #513]	; 0x201
 8003d94:	f7ff fdbc 	bl	8003910 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8003d98:	07c7      	lsls	r7, r0, #31
 8003d9a:	d407      	bmi.n	8003dac <find_volume+0x48>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8003d9c:	2e00      	cmp	r6, #0
 8003d9e:	f000 80c0 	beq.w	8003f22 <find_volume+0x1be>
 8003da2:	0741      	lsls	r1, r0, #29
 8003da4:	f140 80bd 	bpl.w	8003f22 <find_volume+0x1be>
				return FR_WRITE_PROTECTED;
 8003da8:	200a      	movs	r0, #10
 8003daa:	e129      	b.n	8004000 <find_volume+0x29c>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8003dac:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8003dae:	b2e8      	uxtb	r0, r5
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8003db0:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8003db4:	f884 0201 	strb.w	r0, [r4, #513]	; 0x201
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8003db8:	f7ff fdb4 	bl	8003924 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8003dbc:	07c2      	lsls	r2, r0, #31
 8003dbe:	f100 80f7 	bmi.w	8003fb0 <find_volume+0x24c>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 8003dc2:	2e00      	cmp	r6, #0
 8003dc4:	f040 80af 	bne.w	8003f26 <find_volume+0x1c2>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
 8003dc8:	2100      	movs	r1, #0
 8003dca:	4620      	mov	r0, r4
 8003dcc:	f7ff ff9e 	bl	8003d0c <check_fs>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
 8003dd0:	2801      	cmp	r0, #1
 8003dd2:	f040 80b2 	bne.w	8003f3a <find_volume+0x1d6>
 8003dd6:	f504 71e3 	add.w	r1, r4, #454	; 0x1c6
 8003dda:	2200      	movs	r2, #0
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win.d8 + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 8003ddc:	f811 3c04 	ldrb.w	r3, [r1, #-4]
 8003de0:	b103      	cbz	r3, 8003de4 <find_volume+0x80>
 8003de2:	680b      	ldr	r3, [r1, #0]
 8003de4:	f84d 3022 	str.w	r3, [sp, r2, lsl #2]
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
 8003de8:	3201      	adds	r2, #1
 8003dea:	2a04      	cmp	r2, #4
 8003dec:	f101 0110 	add.w	r1, r1, #16
 8003df0:	d1f4      	bne.n	8003ddc <find_volume+0x78>
 8003df2:	2600      	movs	r6, #0
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
 8003df4:	f85d 5026 	ldr.w	r5, [sp, r6, lsl #2]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8003df8:	2d00      	cmp	r5, #0
 8003dfa:	f000 8098 	beq.w	8003f2e <find_volume+0x1ca>
 8003dfe:	4629      	mov	r1, r5
 8003e00:	4620      	mov	r0, r4
 8003e02:	f7ff ff83 	bl	8003d0c <check_fs>
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8003e06:	2800      	cmp	r0, #0
 8003e08:	f040 8092 	bne.w	8003f30 <find_volume+0x1cc>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8003e0c:	7b22      	ldrb	r2, [r4, #12]
 8003e0e:	7ae3      	ldrb	r3, [r4, #11]
 8003e10:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003e14:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003e18:	f040 8092 	bne.w	8003f40 <find_volume+0x1dc>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
 8003e1c:	7da3      	ldrb	r3, [r4, #22]
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
 8003e1e:	f894 c010 	ldrb.w	ip, [r4, #16]
	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
 8003e22:	7de0      	ldrb	r0, [r4, #23]
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
 8003e24:	f884 c203 	strb.w	ip, [r4, #515]	; 0x203

	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
 8003e28:	ea53 2000 	orrs.w	r0, r3, r0, lsl #8
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8003e2c:	f10c 33ff 	add.w	r3, ip, #4294967295

	if (LD_WORD(fs->win.d8 + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win.d8 + BPB_FATSz16);			/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win.d8 + BPB_FATSz32);
 8003e30:	bf08      	it	eq
 8003e32:	6a60      	ldreq	r0, [r4, #36]	; 0x24
	fs->fsize = fasize;
 8003e34:	f8c4 021c 	str.w	r0, [r4, #540]	; 0x21c

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8003e38:	2b01      	cmp	r3, #1
 8003e3a:	f200 8081 	bhi.w	8003f40 <find_volume+0x1dc>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win.d8[BPB_SecPerClus];				/* Number of sectors per cluster */
 8003e3e:	7b63      	ldrb	r3, [r4, #13]
 8003e40:	f884 3202 	strb.w	r3, [r4, #514]	; 0x202
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
 8003e44:	2b00      	cmp	r3, #0
 8003e46:	d07b      	beq.n	8003f40 <find_volume+0x1dc>
 8003e48:	1e5a      	subs	r2, r3, #1
 8003e4a:	421a      	tst	r2, r3
 8003e4c:	d178      	bne.n	8003f40 <find_volume+0x1dc>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
 8003e4e:	f894 e012 	ldrb.w	lr, [r4, #18]
 8003e52:	7c62      	ldrb	r2, [r4, #17]
 8003e54:	ea42 2e0e 	orr.w	lr, r2, lr, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
 8003e58:	f01e 0f0f 	tst.w	lr, #15

	fs->csize = fs->win.d8[BPB_SecPerClus];				/* Number of sectors per cluster */
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
 8003e5c:	f8a4 e208 	strh.w	lr, [r4, #520]	; 0x208
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
 8003e60:	d16e      	bne.n	8003f40 <find_volume+0x1dc>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win.d8 + BPB_TotSec16);			/* Number of sectors on the volume */
 8003e62:	7d21      	ldrb	r1, [r4, #20]
 8003e64:	7ce2      	ldrb	r2, [r4, #19]
	if (!tsect) tsect = LD_DWORD(fs->win.d8 + BPB_TotSec32);

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
 8003e66:	7be6      	ldrb	r6, [r4, #15]
	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win.d8 + BPB_TotSec16);			/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win.d8 + BPB_TotSec32);
 8003e68:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
 8003e6c:	7ba1      	ldrb	r1, [r4, #14]
	fs->n_rootdir = LD_WORD(fs->win.d8 + BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win.d8 + BPB_TotSec16);			/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win.d8 + BPB_TotSec32);
 8003e6e:	bf08      	it	eq
 8003e70:	6a22      	ldreq	r2, [r4, #32]

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 8003e72:	ea51 2106 	orrs.w	r1, r1, r6, lsl #8
 8003e76:	d063      	beq.n	8003f40 <find_volume+0x1dc>
	fs->fsize = fasize;

	fs->n_fats = fs->win.d8[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
 8003e78:	fb00 fc0c 	mul.w	ip, r0, ip

	nrsv = LD_WORD(fs->win.d8 + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
 8003e7c:	eb01 171e 	add.w	r7, r1, lr, lsr #4
 8003e80:	4467      	add	r7, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8003e82:	42ba      	cmp	r2, r7
 8003e84:	d35c      	bcc.n	8003f40 <find_volume+0x1dc>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8003e86:	1bd2      	subs	r2, r2, r7
 8003e88:	fbb2 f3f3 	udiv	r3, r2, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8003e8c:	2b00      	cmp	r3, #0
 8003e8e:	d057      	beq.n	8003f40 <find_volume+0x1dc>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8003e90:	f640 72f5 	movw	r2, #4085	; 0xff5
 8003e94:	4293      	cmp	r3, r2
 8003e96:	f103 0602 	add.w	r6, r3, #2
 8003e9a:	eb01 0205 	add.w	r2, r1, r5
 8003e9e:	442f      	add	r7, r5
 8003ea0:	f240 808c 	bls.w	8003fbc <find_volume+0x258>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8003ea4:	f64f 71f5 	movw	r1, #65525	; 0xfff5
 8003ea8:	428b      	cmp	r3, r1
 8003eaa:	f240 808a 	bls.w	8003fc2 <find_volume+0x25e>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8003eae:	f8c4 6218 	str.w	r6, [r4, #536]	; 0x218
	fs->volbase = bsect;								/* Volume start sector */
 8003eb2:	f8c4 5220 	str.w	r5, [r4, #544]	; 0x220
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8003eb6:	f8c4 2224 	str.w	r2, [r4, #548]	; 0x224
	fs->database = bsect + sysect;						/* Data start sector */
 8003eba:	f8c4 722c 	str.w	r7, [r4, #556]	; 0x22c
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8003ebe:	f1be 0f00 	cmp.w	lr, #0
 8003ec2:	d13d      	bne.n	8003f40 <find_volume+0x1dc>
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
 8003ec4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8003ec6:	f8c4 3228 	str.w	r3, [r4, #552]	; 0x228
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8003eca:	f04f 0803 	mov.w	r8, #3
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	fs->database = bsect + sysect;						/* Data start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
 8003ece:	00b3      	lsls	r3, r6, #2
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
 8003ed0:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 8003ed4:	ebb0 2f53 	cmp.w	r0, r3, lsr #9
 8003ed8:	d332      	bcc.n	8003f40 <find_volume+0x1dc>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8003eda:	f04f 33ff 	mov.w	r3, #4294967295
 8003ede:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
 8003ee2:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
 8003ee6:	f1b8 0f03 	cmp.w	r8, #3
#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8003eea:	f04f 0380 	mov.w	r3, #128	; 0x80
 8003eee:	f884 3205 	strb.w	r3, [r4, #517]	; 0x205
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
 8003ef2:	d029      	beq.n	8003f48 <find_volume+0x1e4>
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
	fs->id = ++Fsid;	/* File system mount ID */
 8003ef4:	4a45      	ldr	r2, [pc, #276]	; (800400c <find_volume+0x2a8>)
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
 8003ef6:	f884 8200 	strb.w	r8, [r4, #512]	; 0x200
	fs->id = ++Fsid;	/* File system mount ID */
 8003efa:	8813      	ldrh	r3, [r2, #0]
 8003efc:	3301      	adds	r3, #1
 8003efe:	b29b      	uxth	r3, r3
 8003f00:	8013      	strh	r3, [r2, #0]
 8003f02:	f8a4 3206 	strh.w	r3, [r4, #518]	; 0x206
)
{
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
 8003f06:	4b42      	ldr	r3, [pc, #264]	; (8004010 <find_volume+0x2ac>)
 8003f08:	6819      	ldr	r1, [r3, #0]
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
	fs->id = ++Fsid;	/* File system mount ID */
#if _FS_RPATH
	fs->cdir = 0;		/* Set current directory to root */
 8003f0a:	2200      	movs	r2, #0
)
{
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
 8003f0c:	428c      	cmp	r4, r1
 8003f0e:	bf08      	it	eq
 8003f10:	601a      	streq	r2, [r3, #0]
 8003f12:	68db      	ldr	r3, [r3, #12]
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
	fs->id = ++Fsid;	/* File system mount ID */
#if _FS_RPATH
	fs->cdir = 0;		/* Set current directory to root */
 8003f14:	f8c4 2214 	str.w	r2, [r4, #532]	; 0x214
)
{
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
 8003f18:	429c      	cmp	r4, r3
 8003f1a:	d102      	bne.n	8003f22 <find_volume+0x1be>
 8003f1c:	4b3c      	ldr	r3, [pc, #240]	; (8004010 <find_volume+0x2ac>)
 8003f1e:	2200      	movs	r2, #0
 8003f20:	60da      	str	r2, [r3, #12]
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
 8003f22:	2000      	movs	r0, #0
 8003f24:	e06c      	b.n	8004000 <find_volume+0x29c>
	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 8003f26:	0743      	lsls	r3, r0, #29
 8003f28:	f53f af3e 	bmi.w	8003da8 <find_volume+0x44>
 8003f2c:	e74c      	b.n	8003dc8 <find_volume+0x64>
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8003f2e:	2002      	movs	r0, #2
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8003f30:	3601      	adds	r6, #1
 8003f32:	2e04      	cmp	r6, #4
 8003f34:	f47f af5e 	bne.w	8003df4 <find_volume+0x90>
 8003f38:	e03c      	b.n	8003fb4 <find_volume+0x250>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003f3a:	2803      	cmp	r0, #3
 8003f3c:	d03c      	beq.n	8003fb8 <find_volume+0x254>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 8003f3e:	b108      	cbz	r0, 8003f44 <find_volume+0x1e0>
 8003f40:	200d      	movs	r0, #13
 8003f42:	e05d      	b.n	8004000 <find_volume+0x29c>
#if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
 8003f44:	4605      	mov	r5, r0
 8003f46:	e761      	b.n	8003e0c <find_volume+0xa8>

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win.d8 + BPB_FSInfo) == 1
 8003f48:	f894 2031 	ldrb.w	r2, [r4, #49]	; 0x31
 8003f4c:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8003f50:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003f54:	2b01      	cmp	r3, #1
 8003f56:	d1cd      	bne.n	8003ef4 <find_volume+0x190>
		&& move_window(fs, bsect + 1) == FR_OK)
 8003f58:	1c69      	adds	r1, r5, #1
 8003f5a:	4620      	mov	r0, r4
 8003f5c:	f7ff feb9 	bl	8003cd2 <move_window>
 8003f60:	2800      	cmp	r0, #0
 8003f62:	d1c7      	bne.n	8003ef4 <find_volume+0x190>
	{
		fs->fsi_flag = 0;
		if (LD_WORD(fs->win.d8 + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8003f64:	f894 21ff 	ldrb.w	r2, [r4, #511]	; 0x1ff
 8003f68:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win.d8 + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
 8003f6c:	f884 0205 	strb.w	r0, [r4, #517]	; 0x205
		if (LD_WORD(fs->win.d8 + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8003f70:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003f74:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8003f78:	4293      	cmp	r3, r2
 8003f7a:	d1bb      	bne.n	8003ef4 <find_volume+0x190>
			&& LD_DWORD(fs->win.d8 + FSI_LeadSig) == 0x41615252
 8003f7c:	6822      	ldr	r2, [r4, #0]
 8003f7e:	4b25      	ldr	r3, [pc, #148]	; (8004014 <find_volume+0x2b0>)
 8003f80:	429a      	cmp	r2, r3
 8003f82:	d1b7      	bne.n	8003ef4 <find_volume+0x190>
			&& LD_DWORD(fs->win.d8 + FSI_StrucSig) == 0x61417272)
 8003f84:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
 8003f88:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
 8003f8c:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8003f90:	3320      	adds	r3, #32
 8003f92:	429a      	cmp	r2, r3
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win.d8 + FSI_Free_Count);
 8003f94:	bf01      	itttt	eq
 8003f96:	f8d4 31e8 	ldreq.w	r3, [r4, #488]	; 0x1e8
 8003f9a:	f8c4 3210 	streq.w	r3, [r4, #528]	; 0x210
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win.d8 + FSI_Nxt_Free);
 8003f9e:	f8d4 31ec 	ldreq.w	r3, [r4, #492]	; 0x1ec
 8003fa2:	f8c4 320c 	streq.w	r3, [r4, #524]	; 0x20c
 8003fa6:	e7a5      	b.n	8003ef4 <find_volume+0x190>


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 8003fa8:	200b      	movs	r0, #11
 8003faa:	e029      	b.n	8004000 <find_volume+0x29c>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8003fac:	200c      	movs	r0, #12
 8003fae:	e027      	b.n	8004000 <find_volume+0x29c>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8003fb0:	2003      	movs	r0, #3
 8003fb2:	e025      	b.n	8004000 <find_volume+0x29c>
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003fb4:	2803      	cmp	r0, #3
 8003fb6:	d1c3      	bne.n	8003f40 <find_volume+0x1dc>
 8003fb8:	2001      	movs	r0, #1
 8003fba:	e021      	b.n	8004000 <find_volume+0x29c>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
 8003fbc:	f04f 0801 	mov.w	r8, #1
 8003fc0:	e001      	b.n	8003fc6 <find_volume+0x262>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8003fc2:	f04f 0802 	mov.w	r8, #2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8003fc6:	f8c4 6218 	str.w	r6, [r4, #536]	; 0x218
	fs->volbase = bsect;								/* Volume start sector */
 8003fca:	f8c4 5220 	str.w	r5, [r4, #544]	; 0x220
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8003fce:	f8c4 2224 	str.w	r2, [r4, #548]	; 0x224
	fs->database = bsect + sysect;						/* Data start sector */
 8003fd2:	f8c4 722c 	str.w	r7, [r4, #556]	; 0x22c
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8003fd6:	f1be 0f00 	cmp.w	lr, #0
 8003fda:	d0b1      	beq.n	8003f40 <find_volume+0x1dc>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003fdc:	f1b8 0f02 	cmp.w	r8, #2
 8003fe0:	ea4f 0346 	mov.w	r3, r6, lsl #1
 8003fe4:	bf18      	it	ne
 8003fe6:	199b      	addne	r3, r3, r6
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8003fe8:	4462      	add	r2, ip
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003fea:	bf18      	it	ne
 8003fec:	f006 0601 	andne.w	r6, r6, #1
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win.d8 + BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8003ff0:	f8c4 2228 	str.w	r2, [r4, #552]	; 0x228
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003ff4:	bf1c      	itt	ne
 8003ff6:	eb06 0353 	addne.w	r3, r6, r3, lsr #1
 8003ffa:	f04f 0801 	movne.w	r8, #1
 8003ffe:	e767      	b.n	8003ed0 <find_volume+0x16c>
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
 8004000:	b004      	add	sp, #16
 8004002:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004006:	bf00      	nop
 8004008:	20000640 	.word	0x20000640
 800400c:	20000624 	.word	0x20000624
 8004010:	20000628 	.word	0x20000628
 8004014:	41615252 	.word	0x41615252

08004018 <clust2sect>:
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8004018:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 800401c:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800401e:	3b02      	subs	r3, #2
 8004020:	4299      	cmp	r1, r3
	return clst * fs->csize + fs->database;
 8004022:	bf3d      	ittte	cc
 8004024:	f890 3202 	ldrbcc.w	r3, [r0, #514]	; 0x202
 8004028:	f8d0 022c 	ldrcc.w	r0, [r0, #556]	; 0x22c
 800402c:	fb01 0003 	mlacc	r0, r1, r3, r0
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8004030:	2000      	movcs	r0, #0
	return clst * fs->csize + fs->database;
}
 8004032:	4770      	bx	lr

08004034 <get_fat>:
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004034:	2901      	cmp	r1, #1

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
 8004036:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004038:	4606      	mov	r6, r0
 800403a:	460d      	mov	r5, r1
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800403c:	d959      	bls.n	80040f2 <get_fat+0xbe>
 800403e:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 8004042:	4299      	cmp	r1, r3
 8004044:	d255      	bcs.n	80040f2 <get_fat+0xbe>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
 8004046:	f890 3200 	ldrb.w	r3, [r0, #512]	; 0x200
 800404a:	2b02      	cmp	r3, #2
 800404c:	d027      	beq.n	800409e <get_fat+0x6a>
 800404e:	2b03      	cmp	r3, #3
 8004050:	d036      	beq.n	80040c0 <get_fat+0x8c>
 8004052:	2b01      	cmp	r3, #1
 8004054:	d14d      	bne.n	80040f2 <get_fat+0xbe>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8004056:	eb01 0451 	add.w	r4, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800405a:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 800405e:	eb01 2154 	add.w	r1, r1, r4, lsr #9
 8004062:	f7ff fe36 	bl	8003cd2 <move_window>
 8004066:	b110      	cbz	r0, 800406e <get_fat+0x3a>

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 8004068:	f04f 30ff 	mov.w	r0, #4294967295
 800406c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win.d8[bc++ % SS(fs)];
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800406e:	f8d6 1224 	ldr.w	r1, [r6, #548]	; 0x224

		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win.d8[bc++ % SS(fs)];
 8004072:	1c67      	adds	r7, r4, #1
 8004074:	f3c4 0408 	ubfx	r4, r4, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8004078:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 800407c:	4630      	mov	r0, r6

		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win.d8[bc++ % SS(fs)];
 800407e:	5d34      	ldrb	r4, [r6, r4]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8004080:	f7ff fe27 	bl	8003cd2 <move_window>
 8004084:	2800      	cmp	r0, #0
 8004086:	d1ef      	bne.n	8004068 <get_fat+0x34>
			wc |= fs->win.d8[bc % SS(fs)] << 8;
 8004088:	f3c7 0708 	ubfx	r7, r7, #0, #9
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
 800408c:	07eb      	lsls	r3, r5, #31
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc = fs->win.d8[bc++ % SS(fs)];
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
			wc |= fs->win.d8[bc % SS(fs)] << 8;
 800408e:	5df0      	ldrb	r0, [r6, r7]
 8004090:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
 8004094:	bf4c      	ite	mi
 8004096:	0900      	lsrmi	r0, r0, #4
 8004098:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 800409c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800409e:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 80040a2:	eb01 2115 	add.w	r1, r1, r5, lsr #8
 80040a6:	f7ff fe14 	bl	8003cd2 <move_window>
 80040aa:	2800      	cmp	r0, #0
 80040ac:	d1dc      	bne.n	8004068 <get_fat+0x34>
			p = &fs->win.d8[clst * 2 % SS(fs)];
 80040ae:	006d      	lsls	r5, r5, #1
 80040b0:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			val = LD_WORD(p);
 80040b4:	1973      	adds	r3, r6, r5
 80040b6:	7858      	ldrb	r0, [r3, #1]
 80040b8:	5d73      	ldrb	r3, [r6, r5]
 80040ba:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80040be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			break;

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80040c0:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 80040c4:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
 80040c8:	f7ff fe03 	bl	8003cd2 <move_window>
 80040cc:	2800      	cmp	r0, #0
 80040ce:	d1cb      	bne.n	8004068 <get_fat+0x34>
			p = &fs->win.d8[clst * 4 % SS(fs)];
 80040d0:	00ad      	lsls	r5, r5, #2
 80040d2:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 80040d6:	1973      	adds	r3, r6, r5
			val = LD_DWORD(p) & 0x0FFFFFFF;
 80040d8:	7898      	ldrb	r0, [r3, #2]
 80040da:	78da      	ldrb	r2, [r3, #3]
 80040dc:	785b      	ldrb	r3, [r3, #1]
 80040de:	0400      	lsls	r0, r0, #16
 80040e0:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
 80040e4:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 80040e8:	5d73      	ldrb	r3, [r6, r5]
 80040ea:	4318      	orrs	r0, r3
 80040ec:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 80040f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			break;

		default:
			val = 1;	/* Internal error */
 80040f2:	2001      	movs	r0, #1
		}
	}

	return val;
}
 80040f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080040f6 <dir_sdi>:
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
 80040f6:	f8d0 2208 	ldr.w	r2, [r0, #520]	; 0x208
static
FRESULT dir_sdi (
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
 80040fa:	b570      	push	{r4, r5, r6, lr}
 80040fc:	4604      	mov	r4, r0
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 80040fe:	2a01      	cmp	r2, #1
static
FRESULT dir_sdi (
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
 8004100:	460d      	mov	r5, r1
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
 8004102:	f8a4 1206 	strh.w	r1, [r4, #518]	; 0x206
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 8004106:	d101      	bne.n	800410c <dir_sdi+0x16>
		return FR_INT_ERR;
 8004108:	2002      	movs	r0, #2
 800410a:	bd70      	pop	{r4, r5, r6, pc}
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 800410c:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 8004110:	f8d3 1218 	ldr.w	r1, [r3, #536]	; 0x218
 8004114:	428a      	cmp	r2, r1
 8004116:	d2f7      	bcs.n	8004108 <dir_sdi+0x12>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 8004118:	b972      	cbnz	r2, 8004138 <dir_sdi+0x42>
 800411a:	f893 1200 	ldrb.w	r1, [r3, #512]	; 0x200
 800411e:	2903      	cmp	r1, #3
 8004120:	d102      	bne.n	8004128 <dir_sdi+0x32>
		clst = dp->fs->dirbase;
 8004122:	f8d3 1228 	ldr.w	r1, [r3, #552]	; 0x228

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 8004126:	b931      	cbnz	r1, 8004136 <dir_sdi+0x40>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
 8004128:	f8b3 1208 	ldrh.w	r1, [r3, #520]	; 0x208
 800412c:	428d      	cmp	r5, r1
 800412e:	d2eb      	bcs.n	8004108 <dir_sdi+0x12>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
 8004130:	f8d3 0228 	ldr.w	r0, [r3, #552]	; 0x228
 8004134:	e019      	b.n	800416a <dir_sdi+0x74>
 8004136:	460a      	mov	r2, r1
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
 8004138:	f893 6202 	ldrb.w	r6, [r3, #514]	; 0x202
 800413c:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
 800413e:	42b5      	cmp	r5, r6
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 8004140:	4611      	mov	r1, r2
 8004142:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
 8004146:	d30e      	bcc.n	8004166 <dir_sdi+0x70>
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 8004148:	f7ff ff74 	bl	8004034 <get_fat>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800414c:	1c43      	adds	r3, r0, #1
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 800414e:	4602      	mov	r2, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8004150:	d01d      	beq.n	800418e <dir_sdi+0x98>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
 8004152:	2801      	cmp	r0, #1
 8004154:	d9d8      	bls.n	8004108 <dir_sdi+0x12>
 8004156:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 800415a:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 800415e:	4298      	cmp	r0, r3
 8004160:	d2d2      	bcs.n	8004108 <dir_sdi+0x12>
				return FR_INT_ERR;
			idx -= ic;
 8004162:	1bad      	subs	r5, r5, r6
 8004164:	e7eb      	b.n	800413e <dir_sdi+0x48>
		}
		sect = clust2sect(dp->fs, clst);
 8004166:	f7ff ff57 	bl	8004018 <clust2sect>
	}
	dp->clust = clst;	/* Current cluster# */
 800416a:	f8c4 220c 	str.w	r2, [r4, #524]	; 0x20c
	if (!sect) return FR_INT_ERR;
 800416e:	2800      	cmp	r0, #0
 8004170:	d0ca      	beq.n	8004108 <dir_sdi+0x12>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
 8004172:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
 8004176:	eb00 1015 	add.w	r0, r0, r5, lsr #4
	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
 800417a:	f005 050f 	and.w	r5, r5, #15
 800417e:	eb03 1545 	add.w	r5, r3, r5, lsl #5
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
 8004182:	f8c4 0210 	str.w	r0, [r4, #528]	; 0x210
	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
 8004186:	f8c4 5214 	str.w	r5, [r4, #532]	; 0x214

	return FR_OK;
 800418a:	2000      	movs	r0, #0
 800418c:	bd70      	pop	{r4, r5, r6, pc}
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800418e:	2001      	movs	r0, #1
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win.d8 + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */

	return FR_OK;
}
 8004190:	bd70      	pop	{r4, r5, r6, pc}

08004192 <put_fat>:
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004192:	2901      	cmp	r1, #1
FRESULT put_fat (
	FATFS* fs,	/* File system object */
	DWORD clst,	/* FAT index number (cluster number) to be changed */
	DWORD val	/* New value to be set to the entry */
)
{
 8004194:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004198:	4605      	mov	r5, r0
 800419a:	460c      	mov	r4, r1
 800419c:	4616      	mov	r6, r2
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800419e:	d96b      	bls.n	8004278 <put_fat+0xe6>
 80041a0:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 80041a4:	4299      	cmp	r1, r3
 80041a6:	d267      	bcs.n	8004278 <put_fat+0xe6>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
 80041a8:	f890 3200 	ldrb.w	r3, [r0, #512]	; 0x200
 80041ac:	2b02      	cmp	r3, #2
 80041ae:	d038      	beq.n	8004222 <put_fat+0x90>
 80041b0:	2b03      	cmp	r3, #3
 80041b2:	d045      	beq.n	8004240 <put_fat+0xae>
 80041b4:	2b01      	cmp	r3, #1
 80041b6:	d15f      	bne.n	8004278 <put_fat+0xe6>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 80041b8:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80041bc:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 80041c0:	eb01 2158 	add.w	r1, r1, r8, lsr #9
 80041c4:	f7ff fd85 	bl	8003cd2 <move_window>
			if (res != FR_OK) break;
 80041c8:	2800      	cmp	r0, #0
 80041ca:	d156      	bne.n	800427a <put_fat+0xe8>
			p = &fs->win.d8[bc++ % SS(fs)];
 80041cc:	f108 0701 	add.w	r7, r8, #1
 80041d0:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 80041d4:	f014 0401 	ands.w	r4, r4, #1
 80041d8:	bf1f      	itttt	ne
 80041da:	f815 3008 	ldrbne.w	r3, [r5, r8]
 80041de:	f003 030f 	andne.w	r3, r3, #15
 80041e2:	ea43 1306 	orrne.w	r3, r3, r6, lsl #4
 80041e6:	b2db      	uxtbne	r3, r3
 80041e8:	bf08      	it	eq
 80041ea:	b2f3      	uxtbeq	r3, r6
 80041ec:	f805 3008 	strb.w	r3, [r5, r8]
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80041f0:	f8d5 1224 	ldr.w	r1, [r5, #548]	; 0x224
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win.d8[bc++ % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			fs->wflag = 1;
 80041f4:	2301      	movs	r3, #1
 80041f6:	f885 3204 	strb.w	r3, [r5, #516]	; 0x204
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80041fa:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 80041fe:	4628      	mov	r0, r5
 8004200:	f7ff fd67 	bl	8003cd2 <move_window>
			if (res != FR_OK) break;
 8004204:	bbc8      	cbnz	r0, 800427a <put_fat+0xe8>
			p = &fs->win.d8[bc % SS(fs)];
 8004206:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800420a:	b114      	cbz	r4, 8004212 <put_fat+0x80>
 800420c:	f3c6 1207 	ubfx	r2, r6, #4, #8
 8004210:	e005      	b.n	800421e <put_fat+0x8c>
 8004212:	5dea      	ldrb	r2, [r5, r7]
 8004214:	f022 030f 	bic.w	r3, r2, #15
 8004218:	f3c6 2203 	ubfx	r2, r6, #8, #4
 800421c:	431a      	orrs	r2, r3
 800421e:	55ea      	strb	r2, [r5, r7]
 8004220:	e025      	b.n	800426e <put_fat+0xdc>
			fs->wflag = 1;
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8004222:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 8004226:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 800422a:	f7ff fd52 	bl	8003cd2 <move_window>
			if (res != FR_OK) break;
 800422e:	bb20      	cbnz	r0, 800427a <put_fat+0xe8>
			p = &fs->win.d8[clst * 2 % SS(fs)];
 8004230:	0064      	lsls	r4, r4, #1
 8004232:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
 8004236:	1232      	asrs	r2, r6, #8
 8004238:	552e      	strb	r6, [r5, r4]
 800423a:	442c      	add	r4, r5
 800423c:	7062      	strb	r2, [r4, #1]
 800423e:	e016      	b.n	800426e <put_fat+0xdc>
			fs->wflag = 1;
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8004240:	f8d0 1224 	ldr.w	r1, [r0, #548]	; 0x224
 8004244:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 8004248:	f7ff fd43 	bl	8003cd2 <move_window>
			if (res != FR_OK) break;
 800424c:	b9a8      	cbnz	r0, 800427a <put_fat+0xe8>
			p = &fs->win.d8[clst * 4 % SS(fs)];
 800424e:	00a4      	lsls	r4, r4, #2
 8004250:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
 8004254:	192b      	adds	r3, r5, r4
			val |= LD_DWORD(p) & 0xF0000000;
 8004256:	78da      	ldrb	r2, [r3, #3]
 8004258:	0612      	lsls	r2, r2, #24
 800425a:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 800425e:	4332      	orrs	r2, r6
			ST_DWORD(p, val);
 8004260:	1211      	asrs	r1, r2, #8
 8004262:	552a      	strb	r2, [r5, r4]
 8004264:	7059      	strb	r1, [r3, #1]
 8004266:	0c11      	lsrs	r1, r2, #16
 8004268:	0e12      	lsrs	r2, r2, #24
 800426a:	7099      	strb	r1, [r3, #2]
 800426c:	70da      	strb	r2, [r3, #3]
			fs->wflag = 1;
 800426e:	2301      	movs	r3, #1
 8004270:	f885 3204 	strb.w	r3, [r5, #516]	; 0x204
 8004274:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			break;

		default :
			res = FR_INT_ERR;
 8004278:	2002      	movs	r0, #2
		}
	}

	return res;
}
 800427a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800427e <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
 800427e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004280:	4605      	mov	r5, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
 8004282:	460f      	mov	r7, r1
 8004284:	b941      	cbnz	r1, 8004298 <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
 8004286:	f8d0 620c 	ldr.w	r6, [r0, #524]	; 0x20c
		if (!scl || scl >= fs->n_fatent) scl = 1;
 800428a:	b1a6      	cbz	r6, 80042b6 <create_chain+0x38>
 800428c:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 8004290:	429e      	cmp	r6, r3
 8004292:	bf28      	it	cs
 8004294:	2601      	movcs	r6, #1
 8004296:	e00f      	b.n	80042b8 <create_chain+0x3a>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
 8004298:	f7ff fecc 	bl	8004034 <get_fat>
		if (cs < 2) return 1;			/* Invalid value */
 800429c:	2801      	cmp	r0, #1
 800429e:	d946      	bls.n	800432e <create_chain+0xb0>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 80042a0:	1c44      	adds	r4, r0, #1
 80042a2:	d102      	bne.n	80042aa <create_chain+0x2c>
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
 80042a4:	f04f 30ff 	mov.w	r0, #4294967295
 80042a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* Invalid value */
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 80042aa:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 80042ae:	4298      	cmp	r0, r3
 80042b0:	d33e      	bcc.n	8004330 <create_chain+0xb2>
 80042b2:	463e      	mov	r6, r7
 80042b4:	e000      	b.n	80042b8 <create_chain+0x3a>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
 80042b6:	2601      	movs	r6, #1
 80042b8:	4634      	mov	r4, r6
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
 80042ba:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
 80042be:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
 80042c0:	429c      	cmp	r4, r3
 80042c2:	d304      	bcc.n	80042ce <create_chain+0x50>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
 80042c4:	2e01      	cmp	r6, #1
 80042c6:	d801      	bhi.n	80042cc <create_chain+0x4e>
 80042c8:	2000      	movs	r0, #0
 80042ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
 80042cc:	2402      	movs	r4, #2
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
 80042ce:	4621      	mov	r1, r4
 80042d0:	4628      	mov	r0, r5
 80042d2:	f7ff feaf 	bl	8004034 <get_fat>
		if (cs == 0) break;				/* Found a free cluster */
 80042d6:	b130      	cbz	r0, 80042e6 <create_chain+0x68>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 80042d8:	1c41      	adds	r1, r0, #1
 80042da:	d0e3      	beq.n	80042a4 <create_chain+0x26>
 80042dc:	2801      	cmp	r0, #1
 80042de:	d026      	beq.n	800432e <create_chain+0xb0>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
 80042e0:	42b4      	cmp	r4, r6
 80042e2:	d1ea      	bne.n	80042ba <create_chain+0x3c>
 80042e4:	e7f0      	b.n	80042c8 <create_chain+0x4a>
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
 80042e6:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 80042ea:	4621      	mov	r1, r4
 80042ec:	4628      	mov	r0, r5
 80042ee:	f7ff ff50 	bl	8004192 <put_fat>
	if (res == FR_OK && clst != 0) {
 80042f2:	b9d0      	cbnz	r0, 800432a <create_chain+0xac>
 80042f4:	b97f      	cbnz	r7, 8004316 <create_chain+0x98>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
 80042f6:	f8d5 3210 	ldr.w	r3, [r5, #528]	; 0x210
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
 80042fa:	f8c5 420c 	str.w	r4, [r5, #524]	; 0x20c
		if (fs->free_clust != 0xFFFFFFFF) {
 80042fe:	1c5a      	adds	r2, r3, #1
 8004300:	d011      	beq.n	8004326 <create_chain+0xa8>
			fs->free_clust--;
 8004302:	3b01      	subs	r3, #1
 8004304:	f8c5 3210 	str.w	r3, [r5, #528]	; 0x210
			fs->fsi_flag |= 1;
 8004308:	f895 3205 	ldrb.w	r3, [r5, #517]	; 0x205
 800430c:	f043 0301 	orr.w	r3, r3, #1
 8004310:	f885 3205 	strb.w	r3, [r5, #517]	; 0x205
 8004314:	e007      	b.n	8004326 <create_chain+0xa8>
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 8004316:	4622      	mov	r2, r4
 8004318:	4639      	mov	r1, r7
 800431a:	4628      	mov	r0, r5
 800431c:	f7ff ff39 	bl	8004192 <put_fat>
	}
	if (res == FR_OK) {
 8004320:	2800      	cmp	r0, #0
 8004322:	d0e8      	beq.n	80042f6 <create_chain+0x78>
 8004324:	e001      	b.n	800432a <create_chain+0xac>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
 8004326:	4620      	mov	r0, r4
 8004328:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 800432a:	2801      	cmp	r0, #1
 800432c:	d0ba      	beq.n	80042a4 <create_chain+0x26>
 800432e:	2001      	movs	r0, #1
	}

	return ncl;		/* Return new cluster number or error code */
}
 8004330:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004332 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8004332:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
 8004336:	f8b0 6206 	ldrh.w	r6, [r0, #518]	; 0x206
 800433a:	3601      	adds	r6, #1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 800433c:	b2b3      	uxth	r3, r6
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 800433e:	4604      	mov	r4, r0
 8004340:	460f      	mov	r7, r1
	UINT c;
#endif


	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 8004342:	b913      	cbnz	r3, 800434a <dir_next+0x18>
		return FR_NO_FILE;
 8004344:	2004      	movs	r0, #4
 8004346:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	UINT c;
#endif


	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 800434a:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800434e:	2b00      	cmp	r3, #0
 8004350:	d0f8      	beq.n	8004344 <dir_next+0x12>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
 8004352:	f016 080f 	ands.w	r8, r6, #15
 8004356:	d16f      	bne.n	8004438 <dir_next+0x106>
		dp->sect++;					/* Next sector */

		if (!dp->clust) {		/* Static table */
 8004358:	f8d0 120c 	ldr.w	r1, [r0, #524]	; 0x20c
	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */
 800435c:	3301      	adds	r3, #1
 800435e:	f8c0 3210 	str.w	r3, [r0, #528]	; 0x210
 8004362:	f8d0 0200 	ldr.w	r0, [r0, #512]	; 0x200

		if (!dp->clust) {		/* Static table */
 8004366:	b921      	cbnz	r1, 8004372 <dir_next+0x40>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
 8004368:	f8b0 3208 	ldrh.w	r3, [r0, #520]	; 0x208
 800436c:	429e      	cmp	r6, r3
 800436e:	d2e9      	bcs.n	8004344 <dir_next+0x12>
 8004370:	e062      	b.n	8004438 <dir_next+0x106>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
 8004372:	f890 3202 	ldrb.w	r3, [r0, #514]	; 0x202
 8004376:	3b01      	subs	r3, #1
 8004378:	ea13 1316 	ands.w	r3, r3, r6, lsr #4
 800437c:	d15c      	bne.n	8004438 <dir_next+0x106>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
 800437e:	f7ff fe59 	bl	8004034 <get_fat>
				if (clst <= 1) return FR_INT_ERR;
 8004382:	2801      	cmp	r0, #1
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
 8004384:	4605      	mov	r5, r0
				if (clst <= 1) return FR_INT_ERR;
 8004386:	d802      	bhi.n	800438e <dir_next+0x5c>
 8004388:	2002      	movs	r0, #2
 800438a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 800438e:	1c42      	adds	r2, r0, #1
 8004390:	d102      	bne.n	8004398 <dir_next+0x66>
 8004392:	2001      	movs	r0, #1
 8004394:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
 8004398:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 800439c:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 80043a0:	429d      	cmp	r5, r3
 80043a2:	d340      	bcc.n	8004426 <dir_next+0xf4>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
 80043a4:	2f00      	cmp	r7, #0
 80043a6:	d0cd      	beq.n	8004344 <dir_next+0x12>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
 80043a8:	f8d4 120c 	ldr.w	r1, [r4, #524]	; 0x20c
 80043ac:	f7ff ff67 	bl	800427e <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 80043b0:	4605      	mov	r5, r0
 80043b2:	2800      	cmp	r0, #0
 80043b4:	d04b      	beq.n	800444e <dir_next+0x11c>
					if (clst == 1) return FR_INT_ERR;
 80043b6:	2801      	cmp	r0, #1
 80043b8:	d0e6      	beq.n	8004388 <dir_next+0x56>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 80043ba:	1c43      	adds	r3, r0, #1
 80043bc:	d0e9      	beq.n	8004392 <dir_next+0x60>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 80043be:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 80043c2:	f7ff fc24 	bl	8003c0e <sync_window>
 80043c6:	4607      	mov	r7, r0
 80043c8:	2800      	cmp	r0, #0
 80043ca:	d1e2      	bne.n	8004392 <dir_next+0x60>
					mem_set(dp->fs->win.d8, 0, SS(dp->fs));		/* Clear window buffer */
 80043cc:	4601      	mov	r1, r0
 80043ce:	f44f 7200 	mov.w	r2, #512	; 0x200
 80043d2:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 80043d6:	f7ff fae9 	bl	80039ac <mem_set>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 80043da:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 80043de:	4629      	mov	r1, r5
 80043e0:	4610      	mov	r0, r2
 80043e2:	f7ff fe19 	bl	8004018 <clust2sect>
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dp->fs->wflag = 1;
 80043e6:	f04f 0901 	mov.w	r9, #1
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win.d8, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 80043ea:	f8c2 0230 	str.w	r0, [r2, #560]	; 0x230
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80043ee:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 80043f2:	f893 2202 	ldrb.w	r2, [r3, #514]	; 0x202
 80043f6:	4297      	cmp	r7, r2
 80043f8:	d210      	bcs.n	800441c <dir_next+0xea>
						dp->fs->wflag = 1;
 80043fa:	f883 9204 	strb.w	r9, [r3, #516]	; 0x204
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 80043fe:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 8004402:	f7ff fc04 	bl	8003c0e <sync_window>
 8004406:	2800      	cmp	r0, #0
 8004408:	d1c3      	bne.n	8004392 <dir_next+0x60>
						dp->fs->winsect++;
 800440a:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 800440e:	f8d2 3230 	ldr.w	r3, [r2, #560]	; 0x230
 8004412:	3301      	adds	r3, #1
 8004414:	f8c2 3230 	str.w	r3, [r2, #560]	; 0x230
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win.d8, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8004418:	3701      	adds	r7, #1
 800441a:	e7e8      	b.n	80043ee <dir_next+0xbc>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
 800441c:	f8d3 2230 	ldr.w	r2, [r3, #560]	; 0x230
 8004420:	1bd7      	subs	r7, r2, r7
 8004422:	f8c3 7230 	str.w	r7, [r3, #560]	; 0x230
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
 8004426:	f8c4 520c 	str.w	r5, [r4, #524]	; 0x20c
				dp->sect = clust2sect(dp->fs, clst);
 800442a:	4629      	mov	r1, r5
 800442c:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 8004430:	f7ff fdf2 	bl	8004018 <clust2sect>
 8004434:	f8c4 0210 	str.w	r0, [r4, #528]	; 0x210
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
	dp->dir = dp->fs->win.d8 + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
 8004438:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
				dp->sect = clust2sect(dp->fs, clst);
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
 800443c:	f8a4 6206 	strh.w	r6, [r4, #518]	; 0x206
	dp->dir = dp->fs->win.d8 + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
 8004440:	eb03 1348 	add.w	r3, r3, r8, lsl #5
 8004444:	f8c4 3214 	str.w	r3, [r4, #532]	; 0x214

	return FR_OK;
 8004448:	2000      	movs	r0, #0
 800444a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800444e:	2007      	movs	r0, #7

	dp->index = (WORD)i;	/* Current index */
	dp->dir = dp->fs->win.d8 + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */

	return FR_OK;
}
 8004450:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08004454 <remove_chain>:
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004454:	2901      	cmp	r1, #1
static
FRESULT remove_chain (
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8004456:	b570      	push	{r4, r5, r6, lr}
 8004458:	4604      	mov	r4, r0
 800445a:	460d      	mov	r5, r1
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800445c:	d801      	bhi.n	8004462 <remove_chain+0xe>
		res = FR_INT_ERR;
 800445e:	2002      	movs	r0, #2
 8004460:	bd70      	pop	{r4, r5, r6, pc}
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004462:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
 8004466:	4299      	cmp	r1, r3
 8004468:	d2f9      	bcs.n	800445e <remove_chain+0xa>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
 800446a:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 800446e:	429d      	cmp	r5, r3
 8004470:	d205      	bcs.n	800447e <remove_chain+0x2a>
			nxt = get_fat(fs, clst);			/* Get cluster status */
 8004472:	4629      	mov	r1, r5
 8004474:	4620      	mov	r0, r4
 8004476:	f7ff fddd 	bl	8004034 <get_fat>
			if (nxt == 0) break;				/* Empty cluster? */
 800447a:	4606      	mov	r6, r0
 800447c:	b908      	cbnz	r0, 8004482 <remove_chain+0x2e>
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
 800447e:	2000      	movs	r0, #0
 8004480:	bd70      	pop	{r4, r5, r6, pc}
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 8004482:	2801      	cmp	r0, #1
 8004484:	d0eb      	beq.n	800445e <remove_chain+0xa>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8004486:	1c41      	adds	r1, r0, #1
 8004488:	d014      	beq.n	80044b4 <remove_chain+0x60>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 800448a:	2200      	movs	r2, #0
 800448c:	4629      	mov	r1, r5
 800448e:	4620      	mov	r0, r4
 8004490:	f7ff fe7f 	bl	8004192 <put_fat>
			if (res != FR_OK) break;
 8004494:	b978      	cbnz	r0, 80044b6 <remove_chain+0x62>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
 8004496:	f8d4 3210 	ldr.w	r3, [r4, #528]	; 0x210
 800449a:	1c5a      	adds	r2, r3, #1
 800449c:	d008      	beq.n	80044b0 <remove_chain+0x5c>
				fs->free_clust++;
 800449e:	3301      	adds	r3, #1
 80044a0:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
				fs->fsi_flag |= 1;
 80044a4:	f894 3205 	ldrb.w	r3, [r4, #517]	; 0x205
 80044a8:	f043 0301 	orr.w	r3, r3, #1
 80044ac:	f884 3205 	strb.w	r3, [r4, #517]	; 0x205
static
FRESULT remove_chain (
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 80044b0:	4635      	mov	r5, r6
 80044b2:	e7da      	b.n	800446a <remove_chain+0x16>
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 80044b4:	2001      	movs	r0, #1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
 80044b6:	bd70      	pop	{r4, r5, r6, pc}

080044b8 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 80044b8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80044ba:	9001      	str	r0, [sp, #4]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 80044bc:	a804      	add	r0, sp, #16
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 80044be:	9100      	str	r1, [sp, #0]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 80044c0:	f840 1d04 	str.w	r1, [r0, #-4]!
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 80044c4:	4616      	mov	r6, r2
	int vol;
	FRESULT res;
	const TCHAR *rp = path;


	vol = get_ldnumber(&rp);
 80044c6:	f7ff fb3c 	bl	8003b42 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 80044ca:	1e05      	subs	r5, r0, #0
 80044cc:	db24      	blt.n	8004518 <f_mount+0x60>
	cfs = FatFs[vol];					/* Pointer to fs object */
 80044ce:	4b15      	ldr	r3, [pc, #84]	; (8004524 <f_mount+0x6c>)
 80044d0:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
 80044d4:	4619      	mov	r1, r3

	if (cfs) {
 80044d6:	b17c      	cbz	r4, 80044f8 <f_mount+0x40>
)
{
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
 80044d8:	4b13      	ldr	r3, [pc, #76]	; (8004528 <f_mount+0x70>)
 80044da:	681a      	ldr	r2, [r3, #0]
 80044dc:	4294      	cmp	r4, r2
 80044de:	bf04      	itt	eq
 80044e0:	2200      	moveq	r2, #0
 80044e2:	601a      	streq	r2, [r3, #0]
 80044e4:	68db      	ldr	r3, [r3, #12]
 80044e6:	429c      	cmp	r4, r3
 80044e8:	bf08      	it	eq
 80044ea:	4a0f      	ldreq	r2, [pc, #60]	; (8004528 <f_mount+0x70>)
 80044ec:	f04f 0300 	mov.w	r3, #0
 80044f0:	bf08      	it	eq
 80044f2:	60d3      	streq	r3, [r2, #12]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 80044f4:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
	}

	if (fs) {
 80044f8:	9801      	ldr	r0, [sp, #4]
 80044fa:	b110      	cbz	r0, 8004502 <f_mount+0x4a>
		fs->fs_type = 0;				/* Clear new fs object */
 80044fc:	2300      	movs	r3, #0
 80044fe:	f880 3200 	strb.w	r3, [r0, #512]	; 0x200
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 8004502:	f841 0025 	str.w	r0, [r1, r5, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8004506:	b150      	cbz	r0, 800451e <f_mount+0x66>
 8004508:	2e01      	cmp	r6, #1
 800450a:	d107      	bne.n	800451c <f_mount+0x64>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
 800450c:	2200      	movs	r2, #0
 800450e:	4669      	mov	r1, sp
 8004510:	a801      	add	r0, sp, #4
 8004512:	f7ff fc27 	bl	8003d64 <find_volume>
	LEAVE_FF(fs, res);
 8004516:	e002      	b.n	800451e <f_mount+0x66>
	FRESULT res;
	const TCHAR *rp = path;


	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
 8004518:	200b      	movs	r0, #11
 800451a:	e000      	b.n	800451e <f_mount+0x66>
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800451c:	2000      	movs	r0, #0

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 800451e:	b004      	add	sp, #16
 8004520:	bd70      	pop	{r4, r5, r6, pc}
 8004522:	bf00      	nop
 8004524:	20000640 	.word	0x20000640
 8004528:	20000628 	.word	0x20000628

0800452c <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 800452c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004530:	4698      	mov	r8, r3
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
 8004532:	2300      	movs	r3, #0
 8004534:	f8c8 3000 	str.w	r3, [r8]
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 8004538:	4604      	mov	r4, r0
 800453a:	460f      	mov	r7, r1
 800453c:	4616      	mov	r6, r2
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
 800453e:	f7ff fb18 	bl	8003b72 <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 8004542:	2800      	cmp	r0, #0
 8004544:	f040 80dd 	bne.w	8004702 <f_write+0x1d6>
	if (fp->err)							/* Check error */
 8004548:	f894 0207 	ldrb.w	r0, [r4, #519]	; 0x207
 800454c:	2800      	cmp	r0, #0
 800454e:	f040 80d8 	bne.w	8004702 <f_write+0x1d6>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8004552:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 8004556:	0799      	lsls	r1, r3, #30
 8004558:	f140 80d2 	bpl.w	8004700 <f_write+0x1d4>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
 800455c:	f8d4 3208 	ldr.w	r3, [r4, #520]	; 0x208
 8004560:	42f3      	cmn	r3, r6
 8004562:	d35d      	bcc.n	8004620 <f_write+0xf4>
		mem_cpy(&fp->buf.d8[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 8004564:	f8d4 3208 	ldr.w	r3, [r4, #520]	; 0x208
 8004568:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
 800456c:	4293      	cmp	r3, r2
 800456e:	f240 80be 	bls.w	80046ee <f_write+0x1c2>
 8004572:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
 8004576:	e0ba      	b.n	80046ee <f_write+0x1c2>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 8004578:	f8d4 1208 	ldr.w	r1, [r4, #520]	; 0x208
 800457c:	f3c1 0308 	ubfx	r3, r1, #0, #9
 8004580:	2b00      	cmp	r3, #0
 8004582:	f040 809f 	bne.w	80046c4 <f_write+0x198>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 8004586:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 800458a:	f890 9202 	ldrb.w	r9, [r0, #514]	; 0x202
 800458e:	f109 39ff 	add.w	r9, r9, #4294967295
 8004592:	ea09 2951 	and.w	r9, r9, r1, lsr #9
			if (!csect) {					/* On the cluster boundary? */
 8004596:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
 800459a:	d044      	beq.n	8004626 <f_write+0xfa>
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
 800459c:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 80045a0:	065b      	lsls	r3, r3, #25
 80045a2:	d467      	bmi.n	8004674 <f_write+0x148>
				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 80045a4:	f8d4 b200 	ldr.w	fp, [r4, #512]	; 0x200
 80045a8:	f8d4 1214 	ldr.w	r1, [r4, #532]	; 0x214
 80045ac:	4658      	mov	r0, fp
 80045ae:	f7ff fd33 	bl	8004018 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 80045b2:	2800      	cmp	r0, #0
 80045b4:	d04c      	beq.n	8004650 <f_write+0x124>
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 80045b6:	0a75      	lsrs	r5, r6, #9
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
 80045b8:	eb00 0a09 	add.w	sl, r0, r9
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 80045bc:	d06d      	beq.n	800469a <f_write+0x16e>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 80045be:	f89b 3202 	ldrb.w	r3, [fp, #514]	; 0x202
					cc = fp->fs->csize - csect;
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
 80045c2:	f89b 0201 	ldrb.w	r0, [fp, #513]	; 0x201
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 80045c6:	eb09 0205 	add.w	r2, r9, r5
 80045ca:	429a      	cmp	r2, r3
					cc = fp->fs->csize - csect;
 80045cc:	bf88      	it	hi
 80045ce:	ebc9 0503 	rsbhi	r5, r9, r3
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
 80045d2:	462b      	mov	r3, r5
 80045d4:	4652      	mov	r2, sl
 80045d6:	4639      	mov	r1, r7
 80045d8:	f7ff f9c2 	bl	8003960 <disk_write>
 80045dc:	2800      	cmp	r0, #0
 80045de:	d13b      	bne.n	8004658 <f_write+0x12c>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win.d8, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 80045e0:	f8d4 1218 	ldr.w	r1, [r4, #536]	; 0x218
 80045e4:	ebca 0101 	rsb	r1, sl, r1
 80045e8:	428d      	cmp	r5, r1
 80045ea:	d90c      	bls.n	8004606 <f_write+0xda>
					mem_cpy(fp->buf.d8, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 80045ec:	f44f 7200 	mov.w	r2, #512	; 0x200
 80045f0:	eb07 2141 	add.w	r1, r7, r1, lsl #9
 80045f4:	4620      	mov	r0, r4
 80045f6:	f7ff f9cf 	bl	8003998 <mem_cpy>
					fp->flag &= ~FA__DIRTY;
 80045fa:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 80045fe:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004602:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
 8004606:	026d      	lsls	r5, r5, #9
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 8004608:	f8d4 3208 	ldr.w	r3, [r4, #520]	; 0x208
 800460c:	442b      	add	r3, r5
 800460e:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
 8004612:	f8d8 3000 	ldr.w	r3, [r8]
 8004616:	442b      	add	r3, r5
 8004618:	442f      	add	r7, r5
 800461a:	f8c8 3000 	str.w	r3, [r8]
 800461e:	1b76      	subs	r6, r6, r5
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
 8004620:	2e00      	cmp	r6, #0
 8004622:	d1a9      	bne.n	8004578 <f_write+0x4c>
 8004624:	e79e      	b.n	8004564 <f_write+0x38>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
 8004626:	b919      	cbnz	r1, 8004630 <f_write+0x104>
					clst = fp->sclust;		/* Follow from the origin */
 8004628:	f8d4 1210 	ldr.w	r1, [r4, #528]	; 0x210
					if (clst == 0)			/* When no cluster is allocated, */
 800462c:	b971      	cbnz	r1, 800464c <f_write+0x120>
 800462e:	e008      	b.n	8004642 <f_write+0x116>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
 8004630:	f8d4 3224 	ldr.w	r3, [r4, #548]	; 0x224
 8004634:	b11b      	cbz	r3, 800463e <f_write+0x112>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 8004636:	4620      	mov	r0, r4
 8004638:	f7ff fa60 	bl	8003afc <clmt_clust>
 800463c:	e003      	b.n	8004646 <f_write+0x11a>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 800463e:	f8d4 1214 	ldr.w	r1, [r4, #532]	; 0x214
 8004642:	f7ff fe1c 	bl	800427e <create_chain>
 8004646:	4601      	mov	r1, r0
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8004648:	2800      	cmp	r0, #0
 800464a:	d08b      	beq.n	8004564 <f_write+0x38>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 800464c:	2901      	cmp	r1, #1
 800464e:	d101      	bne.n	8004654 <f_write+0x128>
 8004650:	2002      	movs	r0, #2
 8004652:	e002      	b.n	800465a <f_write+0x12e>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8004654:	1c4a      	adds	r2, r1, #1
 8004656:	d104      	bne.n	8004662 <f_write+0x136>
 8004658:	2001      	movs	r0, #1
 800465a:	f884 0207 	strb.w	r0, [r4, #519]	; 0x207
 800465e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				fp->clust = clst;			/* Update current cluster */
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
 8004662:	f8d4 3210 	ldr.w	r3, [r4, #528]	; 0x210
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;			/* Update current cluster */
 8004666:	f8c4 1214 	str.w	r1, [r4, #532]	; 0x214
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
 800466a:	2b00      	cmp	r3, #0
 800466c:	d196      	bne.n	800459c <f_write+0x70>
 800466e:	f8c4 1210 	str.w	r1, [r4, #528]	; 0x210
 8004672:	e793      	b.n	800459c <f_write+0x70>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
 8004674:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 8004678:	f8d4 2218 	ldr.w	r2, [r4, #536]	; 0x218
 800467c:	f890 0201 	ldrb.w	r0, [r0, #513]	; 0x201
 8004680:	2301      	movs	r3, #1
 8004682:	4621      	mov	r1, r4
 8004684:	f7ff f96c 	bl	8003960 <disk_write>
 8004688:	2800      	cmp	r0, #0
 800468a:	d1e5      	bne.n	8004658 <f_write+0x12c>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 800468c:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 8004690:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004694:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
 8004698:	e784      	b.n	80045a4 <f_write+0x78>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 800469a:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 800469e:	459a      	cmp	sl, r3
 80046a0:	d00e      	beq.n	80046c0 <f_write+0x194>
				if (fp->fptr < fp->fsize &&
 80046a2:	f8d4 2208 	ldr.w	r2, [r4, #520]	; 0x208
 80046a6:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 80046aa:	429a      	cmp	r2, r3
 80046ac:	d208      	bcs.n	80046c0 <f_write+0x194>
					disk_read(fp->fs->drv, fp->buf.d8, sect, 1) != RES_OK)
 80046ae:	2301      	movs	r3, #1
 80046b0:	4652      	mov	r2, sl
 80046b2:	4621      	mov	r1, r4
 80046b4:	f89b 0201 	ldrb.w	r0, [fp, #513]	; 0x201
 80046b8:	f7ff f944 	bl	8003944 <disk_read>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
 80046bc:	2800      	cmp	r0, #0
 80046be:	d1cb      	bne.n	8004658 <f_write+0x12c>
					disk_read(fp->fs->drv, fp->buf.d8, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
 80046c0:	f8c4 a218 	str.w	sl, [r4, #536]	; 0x218
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 80046c4:	f8d4 0208 	ldr.w	r0, [r4, #520]	; 0x208
 80046c8:	f3c0 0008 	ubfx	r0, r0, #0, #9
 80046cc:	f5c0 7500 	rsb	r5, r0, #512	; 0x200
 80046d0:	42b5      	cmp	r5, r6
 80046d2:	bf28      	it	cs
 80046d4:	4635      	movcs	r5, r6
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win.d8[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf.d8[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 80046d6:	462a      	mov	r2, r5
 80046d8:	4639      	mov	r1, r7
 80046da:	4420      	add	r0, r4
 80046dc:	f7ff f95c 	bl	8003998 <mem_cpy>
		fp->flag |= FA__DIRTY;
 80046e0:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 80046e4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80046e8:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
 80046ec:	e78c      	b.n	8004608 <f_write+0xdc>
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 80046ee:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 80046f2:	f043 0320 	orr.w	r3, r3, #32
 80046f6:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206

	LEAVE_FF(fp->fs, FR_OK);
 80046fa:	2000      	movs	r0, #0
 80046fc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->err)							/* Check error */
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
 8004700:	2007      	movs	r0, #7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
 8004702:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004706 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 8004706:	b570      	push	{r4, r5, r6, lr}
 8004708:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
 800470a:	f7ff fa32 	bl	8003b72 <validate>
	if (res == FR_OK) {
 800470e:	2800      	cmp	r0, #0
 8004710:	d15d      	bne.n	80047ce <f_sync+0xc8>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 8004712:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 8004716:	f003 0220 	and.w	r2, r3, #32
 800471a:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800471e:	2a00      	cmp	r2, #0
 8004720:	d055      	beq.n	80047ce <f_sync+0xc8>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
 8004722:	065b      	lsls	r3, r3, #25
 8004724:	d511      	bpl.n	800474a <f_sync+0x44>
				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
 8004726:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 800472a:	f8d4 2218 	ldr.w	r2, [r4, #536]	; 0x218
 800472e:	f890 0201 	ldrb.w	r0, [r0, #513]	; 0x201
 8004732:	2301      	movs	r3, #1
 8004734:	4621      	mov	r1, r4
 8004736:	f7ff f913 	bl	8003960 <disk_write>
 800473a:	2800      	cmp	r0, #0
 800473c:	d145      	bne.n	80047ca <f_sync+0xc4>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 800473e:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 8004742:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004746:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 800474a:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
 800474e:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
 8004752:	f7ff fabe 	bl	8003cd2 <move_window>
			if (res == FR_OK) {
 8004756:	4606      	mov	r6, r0
 8004758:	bbc8      	cbnz	r0, 80047ce <f_sync+0xc8>
				dir = fp->dir_ptr;
 800475a:	f8d4 5220 	ldr.w	r5, [r4, #544]	; 0x220
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 800475e:	7aeb      	ldrb	r3, [r5, #11]
 8004760:	f043 0320 	orr.w	r3, r3, #32
 8004764:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
 8004766:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 800476a:	772b      	strb	r3, [r5, #28]
 800476c:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 8004770:	121b      	asrs	r3, r3, #8
 8004772:	776b      	strb	r3, [r5, #29]
 8004774:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 8004778:	77ab      	strb	r3, [r5, #30]
 800477a:	f894 320f 	ldrb.w	r3, [r4, #527]	; 0x20f
 800477e:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
 8004780:	f8d4 3210 	ldr.w	r3, [r4, #528]	; 0x210
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8004784:	76ab      	strb	r3, [r5, #26]
 8004786:	121a      	asrs	r2, r3, #8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8004788:	0c1b      	lsrs	r3, r3, #16
 800478a:	752b      	strb	r3, [r5, #20]
 800478c:	121b      	asrs	r3, r3, #8
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 800478e:	76ea      	strb	r2, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8004790:	756b      	strb	r3, [r5, #21]
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = GET_FATTIME();							/* Update updated time */
 8004792:	f7fb fd95 	bl	80002c0 <get_fattime>
				ST_DWORD(dir + DIR_WrtTime, tm);
 8004796:	1203      	asrs	r3, r0, #8
 8004798:	75a8      	strb	r0, [r5, #22]
 800479a:	75eb      	strb	r3, [r5, #23]
 800479c:	0c03      	lsrs	r3, r0, #16
 800479e:	0e00      	lsrs	r0, r0, #24
 80047a0:	762b      	strb	r3, [r5, #24]
 80047a2:	7668      	strb	r0, [r5, #25]
				ST_WORD(dir + DIR_LstAccDate, 0);
 80047a4:	74ae      	strb	r6, [r5, #18]
 80047a6:	74ee      	strb	r6, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
 80047a8:	f894 3206 	ldrb.w	r3, [r4, #518]	; 0x206
 80047ac:	f023 0320 	bic.w	r3, r3, #32
 80047b0:	f884 3206 	strb.w	r3, [r4, #518]	; 0x206
				fp->fs->wflag = 1;
 80047b4:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 80047b8:	2201      	movs	r2, #1
 80047ba:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
				res = sync_fs(fp->fs);
 80047be:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 80047c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				tm = GET_FATTIME();							/* Update updated time */
				ST_DWORD(dir + DIR_WrtTime, tm);
				ST_WORD(dir + DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
				fp->fs->wflag = 1;
				res = sync_fs(fp->fs);
 80047c6:	f7ff ba29 	b.w	8003c1c <sync_fs>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf.d8, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 80047ca:	2001      	movs	r0, #1
 80047cc:	bd70      	pop	{r4, r5, r6, pc}
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 80047ce:	bd70      	pop	{r4, r5, r6, pc}

080047d0 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 80047d0:	b510      	push	{r4, lr}
 80047d2:	4604      	mov	r4, r0
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 80047d4:	f7ff ff97 	bl	8004706 <f_sync>
	if (res == FR_OK)
 80047d8:	b950      	cbnz	r0, 80047f0 <f_close+0x20>
#endif
	{
		res = validate(fp);				/* Lock volume */
 80047da:	4620      	mov	r0, r4
 80047dc:	f7ff f9c9 	bl	8003b72 <validate>
		if (res == FR_OK) {
 80047e0:	b930      	cbnz	r0, 80047f0 <f_close+0x20>
#if _FS_REENTRANT
			FATFS *fs = fp->fs;
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
 80047e2:	f8d4 0228 	ldr.w	r0, [r4, #552]	; 0x228
 80047e6:	f7ff f96d 	bl	8003ac4 <dec_lock>
			if (res == FR_OK)
 80047ea:	b908      	cbnz	r0, 80047f0 <f_close+0x20>
#endif
				fp->fs = 0;				/* Invalidate file object */
 80047ec:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 80047f0:	bd10      	pop	{r4, pc}
	...

080047f4 <ff_convert>:
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 80047f4:	287f      	cmp	r0, #127	; 0x7f

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	chr,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
)
{
 80047f6:	b510      	push	{r4, lr}
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 80047f8:	d916      	bls.n	8004828 <ff_convert+0x34>
		c = chr;

	} else {
		if (dir) {		/* OEMCP to Unicode */
 80047fa:	b969      	cbnz	r1, 8004818 <ff_convert+0x24>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
				if (chr == Tbl[c]) break;
 80047fc:	4a0b      	ldr	r2, [pc, #44]	; (800482c <ff_convert+0x38>)
 80047fe:	f832 4011 	ldrh.w	r4, [r2, r1, lsl #1]
 8004802:	4284      	cmp	r4, r0
 8004804:	b28b      	uxth	r3, r1
 8004806:	d003      	beq.n	8004810 <ff_convert+0x1c>
 8004808:	3101      	adds	r1, #1
	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
 800480a:	2980      	cmp	r1, #128	; 0x80
 800480c:	d1f7      	bne.n	80047fe <ff_convert+0xa>
 800480e:	460b      	mov	r3, r1
				if (chr == Tbl[c]) break;
			}
			c = (c + 0x80) & 0xFF;
 8004810:	f103 0080 	add.w	r0, r3, #128	; 0x80
 8004814:	b2c0      	uxtb	r0, r0
 8004816:	bd10      	pop	{r4, pc}
	if (chr < 0x80) {	/* ASCII */
		c = chr;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8004818:	28ff      	cmp	r0, #255	; 0xff
 800481a:	d804      	bhi.n	8004826 <ff_convert+0x32>
 800481c:	4b03      	ldr	r3, [pc, #12]	; (800482c <ff_convert+0x38>)
 800481e:	3880      	subs	r0, #128	; 0x80
 8004820:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 8004824:	bd10      	pop	{r4, pc}
 8004826:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
 8004828:	bd10      	pop	{r4, pc}
 800482a:	bf00      	nop
 800482c:	080071b4 	.word	0x080071b4

08004830 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
 8004830:	4906      	ldr	r1, [pc, #24]	; (800484c <ff_wtoupper+0x1c>)
 8004832:	2300      	movs	r3, #0
 8004834:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
 8004838:	b132      	cbz	r2, 8004848 <ff_wtoupper+0x18>
 800483a:	4282      	cmp	r2, r0
 800483c:	d001      	beq.n	8004842 <ff_wtoupper+0x12>
 800483e:	3301      	adds	r3, #1
 8004840:	e7f8      	b.n	8004834 <ff_wtoupper+0x4>

	return tbl_lower[i] ? tbl_upper[i] : chr;
 8004842:	4a03      	ldr	r2, [pc, #12]	; (8004850 <ff_wtoupper+0x20>)
 8004844:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
}
 8004848:	4770      	bx	lr
 800484a:	bf00      	nop
 800484c:	08007566 	.word	0x08007566
 8004850:	080072f8 	.word	0x080072f8

08004854 <dir_find.part.9>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
 8004854:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	res = dir_sdi(dp, 0);			/* Rewind directory object */
	if (res != FR_OK) return res;

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8004858:	f64f 79ff 	movw	r9, #65535	; 0xffff
 800485c:	f04f 08ff 	mov.w	r8, #255	; 0xff
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
 8004860:	b085      	sub	sp, #20
 8004862:	4606      	mov	r6, r0

	res = dir_sdi(dp, 0);			/* Rewind directory object */
	if (res != FR_OK) return res;

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 8004864:	f8a0 9224 	strh.w	r9, [r0, #548]	; 0x224
 8004868:	4644      	mov	r4, r8
#endif
	do {
		res = move_window(dp->fs, dp->sect);
 800486a:	f8d6 1210 	ldr.w	r1, [r6, #528]	; 0x210
 800486e:	f8d6 0200 	ldr.w	r0, [r6, #512]	; 0x200
 8004872:	f7ff fa2e 	bl	8003cd2 <move_window>
		if (res != FR_OK) break;
 8004876:	2800      	cmp	r0, #0
 8004878:	f040 8087 	bne.w	800498a <dir_find.part.9+0x136>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
 800487c:	f8d6 5214 	ldr.w	r5, [r6, #532]	; 0x214
		c = dir[DIR_Name];
 8004880:	782a      	ldrb	r2, [r5, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8004882:	2a00      	cmp	r2, #0
 8004884:	d078      	beq.n	8004978 <dir_find.part.9+0x124>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8004886:	2ae5      	cmp	r2, #229	; 0xe5
 8004888:	d069      	beq.n	800495e <dir_find.part.9+0x10a>
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 800488a:	7ae9      	ldrb	r1, [r5, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800488c:	070f      	lsls	r7, r1, #28
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
 800488e:	f001 033f 	and.w	r3, r1, #63	; 0x3f
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8004892:	d502      	bpl.n	800489a <dir_find.part.9+0x46>
 8004894:	2b0f      	cmp	r3, #15
 8004896:	d162      	bne.n	800495e <dir_find.part.9+0x10a>
 8004898:	e001      	b.n	800489e <dir_find.part.9+0x4a>
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 800489a:	2b0f      	cmp	r3, #15
 800489c:	d14a      	bne.n	8004934 <dir_find.part.9+0xe0>
				if (dp->lfn) {
 800489e:	f8d6 b220 	ldr.w	fp, [r6, #544]	; 0x220
 80048a2:	f1bb 0f00 	cmp.w	fp, #0
 80048a6:	d05f      	beq.n	8004968 <dir_find.part.9+0x114>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 80048a8:	0650      	lsls	r0, r2, #25
 80048aa:	d507      	bpl.n	80048bc <dir_find.part.9+0x68>
						sum = dir[LDIR_Chksum];
						c &= ~LLEF; ord = c;	/* LFN start order */
 80048ac:	f002 04bf 	and.w	r4, r2, #191	; 0xbf
						dp->lfn_idx = dp->index;	/* Start index of LFN */
 80048b0:	f8b6 2206 	ldrh.w	r2, [r6, #518]	; 0x206
			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dp->lfn) {
					if (c & LLEF) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
 80048b4:	7b69      	ldrb	r1, [r5, #13]
						c &= ~LLEF; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
 80048b6:	f8a6 2224 	strh.w	r2, [r6, #548]	; 0x224
 80048ba:	e002      	b.n	80048c2 <dir_find.part.9+0x6e>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 80048bc:	42a2      	cmp	r2, r4
 80048be:	d152      	bne.n	8004966 <dir_find.part.9+0x112>
 80048c0:	4641      	mov	r1, r8
 80048c2:	f895 800d 	ldrb.w	r8, [r5, #13]
 80048c6:	4588      	cmp	r8, r1
 80048c8:	d14c      	bne.n	8004964 <dir_find.part.9+0x110>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Get offset in the LFN buffer */
 80048ca:	782b      	ldrb	r3, [r5, #0]
 80048cc:	9301      	str	r3, [sp, #4]
 80048ce:	f023 0740 	bic.w	r7, r3, #64	; 0x40
 80048d2:	1e7a      	subs	r2, r7, #1
 80048d4:	270d      	movs	r7, #13
 80048d6:	4357      	muls	r7, r2
	s = 0; wc = 1;
 80048d8:	2001      	movs	r0, #1
 80048da:	f04f 0a00 	mov.w	sl, #0
	do {
		uc = LD_WORD(dir + LfnOfs[s]);	/* Pick an LFN character from the entry */
 80048de:	4b2c      	ldr	r3, [pc, #176]	; (8004990 <dir_find.part.9+0x13c>)
 80048e0:	f81a 1003 	ldrb.w	r1, [sl, r3]
 80048e4:	186a      	adds	r2, r5, r1
 80048e6:	f892 e001 	ldrb.w	lr, [r2, #1]
 80048ea:	5c6a      	ldrb	r2, [r5, r1]
 80048ec:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
		if (wc) {	/* Last character has not been processed */
 80048f0:	b188      	cbz	r0, 8004916 <dir_find.part.9+0xc2>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
 80048f2:	4610      	mov	r0, r2
 80048f4:	f7ff ff9c 	bl	8004830 <ff_wtoupper>
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 80048f8:	2ffe      	cmp	r7, #254	; 0xfe
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir + LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last character has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
 80048fa:	9003      	str	r0, [sp, #12]
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 80048fc:	d833      	bhi.n	8004966 <dir_find.part.9+0x112>
 80048fe:	1c7a      	adds	r2, r7, #1
 8004900:	f83b 0017 	ldrh.w	r0, [fp, r7, lsl #1]
 8004904:	9202      	str	r2, [sp, #8]
 8004906:	f7ff ff93 	bl	8004830 <ff_wtoupper>
 800490a:	9903      	ldr	r1, [sp, #12]
 800490c:	4281      	cmp	r1, r0
 800490e:	d12a      	bne.n	8004966 <dir_find.part.9+0x112>
 8004910:	9a02      	ldr	r2, [sp, #8]
 8004912:	4617      	mov	r7, r2
 8004914:	e001      	b.n	800491a <dir_find.part.9+0xc6>
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
 8004916:	454a      	cmp	r2, r9
 8004918:	d125      	bne.n	8004966 <dir_find.part.9+0x112>
		}
	} while (++s < 13);				/* Repeat until all characters in the entry are checked */
 800491a:	f10a 0a01 	add.w	sl, sl, #1
 800491e:	f1ba 0f0d 	cmp.w	sl, #13
 8004922:	d1dc      	bne.n	80048de <dir_find.part.9+0x8a>

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
 8004924:	9b01      	ldr	r3, [sp, #4]
 8004926:	0659      	lsls	r1, r3, #25
 8004928:	d52c      	bpl.n	8004984 <dir_find.part.9+0x130>
 800492a:	b358      	cbz	r0, 8004984 <dir_find.part.9+0x130>
 800492c:	f83b 3017 	ldrh.w	r3, [fp, r7, lsl #1]
 8004930:	b343      	cbz	r3, 8004984 <dir_find.part.9+0x130>
 8004932:	e018      	b.n	8004966 <dir_find.part.9+0x112>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 8004934:	b924      	cbnz	r4, 8004940 <dir_find.part.9+0xec>
 8004936:	4628      	mov	r0, r5
 8004938:	f7ff f8f4 	bl	8003b24 <sum_sfn>
 800493c:	4540      	cmp	r0, r8
 800493e:	d01d      	beq.n	800497c <dir_find.part.9+0x128>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
 8004940:	f8d6 3218 	ldr.w	r3, [r6, #536]	; 0x218
 8004944:	7ada      	ldrb	r2, [r3, #11]
 8004946:	07d2      	lsls	r2, r2, #31
 8004948:	d409      	bmi.n	800495e <dir_find.part.9+0x10a>
 800494a:	f105 000b 	add.w	r0, r5, #11
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 800494e:	4285      	cmp	r5, r0
 8004950:	d016      	beq.n	8004980 <dir_find.part.9+0x12c>
 8004952:	f815 1b01 	ldrb.w	r1, [r5], #1
 8004956:	f813 2b01 	ldrb.w	r2, [r3], #1
 800495a:	4291      	cmp	r1, r2
 800495c:	d0f7      	beq.n	800494e <dir_find.part.9+0xfa>
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 800495e:	f8a6 9224 	strh.w	r9, [r6, #548]	; 0x224
 8004962:	e000      	b.n	8004966 <dir_find.part.9+0x112>
						sum = dir[LDIR_Chksum];
						c &= ~LLEF; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8004964:	4688      	mov	r8, r1
 8004966:	24ff      	movs	r4, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
 8004968:	2100      	movs	r1, #0
 800496a:	4630      	mov	r0, r6
 800496c:	f7ff fce1 	bl	8004332 <dir_next>
	} while (res == FR_OK);
 8004970:	2800      	cmp	r0, #0
 8004972:	f43f af7a 	beq.w	800486a <dir_find.part.9+0x16>
 8004976:	e008      	b.n	800498a <dir_find.part.9+0x136>
	do {
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8004978:	2004      	movs	r0, #4
 800497a:	e006      	b.n	800498a <dir_find.part.9+0x136>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 800497c:	4620      	mov	r0, r4
 800497e:	e004      	b.n	800498a <dir_find.part.9+0x136>
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8004980:	2000      	movs	r0, #0
 8004982:	e002      	b.n	800498a <dir_find.part.9+0x136>
						sum = dir[LDIR_Chksum];
						c &= ~LLEF; ord = c;	/* LFN start order */
						dp->lfn_idx = dp->index;	/* Start index of LFN */
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
 8004984:	3c01      	subs	r4, #1
 8004986:	b2e4      	uxtb	r4, r4
 8004988:	e7ee      	b.n	8004968 <dir_find.part.9+0x114>
#endif
		res = dir_next(dp, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
 800498a:	b005      	add	sp, #20
 800498c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004990:	080074d8 	.word	0x080074d8

08004994 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 8004994:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	UINT n, nent;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
 8004998:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
 800499c:	f8d0 6220 	ldr.w	r6, [r0, #544]	; 0x220
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 80049a0:	b087      	sub	sp, #28
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
	mem_cpy(sn, fn, 12);
 80049a2:	220c      	movs	r2, #12
 80049a4:	4621      	mov	r1, r4
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 80049a6:	4605      	mov	r5, r0
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dp->fn; lfn = dp->lfn;
	mem_cpy(sn, fn, 12);
 80049a8:	eb0d 0002 	add.w	r0, sp, r2
 80049ac:	f7fe fff4 	bl	8003998 <mem_cpy>

	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
 80049b0:	f89d 2017 	ldrb.w	r2, [sp, #23]
 80049b4:	f002 0120 	and.w	r1, r2, #32
 80049b8:	f001 03ff 	and.w	r3, r1, #255	; 0xff
 80049bc:	2900      	cmp	r1, #0
 80049be:	f040 80f4 	bne.w	8004baa <dir_register+0x216>
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 80049c2:	07d2      	lsls	r2, r2, #31
 80049c4:	d563      	bpl.n	8004a8e <dir_register+0xfa>
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
 80049c6:	72e3      	strb	r3, [r4, #11]
		for (n = 1; n < 100; n++) {
 80049c8:	2701      	movs	r7, #1

	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
 80049ca:	f8c5 3220 	str.w	r3, [r5, #544]	; 0x220
	UINT i, j;
	WCHAR wc;
	DWORD sr;


	mem_cpy(dst, src, 11);
 80049ce:	220b      	movs	r2, #11
 80049d0:	a903      	add	r1, sp, #12
 80049d2:	4620      	mov	r0, r4
 80049d4:	f7fe ffe0 	bl	8003998 <mem_cpy>

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 80049d8:	2f05      	cmp	r7, #5
 80049da:	d801      	bhi.n	80049e0 <dir_register+0x4c>
 80049dc:	463b      	mov	r3, r7
 80049de:	e015      	b.n	8004a0c <dir_register+0x78>
 80049e0:	1eb0      	subs	r0, r6, #2
 80049e2:	463b      	mov	r3, r7
		sr = seq;
		while (*lfn) {	/* Create a CRC */
 80049e4:	f830 2f02 	ldrh.w	r2, [r0, #2]!
 80049e8:	b182      	cbz	r2, 8004a0c <dir_register+0x78>
 80049ea:	2110      	movs	r1, #16
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
				sr = (sr << 1) + (wc & 1);
 80049ec:	f002 0e01 	and.w	lr, r2, #1
 80049f0:	eb0e 0343 	add.w	r3, lr, r3, lsl #1
				wc >>= 1;
				if (sr & 0x10000) sr ^= 0x11021;
 80049f4:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80049f8:	bf1c      	itt	ne
 80049fa:	f483 3388 	eorne.w	r3, r3, #69632	; 0x11000
 80049fe:	f083 0321 	eorne.w	r3, r3, #33	; 0x21

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
		sr = seq;
		while (*lfn) {	/* Create a CRC */
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
 8004a02:	3901      	subs	r1, #1
				sr = (sr << 1) + (wc & 1);
				wc >>= 1;
 8004a04:	ea4f 0252 	mov.w	r2, r2, lsr #1

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
		sr = seq;
		while (*lfn) {	/* Create a CRC */
			wc = *lfn++;
			for (i = 0; i < 16; i++) {
 8004a08:	d1f0      	bne.n	80049ec <dir_register+0x58>
 8004a0a:	e7eb      	b.n	80049e4 <dir_register+0x50>
	DWORD sr;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 8004a0c:	2207      	movs	r2, #7
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
 8004a0e:	f003 000f 	and.w	r0, r3, #15
 8004a12:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
 8004a16:	2939      	cmp	r1, #57	; 0x39
 8004a18:	bf88      	it	hi
 8004a1a:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
		ns[i--] = c;
 8004a1e:	3a01      	subs	r2, #1
 8004a20:	a801      	add	r0, sp, #4
 8004a22:	4410      	add	r0, r2
		seq /= 16;
	} while (seq);
 8004a24:	091b      	lsrs	r3, r3, #4
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
 8004a26:	7041      	strb	r1, [r0, #1]
		seq /= 16;
	} while (seq);
 8004a28:	d1f1      	bne.n	8004a0e <dir_register+0x7a>
	ns[i] = '~';
 8004a2a:	a906      	add	r1, sp, #24
 8004a2c:	4411      	add	r1, r2
 8004a2e:	207e      	movs	r0, #126	; 0x7e
 8004a30:	f801 0c14 	strb.w	r0, [r1, #-20]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 8004a34:	429a      	cmp	r2, r3
 8004a36:	d004      	beq.n	8004a42 <dir_register+0xae>
 8004a38:	5ce1      	ldrb	r1, [r4, r3]
 8004a3a:	2920      	cmp	r1, #32
 8004a3c:	d001      	beq.n	8004a42 <dir_register+0xae>
 8004a3e:	3301      	adds	r3, #1
 8004a40:	e7f8      	b.n	8004a34 <dir_register+0xa0>
 8004a42:	4423      	add	r3, r4
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 8004a44:	2a07      	cmp	r2, #7
 8004a46:	bf9b      	ittet	ls
 8004a48:	a906      	addls	r1, sp, #24
 8004a4a:	1889      	addls	r1, r1, r2
 8004a4c:	2120      	movhi	r1, #32
 8004a4e:	f811 1c14 	ldrbls.w	r1, [r1, #-20]
 8004a52:	f803 1b01 	strb.w	r1, [r3], #1
	} while (j < 8);
 8004a56:	eba3 0104 	sub.w	r1, r3, r4
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 8004a5a:	bf98      	it	ls
 8004a5c:	3201      	addls	r2, #1
	} while (j < 8);
 8004a5e:	2907      	cmp	r1, #7
 8004a60:	d9f0      	bls.n	8004a44 <dir_register+0xb0>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8004a62:	2100      	movs	r1, #0
 8004a64:	4628      	mov	r0, r5
 8004a66:	f7ff fb46 	bl	80040f6 <dir_sdi>
	if (res != FR_OK) return res;
 8004a6a:	b940      	cbnz	r0, 8004a7e <dir_register+0xea>
 8004a6c:	4628      	mov	r0, r5
 8004a6e:	f7ff fef1 	bl	8004854 <dir_find.part.9>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
 8004a72:	b920      	cbnz	r0, 8004a7e <dir_register+0xea>
	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
 8004a74:	3701      	adds	r7, #1
 8004a76:	2f64      	cmp	r7, #100	; 0x64
 8004a78:	d1a9      	bne.n	80049ce <dir_register+0x3a>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 8004a7a:	2007      	movs	r0, #7
 8004a7c:	e0be      	b.n	8004bfc <dir_register+0x268>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 8004a7e:	2804      	cmp	r0, #4
 8004a80:	f040 80bc 	bne.w	8004bfc <dir_register+0x268>
		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
 8004a84:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8004a88:	72e3      	strb	r3, [r4, #11]
 8004a8a:	f8c5 6220 	str.w	r6, [r5, #544]	; 0x220
	}

	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
 8004a8e:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8004a92:	079b      	lsls	r3, r3, #30
 8004a94:	d50a      	bpl.n	8004aac <dir_register+0x118>
 8004a96:	2400      	movs	r4, #0
		for (n = 0; lfn[n]; n++) ;
 8004a98:	f836 3014 	ldrh.w	r3, [r6, r4, lsl #1]
 8004a9c:	b10b      	cbz	r3, 8004aa2 <dir_register+0x10e>
 8004a9e:	3401      	adds	r4, #1
 8004aa0:	e7fa      	b.n	8004a98 <dir_register+0x104>
		nent = (n + 25) / 13;
 8004aa2:	3419      	adds	r4, #25
 8004aa4:	230d      	movs	r3, #13
 8004aa6:	fbb4 f4f3 	udiv	r4, r4, r3
 8004aaa:	e000      	b.n	8004aae <dir_register+0x11a>
	} else {						/* Otherwise allocate an entry for an SFN  */
		nent = 1;
 8004aac:	2401      	movs	r4, #1
{
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
 8004aae:	2100      	movs	r1, #0
 8004ab0:	4628      	mov	r0, r5
 8004ab2:	f7ff fb20 	bl	80040f6 <dir_sdi>
	if (res == FR_OK) {
 8004ab6:	2800      	cmp	r0, #0
 8004ab8:	f040 809d 	bne.w	8004bf6 <dir_register+0x262>
 8004abc:	4606      	mov	r6, r0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
 8004abe:	f8d5 1210 	ldr.w	r1, [r5, #528]	; 0x210
 8004ac2:	f8d5 0200 	ldr.w	r0, [r5, #512]	; 0x200
 8004ac6:	f7ff f904 	bl	8003cd2 <move_window>
			if (res != FR_OK) break;
 8004aca:	2800      	cmp	r0, #0
 8004acc:	f040 8093 	bne.w	8004bf6 <dir_register+0x262>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
 8004ad0:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 8004ad4:	781b      	ldrb	r3, [r3, #0]
 8004ad6:	2be5      	cmp	r3, #229	; 0xe5
 8004ad8:	d000      	beq.n	8004adc <dir_register+0x148>
 8004ada:	b92b      	cbnz	r3, 8004ae8 <dir_register+0x154>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 8004adc:	3601      	adds	r6, #1
 8004ade:	42b4      	cmp	r4, r6
 8004ae0:	d103      	bne.n	8004aea <dir_register+0x156>
	} else {						/* Otherwise allocate an entry for an SFN  */
		nent = 1;
	}
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 8004ae2:	3c01      	subs	r4, #1
 8004ae4:	d063      	beq.n	8004bae <dir_register+0x21a>
 8004ae6:	e007      	b.n	8004af8 <dir_register+0x164>
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
 8004ae8:	4606      	mov	r6, r0
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
 8004aea:	2101      	movs	r1, #1
 8004aec:	4628      	mov	r0, r5
 8004aee:	f7ff fc20 	bl	8004332 <dir_next>
		} while (res == FR_OK);
 8004af2:	2800      	cmp	r0, #0
 8004af4:	d0e3      	beq.n	8004abe <dir_register+0x12a>
 8004af6:	e07e      	b.n	8004bf6 <dir_register+0x262>
		nent = 1;
	}
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
		res = dir_sdi(dp, dp->index - nent);
 8004af8:	f8b5 1206 	ldrh.w	r1, [r5, #518]	; 0x206
 8004afc:	4628      	mov	r0, r5
 8004afe:	1b09      	subs	r1, r1, r4
 8004b00:	f7ff faf9 	bl	80040f6 <dir_sdi>
		if (res == FR_OK) {
 8004b04:	2800      	cmp	r0, #0
 8004b06:	d179      	bne.n	8004bfc <dir_register+0x268>
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
 8004b08:	f8d5 0218 	ldr.w	r0, [r5, #536]	; 0x218

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004b0c:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 8004c04 <dir_register+0x270>
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
		res = dir_sdi(dp, dp->index - nent);
		if (res == FR_OK) {
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
 8004b10:	f7ff f808 	bl	8003b24 <sum_sfn>
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 8004b14:	270f      	movs	r7, #15
	res = dir_alloc(dp, nent);		/* Allocate entries */

	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
		res = dir_sdi(dp, dp->index - nent);
		if (res == FR_OK) {
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
 8004b16:	4606      	mov	r6, r0
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
 8004b18:	f8d5 1210 	ldr.w	r1, [r5, #528]	; 0x210
 8004b1c:	f8d5 0200 	ldr.w	r0, [r5, #512]	; 0x200
 8004b20:	f7ff f8d7 	bl	8003cd2 <move_window>
 8004b24:	4603      	mov	r3, r0
				if (res != FR_OK) break;
 8004b26:	2800      	cmp	r0, #0
 8004b28:	d168      	bne.n	8004bfc <dir_register+0x268>
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
 8004b2a:	f8d5 2214 	ldr.w	r2, [r5, #532]	; 0x214
 8004b2e:	f8d5 9220 	ldr.w	r9, [r5, #544]	; 0x220
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
 8004b32:	7310      	strb	r0, [r2, #12]
		if (res == FR_OK) {
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
				if (res != FR_OK) break;
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
 8004b34:	fa5f fe84 	uxtb.w	lr, r4


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir + LDIR_FstClusLO, 0);
 8004b38:	7690      	strb	r0, [r2, #26]
 8004b3a:	76d0      	strb	r0, [r2, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
 8004b3c:	f10e 31ff 	add.w	r1, lr, #4294967295
 8004b40:	200d      	movs	r0, #13
 8004b42:	4341      	muls	r1, r0
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
 8004b44:	7356      	strb	r6, [r2, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 8004b46:	72d7      	strb	r7, [r2, #11]
	dir[LDIR_Type] = 0;
	ST_WORD(dir + LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
 8004b48:	4618      	mov	r0, r3
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8004b4a:	f64f 7aff 	movw	sl, #65535	; 0xffff
 8004b4e:	4550      	cmp	r0, sl
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004b50:	f813 c008 	ldrb.w	ip, [r3, r8]
	ST_WORD(dir + LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8004b54:	bf18      	it	ne
 8004b56:	f839 0011 	ldrhne.w	r0, [r9, r1, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004b5a:	f802 000c 	strb.w	r0, [r2, ip]
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
	} while (++s < 13);
 8004b5e:	f103 0301 	add.w	r3, r3, #1

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004b62:	4494      	add	ip, r2
	ST_WORD(dir + LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
 8004b64:	bf18      	it	ne
 8004b66:	3101      	addne	r1, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004b68:	ea4f 2b10 	mov.w	fp, r0, lsr #8
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
 8004b6c:	2800      	cmp	r0, #0
 8004b6e:	bf08      	it	eq
 8004b70:	4650      	moveq	r0, sl
	} while (++s < 13);
 8004b72:	2b0d      	cmp	r3, #13

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 8004b74:	f88c b001 	strb.w	fp, [ip, #1]
		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
	} while (++s < 13);
 8004b78:	d1e9      	bne.n	8004b4e <dir_register+0x1ba>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLEF;	/* Bottom LFN part is the start of LFN sequence */
 8004b7a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004b7e:	4298      	cmp	r0, r3
 8004b80:	d002      	beq.n	8004b88 <dir_register+0x1f4>
 8004b82:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
 8004b86:	b90b      	cbnz	r3, 8004b8c <dir_register+0x1f8>
 8004b88:	f04e 0e40 	orr.w	lr, lr, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 8004b8c:	f882 e000 	strb.w	lr, [r2]
			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
			do {					/* Store LFN entries in bottom first */
				res = move_window(dp->fs, dp->sect);
				if (res != FR_OK) break;
				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
				dp->fs->wflag = 1;
 8004b90:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
 8004b94:	2201      	movs	r2, #1
 8004b96:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
				res = dir_next(dp, 0);	/* Next entry */
 8004b9a:	2100      	movs	r1, #0
 8004b9c:	4628      	mov	r0, r5
 8004b9e:	f7ff fbc8 	bl	8004332 <dir_next>
			} while (res == FR_OK && --nent);
 8004ba2:	bb58      	cbnz	r0, 8004bfc <dir_register+0x268>
 8004ba4:	3c01      	subs	r4, #1
 8004ba6:	d1b7      	bne.n	8004b18 <dir_register+0x184>
 8004ba8:	e001      	b.n	8004bae <dir_register+0x21a>

	fn = dp->fn; lfn = dp->lfn;
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;
 8004baa:	2006      	movs	r0, #6
 8004bac:	e026      	b.n	8004bfc <dir_register+0x268>
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
#endif

	if (res == FR_OK) {				/* Set SFN entry */
		res = move_window(dp->fs, dp->sect);
 8004bae:	f8d5 1210 	ldr.w	r1, [r5, #528]	; 0x210
 8004bb2:	f8d5 0200 	ldr.w	r0, [r5, #512]	; 0x200
 8004bb6:	f7ff f88c 	bl	8003cd2 <move_window>
		if (res == FR_OK) {
 8004bba:	4604      	mov	r4, r0
 8004bbc:	b9c8      	cbnz	r0, 8004bf2 <dir_register+0x25e>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
 8004bbe:	2220      	movs	r2, #32
 8004bc0:	4621      	mov	r1, r4
 8004bc2:	f8d5 0214 	ldr.w	r0, [r5, #532]	; 0x214
 8004bc6:	f7fe fef1 	bl	80039ac <mem_set>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
 8004bca:	220b      	movs	r2, #11
 8004bcc:	f8d5 1218 	ldr.w	r1, [r5, #536]	; 0x218
 8004bd0:	f8d5 0214 	ldr.w	r0, [r5, #532]	; 0x214
 8004bd4:	f7fe fee0 	bl	8003998 <mem_cpy>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 8004bd8:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004bdc:	f8d5 2214 	ldr.w	r2, [r5, #532]	; 0x214
 8004be0:	7adb      	ldrb	r3, [r3, #11]
 8004be2:	f003 0318 	and.w	r3, r3, #24
 8004be6:	7313      	strb	r3, [r2, #12]
#endif
			dp->fs->wflag = 1;
 8004be8:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
 8004bec:	2201      	movs	r2, #1
 8004bee:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
 8004bf2:	4620      	mov	r0, r4
 8004bf4:	e002      	b.n	8004bfc <dir_register+0x268>
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
		} while (res == FR_OK);
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8004bf6:	2804      	cmp	r0, #4
 8004bf8:	bf08      	it	eq
 8004bfa:	2007      	moveq	r0, #7
			dp->fs->wflag = 1;
		}
	}

	return res;
}
 8004bfc:	b007      	add	sp, #28
 8004bfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004c02:	bf00      	nop
 8004c04:	080074d8 	.word	0x080074d8

08004c08 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8004c08:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
 8004c0c:	780b      	ldrb	r3, [r1, #0]
 8004c0e:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8004c10:	4605      	mov	r5, r0
 8004c12:	4688      	mov	r8, r1
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
 8004c14:	d001      	beq.n	8004c1a <follow_path+0x12>
 8004c16:	2b5c      	cmp	r3, #92	; 0x5c
 8004c18:	d103      	bne.n	8004c22 <follow_path+0x1a>
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
 8004c1a:	f108 0801 	add.w	r8, r8, #1
 8004c1e:	2300      	movs	r3, #0
 8004c20:	e003      	b.n	8004c2a <follow_path+0x22>
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
 8004c22:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 8004c26:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8004c2a:	f8c5 3208 	str.w	r3, [r5, #520]	; 0x208
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
		path++;
	dp->sclust = 0;							/* Always start from the root directory */
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8004c2e:	f898 3000 	ldrb.w	r3, [r8]
 8004c32:	2b1f      	cmp	r3, #31
 8004c34:	d84e      	bhi.n	8004cd4 <follow_path+0xcc>
		res = dir_sdi(dp, 0);
 8004c36:	2100      	movs	r1, #0
 8004c38:	4628      	mov	r0, r5
 8004c3a:	f7ff fa5c 	bl	80040f6 <dir_sdi>
		dp->dir = 0;
 8004c3e:	2300      	movs	r3, #0
 8004c40:	f8c5 3214 	str.w	r3, [r5, #532]	; 0x214
 8004c44:	e13b      	b.n	8004ebe <follow_path+0x2b6>
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 8004c46:	2b5c      	cmp	r3, #92	; 0x5c
 8004c48:	d044      	beq.n	8004cd4 <follow_path+0xcc>
	lfn = dp->lfn;
 8004c4a:	f8d5 9220 	ldr.w	r9, [r5, #544]	; 0x220
 8004c4e:	f104 3aff 	add.w	sl, r4, #4294967295
 8004c52:	f1a9 0702 	sub.w	r7, r9, #2
	si = di = 0;
 8004c56:	2600      	movs	r6, #0
	for (;;) {
		w = p[si++];					/* Get a character */
 8004c58:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8004c5c:	281f      	cmp	r0, #31
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dp->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
 8004c5e:	f106 0801 	add.w	r8, r6, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8004c62:	d83f      	bhi.n	8004ce4 <follow_path+0xdc>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
	}
	*path = &p[si];						/* Return pointer to the next segment */
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8004c64:	2820      	cmp	r0, #32
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
	}
	*path = &p[si];						/* Return pointer to the next segment */
 8004c66:	44a0      	add	r8, r4
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8004c68:	bf34      	ite	cc
 8004c6a:	2404      	movcc	r4, #4
 8004c6c:	2400      	movcs	r4, #0
#if _FS_RPATH
	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
 8004c6e:	2e01      	cmp	r6, #1
 8004c70:	d151      	bne.n	8004d16 <follow_path+0x10e>
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
 8004c72:	f8b9 3000 	ldrh.w	r3, [r9]
 8004c76:	2b2e      	cmp	r3, #46	; 0x2e
 8004c78:	d153      	bne.n	8004d22 <follow_path+0x11a>
		lfn[di] = 0;
 8004c7a:	2300      	movs	r3, #0
 8004c7c:	f829 3016 	strh.w	r3, [r9, r6, lsl #1]
		for (i = 0; i < 11; i++)
			dp->fn[i] = (i < di) ? '.' : ' ';
 8004c80:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
 8004c84:	429e      	cmp	r6, r3
 8004c86:	bf8c      	ite	hi
 8004c88:	212e      	movhi	r1, #46	; 0x2e
 8004c8a:	2120      	movls	r1, #32
 8004c8c:	54d1      	strb	r1, [r2, r3]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
#if _FS_RPATH
	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
		lfn[di] = 0;
		for (i = 0; i < 11; i++)
 8004c8e:	3301      	adds	r3, #1
 8004c90:	2b0b      	cmp	r3, #11
 8004c92:	d1f5      	bne.n	8004c80 <follow_path+0x78>
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
 8004c94:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004c98:	f044 0420 	orr.w	r4, r4, #32
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
 8004c9c:	72dc      	strb	r4, [r3, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8004c9e:	2100      	movs	r1, #0
 8004ca0:	4628      	mov	r0, r5
 8004ca2:	f7ff fa28 	bl	80040f6 <dir_sdi>
	if (res != FR_OK) return res;
 8004ca6:	b910      	cbnz	r0, 8004cae <follow_path+0xa6>
 8004ca8:	4628      	mov	r0, r5
 8004caa:	f7ff fdd3 	bl	8004854 <dir_find.part.9>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
 8004cae:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004cb2:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
 8004cb4:	2800      	cmp	r0, #0
 8004cb6:	d042      	beq.n	8004d3e <follow_path+0x136>
				if (res == FR_NO_FILE) {	/* Object is not found */
 8004cb8:	2804      	cmp	r0, #4
 8004cba:	f040 8100 	bne.w	8004ebe <follow_path+0x2b6>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
 8004cbe:	f013 0f20 	tst.w	r3, #32
 8004cc2:	f003 0304 	and.w	r3, r3, #4
 8004cc6:	d03e      	beq.n	8004d46 <follow_path+0x13e>
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
 8004cc8:	2200      	movs	r2, #0
 8004cca:	f8c5 2208 	str.w	r2, [r5, #520]	; 0x208
 8004cce:	f8c5 2214 	str.w	r2, [r5, #532]	; 0x214
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
 8004cd2:	bbb3      	cbnz	r3, 8004d42 <follow_path+0x13a>
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 8004cd4:	f898 3000 	ldrb.w	r3, [r8]
 8004cd8:	2b2f      	cmp	r3, #47	; 0x2f
 8004cda:	4644      	mov	r4, r8
 8004cdc:	f108 0801 	add.w	r8, r8, #1
 8004ce0:	d1b1      	bne.n	8004c46 <follow_path+0x3e>
 8004ce2:	e7f7      	b.n	8004cd4 <follow_path+0xcc>
	lfn = dp->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 8004ce4:	282f      	cmp	r0, #47	; 0x2f
 8004ce6:	d0bd      	beq.n	8004c64 <follow_path+0x5c>
 8004ce8:	285c      	cmp	r0, #92	; 0x5c
 8004cea:	d0bb      	beq.n	8004c64 <follow_path+0x5c>
		if (di >= _MAX_LFN)				/* Reject too long name */
 8004cec:	f5b8 7f80 	cmp.w	r8, #256	; 0x100
 8004cf0:	d03c      	beq.n	8004d6c <follow_path+0x164>
			w = (w << 8) + b;			/* Create a DBC */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
#endif
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 8004cf2:	2101      	movs	r1, #1
 8004cf4:	f7ff fd7e 	bl	80047f4 <ff_convert>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8004cf8:	2800      	cmp	r0, #0
 8004cfa:	d037      	beq.n	8004d6c <follow_path+0x164>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
 8004cfc:	287f      	cmp	r0, #127	; 0x7f
 8004cfe:	d806      	bhi.n	8004d0e <follow_path+0x106>
 8004d00:	4a70      	ldr	r2, [pc, #448]	; (8004ec4 <follow_path+0x2bc>)
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 8004d02:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8004d06:	b113      	cbz	r3, 8004d0e <follow_path+0x106>
 8004d08:	4298      	cmp	r0, r3
 8004d0a:	d1fa      	bne.n	8004d02 <follow_path+0xfa>
 8004d0c:	e02e      	b.n	8004d6c <follow_path+0x164>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode character */
 8004d0e:	f827 0f02 	strh.w	r0, [r7, #2]!
 8004d12:	4646      	mov	r6, r8
 8004d14:	e7a0      	b.n	8004c58 <follow_path+0x50>
	}
	*path = &p[si];						/* Return pointer to the next segment */
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
#if _FS_RPATH
	if ((di == 1 && lfn[di - 1] == '.') || /* Is this a dot entry? */
 8004d16:	2e02      	cmp	r6, #2
 8004d18:	d103      	bne.n	8004d22 <follow_path+0x11a>
		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {
 8004d1a:	f8b9 3002 	ldrh.w	r3, [r9, #2]
 8004d1e:	2b2e      	cmp	r3, #46	; 0x2e
 8004d20:	d0a7      	beq.n	8004c72 <follow_path+0x6a>
 8004d22:	eb09 0346 	add.w	r3, r9, r6, lsl #1
 8004d26:	e004      	b.n	8004d32 <follow_path+0x12a>
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
		w = lfn[di - 1];
 8004d28:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
		if (w != ' ' && w != '.') break;
 8004d2c:	2a20      	cmp	r2, #32
 8004d2e:	d103      	bne.n	8004d38 <follow_path+0x130>
		di--;
 8004d30:	3e01      	subs	r6, #1
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
 8004d32:	2e00      	cmp	r6, #0
 8004d34:	d1f8      	bne.n	8004d28 <follow_path+0x120>
 8004d36:	e019      	b.n	8004d6c <follow_path+0x164>
		w = lfn[di - 1];
		if (w != ' ' && w != '.') break;
 8004d38:	2a2e      	cmp	r2, #46	; 0x2e
 8004d3a:	d0f9      	beq.n	8004d30 <follow_path+0x128>
 8004d3c:	e01a      	b.n	8004d74 <follow_path+0x16c>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8004d3e:	075a      	lsls	r2, r3, #29
 8004d40:	d506      	bpl.n	8004d50 <follow_path+0x148>
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
 8004d42:	2000      	movs	r0, #0
 8004d44:	e0bb      	b.n	8004ebe <follow_path+0x2b6>
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8004d46:	2b00      	cmp	r3, #0
 8004d48:	bf14      	ite	ne
 8004d4a:	2004      	movne	r0, #4
 8004d4c:	2005      	moveq	r0, #5
 8004d4e:	e0b6      	b.n	8004ebe <follow_path+0x2b6>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
 8004d50:	f8d5 1214 	ldr.w	r1, [r5, #532]	; 0x214
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
 8004d54:	7acb      	ldrb	r3, [r1, #11]
 8004d56:	06db      	lsls	r3, r3, #27
 8004d58:	d50a      	bpl.n	8004d70 <follow_path+0x168>
 8004d5a:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
 8004d5e:	f893 0200 	ldrb.w	r0, [r3, #512]	; 0x200
 8004d62:	f7fe ff1d 	bl	8003ba0 <ld_clust.isra.0>
 8004d66:	f8c5 0208 	str.w	r0, [r5, #520]	; 0x208
 8004d6a:	e7b3      	b.n	8004cd4 <follow_path+0xcc>
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
#endif
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8004d6c:	2006      	movs	r0, #6
 8004d6e:	e0a6      	b.n	8004ebe <follow_path+0x2b6>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8004d70:	2005      	movs	r0, #5
			}
			dp->sclust = ld_clust(dp->fs, dir);
		}
	}

	return res;
 8004d72:	e0a4      	b.n	8004ebe <follow_path+0x2b6>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
 8004d74:	2300      	movs	r3, #0

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
 8004d76:	2120      	movs	r1, #32
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
 8004d78:	f829 3016 	strh.w	r3, [r9, r6, lsl #1]

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
 8004d7c:	220b      	movs	r2, #11
 8004d7e:	f8d5 0218 	ldr.w	r0, [r5, #536]	; 0x218
 8004d82:	f7fe fe13 	bl	80039ac <mem_set>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
 8004d86:	eb09 0746 	add.w	r7, r9, r6, lsl #1

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 8004d8a:	4619      	mov	r1, r3
 8004d8c:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
 8004d90:	2b20      	cmp	r3, #32
 8004d92:	d101      	bne.n	8004d98 <follow_path+0x190>
 8004d94:	3101      	adds	r1, #1
 8004d96:	e7f9      	b.n	8004d8c <follow_path+0x184>
 8004d98:	2b2e      	cmp	r3, #46	; 0x2e
 8004d9a:	d0fb      	beq.n	8004d94 <follow_path+0x18c>
	if (si) cf |= NS_LOSS | NS_LFN;
 8004d9c:	b109      	cbz	r1, 8004da2 <follow_path+0x19a>
 8004d9e:	f044 0403 	orr.w	r4, r4, #3
 8004da2:	463b      	mov	r3, r7
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 8004da4:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
 8004da8:	2a2e      	cmp	r2, #46	; 0x2e
 8004daa:	d001      	beq.n	8004db0 <follow_path+0x1a8>
 8004dac:	3e01      	subs	r6, #1
 8004dae:	d1f9      	bne.n	8004da4 <follow_path+0x19c>
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8004db0:	2300      	movs	r3, #0
 8004db2:	f04f 0a08 	mov.w	sl, #8
 8004db6:	461f      	mov	r7, r3
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
 8004db8:	f839 0011 	ldrh.w	r0, [r9, r1, lsl #1]
 8004dbc:	f101 0b01 	add.w	fp, r1, #1
		if (!w) break;					/* Break on end of the LFN */
 8004dc0:	2800      	cmp	r0, #0
 8004dc2:	d049      	beq.n	8004e58 <follow_path+0x250>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8004dc4:	2820      	cmp	r0, #32
 8004dc6:	d003      	beq.n	8004dd0 <follow_path+0x1c8>
 8004dc8:	282e      	cmp	r0, #46	; 0x2e
 8004dca:	d105      	bne.n	8004dd8 <follow_path+0x1d0>
 8004dcc:	455e      	cmp	r6, fp
 8004dce:	d008      	beq.n	8004de2 <follow_path+0x1da>
			cf |= NS_LOSS | NS_LFN; continue;
 8004dd0:	f044 0403 	orr.w	r4, r4, #3
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8004dd4:	4659      	mov	r1, fp
 8004dd6:	e7ef      	b.n	8004db8 <follow_path+0x1b0>
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
 8004dd8:	4553      	cmp	r3, sl
 8004dda:	d204      	bcs.n	8004de6 <follow_path+0x1de>
 8004ddc:	455e      	cmp	r6, fp
 8004dde:	d116      	bne.n	8004e0e <follow_path+0x206>
 8004de0:	e069      	b.n	8004eb6 <follow_path+0x2ae>
 8004de2:	4553      	cmp	r3, sl
 8004de4:	d367      	bcc.n	8004eb6 <follow_path+0x2ae>
			if (ni == 11) {				/* Long extension */
 8004de6:	f1ba 0f0b 	cmp.w	sl, #11
 8004dea:	d104      	bne.n	8004df6 <follow_path+0x1ee>
				cf |= NS_LOSS | NS_LFN; break;
 8004dec:	f044 0403 	orr.w	r4, r4, #3
 8004df0:	f04f 0a0b 	mov.w	sl, #11
 8004df4:	e030      	b.n	8004e58 <follow_path+0x250>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 8004df6:	455e      	cmp	r6, fp
 8004df8:	d002      	beq.n	8004e00 <follow_path+0x1f8>
 8004dfa:	f044 0403 	orr.w	r4, r4, #3
			if (si > di) break;			/* No extension */
 8004dfe:	d32b      	bcc.n	8004e58 <follow_path+0x250>
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
 8004e00:	00bf      	lsls	r7, r7, #2
 8004e02:	b2ff      	uxtb	r7, r7
 8004e04:	46b3      	mov	fp, r6
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8004e06:	f04f 0a0b 	mov.w	sl, #11
 8004e0a:	2308      	movs	r3, #8
 8004e0c:	e7e2      	b.n	8004dd4 <follow_path+0x1cc>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII character */
 8004e0e:	287f      	cmp	r0, #127	; 0x7f
 8004e10:	d90c      	bls.n	8004e2c <follow_path+0x224>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 8004e12:	2100      	movs	r1, #0
 8004e14:	9301      	str	r3, [sp, #4]
 8004e16:	f7ff fced 	bl	80047f4 <ff_convert>
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 8004e1a:	9b01      	ldr	r3, [sp, #4]
 8004e1c:	b118      	cbz	r0, 8004e26 <follow_path+0x21e>
 8004e1e:	4a2a      	ldr	r2, [pc, #168]	; (8004ec8 <follow_path+0x2c0>)
 8004e20:	4410      	add	r0, r2
 8004e22:	f810 0c80 	ldrb.w	r0, [r0, #-128]
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
 8004e26:	f044 0402 	orr.w	r4, r4, #2
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 8004e2a:	b128      	cbz	r0, 8004e38 <follow_path+0x230>
 8004e2c:	4a27      	ldr	r2, [pc, #156]	; (8004ecc <follow_path+0x2c4>)
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 8004e2e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8004e32:	b129      	cbz	r1, 8004e40 <follow_path+0x238>
 8004e34:	4288      	cmp	r0, r1
 8004e36:	d1fa      	bne.n	8004e2e <follow_path+0x226>
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 8004e38:	f044 0403 	orr.w	r4, r4, #3
 8004e3c:	205f      	movs	r0, #95	; 0x5f
 8004e3e:	e006      	b.n	8004e4e <follow_path+0x246>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
 8004e40:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
 8004e44:	b289      	uxth	r1, r1
 8004e46:	2919      	cmp	r1, #25
 8004e48:	d82b      	bhi.n	8004ea2 <follow_path+0x29a>
					b |= 2;
 8004e4a:	f047 0702 	orr.w	r7, r7, #2
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
 8004e4e:	f8d5 1218 	ldr.w	r1, [r5, #536]	; 0x218
 8004e52:	54c8      	strb	r0, [r1, r3]
 8004e54:	3301      	adds	r3, #1
 8004e56:	e7bd      	b.n	8004dd4 <follow_path+0x1cc>
	}

	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with deleted mark, replace it with RDDEM */
 8004e58:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004e5c:	781a      	ldrb	r2, [r3, #0]
 8004e5e:	2ae5      	cmp	r2, #229	; 0xe5
 8004e60:	bf04      	itt	eq
 8004e62:	2205      	moveq	r2, #5
 8004e64:	701a      	strbeq	r2, [r3, #0]

	if (ni == 8) b <<= 2;
 8004e66:	f1ba 0f08 	cmp.w	sl, #8
 8004e6a:	bf04      	itt	eq
 8004e6c:	00bf      	lsleq	r7, r7, #2
 8004e6e:	b2ff      	uxtbeq	r7, r7
 8004e70:	f007 030c 	and.w	r3, r7, #12
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
 8004e74:	2b0c      	cmp	r3, #12
 8004e76:	d003      	beq.n	8004e80 <follow_path+0x278>
 8004e78:	f007 0203 	and.w	r2, r7, #3
 8004e7c:	2a03      	cmp	r2, #3
 8004e7e:	d101      	bne.n	8004e84 <follow_path+0x27c>
		cf |= NS_LFN;
 8004e80:	f044 0402 	orr.w	r4, r4, #2
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 8004e84:	07a1      	lsls	r1, r4, #30
 8004e86:	d409      	bmi.n	8004e9c <follow_path+0x294>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 8004e88:	f007 0703 	and.w	r7, r7, #3
 8004e8c:	2f01      	cmp	r7, #1
 8004e8e:	bf08      	it	eq
 8004e90:	f044 0410 	orreq.w	r4, r4, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 8004e94:	2b04      	cmp	r3, #4
 8004e96:	bf08      	it	eq
 8004e98:	f044 0408 	orreq.w	r4, r4, #8
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
 8004e9c:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8004ea0:	e6fc      	b.n	8004c9c <follow_path+0x94>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
 8004ea2:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
 8004ea6:	b289      	uxth	r1, r1
 8004ea8:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
 8004eaa:	bf9e      	ittt	ls
 8004eac:	3820      	subls	r0, #32
 8004eae:	f047 0701 	orrls.w	r7, r7, #1
 8004eb2:	b280      	uxthls	r0, r0
 8004eb4:	e7cb      	b.n	8004e4e <follow_path+0x246>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
 8004eb6:	f1ba 0f0b 	cmp.w	sl, #11
 8004eba:	d1a1      	bne.n	8004e00 <follow_path+0x1f8>
 8004ebc:	e796      	b.n	8004dec <follow_path+0x1e4>
			dp->sclust = ld_clust(dp->fs, dir);
		}
	}

	return res;
}
 8004ebe:	b003      	add	sp, #12
 8004ec0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004ec4:	080072e7 	.word	0x080072e7
 8004ec8:	080074e5 	.word	0x080074e5
 8004ecc:	080072f0 	.word	0x080072f0

08004ed0 <f_chdir>:


FRESULT f_chdir (
	const TCHAR* path	/* Pointer to the directory path */
)
{
 8004ed0:	b530      	push	{r4, r5, lr}
 8004ed2:	f5ad 7d11 	sub.w	sp, sp, #580	; 0x244
	DIR dj;
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
 8004ed6:	2200      	movs	r2, #0


FRESULT f_chdir (
	const TCHAR* path	/* Pointer to the directory path */
)
{
 8004ed8:	9001      	str	r0, [sp, #4]
	DIR dj;
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
 8004eda:	a901      	add	r1, sp, #4
 8004edc:	a886      	add	r0, sp, #536	; 0x218
 8004ede:	f7fe ff41 	bl	8003d64 <find_volume>
	if (res == FR_OK) {
 8004ee2:	bb68      	cbnz	r0, 8004f40 <f_chdir+0x70>
		INIT_BUF(dj);
 8004ee4:	f44f 7000 	mov.w	r0, #512	; 0x200
 8004ee8:	f000 faa4 	bl	8005434 <ff_memalloc>
 8004eec:	4605      	mov	r5, r0
 8004eee:	b308      	cbz	r0, 8004f34 <f_chdir+0x64>
 8004ef0:	908e      	str	r0, [sp, #568]	; 0x238
 8004ef2:	ab03      	add	r3, sp, #12
		res = follow_path(&dj, path);		/* Follow the path */
 8004ef4:	9901      	ldr	r1, [sp, #4]


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004ef6:	938c      	str	r3, [sp, #560]	; 0x230
		res = follow_path(&dj, path);		/* Follow the path */
 8004ef8:	a806      	add	r0, sp, #24
 8004efa:	f7ff fe85 	bl	8004c08 <follow_path>
 8004efe:	4604      	mov	r4, r0
		FREE_BUF();
 8004f00:	4628      	mov	r0, r5
 8004f02:	f000 fa99 	bl	8005438 <ff_memfree>
		if (res == FR_OK) {					/* Follow completed */
 8004f06:	b98c      	cbnz	r4, 8004f2c <f_chdir+0x5c>
			if (!dj.dir) {
 8004f08:	998b      	ldr	r1, [sp, #556]	; 0x22c
 8004f0a:	b921      	cbnz	r1, 8004f16 <f_chdir+0x46>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
 8004f0c:	9b86      	ldr	r3, [sp, #536]	; 0x218
 8004f0e:	9a88      	ldr	r2, [sp, #544]	; 0x220
 8004f10:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
 8004f14:	e00c      	b.n	8004f30 <f_chdir+0x60>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
 8004f16:	7acb      	ldrb	r3, [r1, #11]
 8004f18:	06db      	lsls	r3, r3, #27
 8004f1a:	d50f      	bpl.n	8004f3c <f_chdir+0x6c>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
 8004f1c:	9d86      	ldr	r5, [sp, #536]	; 0x218
 8004f1e:	f895 0200 	ldrb.w	r0, [r5, #512]	; 0x200
 8004f22:	f7fe fe3d 	bl	8003ba0 <ld_clust.isra.0>
 8004f26:	f8c5 0214 	str.w	r0, [r5, #532]	; 0x214
 8004f2a:	e001      	b.n	8004f30 <f_chdir+0x60>
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8004f2c:	2c04      	cmp	r4, #4
 8004f2e:	d003      	beq.n	8004f38 <f_chdir+0x68>


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004f30:	4620      	mov	r0, r4
 8004f32:	e005      	b.n	8004f40 <f_chdir+0x70>
 8004f34:	2011      	movs	r0, #17
 8004f36:	e003      	b.n	8004f40 <f_chdir+0x70>
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8004f38:	2005      	movs	r0, #5
 8004f3a:	e001      	b.n	8004f40 <f_chdir+0x70>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
				else
					res = FR_NO_PATH;		/* Reached but a file */
 8004f3c:	2405      	movs	r4, #5
 8004f3e:	e7f7      	b.n	8004f30 <f_chdir+0x60>
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}

	LEAVE_FF(dj.fs, res);
}
 8004f40:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
 8004f44:	bd30      	pop	{r4, r5, pc}
	...

08004f48 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8004f48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004f4c:	f5ad 7d10 	sub.w	sp, sp, #576	; 0x240
 8004f50:	4691      	mov	r9, r2
 8004f52:	9101      	str	r1, [sp, #4]
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
 8004f54:	4606      	mov	r6, r0
 8004f56:	2800      	cmp	r0, #0
 8004f58:	f000 80c5 	beq.w	80050e6 <f_open+0x19e>
	fp->fs = 0;			/* Clear file object */
 8004f5c:	2300      	movs	r3, #0
 8004f5e:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
 8004f62:	f002 021e 	and.w	r2, r2, #30
 8004f66:	a901      	add	r1, sp, #4
 8004f68:	a886      	add	r0, sp, #536	; 0x218
 8004f6a:	f7fe fefb 	bl	8003d64 <find_volume>
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
 8004f6e:	4604      	mov	r4, r0
 8004f70:	2800      	cmp	r0, #0
 8004f72:	f040 80c9 	bne.w	8005108 <f_open+0x1c0>
		INIT_BUF(dj);
 8004f76:	f44f 7000 	mov.w	r0, #512	; 0x200
 8004f7a:	f000 fa5b 	bl	8005434 <ff_memalloc>
 8004f7e:	4680      	mov	r8, r0
 8004f80:	2800      	cmp	r0, #0
 8004f82:	f000 80b2 	beq.w	80050ea <f_open+0x1a2>
 8004f86:	908e      	str	r0, [sp, #568]	; 0x238
 8004f88:	ab03      	add	r3, sp, #12
		res = follow_path(&dj, path);	/* Follow the file path */
 8004f8a:	9901      	ldr	r1, [sp, #4]
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004f8c:	938c      	str	r3, [sp, #560]	; 0x230
		res = follow_path(&dj, path);	/* Follow the file path */
 8004f8e:	a806      	add	r0, sp, #24
 8004f90:	f7ff fe3a 	bl	8004c08 <follow_path>
	if (!fp) return FR_INVALID_OBJECT;
	fp->fs = 0;			/* Clear file object */

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 8004f94:	f009 071f 	and.w	r7, r9, #31
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
 8004f98:	9d8b      	ldr	r5, [sp, #556]	; 0x22c
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 8004f9a:	4604      	mov	r4, r0
 8004f9c:	b958      	cbnz	r0, 8004fb6 <f_open+0x6e>
			if (!dir)	/* Default directory itself */
 8004f9e:	b14d      	cbz	r5, 8004fb4 <f_open+0x6c>
				res = FR_INVALID_NAME;
#if _FS_LOCK
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 8004fa0:	f017 0f1e 	tst.w	r7, #30
 8004fa4:	bf14      	ite	ne
 8004fa6:	2101      	movne	r1, #1
 8004fa8:	2100      	moveq	r1, #0
 8004faa:	a806      	add	r0, sp, #24
 8004fac:	f7fe fd06 	bl	80039bc <chk_lock>
 8004fb0:	4604      	mov	r4, r0
 8004fb2:	e000      	b.n	8004fb6 <f_open+0x6e>
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
			if (!dir)	/* Default directory itself */
				res = FR_INVALID_NAME;
 8004fb4:	2406      	movs	r4, #6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 8004fb6:	f019 0f1c 	tst.w	r9, #28
 8004fba:	d051      	beq.n	8005060 <f_open+0x118>
			if (res != FR_OK) {					/* No file, create new */
 8004fbc:	b194      	cbz	r4, 8004fe4 <f_open+0x9c>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 8004fbe:	2c04      	cmp	r4, #4
 8004fc0:	d109      	bne.n	8004fd6 <f_open+0x8e>
static
int enq_lock (void)	/* Check if an entry is available for a new object */
{
	UINT i;

	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8004fc2:	4b54      	ldr	r3, [pc, #336]	; (8005114 <f_open+0x1cc>)
 8004fc4:	681a      	ldr	r2, [r3, #0]
 8004fc6:	2a00      	cmp	r2, #0
 8004fc8:	f000 8091 	beq.w	80050ee <f_open+0x1a6>
 8004fcc:	68db      	ldr	r3, [r3, #12]
 8004fce:	2b00      	cmp	r3, #0
 8004fd0:	f000 808d 	beq.w	80050ee <f_open+0x1a6>
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
			if (res != FR_OK) {					/* No file, create new */
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 8004fd4:	2412      	movs	r4, #18
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 8004fd6:	f047 0708 	orr.w	r7, r7, #8
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8004fda:	2c00      	cmp	r4, #0
 8004fdc:	f040 8091 	bne.w	8005102 <f_open+0x1ba>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
 8004fe0:	9d8b      	ldr	r5, [sp, #556]	; 0x22c
 8004fe2:	e008      	b.n	8004ff6 <f_open+0xae>
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8004fe4:	7aeb      	ldrb	r3, [r5, #11]
 8004fe6:	f013 0f11 	tst.w	r3, #17
 8004fea:	f040 8087 	bne.w	80050fc <f_open+0x1b4>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 8004fee:	f019 0f04 	tst.w	r9, #4
 8004ff2:	f040 8085 	bne.w	8005100 <f_open+0x1b8>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8004ff6:	073b      	lsls	r3, r7, #28
 8004ff8:	d540      	bpl.n	800507c <f_open+0x134>
				dw = GET_FATTIME();				/* Created time */
 8004ffa:	f7fb f961 	bl	80002c0 <get_fattime>
				ST_DWORD(dir + DIR_CrtTime, dw);
 8004ffe:	1203      	asrs	r3, r0, #8
				dir[DIR_Attr] = 0;				/* Reset attribute */
 8005000:	2400      	movs	r4, #0
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
				dw = GET_FATTIME();				/* Created time */
				ST_DWORD(dir + DIR_CrtTime, dw);
 8005002:	73a8      	strb	r0, [r5, #14]
 8005004:	73eb      	strb	r3, [r5, #15]
 8005006:	0c03      	lsrs	r3, r0, #16
 8005008:	0e00      	lsrs	r0, r0, #24
 800500a:	742b      	strb	r3, [r5, #16]
 800500c:	7468      	strb	r0, [r5, #17]
				dir[DIR_Attr] = 0;				/* Reset attribute */
 800500e:	72ec      	strb	r4, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
 8005010:	772c      	strb	r4, [r5, #28]
 8005012:	776c      	strb	r4, [r5, #29]
 8005014:	77ac      	strb	r4, [r5, #30]
 8005016:	77ec      	strb	r4, [r5, #31]
 8005018:	9b86      	ldr	r3, [sp, #536]	; 0x218
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
 800501a:	4629      	mov	r1, r5
 800501c:	f893 0200 	ldrb.w	r0, [r3, #512]	; 0x200
 8005020:	f7fe fdbe 	bl	8003ba0 <ld_clust.isra.0>
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8005024:	76ac      	strb	r4, [r5, #26]
 8005026:	76ec      	strb	r4, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005028:	752c      	strb	r4, [r5, #20]
 800502a:	756c      	strb	r4, [r5, #21]
				ST_DWORD(dir + DIR_CrtTime, dw);
				dir[DIR_Attr] = 0;				/* Reset attribute */
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
 800502c:	9b86      	ldr	r3, [sp, #536]	; 0x218
 800502e:	2201      	movs	r2, #1
 8005030:	f883 2204 	strb.w	r2, [r3, #516]	; 0x204
				if (cl) {						/* Remove the cluster chain if exist */
 8005034:	4681      	mov	r9, r0
 8005036:	b1f8      	cbz	r0, 8005078 <f_open+0x130>
					dw = dj.fs->winsect;
					res = remove_chain(dj.fs, cl);
 8005038:	4601      	mov	r1, r0
 800503a:	4618      	mov	r0, r3
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
				if (cl) {						/* Remove the cluster chain if exist */
					dw = dj.fs->winsect;
 800503c:	f8d3 a230 	ldr.w	sl, [r3, #560]	; 0x230
					res = remove_chain(dj.fs, cl);
 8005040:	f7ff fa08 	bl	8004454 <remove_chain>
					if (res == FR_OK) {
 8005044:	4604      	mov	r4, r0
 8005046:	2800      	cmp	r0, #0
 8005048:	d15b      	bne.n	8005102 <f_open+0x1ba>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 800504a:	9886      	ldr	r0, [sp, #536]	; 0x218
 800504c:	f109 33ff 	add.w	r3, r9, #4294967295
 8005050:	f8c0 320c 	str.w	r3, [r0, #524]	; 0x20c
						res = move_window(dj.fs, dw);
 8005054:	4651      	mov	r1, sl
 8005056:	f7fe fe3c 	bl	8003cd2 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
 800505a:	b158      	cbz	r0, 8005074 <f_open+0x12c>
 800505c:	4604      	mov	r4, r0
 800505e:	e022      	b.n	80050a6 <f_open+0x15e>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Follow succeeded */
 8005060:	2c00      	cmp	r4, #0
 8005062:	d14e      	bne.n	8005102 <f_open+0x1ba>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
 8005064:	7aeb      	ldrb	r3, [r5, #11]
 8005066:	06d8      	lsls	r0, r3, #27
 8005068:	d446      	bmi.n	80050f8 <f_open+0x1b0>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 800506a:	f019 0f02 	tst.w	r9, #2
 800506e:	d001      	beq.n	8005074 <f_open+0x12c>
 8005070:	07da      	lsls	r2, r3, #31
 8005072:	d443      	bmi.n	80050fc <f_open+0x1b4>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 8005074:	073b      	lsls	r3, r7, #28
 8005076:	d501      	bpl.n	800507c <f_open+0x134>
				mode |= FA__WRITTEN;
 8005078:	f047 0720 	orr.w	r7, r7, #32
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 800507c:	9b86      	ldr	r3, [sp, #536]	; 0x218
			fp->dir_ptr = dir;
#if _FS_LOCK
			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800507e:	f017 0ffe 	tst.w	r7, #254	; 0xfe
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 8005082:	f8d3 3230 	ldr.w	r3, [r3, #560]	; 0x230
 8005086:	f8c6 321c 	str.w	r3, [r6, #540]	; 0x21c
			fp->dir_ptr = dir;
#if _FS_LOCK
			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800508a:	bf14      	ite	ne
 800508c:	2101      	movne	r1, #1
 800508e:	2100      	moveq	r1, #0
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
			fp->dir_ptr = dir;
 8005090:	f8c6 5220 	str.w	r5, [r6, #544]	; 0x220
#if _FS_LOCK
			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 8005094:	a806      	add	r0, sp, #24
 8005096:	f7fe fcc9 	bl	8003a2c <inc_lock>
			if (!fp->lockid) res = FR_INT_ERR;
 800509a:	2800      	cmp	r0, #0
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
			fp->dir_ptr = dir;
#if _FS_LOCK
			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800509c:	f8c6 0228 	str.w	r0, [r6, #552]	; 0x228
			if (!fp->lockid) res = FR_INT_ERR;
 80050a0:	bf14      	ite	ne
 80050a2:	2400      	movne	r4, #0
 80050a4:	2402      	moveq	r4, #2
				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
					res = FR_NO_FILE;
			}
		}
#endif
		FREE_BUF();
 80050a6:	4640      	mov	r0, r8
 80050a8:	f000 f9c6 	bl	8005438 <ff_memfree>

		if (res == FR_OK) {
 80050ac:	bb64      	cbnz	r4, 8005108 <f_open+0x1c0>
			fp->flag = mode;					/* File access mode */
 80050ae:	f886 7206 	strb.w	r7, [r6, #518]	; 0x206
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 80050b2:	9f86      	ldr	r7, [sp, #536]	; 0x218
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
 80050b4:	f886 4207 	strb.w	r4, [r6, #519]	; 0x207
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 80050b8:	f897 0200 	ldrb.w	r0, [r7, #512]	; 0x200
 80050bc:	4629      	mov	r1, r5
 80050be:	f7fe fd6f 	bl	8003ba0 <ld_clust.isra.0>
 80050c2:	f8c6 0210 	str.w	r0, [r6, #528]	; 0x210
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
 80050c6:	69eb      	ldr	r3, [r5, #28]
 80050c8:	f8c6 320c 	str.w	r3, [r6, #524]	; 0x20c
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
 80050cc:	f8b7 3206 	ldrh.w	r3, [r7, #518]	; 0x206
		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
			fp->fptr = 0;						/* File pointer */
 80050d0:	f8c6 4208 	str.w	r4, [r6, #520]	; 0x208
			fp->dsect = 0;
 80050d4:	f8c6 4218 	str.w	r4, [r6, #536]	; 0x218
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
 80050d8:	f8c6 4224 	str.w	r4, [r6, #548]	; 0x224
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
 80050dc:	f8c6 7200 	str.w	r7, [r6, #512]	; 0x200
			fp->id = fp->fs->id;
 80050e0:	f8a6 3204 	strh.w	r3, [r6, #516]	; 0x204
 80050e4:	e010      	b.n	8005108 <f_open+0x1c0>
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
 80050e6:	2009      	movs	r0, #9
 80050e8:	e00f      	b.n	800510a <f_open+0x1c2>
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 80050ea:	2011      	movs	r0, #17
 80050ec:	e00d      	b.n	800510a <f_open+0x1c2>
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
			if (res != FR_OK) {					/* No file, create new */
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 80050ee:	a806      	add	r0, sp, #24
 80050f0:	f7ff fc50 	bl	8004994 <dir_register>
 80050f4:	4604      	mov	r4, r0
 80050f6:	e76e      	b.n	8004fd6 <f_open+0x8e>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
					res = FR_NO_FILE;
 80050f8:	2404      	movs	r4, #4
 80050fa:	e002      	b.n	8005102 <f_open+0x1ba>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
 80050fc:	2407      	movs	r4, #7
 80050fe:	e000      	b.n	8005102 <f_open+0x1ba>
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
 8005100:	2408      	movs	r4, #8
				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
					res = FR_NO_FILE;
			}
		}
#endif
		FREE_BUF();
 8005102:	4640      	mov	r0, r8
 8005104:	f000 f998 	bl	8005438 <ff_memfree>
 8005108:	4620      	mov	r0, r4
			fp->id = fp->fs->id;
		}
	}

	LEAVE_FF(dj.fs, res);
}
 800510a:	f50d 7d10 	add.w	sp, sp, #576	; 0x240
 800510e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005112:	bf00      	nop
 8005114:	20000628 	.word	0x20000628

08005118 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
 8005118:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800511c:	f5ad 7d17 	sub.w	sp, sp, #604	; 0x25c
 8005120:	9007      	str	r0, [sp, #28]
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
 8005122:	f7fb f8cd 	bl	80002c0 <get_fattime>
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
 8005126:	2201      	movs	r2, #1
)
{
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
 8005128:	4607      	mov	r7, r0
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
 800512a:	a907      	add	r1, sp, #28
 800512c:	a88c      	add	r0, sp, #560	; 0x230
 800512e:	f7fe fe19 	bl	8003d64 <find_volume>
	if (res == FR_OK) {
 8005132:	2800      	cmp	r0, #0
 8005134:	f040 80e9 	bne.w	800530a <f_mkdir+0x1f2>
		INIT_BUF(dj);
 8005138:	f44f 7000 	mov.w	r0, #512	; 0x200
 800513c:	f000 f97a 	bl	8005434 <ff_memalloc>
 8005140:	4682      	mov	sl, r0
 8005142:	b1b8      	cbz	r0, 8005174 <f_mkdir+0x5c>
 8005144:	9094      	str	r0, [sp, #592]	; 0x250
 8005146:	ab09      	add	r3, sp, #36	; 0x24
		res = follow_path(&dj, path);			/* Follow the file path */
 8005148:	9907      	ldr	r1, [sp, #28]


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
 800514a:	9392      	str	r3, [sp, #584]	; 0x248
		res = follow_path(&dj, path);			/* Follow the file path */
 800514c:	a80c      	add	r0, sp, #48	; 0x30
 800514e:	f7ff fd5b 	bl	8004c08 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8005152:	4604      	mov	r4, r0
 8005154:	b180      	cbz	r0, 8005178 <f_mkdir+0x60>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
 8005156:	2804      	cmp	r0, #4
 8005158:	d107      	bne.n	800516a <f_mkdir+0x52>
 800515a:	9b92      	ldr	r3, [sp, #584]	; 0x248
 800515c:	7adb      	ldrb	r3, [r3, #11]
 800515e:	f003 0320 	and.w	r3, r3, #32
 8005162:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 8005166:	b14b      	cbz	r3, 800517c <f_mkdir+0x64>
			res = FR_INVALID_NAME;
 8005168:	2406      	movs	r4, #6
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
			}
		}
		FREE_BUF();
 800516a:	4650      	mov	r0, sl
 800516c:	f000 f964 	bl	8005438 <ff_memfree>
 8005170:	4620      	mov	r0, r4
 8005172:	e0ca      	b.n	800530a <f_mkdir+0x1f2>


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
 8005174:	2011      	movs	r0, #17
 8005176:	e0c8      	b.n	800530a <f_mkdir+0x1f2>
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8005178:	2408      	movs	r4, #8
 800517a:	e7f6      	b.n	800516a <f_mkdir+0x52>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
 800517c:	988c      	ldr	r0, [sp, #560]	; 0x230
 800517e:	f7ff f87e 	bl	800427e <create_chain>
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8005182:	4606      	mov	r6, r0
 8005184:	b138      	cbz	r0, 8005196 <f_mkdir+0x7e>
			if (dcl == 1) res = FR_INT_ERR;
 8005186:	2e01      	cmp	r6, #1
 8005188:	d107      	bne.n	800519a <f_mkdir+0x82>
 800518a:	2402      	movs	r4, #2
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
 800518c:	4631      	mov	r1, r6
 800518e:	988c      	ldr	r0, [sp, #560]	; 0x230
 8005190:	f7ff f960 	bl	8004454 <remove_chain>
 8005194:	e7e9      	b.n	800516a <f_mkdir+0x52>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8005196:	2407      	movs	r4, #7
 8005198:	e7f8      	b.n	800518c <f_mkdir+0x74>
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 800519a:	1c73      	adds	r3, r6, #1
 800519c:	f000 8089 	beq.w	80052b2 <f_mkdir+0x19a>
			if (res == FR_OK)					/* Flush FAT */
				res = sync_window(dj.fs);
 80051a0:	988c      	ldr	r0, [sp, #560]	; 0x230
 80051a2:	f7fe fd34 	bl	8003c0e <sync_window>
			if (res == FR_OK) {					/* Initialize the new directory table */
 80051a6:	4604      	mov	r4, r0
 80051a8:	2800      	cmp	r0, #0
 80051aa:	d1ef      	bne.n	800518c <f_mkdir+0x74>
				dsc = clust2sect(dj.fs, dcl);
 80051ac:	9d8c      	ldr	r5, [sp, #560]	; 0x230
 80051ae:	4631      	mov	r1, r6
 80051b0:	4628      	mov	r0, r5
 80051b2:	f7fe ff31 	bl	8004018 <clust2sect>
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
 80051b6:	4621      	mov	r1, r4
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
				res = sync_window(dj.fs);
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
 80051b8:	9006      	str	r0, [sp, #24]
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
 80051ba:	f44f 7200 	mov.w	r2, #512	; 0x200
 80051be:	4628      	mov	r0, r5
 80051c0:	f7fe fbf4 	bl	80039ac <mem_set>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
 80051c4:	220b      	movs	r2, #11
 80051c6:	2120      	movs	r1, #32
 80051c8:	4628      	mov	r0, r5
 80051ca:	f7fe fbef 	bl	80039ac <mem_set>
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
 80051ce:	f3c7 2307 	ubfx	r3, r7, #8, #8
 80051d2:	9300      	str	r3, [sp, #0]
 80051d4:	f89d 3000 	ldrb.w	r3, [sp]
 80051d8:	75eb      	strb	r3, [r5, #23]
 80051da:	f3c7 4307 	ubfx	r3, r7, #16, #8
 80051de:	9301      	str	r3, [sp, #4]
 80051e0:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80051e4:	762b      	strb	r3, [r5, #24]
 80051e6:	0e3b      	lsrs	r3, r7, #24
 80051e8:	9302      	str	r3, [sp, #8]
 80051ea:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80051ee:	766b      	strb	r3, [r5, #25]
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 80051f0:	b2f3      	uxtb	r3, r6
 80051f2:	9303      	str	r3, [sp, #12]
 80051f4:	f89d 300c 	ldrb.w	r3, [sp, #12]
 80051f8:	76ab      	strb	r3, [r5, #26]
 80051fa:	f3c6 2307 	ubfx	r3, r6, #8, #8
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
 80051fe:	2210      	movs	r2, #16
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8005200:	9304      	str	r3, [sp, #16]
 8005202:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8005206:	76eb      	strb	r3, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005208:	fa26 f802 	lsr.w	r8, r6, r2
 800520c:	fa5f f388 	uxtb.w	r3, r8
 8005210:	9305      	str	r3, [sp, #20]
 8005212:	f89d 3014 	ldrb.w	r3, [sp, #20]
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
 8005216:	72ea      	strb	r2, [r5, #11]
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
 8005218:	242e      	movs	r4, #46	; 0x2e
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
 800521a:	2220      	movs	r2, #32
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
 800521c:	fa5f fb87 	uxtb.w	fp, r7
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005220:	ea4f 2818 	mov.w	r8, r8, lsr #8
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
 8005224:	18a8      	adds	r0, r5, r2
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005226:	752b      	strb	r3, [r5, #20]
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
 8005228:	4629      	mov	r1, r5
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win.d8;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
 800522a:	702c      	strb	r4, [r5, #0]
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
 800522c:	f885 b016 	strb.w	fp, [r5, #22]
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005230:	f885 8015 	strb.w	r8, [r5, #21]
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
 8005234:	f7fe fbb0 	bl	8003998 <mem_cpy>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
 8005238:	f885 4021 	strb.w	r4, [r5, #33]	; 0x21
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 800523c:	998c      	ldr	r1, [sp, #560]	; 0x230
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir + DIR_WrtTime, tm);
				st_clust(dir, dcl);
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
 800523e:	9a8e      	ldr	r2, [sp, #568]	; 0x238
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 8005240:	f891 0200 	ldrb.w	r0, [r1, #512]	; 0x200
 8005244:	9b06      	ldr	r3, [sp, #24]
 8005246:	2803      	cmp	r0, #3
 8005248:	d104      	bne.n	8005254 <f_mkdir+0x13c>
 800524a:	f8d1 1228 	ldr.w	r1, [r1, #552]	; 0x228
					pcl = 0;
 800524e:	428a      	cmp	r2, r1
 8005250:	bf08      	it	eq
 8005252:	2200      	moveq	r2, #0
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8005254:	f885 203a 	strb.w	r2, [r5, #58]	; 0x3a
 8005258:	1211      	asrs	r1, r2, #8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 800525a:	0c12      	lsrs	r2, r2, #16
 800525c:	f885 2034 	strb.w	r2, [r5, #52]	; 0x34
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 8005260:	af0c      	add	r7, sp, #48	; 0x30
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005262:	1212      	asrs	r2, r2, #8
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 8005264:	f885 103b 	strb.w	r1, [r5, #59]	; 0x3b
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 8005268:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 800526c:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
 8005270:	f892 9202 	ldrb.w	r9, [r2, #514]	; 0x202
 8005274:	f1b9 0f00 	cmp.w	r9, #0
 8005278:	d01d      	beq.n	80052b6 <f_mkdir+0x19e>
					dj.fs->winsect = dsc++;
 800527a:	f8d7 0200 	ldr.w	r0, [r7, #512]	; 0x200
 800527e:	1c5a      	adds	r2, r3, #1
 8005280:	f8c0 3230 	str.w	r3, [r0, #560]	; 0x230
					dj.fs->wflag = 1;
 8005284:	f04f 0301 	mov.w	r3, #1
 8005288:	f880 3204 	strb.w	r3, [r0, #516]	; 0x204
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
 800528c:	9206      	str	r2, [sp, #24]
 800528e:	f7fe fc95 	bl	8003bbc <sync_window.part.1>
					dj.fs->wflag = 1;
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
 8005292:	4604      	mov	r4, r0
 8005294:	2800      	cmp	r0, #0
 8005296:	f47f af79 	bne.w	800518c <f_mkdir+0x74>
					mem_set(dir, 0, SS(dj.fs));
 800529a:	4601      	mov	r1, r0
 800529c:	f44f 7200 	mov.w	r2, #512	; 0x200
 80052a0:	4628      	mov	r0, r5
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 80052a2:	f109 39ff 	add.w	r9, r9, #4294967295
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
 80052a6:	f7fe fb81 	bl	80039ac <mem_set>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 80052aa:	fa5f f989 	uxtb.w	r9, r9
					dj.fs->winsect = dsc++;
 80052ae:	9b06      	ldr	r3, [sp, #24]
 80052b0:	e7e0      	b.n	8005274 <f_mkdir+0x15c>
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 80052b2:	2401      	movs	r4, #1
 80052b4:	e76a      	b.n	800518c <f_mkdir+0x74>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
 80052b6:	4638      	mov	r0, r7
 80052b8:	f7ff fb6c 	bl	8004994 <dir_register>
			if (res != FR_OK) {
 80052bc:	4604      	mov	r4, r0
 80052be:	2800      	cmp	r0, #0
 80052c0:	f47f af64 	bne.w	800518c <f_mkdir+0x74>
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
 80052c4:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
 80052c8:	2210      	movs	r2, #16
 80052ca:	72da      	strb	r2, [r3, #11]
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
 80052cc:	f89d 2000 	ldrb.w	r2, [sp]
 80052d0:	75da      	strb	r2, [r3, #23]
 80052d2:	f89d 2004 	ldrb.w	r2, [sp, #4]
 80052d6:	761a      	strb	r2, [r3, #24]
 80052d8:	f89d 2008 	ldrb.w	r2, [sp, #8]
 80052dc:	765a      	strb	r2, [r3, #25]
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
 80052de:	f89d 200c 	ldrb.w	r2, [sp, #12]
 80052e2:	769a      	strb	r2, [r3, #26]
 80052e4:	f89d 2010 	ldrb.w	r2, [sp, #16]
 80052e8:	76da      	strb	r2, [r3, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 80052ea:	f89d 2014 	ldrb.w	r2, [sp, #20]
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
 80052ee:	f883 b016 	strb.w	fp, [r3, #22]
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
 80052f2:	751a      	strb	r2, [r3, #20]
 80052f4:	f883 8015 	strb.w	r8, [r3, #21]
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
 80052f8:	f8d7 0200 	ldr.w	r0, [r7, #512]	; 0x200
 80052fc:	2301      	movs	r3, #1
 80052fe:	f880 3204 	strb.w	r3, [r0, #516]	; 0x204
				res = sync_fs(dj.fs);
 8005302:	f7fe fc8b 	bl	8003c1c <sync_fs>
 8005306:	4604      	mov	r4, r0
 8005308:	e72f      	b.n	800516a <f_mkdir+0x52>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
 800530a:	f50d 7d17 	add.w	sp, sp, #604	; 0x25c
 800530e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08005314 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 8005314:	b530      	push	{r4, r5, lr}
  uint8_t ret = 1;
  uint8_t DiskNum = 0;
  
  if(disk.nbr <= _VOLUMES)
 8005316:	4b0f      	ldr	r3, [pc, #60]	; (8005354 <FATFS_LinkDriverEx+0x40>)
 8005318:	7a5c      	ldrb	r4, [r3, #9]
 800531a:	2c01      	cmp	r4, #1
 800531c:	d818      	bhi.n	8005350 <FATFS_LinkDriverEx+0x3c>
  {
    disk.is_initialized[disk.nbr] = 0;
 800531e:	7a5d      	ldrb	r5, [r3, #9]
 8005320:	b2ed      	uxtb	r5, r5
 8005322:	2400      	movs	r4, #0
 8005324:	555c      	strb	r4, [r3, r5]
    disk.drv[disk.nbr] = drv;  
 8005326:	7a5d      	ldrb	r5, [r3, #9]
 8005328:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 800532c:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;  
 800532e:	7a58      	ldrb	r0, [r3, #9]
 8005330:	4418      	add	r0, r3
 8005332:	7202      	strb	r2, [r0, #8]
    DiskNum = disk.nbr++;
 8005334:	7a5a      	ldrb	r2, [r3, #9]
 8005336:	b2d2      	uxtb	r2, r2
 8005338:	1c50      	adds	r0, r2, #1
 800533a:	b2c0      	uxtb	r0, r0
 800533c:	7258      	strb	r0, [r3, #9]
    path[0] = DiskNum + '0';
    path[1] = ':';
 800533e:	233a      	movs	r3, #58	; 0x3a
  {
    disk.is_initialized[disk.nbr] = 0;
    disk.drv[disk.nbr] = drv;  
    disk.lun[disk.nbr] = lun;  
    DiskNum = disk.nbr++;
    path[0] = DiskNum + '0';
 8005340:	3230      	adds	r2, #48	; 0x30
    path[1] = ':';
 8005342:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
 8005344:	232f      	movs	r3, #47	; 0x2f
  {
    disk.is_initialized[disk.nbr] = 0;
    disk.drv[disk.nbr] = drv;  
    disk.lun[disk.nbr] = lun;  
    DiskNum = disk.nbr++;
    path[0] = DiskNum + '0';
 8005346:	700a      	strb	r2, [r1, #0]
    path[1] = ':';
    path[2] = '/';
 8005348:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 800534a:	70cc      	strb	r4, [r1, #3]
 800534c:	4620      	mov	r0, r4
 800534e:	bd30      	pop	{r4, r5, pc}
            else the paramter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
 8005350:	2001      	movs	r0, #1
    path[3] = 0;
    ret = 0;
  }
  
  return ret;
}
 8005352:	bd30      	pop	{r4, r5, pc}
 8005354:	20000644 	.word	0x20000644

08005358 <FATFS_LinkDriver>:
  * @param  path: pointer to the logical drive path 
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
 8005358:	2200      	movs	r2, #0
 800535a:	f7ff bfdb 	b.w	8005314 <FATFS_LinkDriverEx>
	...

08005360 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used 
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 8005360:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 8005362:	4c06      	ldr	r4, [pc, #24]	; (800537c <SD_initialize+0x1c>)
 8005364:	2301      	movs	r3, #1
 8005366:	7023      	strb	r3, [r4, #0]
  
  /* Configure the uSD device */
  if(BSP_SD_Init() == MSD_OK)
 8005368:	f7fa ff58 	bl	800021c <BSP_SD_Init>
 800536c:	4623      	mov	r3, r4
 800536e:	b918      	cbnz	r0, 8005378 <SD_initialize+0x18>
  {
    Stat &= ~STA_NOINIT;
 8005370:	7822      	ldrb	r2, [r4, #0]
 8005372:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 8005376:	7022      	strb	r2, [r4, #0]
  }

  return Stat;
 8005378:	7818      	ldrb	r0, [r3, #0]
}
 800537a:	bd10      	pop	{r4, pc}
 800537c:	20000058 	.word	0x20000058

08005380 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 8005380:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 8005382:	4c06      	ldr	r4, [pc, #24]	; (800539c <SD_status+0x1c>)
 8005384:	2301      	movs	r3, #1
 8005386:	7023      	strb	r3, [r4, #0]

  if(BSP_SD_GetStatus() == MSD_OK)
 8005388:	f7fa ff80 	bl	800028c <BSP_SD_GetStatus>
 800538c:	4623      	mov	r3, r4
 800538e:	b918      	cbnz	r0, 8005398 <SD_status+0x18>
  {
    Stat &= ~STA_NOINIT;
 8005390:	7822      	ldrb	r2, [r4, #0]
 8005392:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 8005396:	7022      	strb	r2, [r4, #0]
  }
  
  return Stat;
 8005398:	7818      	ldrb	r0, [r3, #0]
}
 800539a:	bd10      	pop	{r4, pc}
 800539c:	20000058 	.word	0x20000058

080053a0 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 80053a0:	b507      	push	{r0, r1, r2, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_ReadBlocks((uint32_t*)buff, 
 80053a2:	9301      	str	r3, [sp, #4]
 80053a4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80053a8:	9300      	str	r3, [sp, #0]
 80053aa:	0252      	lsls	r2, r2, #9
 80053ac:	2300      	movs	r3, #0
 80053ae:	4608      	mov	r0, r1
 80053b0:	f7fa ff48 	bl	8000244 <BSP_SD_ReadBlocks>
  {
    res = RES_ERROR;
  }
  
  return res;
}
 80053b4:	3000      	adds	r0, #0
 80053b6:	bf18      	it	ne
 80053b8:	2001      	movne	r0, #1
 80053ba:	b003      	add	sp, #12
 80053bc:	f85d fb04 	ldr.w	pc, [sp], #4

080053c0 <SD_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 80053c0:	b507      	push	{r0, r1, r2, lr}
  DRESULT res = RES_OK;
  
  if(BSP_SD_WriteBlocks((uint32_t*)buff, 
 80053c2:	9301      	str	r3, [sp, #4]
 80053c4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80053c8:	9300      	str	r3, [sp, #0]
 80053ca:	0252      	lsls	r2, r2, #9
 80053cc:	2300      	movs	r3, #0
 80053ce:	4608      	mov	r0, r1
 80053d0:	f7fa ff4a 	bl	8000268 <BSP_SD_WriteBlocks>
  {
    res = RES_ERROR;
  }
  
  return res;
}
 80053d4:	3000      	adds	r0, #0
 80053d6:	bf18      	it	ne
 80053d8:	2001      	movne	r0, #1
 80053da:	b003      	add	sp, #12
 80053dc:	f85d fb04 	ldr.w	pc, [sp], #4

080053e0 <SD_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 80053e0:	b510      	push	{r4, lr}
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 80053e2:	4b13      	ldr	r3, [pc, #76]	; (8005430 <SD_ioctl+0x50>)
 80053e4:	781b      	ldrb	r3, [r3, #0]
 80053e6:	07db      	lsls	r3, r3, #31
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 80053e8:	b096      	sub	sp, #88	; 0x58
 80053ea:	4614      	mov	r4, r2
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 80053ec:	d41a      	bmi.n	8005424 <SD_ioctl+0x44>
  
  switch (cmd)
 80053ee:	2903      	cmp	r1, #3
 80053f0:	d803      	bhi.n	80053fa <SD_ioctl+0x1a>
 80053f2:	e8df f001 	tbb	[pc, r1]
 80053f6:	0419      	.short	0x0419
 80053f8:	120e      	.short	0x120e
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
    break;
  
  default:
    res = RES_PARERR;
 80053fa:	2004      	movs	r0, #4
 80053fc:	e015      	b.n	800542a <SD_ioctl+0x4a>
    res = RES_OK;
    break;
  
  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    BSP_SD_GetCardInfo(&CardInfo);
 80053fe:	4668      	mov	r0, sp
 8005400:	f7fa ff4a 	bl	8000298 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.CardCapacity / BLOCK_SIZE;
 8005404:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8005406:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8005408:	0a5b      	lsrs	r3, r3, #9
 800540a:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 800540e:	6023      	str	r3, [r4, #0]
 8005410:	e00a      	b.n	8005428 <SD_ioctl+0x48>
    res = RES_OK;
    break;
  
  /* Get R/W sector size (WORD) */
  case GET_SECTOR_SIZE :
    *(WORD*)buff = BLOCK_SIZE;
 8005412:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005416:	8013      	strh	r3, [r2, #0]
 8005418:	e006      	b.n	8005428 <SD_ioctl+0x48>
    res = RES_OK;
    break;
  
  /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
 800541a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800541e:	6013      	str	r3, [r2, #0]
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
 8005420:	2001      	movs	r0, #1
    break;
  
  /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :
    *(DWORD*)buff = BLOCK_SIZE;
    break;
 8005422:	e002      	b.n	800542a <SD_ioctl+0x4a>
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  SD_CardInfo CardInfo;
  
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8005424:	2003      	movs	r0, #3
 8005426:	e000      	b.n	800542a <SD_ioctl+0x4a>
  
  switch (cmd)
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC :
    res = RES_OK;
 8005428:	2000      	movs	r0, #0
  default:
    res = RES_PARERR;
  }
  
  return res;
}
 800542a:	b016      	add	sp, #88	; 0x58
 800542c:	bd10      	pop	{r4, pc}
 800542e:	bf00      	nop
 8005430:	20000058 	.word	0x20000058

08005434 <ff_memalloc>:

void* ff_memalloc (	/* Returns pointer to the allocated memory block */
	UINT msize		/* Number of bytes to allocate */
)
{
	return malloc(msize);	/* Allocate a new memory block with POSIX API */
 8005434:	f001 baf4 	b.w	8006a20 <malloc>

08005438 <ff_memfree>:

void ff_memfree (
	void* mblock	/* Pointer to the memory block to free */
)
{
	free(mblock);	/* Discard the memory block with POSIX API */
 8005438:	f001 bafa 	b.w	8006a30 <free>

0800543c <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 800543c:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 800543e:	b180      	cbz	r0, 8005462 <USBD_Init+0x26>
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8005440:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005444:	b113      	cbz	r3, 800544c <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 8005446:	2300      	movs	r3, #0
 8005448:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 800544c:	b109      	cbz	r1, 8005452 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 800544e:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8005452:	2301      	movs	r3, #1
 8005454:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 8005458:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 800545a:	f7fb f9d3 	bl	8000804 <USBD_LL_Init>
  
  return USBD_OK; 
 800545e:	2000      	movs	r0, #0
 8005460:	bd08      	pop	{r3, pc}
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
 8005462:	2002      	movs	r0, #2
  pdev->id = id;
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  
  return USBD_OK; 
}
 8005464:	bd08      	pop	{r3, pc}

08005466 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 8005466:	b119      	cbz	r1, 8005470 <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8005468:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 800546c:	2000      	movs	r0, #0
 800546e:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 8005470:	2002      	movs	r0, #2
  }
  
  return status;
}
 8005472:	4770      	bx	lr

08005474 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8005474:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 8005476:	f7fb f9f5 	bl	8000864 <USBD_LL_Start>
  
  return USBD_OK;  
}
 800547a:	2000      	movs	r0, #0
 800547c:	bd08      	pop	{r3, pc}

0800547e <USBD_Stop>:
  *         Stop the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
{
 800547e:	b510      	push	{r4, lr}
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8005480:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005484:	7901      	ldrb	r1, [r0, #4]
 8005486:	685b      	ldr	r3, [r3, #4]
  *         Stop the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
{
 8005488:	4604      	mov	r4, r0
  /* Free Class Resources */
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 800548a:	4798      	blx	r3

  /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
 800548c:	4620      	mov	r0, r4
 800548e:	f7fb f9f0 	bl	8000872 <USBD_LL_Stop>
  
  return USBD_OK;  
}
 8005492:	2000      	movs	r0, #0
 8005494:	bd10      	pop	{r4, pc}

08005496 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8005496:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 8005498:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800549c:	b90b      	cbnz	r3, 80054a2 <USBD_SetClassConfig+0xc>
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  USBD_StatusTypeDef   ret = USBD_FAIL;
 800549e:	2002      	movs	r0, #2
 80054a0:	bd08      	pop	{r3, pc}
  
  if(pdev->pClass != NULL)
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 80054a2:	681b      	ldr	r3, [r3, #0]
 80054a4:	4798      	blx	r3
 80054a6:	2800      	cmp	r0, #0
 80054a8:	d1f9      	bne.n	800549e <USBD_SetClassConfig+0x8>
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
 80054aa:	bd08      	pop	{r3, pc}

080054ac <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 80054ac:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 80054ae:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80054b2:	685b      	ldr	r3, [r3, #4]
 80054b4:	4798      	blx	r3
  return USBD_OK;
}
 80054b6:	2000      	movs	r0, #0
 80054b8:	bd08      	pop	{r3, pc}

080054ba <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80054ba:	b538      	push	{r3, r4, r5, lr}
 80054bc:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 80054be:	f500 7502 	add.w	r5, r0, #520	; 0x208
 80054c2:	4628      	mov	r0, r5
 80054c4:	f000 f8f3 	bl	80056ae <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 80054c8:	2301      	movs	r3, #1
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
 80054ca:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{

  USBD_ParseSetupRequest(&pdev->request, psetup);
  
  pdev->ep0_state = USBD_EP0_SETUP;
 80054ce:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 80054d2:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 80054d6:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 80054da:	f001 031f 	and.w	r3, r1, #31
 80054de:	2b01      	cmp	r3, #1
 80054e0:	d00c      	beq.n	80054fc <USBD_LL_SetupStage+0x42>
 80054e2:	d306      	bcc.n	80054f2 <USBD_LL_SetupStage+0x38>
 80054e4:	2b02      	cmp	r3, #2
 80054e6:	d10e      	bne.n	8005506 <USBD_LL_SetupStage+0x4c>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
 80054e8:	4629      	mov	r1, r5
 80054ea:	4620      	mov	r0, r4
 80054ec:	f000 fa26 	bl	800593c <USBD_StdEPReq>
    break;
 80054f0:	e00e      	b.n	8005510 <USBD_LL_SetupStage+0x56>
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
 80054f2:	4629      	mov	r1, r5
 80054f4:	4620      	mov	r0, r4
 80054f6:	f000 f8f9 	bl	80056ec <USBD_StdDevReq>
    break;
 80054fa:	e009      	b.n	8005510 <USBD_LL_SetupStage+0x56>
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
 80054fc:	4629      	mov	r1, r5
 80054fe:	4620      	mov	r0, r4
 8005500:	f000 fa04 	bl	800590c <USBD_StdItfReq>
    break;
 8005504:	e004      	b.n	8005510 <USBD_LL_SetupStage+0x56>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 8005506:	f001 0180 	and.w	r1, r1, #128	; 0x80
 800550a:	4620      	mov	r0, r4
 800550c:	f7fb f9d0 	bl	80008b0 <USBD_LL_StallEP>
    break;
  }  
  return USBD_OK;  
}
 8005510:	2000      	movs	r0, #0
 8005512:	bd38      	pop	{r3, r4, r5, pc}

08005514 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 8005514:	b538      	push	{r3, r4, r5, lr}
 8005516:	4604      	mov	r4, r0
 8005518:	4615      	mov	r5, r2
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 800551a:	bb09      	cbnz	r1, 8005560 <USBD_LL_DataOutStage+0x4c>
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 800551c:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
 8005520:	2b03      	cmp	r3, #3
 8005522:	d126      	bne.n	8005572 <USBD_LL_DataOutStage+0x5e>
    {
      if(pep->rem_length > pep->maxpacket)
 8005524:	f8d0 110c 	ldr.w	r1, [r0, #268]	; 0x10c
 8005528:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 800552c:	4291      	cmp	r1, r2
 800552e:	d90a      	bls.n	8005546 <USBD_LL_DataOutStage+0x32>
      {
        pep->rem_length -=  pep->maxpacket;
 8005530:	1a8b      	subs	r3, r1, r2
       
        USBD_CtlContinueRx (pdev, 
 8005532:	429a      	cmp	r2, r3
 8005534:	bf28      	it	cs
 8005536:	461a      	movcs	r2, r3
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
 8005538:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
       
        USBD_CtlContinueRx (pdev, 
 800553c:	b292      	uxth	r2, r2
 800553e:	4629      	mov	r1, r5
 8005540:	f000 fa90 	bl	8005a64 <USBD_CtlContinueRx>
 8005544:	e015      	b.n	8005572 <USBD_LL_DataOutStage+0x5e>
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8005546:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800554a:	691b      	ldr	r3, [r3, #16]
 800554c:	b123      	cbz	r3, 8005558 <USBD_LL_DataOutStage+0x44>
 800554e:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8005552:	2a03      	cmp	r2, #3
 8005554:	d100      	bne.n	8005558 <USBD_LL_DataOutStage+0x44>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
 8005556:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 8005558:	4620      	mov	r0, r4
 800555a:	f000 fa8b 	bl	8005a74 <USBD_CtlSendStatus>
 800555e:	e008      	b.n	8005572 <USBD_LL_DataOutStage+0x5e>
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 8005560:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005564:	699b      	ldr	r3, [r3, #24]
 8005566:	b123      	cbz	r3, 8005572 <USBD_LL_DataOutStage+0x5e>
 8005568:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800556c:	2a03      	cmp	r2, #3
 800556e:	d100      	bne.n	8005572 <USBD_LL_DataOutStage+0x5e>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
 8005570:	4798      	blx	r3
  }  
  return USBD_OK;
}
 8005572:	2000      	movs	r0, #0
 8005574:	bd38      	pop	{r3, r4, r5, pc}

08005576 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8005576:	b570      	push	{r4, r5, r6, lr}
 8005578:	4613      	mov	r3, r2
 800557a:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 800557c:	460e      	mov	r6, r1
 800557e:	2900      	cmp	r1, #0
 8005580:	d13c      	bne.n	80055fc <USBD_LL_DataInStage+0x86>
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8005582:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8005586:	2a02      	cmp	r2, #2
 8005588:	d130      	bne.n	80055ec <USBD_LL_DataInStage+0x76>
    {
      if(pep->rem_length > pep->maxpacket)
 800558a:	69c5      	ldr	r5, [r0, #28]
 800558c:	6a02      	ldr	r2, [r0, #32]
 800558e:	4295      	cmp	r5, r2
 8005590:	d907      	bls.n	80055a2 <USBD_LL_DataInStage+0x2c>
      {
        pep->rem_length -=  pep->maxpacket;
 8005592:	1aaa      	subs	r2, r5, r2
 8005594:	61c2      	str	r2, [r0, #28]
        
        USBD_CtlContinueSendData (pdev, 
 8005596:	4619      	mov	r1, r3
 8005598:	b292      	uxth	r2, r2
 800559a:	f000 fa5b 	bl	8005a54 <USBD_CtlContinueSendData>
                                  pdata, 
                                  pep->rem_length);
        
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 800559e:	4633      	mov	r3, r6
 80055a0:	e011      	b.n	80055c6 <USBD_LL_DataInStage+0x50>
                                NULL,
                                0);  
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
 80055a2:	6983      	ldr	r3, [r0, #24]
 80055a4:	fbb3 f5f2 	udiv	r5, r3, r2
 80055a8:	fb02 3515 	mls	r5, r2, r5, r3
 80055ac:	b98d      	cbnz	r5, 80055d2 <USBD_LL_DataInStage+0x5c>
 80055ae:	429a      	cmp	r2, r3
 80055b0:	d80f      	bhi.n	80055d2 <USBD_LL_DataInStage+0x5c>
           (pep->total_length >= pep->maxpacket) &&
 80055b2:	f8d0 21f8 	ldr.w	r2, [r0, #504]	; 0x1f8
 80055b6:	4293      	cmp	r3, r2
 80055b8:	d20b      	bcs.n	80055d2 <USBD_LL_DataInStage+0x5c>
             (pep->total_length < pdev->ep0_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 80055ba:	462a      	mov	r2, r5
 80055bc:	f000 fa4a 	bl	8005a54 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 80055c0:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
          
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 80055c4:	462b      	mov	r3, r5
 80055c6:	461a      	mov	r2, r3
 80055c8:	4619      	mov	r1, r3
 80055ca:	4620      	mov	r0, r4
 80055cc:	f7fb f99f 	bl	800090e <USBD_LL_PrepareReceive>
 80055d0:	e00c      	b.n	80055ec <USBD_LL_DataInStage+0x76>
                                NULL,
                                0);
        }
        else
        {
          if((pdev->pClass->EP0_TxSent != NULL)&&
 80055d2:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80055d6:	68db      	ldr	r3, [r3, #12]
 80055d8:	b12b      	cbz	r3, 80055e6 <USBD_LL_DataInStage+0x70>
 80055da:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 80055de:	2a03      	cmp	r2, #3
 80055e0:	d101      	bne.n	80055e6 <USBD_LL_DataInStage+0x70>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
          {
            pdev->pClass->EP0_TxSent(pdev); 
 80055e2:	4620      	mov	r0, r4
 80055e4:	4798      	blx	r3
          }          
          USBD_CtlReceiveStatus(pdev);
 80055e6:	4620      	mov	r0, r4
 80055e8:	f000 fa4f 	bl	8005a8a <USBD_CtlReceiveStatus>
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 80055ec:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 80055f0:	2b01      	cmp	r3, #1
 80055f2:	d10c      	bne.n	800560e <USBD_LL_DataInStage+0x98>
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
 80055f4:	2300      	movs	r3, #0
 80055f6:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
 80055fa:	e008      	b.n	800560e <USBD_LL_DataInStage+0x98>
    }
  }
  else if((pdev->pClass->DataIn != NULL)&& 
 80055fc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005600:	695b      	ldr	r3, [r3, #20]
 8005602:	b123      	cbz	r3, 800560e <USBD_LL_DataInStage+0x98>
 8005604:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8005608:	2a03      	cmp	r2, #3
 800560a:	d100      	bne.n	800560e <USBD_LL_DataInStage+0x98>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
 800560c:	4798      	blx	r3
  }  
  return USBD_OK;
}
 800560e:	2000      	movs	r0, #0
 8005610:	bd70      	pop	{r4, r5, r6, pc}

08005612 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8005612:	b538      	push	{r3, r4, r5, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8005614:	2200      	movs	r2, #0
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8005616:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8005618:	4611      	mov	r1, r2
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800561a:	2540      	movs	r5, #64	; 0x40
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 800561c:	2340      	movs	r3, #64	; 0x40
 800561e:	f7fb f92f 	bl	8000880 <USBD_LL_OpenEP>
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8005622:	462b      	mov	r3, r5
  USBD_LL_OpenEP(pdev,
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8005624:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8005628:	2200      	movs	r2, #0
 800562a:	2180      	movs	r1, #128	; 0x80
 800562c:	4620      	mov	r0, r4
 800562e:	f7fb f927 	bl	8000880 <USBD_LL_OpenEP>
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8005632:	2301      	movs	r3, #1
 8005634:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8005638:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  USBD_LL_OpenEP(pdev,
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 800563c:	6225      	str	r5, [r4, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  
  if (pdev->pClassData) 
 800563e:	b12b      	cbz	r3, 800564c <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8005640:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8005644:	7921      	ldrb	r1, [r4, #4]
 8005646:	685b      	ldr	r3, [r3, #4]
 8005648:	4620      	mov	r0, r4
 800564a:	4798      	blx	r3
 
  
  return USBD_OK;
}
 800564c:	2000      	movs	r0, #0
 800564e:	bd38      	pop	{r3, r4, r5, pc}

08005650 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8005650:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8005652:	2000      	movs	r0, #0
 8005654:	4770      	bx	lr

08005656 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8005656:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800565a:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 800565e:	2304      	movs	r3, #4
 8005660:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8005664:	2000      	movs	r0, #0
 8005666:	4770      	bx	lr

08005668 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 8005668:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 800566c:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8005670:	2000      	movs	r0, #0
 8005672:	4770      	bx	lr

08005674 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8005674:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8005676:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800567a:	2a03      	cmp	r2, #3
 800567c:	d104      	bne.n	8005688 <USBD_LL_SOF+0x14>
  {
    if(pdev->pClass->SOF != NULL)
 800567e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005682:	69db      	ldr	r3, [r3, #28]
 8005684:	b103      	cbz	r3, 8005688 <USBD_LL_SOF+0x14>
    {
      pdev->pClass->SOF(pdev);
 8005686:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 8005688:	2000      	movs	r0, #0
 800568a:	bd08      	pop	{r3, pc}

0800568c <USBD_LL_IsoINIncomplete>:
 800568c:	2000      	movs	r0, #0
 800568e:	4770      	bx	lr

08005690 <USBD_LL_IsoOUTIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 8005690:	2000      	movs	r0, #0
 8005692:	4770      	bx	lr

08005694 <USBD_LL_DevConnected>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
{
  return USBD_OK;
}
 8005694:	2000      	movs	r0, #0
 8005696:	4770      	bx	lr

08005698 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 8005698:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800569a:	2201      	movs	r2, #1
 800569c:	f880 21fc 	strb.w	r2, [r0, #508]	; 0x1fc
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 80056a0:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
 80056a4:	7901      	ldrb	r1, [r0, #4]
 80056a6:	6852      	ldr	r2, [r2, #4]
 80056a8:	4790      	blx	r2
   
  return USBD_OK;
}
 80056aa:	2000      	movs	r0, #0
 80056ac:	bd08      	pop	{r3, pc}

080056ae <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
 80056ae:	780b      	ldrb	r3, [r1, #0]
 80056b0:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 80056b2:	784b      	ldrb	r3, [r1, #1]
 80056b4:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 80056b6:	78ca      	ldrb	r2, [r1, #3]
 80056b8:	788b      	ldrb	r3, [r1, #2]
 80056ba:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80056be:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 80056c0:	794a      	ldrb	r2, [r1, #5]
 80056c2:	790b      	ldrb	r3, [r1, #4]
 80056c4:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80056c8:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 80056ca:	79ca      	ldrb	r2, [r1, #7]
 80056cc:	798b      	ldrb	r3, [r1, #6]
 80056ce:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80056d2:	80c3      	strh	r3, [r0, #6]
 80056d4:	4770      	bx	lr

080056d6 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 80056d6:	b510      	push	{r4, lr}
  USBD_LL_StallEP(pdev , 0x80);
 80056d8:	2180      	movs	r1, #128	; 0x80
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 80056da:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 80056dc:	f7fb f8e8 	bl	80008b0 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 80056e0:	4620      	mov	r0, r4
 80056e2:	2100      	movs	r1, #0
}
 80056e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
  USBD_LL_StallEP(pdev , 0);
 80056e8:	f7fb b8e2 	b.w	80008b0 <USBD_LL_StallEP>

080056ec <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80056ec:	b573      	push	{r0, r1, r4, r5, r6, lr}
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 80056ee:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80056f0:	4604      	mov	r4, r0
 80056f2:	460d      	mov	r5, r1
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 80056f4:	2b09      	cmp	r3, #9
 80056f6:	f200 80ff 	bhi.w	80058f8 <USBD_StdDevReq+0x20c>
 80056fa:	e8df f013 	tbh	[pc, r3, lsl #1]
 80056fe:	00d1      	.short	0x00d1
 8005700:	00fd00e8 	.word	0x00fd00e8
 8005704:	00fd00e4 	.word	0x00fd00e4
 8005708:	000a007b 	.word	0x000a007b
 800570c:	00c100fd 	.word	0x00c100fd
 8005710:	0097      	.short	0x0097
{
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
 8005712:	8849      	ldrh	r1, [r1, #2]
 8005714:	0a0b      	lsrs	r3, r1, #8
 8005716:	3b01      	subs	r3, #1
 8005718:	2b06      	cmp	r3, #6
 800571a:	f200 80ed 	bhi.w	80058f8 <USBD_StdDevReq+0x20c>
 800571e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005722:	0007      	.short	0x0007
 8005724:	0017000b 	.word	0x0017000b
 8005728:	00eb00eb 	.word	0x00eb00eb
 800572c:	004d0042 	.word	0x004d0042
  case USB_DESC_TYPE_BOS:
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    break;
#endif    
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8005730:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005734:	681b      	ldr	r3, [r3, #0]
 8005736:	e016      	b.n	8005766 <USBD_StdDevReq+0x7a>
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8005738:	7c02      	ldrb	r2, [r0, #16]
 800573a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800573e:	b90a      	cbnz	r2, 8005744 <USBD_StdDevReq+0x58>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 8005740:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005742:	e000      	b.n	8005746 <USBD_StdDevReq+0x5a>
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8005744:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005746:	f10d 0006 	add.w	r0, sp, #6
 800574a:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800574c:	2302      	movs	r3, #2
 800574e:	e040      	b.n	80057d2 <USBD_StdDevReq+0xe6>
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 8005750:	b2c9      	uxtb	r1, r1
 8005752:	2905      	cmp	r1, #5
 8005754:	d820      	bhi.n	8005798 <USBD_StdDevReq+0xac>
 8005756:	e8df f001 	tbb	[pc, r1]
 800575a:	0b03      	.short	0x0b03
 800575c:	1b17130f 	.word	0x1b17130f
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8005760:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005764:	685b      	ldr	r3, [r3, #4]
 8005766:	7c20      	ldrb	r0, [r4, #16]
 8005768:	f10d 0106 	add.w	r1, sp, #6
 800576c:	4798      	blx	r3
 800576e:	e031      	b.n	80057d4 <USBD_StdDevReq+0xe8>
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8005770:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005774:	689b      	ldr	r3, [r3, #8]
 8005776:	e7f6      	b.n	8005766 <USBD_StdDevReq+0x7a>
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8005778:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800577c:	68db      	ldr	r3, [r3, #12]
 800577e:	e7f2      	b.n	8005766 <USBD_StdDevReq+0x7a>
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8005780:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005784:	691b      	ldr	r3, [r3, #16]
 8005786:	e7ee      	b.n	8005766 <USBD_StdDevReq+0x7a>
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8005788:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800578c:	695b      	ldr	r3, [r3, #20]
 800578e:	e7ea      	b.n	8005766 <USBD_StdDevReq+0x7a>
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8005790:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005794:	699b      	ldr	r3, [r3, #24]
 8005796:	e7e6      	b.n	8005766 <USBD_StdDevReq+0x7a>
      break;
      
    default:
#if (USBD_SUPPORT_USER_STRING == 1)
      pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue) , &len);
 8005798:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800579c:	f10d 0206 	add.w	r2, sp, #6
 80057a0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80057a2:	4798      	blx	r3
 80057a4:	e016      	b.n	80057d4 <USBD_StdDevReq+0xe8>
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 80057a6:	7c03      	ldrb	r3, [r0, #16]
 80057a8:	2b00      	cmp	r3, #0
 80057aa:	f040 80a5 	bne.w	80058f8 <USBD_StdDevReq+0x20c>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 80057ae:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80057b2:	f10d 0006 	add.w	r0, sp, #6
 80057b6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80057b8:	4798      	blx	r3
 80057ba:	e00b      	b.n	80057d4 <USBD_StdDevReq+0xe8>
      USBD_CtlError(pdev , req);
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 80057bc:	7c03      	ldrb	r3, [r0, #16]
 80057be:	2b00      	cmp	r3, #0
 80057c0:	f040 809a 	bne.w	80058f8 <USBD_StdDevReq+0x20c>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 80057c4:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80057c8:	f10d 0006 	add.w	r0, sp, #6
 80057cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80057ce:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80057d0:	2307      	movs	r3, #7
 80057d2:	7043      	strb	r3, [r0, #1]
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 80057d4:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80057d8:	2a00      	cmp	r2, #0
 80057da:	f000 8091 	beq.w	8005900 <USBD_StdDevReq+0x214>
 80057de:	88eb      	ldrh	r3, [r5, #6]
 80057e0:	2b00      	cmp	r3, #0
 80057e2:	f000 808d 	beq.w	8005900 <USBD_StdDevReq+0x214>
  {
    
    len = MIN(len , req->wLength);
 80057e6:	429a      	cmp	r2, r3
 80057e8:	bf28      	it	cs
 80057ea:	461a      	movcs	r2, r3
 80057ec:	f8ad 2006 	strh.w	r2, [sp, #6]
    
    USBD_CtlSendData (pdev, 
 80057f0:	4601      	mov	r1, r0
 80057f2:	e064      	b.n	80058be <USBD_StdDevReq+0x1d2>
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 80057f4:	888b      	ldrh	r3, [r1, #4]
 80057f6:	2b00      	cmp	r3, #0
 80057f8:	d17e      	bne.n	80058f8 <USBD_StdDevReq+0x20c>
 80057fa:	88cb      	ldrh	r3, [r1, #6]
 80057fc:	2b00      	cmp	r3, #0
 80057fe:	d17b      	bne.n	80058f8 <USBD_StdDevReq+0x20c>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8005800:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8005804:	788e      	ldrb	r6, [r1, #2]
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8005806:	2b03      	cmp	r3, #3
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8005808:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 800580c:	d074      	beq.n	80058f8 <USBD_StdDevReq+0x20c>
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev_address = dev_addr;
 800580e:	f880 61fe 	strb.w	r6, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 8005812:	4631      	mov	r1, r6
 8005814:	f7fb f86d 	bl	80008f2 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 8005818:	4620      	mov	r0, r4
 800581a:	f000 f92b 	bl	8005a74 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 800581e:	b10e      	cbz	r6, 8005824 <USBD_StdDevReq+0x138>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 8005820:	2302      	movs	r3, #2
 8005822:	e000      	b.n	8005826 <USBD_StdDevReq+0x13a>
      } 
      else 
      {
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8005824:	2301      	movs	r3, #1
 8005826:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
 800582a:	e069      	b.n	8005900 <USBD_StdDevReq+0x214>
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 800582c:	7889      	ldrb	r1, [r1, #2]
 800582e:	4e36      	ldr	r6, [pc, #216]	; (8005908 <USBD_StdDevReq+0x21c>)
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8005830:	2901      	cmp	r1, #1
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8005832:	7031      	strb	r1, [r6, #0]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8005834:	d860      	bhi.n	80058f8 <USBD_StdDevReq+0x20c>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
 8005836:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800583a:	2b02      	cmp	r3, #2
 800583c:	d002      	beq.n	8005844 <USBD_StdDevReq+0x158>
 800583e:	2b03      	cmp	r3, #3
 8005840:	d008      	beq.n	8005854 <USBD_StdDevReq+0x168>
 8005842:	e059      	b.n	80058f8 <USBD_StdDevReq+0x20c>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
 8005844:	2900      	cmp	r1, #0
 8005846:	d053      	beq.n	80058f0 <USBD_StdDevReq+0x204>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 8005848:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 800584a:	2303      	movs	r3, #3
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 800584c:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 800584e:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
 8005852:	e00f      	b.n	8005874 <USBD_StdDevReq+0x188>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
 8005854:	b931      	cbnz	r1, 8005864 <USBD_StdDevReq+0x178>
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8005856:	2302      	movs	r3, #2
 8005858:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 800585c:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 800585e:	f7ff fe25 	bl	80054ac <USBD_ClrClassConfig>
 8005862:	e045      	b.n	80058f0 <USBD_StdDevReq+0x204>
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev_config) 
 8005864:	6841      	ldr	r1, [r0, #4]
 8005866:	2901      	cmp	r1, #1
 8005868:	d042      	beq.n	80058f0 <USBD_StdDevReq+0x204>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 800586a:	b2c9      	uxtb	r1, r1
 800586c:	f7ff fe1e 	bl	80054ac <USBD_ClrClassConfig>
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
 8005870:	7831      	ldrb	r1, [r6, #0]
 8005872:	6061      	str	r1, [r4, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8005874:	4620      	mov	r0, r4
 8005876:	f7ff fe0e 	bl	8005496 <USBD_SetClassConfig>
 800587a:	2802      	cmp	r0, #2
 800587c:	d138      	bne.n	80058f0 <USBD_StdDevReq+0x204>
 800587e:	e03b      	b.n	80058f8 <USBD_StdDevReq+0x20c>
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{

  if (req->wLength != 1) 
 8005880:	88ca      	ldrh	r2, [r1, #6]
 8005882:	2a01      	cmp	r2, #1
 8005884:	d138      	bne.n	80058f8 <USBD_StdDevReq+0x20c>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
 8005886:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800588a:	2b02      	cmp	r3, #2
 800588c:	d003      	beq.n	8005896 <USBD_StdDevReq+0x1aa>
 800588e:	2b03      	cmp	r3, #3
 8005890:	d132      	bne.n	80058f8 <USBD_StdDevReq+0x20c>
                        1);
      break;
      
    case USBD_STATE_CONFIGURED:   
      
      USBD_CtlSendData (pdev, 
 8005892:	1d01      	adds	r1, r0, #4
 8005894:	e013      	b.n	80058be <USBD_StdDevReq+0x1d2>
  else 
  {
    switch (pdev->dev_state )  
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
 8005896:	4601      	mov	r1, r0
 8005898:	2300      	movs	r3, #0
 800589a:	f841 3f08 	str.w	r3, [r1, #8]!
 800589e:	e00e      	b.n	80058be <USBD_StdDevReq+0x1d2>
static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
  
    
  switch (pdev->dev_state) 
 80058a0:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80058a4:	3b02      	subs	r3, #2
 80058a6:	2b01      	cmp	r3, #1
 80058a8:	d826      	bhi.n	80058f8 <USBD_StdDevReq+0x20c>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 80058aa:	2301      	movs	r3, #1
 80058ac:	60c3      	str	r3, [r0, #12]
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
 80058ae:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 80058b2:	b10b      	cbz	r3, 80058b8 <USBD_StdDevReq+0x1cc>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 80058b4:	2303      	movs	r3, #3
 80058b6:	60c3      	str	r3, [r0, #12]
    }
    
    USBD_CtlSendData (pdev, 
 80058b8:	2202      	movs	r2, #2
 80058ba:	f104 010c 	add.w	r1, r4, #12
 80058be:	4620      	mov	r0, r4
 80058c0:	f000 f8bb 	bl	8005a3a <USBD_CtlSendData>
 80058c4:	e01c      	b.n	8005900 <USBD_StdDevReq+0x214>
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80058c6:	884b      	ldrh	r3, [r1, #2]
 80058c8:	2b01      	cmp	r3, #1
 80058ca:	d119      	bne.n	8005900 <USBD_StdDevReq+0x214>
 80058cc:	e008      	b.n	80058e0 <USBD_StdDevReq+0x1f4>
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  switch (pdev->dev_state)
 80058ce:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80058d2:	3b02      	subs	r3, #2
 80058d4:	2b01      	cmp	r3, #1
 80058d6:	d80f      	bhi.n	80058f8 <USBD_StdDevReq+0x20c>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 80058d8:	884b      	ldrh	r3, [r1, #2]
 80058da:	2b01      	cmp	r3, #1
 80058dc:	d110      	bne.n	8005900 <USBD_StdDevReq+0x214>
    {
      pdev->dev_remote_wakeup = 0; 
 80058de:	2300      	movs	r3, #0
 80058e0:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 80058e4:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80058e8:	4629      	mov	r1, r5
 80058ea:	689b      	ldr	r3, [r3, #8]
 80058ec:	4620      	mov	r0, r4
 80058ee:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 80058f0:	4620      	mov	r0, r4
 80058f2:	f000 f8bf 	bl	8005a74 <USBD_CtlSendStatus>
 80058f6:	e003      	b.n	8005900 <USBD_StdDevReq+0x214>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
 80058f8:	4629      	mov	r1, r5
 80058fa:	4620      	mov	r0, r4
 80058fc:	f7ff feeb 	bl	80056d6 <USBD_CtlError>
    break;
  }
  
  return ret;
}
 8005900:	2000      	movs	r0, #0
 8005902:	b002      	add	sp, #8
 8005904:	bd70      	pop	{r4, r5, r6, pc}
 8005906:	bf00      	nop
 8005908:	20000650 	.word	0x20000650

0800590c <USBD_StdItfReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 800590c:	b538      	push	{r3, r4, r5, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 800590e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8005912:	2b03      	cmp	r3, #3
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8005914:	4604      	mov	r4, r0
 8005916:	460d      	mov	r5, r1
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 8005918:	d10c      	bne.n	8005934 <USBD_StdItfReq+0x28>
  {
  case USBD_STATE_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 800591a:	790b      	ldrb	r3, [r1, #4]
 800591c:	2b01      	cmp	r3, #1
 800591e:	d809      	bhi.n	8005934 <USBD_StdItfReq+0x28>
    {
      pdev->pClass->Setup (pdev, req); 
 8005920:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005924:	689b      	ldr	r3, [r3, #8]
 8005926:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 8005928:	88eb      	ldrh	r3, [r5, #6]
 800592a:	b92b      	cbnz	r3, 8005938 <USBD_StdItfReq+0x2c>
      {
         USBD_CtlSendStatus(pdev);
 800592c:	4620      	mov	r0, r4
 800592e:	f000 f8a1 	bl	8005a74 <USBD_CtlSendStatus>
 8005932:	e001      	b.n	8005938 <USBD_StdItfReq+0x2c>
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
 8005934:	f7ff fecf 	bl	80056d6 <USBD_CtlError>
    break;
  }
  return USBD_OK;
}
 8005938:	2000      	movs	r0, #0
 800593a:	bd38      	pop	{r3, r4, r5, pc}

0800593c <USBD_StdEPReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 800593c:	b570      	push	{r4, r5, r6, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 800593e:	780a      	ldrb	r2, [r1, #0]
{
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 8005940:	888e      	ldrh	r6, [r1, #4]
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 8005942:	f002 0260 	and.w	r2, r2, #96	; 0x60
 8005946:	2a20      	cmp	r2, #32
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8005948:	4604      	mov	r4, r0
 800594a:	460d      	mov	r5, r1
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 800594c:	b2f3      	uxtb	r3, r6
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 800594e:	d104      	bne.n	800595a <USBD_StdEPReq+0x1e>
  {
    pdev->pClass->Setup (pdev, req);
 8005950:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005954:	689b      	ldr	r3, [r3, #8]
 8005956:	4798      	blx	r3
    
    return USBD_OK;
 8005958:	e051      	b.n	80059fe <USBD_StdEPReq+0xc2>
  }
  
  switch (req->bRequest) 
 800595a:	784a      	ldrb	r2, [r1, #1]
 800595c:	2a01      	cmp	r2, #1
 800595e:	d010      	beq.n	8005982 <USBD_StdEPReq+0x46>
 8005960:	d326      	bcc.n	80059b0 <USBD_StdEPReq+0x74>
 8005962:	2a03      	cmp	r2, #3
 8005964:	d14b      	bne.n	80059fe <USBD_StdEPReq+0xc2>
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev_state) 
 8005966:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800596a:	2a02      	cmp	r2, #2
 800596c:	d027      	beq.n	80059be <USBD_StdEPReq+0x82>
 800596e:	2a03      	cmp	r2, #3
 8005970:	d143      	bne.n	80059fa <USBD_StdEPReq+0xbe>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 8005972:	884a      	ldrh	r2, [r1, #2]
 8005974:	b992      	cbnz	r2, 800599c <USBD_StdEPReq+0x60>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8005976:	065e      	lsls	r6, r3, #25
 8005978:	d010      	beq.n	800599c <USBD_StdEPReq+0x60>
        { 
          USBD_LL_StallEP(pdev , ep_addr);
 800597a:	4619      	mov	r1, r3
 800597c:	f7fa ff98 	bl	80008b0 <USBD_LL_StallEP>
 8005980:	e00c      	b.n	800599c <USBD_StdEPReq+0x60>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev_state) 
 8005982:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8005986:	2a02      	cmp	r2, #2
 8005988:	d019      	beq.n	80059be <USBD_StdEPReq+0x82>
 800598a:	2a03      	cmp	r2, #3
 800598c:	d135      	bne.n	80059fa <USBD_StdEPReq+0xbe>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 800598e:	884a      	ldrh	r2, [r1, #2]
 8005990:	bbaa      	cbnz	r2, 80059fe <USBD_StdEPReq+0xc2>
      {
        if ((ep_addr & 0x7F) != 0x00) 
 8005992:	0659      	lsls	r1, r3, #25
 8005994:	d008      	beq.n	80059a8 <USBD_StdEPReq+0x6c>
        {        
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8005996:	4619      	mov	r1, r3
 8005998:	f7fa ff91 	bl	80008be <USBD_LL_ClearStallEP>
          pdev->pClass->Setup (pdev, req);
 800599c:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80059a0:	4629      	mov	r1, r5
 80059a2:	689b      	ldr	r3, [r3, #8]
 80059a4:	4620      	mov	r0, r4
 80059a6:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 80059a8:	4620      	mov	r0, r4
 80059aa:	f000 f863 	bl	8005a74 <USBD_CtlSendStatus>
 80059ae:	e026      	b.n	80059fe <USBD_StdEPReq+0xc2>
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev_state) 
 80059b0:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80059b4:	2a02      	cmp	r2, #2
 80059b6:	d002      	beq.n	80059be <USBD_StdEPReq+0x82>
 80059b8:	2a03      	cmp	r2, #3
 80059ba:	d006      	beq.n	80059ca <USBD_StdEPReq+0x8e>
 80059bc:	e01d      	b.n	80059fa <USBD_StdEPReq+0xbe>
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr & 0x7F) != 0x00) 
 80059be:	065a      	lsls	r2, r3, #25
 80059c0:	d01d      	beq.n	80059fe <USBD_StdEPReq+0xc2>
      {
        USBD_LL_StallEP(pdev , ep_addr);
 80059c2:	4619      	mov	r1, r3
 80059c4:	f7fa ff74 	bl	80008b0 <USBD_LL_StallEP>
 80059c8:	e019      	b.n	80059fe <USBD_StdEPReq+0xc2>
 80059ca:	f003 057f 	and.w	r5, r3, #127	; 0x7f
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 80059ce:	f016 0f80 	tst.w	r6, #128	; 0x80
 80059d2:	eb00 1505 	add.w	r5, r0, r5, lsl #4
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 80059d6:	4619      	mov	r1, r3
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 80059d8:	bf14      	ite	ne
 80059da:	3514      	addne	r5, #20
 80059dc:	f505 7582 	addeq.w	r5, r5, #260	; 0x104
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 80059e0:	f7fa ff74 	bl	80008cc <USBD_LL_IsStallEP>
 80059e4:	b110      	cbz	r0, 80059ec <USBD_StdEPReq+0xb0>
      {
        pep->status = 0x0001;     
 80059e6:	2301      	movs	r3, #1
 80059e8:	602b      	str	r3, [r5, #0]
 80059ea:	e000      	b.n	80059ee <USBD_StdEPReq+0xb2>
      }
      else
      {
        pep->status = 0x0000;  
 80059ec:	6028      	str	r0, [r5, #0]
      }
      
      USBD_CtlSendData (pdev,
 80059ee:	2202      	movs	r2, #2
 80059f0:	4629      	mov	r1, r5
 80059f2:	4620      	mov	r0, r4
 80059f4:	f000 f821 	bl	8005a3a <USBD_CtlSendData>
                        (uint8_t *)&pep->status,
                        2);
      break;
 80059f8:	e001      	b.n	80059fe <USBD_StdEPReq+0xc2>
      
    default:                         
      USBD_CtlError(pdev , req);
 80059fa:	f7ff fe6c 	bl	80056d6 <USBD_CtlError>
    
  default:
    break;
  }
  return ret;
}
 80059fe:	2000      	movs	r0, #0
 8005a00:	bd70      	pop	{r4, r5, r6, pc}

08005a02 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8005a02:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8005a04:	b1c0      	cbz	r0, 8005a38 <USBD_GetString+0x36>
 8005a06:	4605      	mov	r5, r0
 8005a08:	1a2b      	subs	r3, r5, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 8005a0a:	f815 4b01 	ldrb.w	r4, [r5], #1
 8005a0e:	b2db      	uxtb	r3, r3
 8005a10:	2c00      	cmp	r4, #0
 8005a12:	d1f9      	bne.n	8005a08 <USBD_GetString+0x6>
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8005a14:	005b      	lsls	r3, r3, #1
 8005a16:	3302      	adds	r3, #2
 8005a18:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 8005a1a:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8005a1c:	2303      	movs	r3, #3
 8005a1e:	704b      	strb	r3, [r1, #1]
 8005a20:	3801      	subs	r0, #1
 8005a22:	2302      	movs	r3, #2
    
    while (*desc != '\0') 
 8005a24:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8005a28:	b135      	cbz	r5, 8005a38 <USBD_GetString+0x36>
    {
      unicode[idx++] = *desc++;
 8005a2a:	1c5a      	adds	r2, r3, #1
 8005a2c:	b2d2      	uxtb	r2, r2
 8005a2e:	54cd      	strb	r5, [r1, r3]
      unicode[idx++] =  0x00;
 8005a30:	3302      	adds	r3, #2
 8005a32:	b2db      	uxtb	r3, r3
 8005a34:	548c      	strb	r4, [r1, r2]
 8005a36:	e7f5      	b.n	8005a24 <USBD_GetString+0x22>
 8005a38:	bd30      	pop	{r4, r5, pc}

08005a3a <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8005a3a:	b510      	push	{r4, lr}
 8005a3c:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8005a3e:	2202      	movs	r2, #2
 8005a40:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 8005a44:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8005a46:	460a      	mov	r2, r1
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 8005a48:	61c3      	str	r3, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8005a4a:	2100      	movs	r1, #0
 8005a4c:	f7fa ff58 	bl	8000900 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8005a50:	2000      	movs	r0, #0
 8005a52:	bd10      	pop	{r4, pc}

08005a54 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8005a54:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 8005a56:	4613      	mov	r3, r2
 8005a58:	460a      	mov	r2, r1
 8005a5a:	2100      	movs	r1, #0
 8005a5c:	f7fa ff50 	bl	8000900 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8005a60:	2000      	movs	r0, #0
 8005a62:	bd08      	pop	{r3, pc}

08005a64 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8005a64:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 8005a66:	4613      	mov	r3, r2
 8005a68:	460a      	mov	r2, r1
 8005a6a:	2100      	movs	r1, #0
 8005a6c:	f7fa ff4f 	bl	800090e <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 8005a70:	2000      	movs	r0, #0
 8005a72:	bd08      	pop	{r3, pc}

08005a74 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 8005a74:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8005a76:	2304      	movs	r3, #4
 8005a78:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8005a7c:	2300      	movs	r3, #0
 8005a7e:	461a      	mov	r2, r3
 8005a80:	4619      	mov	r1, r3
 8005a82:	f7fa ff3d 	bl	8000900 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8005a86:	2000      	movs	r0, #0
 8005a88:	bd08      	pop	{r3, pc}

08005a8a <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 8005a8a:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 8005a8c:	2305      	movs	r3, #5
 8005a8e:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8005a92:	2300      	movs	r3, #0
 8005a94:	461a      	mov	r2, r3
 8005a96:	4619      	mov	r1, r3
 8005a98:	f7fa ff39 	bl	800090e <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 8005a9c:	2000      	movs	r0, #0
 8005a9e:	bd08      	pop	{r3, pc}

08005aa0 <USBD_MSC_GetHSCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MSC_CfgHSDesc);
 8005aa0:	2320      	movs	r3, #32
 8005aa2:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_CfgHSDesc;
}
 8005aa4:	4800      	ldr	r0, [pc, #0]	; (8005aa8 <USBD_MSC_GetHSCfgDesc+0x8>)
 8005aa6:	4770      	bx	lr
 8005aa8:	20000088 	.word	0x20000088

08005aac <USBD_MSC_GetFSCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MSC_CfgFSDesc);
 8005aac:	2320      	movs	r3, #32
 8005aae:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_CfgFSDesc;
}
 8005ab0:	4800      	ldr	r0, [pc, #0]	; (8005ab4 <USBD_MSC_GetFSCfgDesc+0x8>)
 8005ab2:	4770      	bx	lr
 8005ab4:	200000e4 	.word	0x200000e4

08005ab8 <USBD_MSC_GetOtherSpeedCfgDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MSC_OtherSpeedCfgDesc);
 8005ab8:	2320      	movs	r3, #32
 8005aba:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_OtherSpeedCfgDesc;
}
 8005abc:	4800      	ldr	r0, [pc, #0]	; (8005ac0 <USBD_MSC_GetOtherSpeedCfgDesc+0x8>)
 8005abe:	4770      	bx	lr
 8005ac0:	2000005c 	.word	0x2000005c

08005ac4 <USBD_MSC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetDeviceQualifierDescriptor (uint16_t *length)
{
  *length = sizeof (USBD_MSC_DeviceQualifierDesc);
 8005ac4:	230a      	movs	r3, #10
 8005ac6:	8003      	strh	r3, [r0, #0]
  return USBD_MSC_DeviceQualifierDesc;
}
 8005ac8:	4800      	ldr	r0, [pc, #0]	; (8005acc <USBD_MSC_GetDeviceQualifierDescriptor+0x8>)
 8005aca:	4770      	bx	lr
 8005acc:	2000007c 	.word	0x2000007c

08005ad0 <USBD_MSC_Init>:
uint8_t  USBD_MSC_Init (USBD_HandleTypeDef *pdev, 
                            uint8_t cfgidx)
{
  int16_t ret = 0;
   
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8005ad0:	7c03      	ldrb	r3, [r0, #16]
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t  USBD_MSC_Init (USBD_HandleTypeDef *pdev, 
                            uint8_t cfgidx)
{
 8005ad2:	b510      	push	{r4, lr}
 8005ad4:	4604      	mov	r4, r0
  int16_t ret = 0;
   
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8005ad6:	b943      	cbnz	r3, 8005aea <USBD_MSC_Init+0x1a>
  {
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 8005ad8:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005adc:	2202      	movs	r2, #2
 8005ade:	2101      	movs	r1, #1
 8005ae0:	f7fa fece 	bl	8000880 <USBD_LL_OpenEP>
                   MSC_EPOUT_ADDR,
                   USBD_EP_TYPE_BULK,
                   MSC_MAX_HS_PACKET);
    
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 8005ae4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005ae8:	e005      	b.n	8005af6 <USBD_MSC_Init+0x26>
                   MSC_MAX_HS_PACKET);  
  }
  else
  {
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 8005aea:	2340      	movs	r3, #64	; 0x40
 8005aec:	2202      	movs	r2, #2
 8005aee:	2101      	movs	r1, #1
 8005af0:	f7fa fec6 	bl	8000880 <USBD_LL_OpenEP>
                   MSC_EPOUT_ADDR,
                   USBD_EP_TYPE_BULK,
                   MSC_MAX_FS_PACKET);
    
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 8005af4:	2340      	movs	r3, #64	; 0x40
 8005af6:	2202      	movs	r2, #2
 8005af8:	2181      	movs	r1, #129	; 0x81
 8005afa:	4620      	mov	r0, r4
 8005afc:	f7fa fec0 	bl	8000880 <USBD_LL_OpenEP>
                   MSC_EPIN_ADDR,
                   USBD_EP_TYPE_BULK,
                   MSC_MAX_FS_PACKET);  
  }
  pdev->pClassData = USBD_malloc(sizeof (USBD_MSC_BOT_HandleTypeDef));
 8005b00:	f44f 701b 	mov.w	r0, #620	; 0x26c
 8005b04:	f000 ff8c 	bl	8006a20 <malloc>
 8005b08:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
  
  if(pdev->pClassData == NULL)
 8005b0c:	b120      	cbz	r0, 8005b18 <USBD_MSC_Init+0x48>
    ret = 1; 
  }
  else
  {
    /* Init the BOT  layer */
    MSC_BOT_Init(pdev); 
 8005b0e:	4620      	mov	r0, r4
 8005b10:	f000 f8b6 	bl	8005c80 <MSC_BOT_Init>
    ret = 0;
 8005b14:	2000      	movs	r0, #0
 8005b16:	bd10      	pop	{r4, pc}
  }
  pdev->pClassData = USBD_malloc(sizeof (USBD_MSC_BOT_HandleTypeDef));
  
  if(pdev->pClassData == NULL)
  {
    ret = 1; 
 8005b18:	2001      	movs	r0, #1
    MSC_BOT_Init(pdev); 
    ret = 0;
  }
  
  return ret;
}
 8005b1a:	bd10      	pop	{r4, pc}

08005b1c <USBD_MSC_DeInit>:
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t  USBD_MSC_DeInit (USBD_HandleTypeDef *pdev, 
                              uint8_t cfgidx)
{
 8005b1c:	b510      	push	{r4, lr}
  /* Close MSC EPs */
  USBD_LL_CloseEP(pdev,
 8005b1e:	2101      	movs	r1, #1
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t  USBD_MSC_DeInit (USBD_HandleTypeDef *pdev, 
                              uint8_t cfgidx)
{
 8005b20:	4604      	mov	r4, r0
  /* Close MSC EPs */
  USBD_LL_CloseEP(pdev,
 8005b22:	f7fa feb7 	bl	8000894 <USBD_LL_CloseEP>
                  MSC_EPOUT_ADDR);
  
  /* Open EP IN */
  USBD_LL_CloseEP(pdev,
 8005b26:	2181      	movs	r1, #129	; 0x81
 8005b28:	4620      	mov	r0, r4
 8005b2a:	f7fa feb3 	bl	8000894 <USBD_LL_CloseEP>
                  MSC_EPIN_ADDR);
  
  
    /* De-Init the BOT layer */
  MSC_BOT_DeInit(pdev);
 8005b2e:	4620      	mov	r0, r4
 8005b30:	f000 f8d1 	bl	8005cd6 <MSC_BOT_DeInit>
  
  /* Free MSC Class Resources */
  if(pdev->pClassData != NULL)
 8005b34:	f8d4 0218 	ldr.w	r0, [r4, #536]	; 0x218
 8005b38:	b120      	cbz	r0, 8005b44 <USBD_MSC_DeInit+0x28>
  {
    USBD_free(pdev->pClassData);
 8005b3a:	f000 ff79 	bl	8006a30 <free>
    pdev->pClassData  = NULL; 
 8005b3e:	2300      	movs	r3, #0
 8005b40:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
  }
  return 0;
}
 8005b44:	2000      	movs	r0, #0
 8005b46:	bd10      	pop	{r4, pc}

08005b48 <USBD_MSC_Setup>:
* @param  pdev: device instance
* @param  req: USB request
* @retval status
*/
uint8_t  USBD_MSC_Setup (USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8005b48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  USBD_MSC_BOT_HandleTypeDef     *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005b4c:	780b      	ldrb	r3, [r1, #0]
* @param  req: USB request
* @retval status
*/
uint8_t  USBD_MSC_Setup (USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
  USBD_MSC_BOT_HandleTypeDef     *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
 8005b4e:	f8d0 8218 	ldr.w	r8, [r0, #536]	; 0x218
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005b52:	f013 0460 	ands.w	r4, r3, #96	; 0x60
* @param  pdev: device instance
* @param  req: USB request
* @retval status
*/
uint8_t  USBD_MSC_Setup (USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8005b56:	4607      	mov	r7, r0
 8005b58:	460e      	mov	r6, r1
  USBD_MSC_BOT_HandleTypeDef     *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005b5a:	d029      	beq.n	8005bb0 <USBD_MSC_Setup+0x68>
 8005b5c:	2c20      	cmp	r4, #32
 8005b5e:	d15c      	bne.n	8005c1a <USBD_MSC_Setup+0xd2>
  {

  /* Class request */
  case USB_REQ_TYPE_CLASS :
    switch (req->bRequest)
 8005b60:	784a      	ldrb	r2, [r1, #1]
 8005b62:	2afe      	cmp	r2, #254	; 0xfe
 8005b64:	d002      	beq.n	8005b6c <USBD_MSC_Setup+0x24>
 8005b66:	2aff      	cmp	r2, #255	; 0xff
 8005b68:	d011      	beq.n	8005b8e <USBD_MSC_Setup+0x46>
 8005b6a:	e01d      	b.n	8005ba8 <USBD_MSC_Setup+0x60>
    {
    case BOT_GET_MAX_LUN :

      if((req->wValue  == 0) && 
 8005b6c:	884c      	ldrh	r4, [r1, #2]
 8005b6e:	b984      	cbnz	r4, 8005b92 <USBD_MSC_Setup+0x4a>
 8005b70:	88cd      	ldrh	r5, [r1, #6]
 8005b72:	2d01      	cmp	r5, #1
 8005b74:	d10d      	bne.n	8005b92 <USBD_MSC_Setup+0x4a>
         (req->wLength == 1) &&
 8005b76:	061a      	lsls	r2, r3, #24
 8005b78:	d50b      	bpl.n	8005b92 <USBD_MSC_Setup+0x4a>
         ((req->bmRequest & 0x80) == 0x80))
      {
        hmsc->max_lun = ((USBD_StorageTypeDef *)pdev->pUserData)->GetMaxLun();
 8005b7a:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8005b7e:	699b      	ldr	r3, [r3, #24]
 8005b80:	4798      	blx	r3
        USBD_CtlSendData (pdev,
 8005b82:	462a      	mov	r2, r5

      if((req->wValue  == 0) && 
         (req->wLength == 1) &&
         ((req->bmRequest & 0x80) == 0x80))
      {
        hmsc->max_lun = ((USBD_StorageTypeDef *)pdev->pUserData)->GetMaxLun();
 8005b84:	f8c8 0000 	str.w	r0, [r8]
        USBD_CtlSendData (pdev,
 8005b88:	4641      	mov	r1, r8
 8005b8a:	4638      	mov	r0, r7
 8005b8c:	e01b      	b.n	8005bc6 <USBD_MSC_Setup+0x7e>
         return USBD_FAIL; 
      }
      break;
      
    case BOT_RESET :
      if((req->wValue  == 0) && 
 8005b8e:	884a      	ldrh	r2, [r1, #2]
 8005b90:	b112      	cbz	r2, 8005b98 <USBD_MSC_Setup+0x50>
                          (uint8_t *)&hmsc->max_lun,
                          1);
      }
      else
      {
         USBD_CtlError(pdev , req);
 8005b92:	4631      	mov	r1, r6
 8005b94:	4638      	mov	r0, r7
 8005b96:	e007      	b.n	8005ba8 <USBD_MSC_Setup+0x60>
         return USBD_FAIL; 
      }
      break;
      
    case BOT_RESET :
      if((req->wValue  == 0) && 
 8005b98:	88cc      	ldrh	r4, [r1, #6]
 8005b9a:	2c00      	cmp	r4, #0
 8005b9c:	d1f9      	bne.n	8005b92 <USBD_MSC_Setup+0x4a>
         (req->wLength == 0) &&
 8005b9e:	061b      	lsls	r3, r3, #24
 8005ba0:	d4f7      	bmi.n	8005b92 <USBD_MSC_Setup+0x4a>
        ((req->bmRequest & 0x80) != 0x80))
      {      
         MSC_BOT_Reset(pdev);
 8005ba2:	f000 f88d 	bl	8005cc0 <MSC_BOT_Reset>
      else
      {
         USBD_CtlError(pdev , req);
         return USBD_FAIL; 
      }
      break;
 8005ba6:	e039      	b.n	8005c1c <USBD_MSC_Setup+0xd4>

    default:
       USBD_CtlError(pdev , req);
 8005ba8:	f7ff fd95 	bl	80056d6 <USBD_CtlError>
       return USBD_FAIL; 
 8005bac:	2402      	movs	r4, #2
 8005bae:	e035      	b.n	8005c1c <USBD_MSC_Setup+0xd4>
    }
    break;
  /* Interface & Endpoint request */
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 8005bb0:	784d      	ldrb	r5, [r1, #1]
 8005bb2:	2d0a      	cmp	r5, #10
 8005bb4:	d004      	beq.n	8005bc0 <USBD_MSC_Setup+0x78>
 8005bb6:	2d0b      	cmp	r5, #11
 8005bb8:	d008      	beq.n	8005bcc <USBD_MSC_Setup+0x84>
 8005bba:	2d01      	cmp	r5, #1
 8005bbc:	d12e      	bne.n	8005c1c <USBD_MSC_Setup+0xd4>
 8005bbe:	e009      	b.n	8005bd4 <USBD_MSC_Setup+0x8c>
    {
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 8005bc0:	2201      	movs	r2, #1
 8005bc2:	f108 0104 	add.w	r1, r8, #4
 8005bc6:	f7ff ff38 	bl	8005a3a <USBD_CtlSendData>
                        (uint8_t *)&hmsc->interface,
                        1);
      break;
 8005bca:	e027      	b.n	8005c1c <USBD_MSC_Setup+0xd4>
      
    case USB_REQ_SET_INTERFACE :
      hmsc->interface = (uint8_t)(req->wValue);
 8005bcc:	788b      	ldrb	r3, [r1, #2]
 8005bce:	f8c8 3004 	str.w	r3, [r8, #4]
      break;
 8005bd2:	e023      	b.n	8005c1c <USBD_MSC_Setup+0xd4>
    
    case USB_REQ_CLEAR_FEATURE:  
      
      /* Flush the FIFO and Clear the stall status */    
      USBD_LL_FlushEP(pdev, (uint8_t)req->wIndex);
 8005bd4:	7909      	ldrb	r1, [r1, #4]
 8005bd6:	f7fa fe64 	bl	80008a2 <USBD_LL_FlushEP>
      
      /* Reactivate the EP */      
      USBD_LL_CloseEP (pdev , (uint8_t)req->wIndex);
 8005bda:	7931      	ldrb	r1, [r6, #4]
 8005bdc:	4638      	mov	r0, r7
 8005bde:	f7fa fe59 	bl	8000894 <USBD_LL_CloseEP>
      if((((uint8_t)req->wIndex) & 0x80) == 0x80)
 8005be2:	f996 3004 	ldrsb.w	r3, [r6, #4]
 8005be6:	2b00      	cmp	r3, #0
 8005be8:	7c3b      	ldrb	r3, [r7, #16]
 8005bea:	da07      	bge.n	8005bfc <USBD_MSC_Setup+0xb4>
      {
        if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8005bec:	b913      	cbnz	r3, 8005bf4 <USBD_MSC_Setup+0xac>
        {
          /* Open EP IN */
          USBD_LL_OpenEP(pdev,
 8005bee:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005bf2:	e000      	b.n	8005bf6 <USBD_MSC_Setup+0xae>
                         MSC_MAX_HS_PACKET);  
        }
        else
        {   
          /* Open EP IN */
          USBD_LL_OpenEP(pdev,
 8005bf4:	2340      	movs	r3, #64	; 0x40
 8005bf6:	2202      	movs	r2, #2
 8005bf8:	2181      	movs	r1, #129	; 0x81
 8005bfa:	e006      	b.n	8005c0a <USBD_MSC_Setup+0xc2>
                         MSC_MAX_FS_PACKET);  
        }
      }
      else
      {
        if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8005bfc:	b913      	cbnz	r3, 8005c04 <USBD_MSC_Setup+0xbc>
        {
          /* Open EP IN */
          USBD_LL_OpenEP(pdev,
 8005bfe:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005c02:	e000      	b.n	8005c06 <USBD_MSC_Setup+0xbe>
                         MSC_MAX_HS_PACKET);  
        }
        else
        {   
          /* Open EP IN */
          USBD_LL_OpenEP(pdev,
 8005c04:	2340      	movs	r3, #64	; 0x40
 8005c06:	2202      	movs	r2, #2
 8005c08:	4629      	mov	r1, r5
 8005c0a:	4638      	mov	r0, r7
 8005c0c:	f7fa fe38 	bl	8000880 <USBD_LL_OpenEP>
                         MSC_MAX_FS_PACKET);  
        }
      }
      
      /* Handle BOT error */
      MSC_BOT_CplClrFeature(pdev, (uint8_t)req->wIndex);
 8005c10:	7931      	ldrb	r1, [r6, #4]
 8005c12:	4638      	mov	r0, r7
 8005c14:	f000 f908 	bl	8005e28 <MSC_BOT_CplClrFeature>
      break;
 8005c18:	e000      	b.n	8005c1c <USBD_MSC_Setup+0xd4>
    break;
   
  default:
    break;
  }
  return 0;
 8005c1a:	2400      	movs	r4, #0
}
 8005c1c:	4620      	mov	r0, r4
 8005c1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005c22 <USBD_MSC_DataIn>:
* @param  epnum: endpoint index
* @retval status
*/
uint8_t  USBD_MSC_DataIn (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
 8005c22:	b508      	push	{r3, lr}
  MSC_BOT_DataIn(pdev , epnum);
 8005c24:	f000 f878 	bl	8005d18 <MSC_BOT_DataIn>
  return 0;
}
 8005c28:	2000      	movs	r0, #0
 8005c2a:	bd08      	pop	{r3, pc}

08005c2c <USBD_MSC_DataOut>:
* @param  epnum: endpoint index
* @retval status
*/
uint8_t  USBD_MSC_DataOut (USBD_HandleTypeDef *pdev, 
                               uint8_t epnum)
{
 8005c2c:	b508      	push	{r3, lr}
  MSC_BOT_DataOut(pdev , epnum);
 8005c2e:	f000 f88f 	bl	8005d50 <MSC_BOT_DataOut>
  return 0;
}
 8005c32:	2000      	movs	r0, #0
 8005c34:	bd08      	pop	{r3, pc}

08005c36 <USBD_MSC_RegisterStorage>:
* @retval status
*/
uint8_t  USBD_MSC_RegisterStorage  (USBD_HandleTypeDef   *pdev, 
                                    USBD_StorageTypeDef *fops)
{
  if(fops != NULL)
 8005c36:	b109      	cbz	r1, 8005c3c <USBD_MSC_RegisterStorage+0x6>
  {
    pdev->pUserData= fops;
 8005c38:	f8c0 121c 	str.w	r1, [r0, #540]	; 0x21c
  }
  return 0;
}
 8005c3c:	2000      	movs	r0, #0
 8005c3e:	4770      	bx	lr

08005c40 <MSC_BOT_Abort>:
* @param  pdev: device instance
* @retval status
*/

static void  MSC_BOT_Abort (USBD_HandleTypeDef  *pdev)
{
 8005c40:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005c42:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if ((hmsc->cbw.bmFlags == 0) && 
 8005c46:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
* @param  pdev: device instance
* @retval status
*/

static void  MSC_BOT_Abort (USBD_HandleTypeDef  *pdev)
{
 8005c4a:	4605      	mov	r5, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  if ((hmsc->cbw.bmFlags == 0) && 
 8005c4c:	b93b      	cbnz	r3, 8005c5e <MSC_BOT_Abort+0x1e>
 8005c4e:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8005c52:	b123      	cbz	r3, 8005c5e <MSC_BOT_Abort+0x1e>
      (hmsc->cbw.dDataLength != 0) &&
 8005c54:	7a63      	ldrb	r3, [r4, #9]
 8005c56:	b913      	cbnz	r3, 8005c5e <MSC_BOT_Abort+0x1e>
      (hmsc->bot_status == USBD_BOT_STATUS_NORMAL) )
  {
    USBD_LL_StallEP(pdev, MSC_EPOUT_ADDR );
 8005c58:	2101      	movs	r1, #1
 8005c5a:	f7fa fe29 	bl	80008b0 <USBD_LL_StallEP>
  }
  USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 8005c5e:	2181      	movs	r1, #129	; 0x81
 8005c60:	4628      	mov	r0, r5
 8005c62:	f7fa fe25 	bl	80008b0 <USBD_LL_StallEP>
  
  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR)
 8005c66:	7a63      	ldrb	r3, [r4, #9]
 8005c68:	2b02      	cmp	r3, #2
 8005c6a:	d108      	bne.n	8005c7e <MSC_BOT_Abort+0x3e>
  {
    USBD_LL_PrepareReceive (pdev,
 8005c6c:	f504 7203 	add.w	r2, r4, #524	; 0x20c
 8005c70:	4628      	mov	r0, r5
 8005c72:	231f      	movs	r3, #31
 8005c74:	2101      	movs	r1, #1
                      MSC_EPOUT_ADDR,
                      (uint8_t *)&hmsc->cbw, 
                      USBD_BOT_CBW_LENGTH);    
  }
}
 8005c76:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }
  USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
  
  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR)
  {
    USBD_LL_PrepareReceive (pdev,
 8005c7a:	f7fa be48 	b.w	800090e <USBD_LL_PrepareReceive>
 8005c7e:	bd70      	pop	{r4, r5, r6, pc}

08005c80 <MSC_BOT_Init>:
*         Initialize the BOT Process
* @param  pdev: device instance
* @retval None
*/
void MSC_BOT_Init (USBD_HandleTypeDef  *pdev)
{
 8005c80:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 8005c82:	f8d0 5218 	ldr.w	r5, [r0, #536]	; 0x218
*         Initialize the BOT Process
* @param  pdev: device instance
* @retval None
*/
void MSC_BOT_Init (USBD_HandleTypeDef  *pdev)
{
 8005c86:	4604      	mov	r4, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
    
  hmsc->bot_state  = USBD_BOT_IDLE;
 8005c88:	2000      	movs	r0, #0
 8005c8a:	7228      	strb	r0, [r5, #8]
  hmsc->bot_status = USBD_BOT_STATUS_NORMAL;
 8005c8c:	7268      	strb	r0, [r5, #9]
  
  hmsc->scsi_sense_tail = 0;
 8005c8e:	f885 025d 	strb.w	r0, [r5, #605]	; 0x25d
  hmsc->scsi_sense_head = 0;
 8005c92:	f885 025c 	strb.w	r0, [r5, #604]	; 0x25c
  
  ((USBD_StorageTypeDef *)pdev->pUserData)->Init(0);
 8005c96:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 8005c9a:	681b      	ldr	r3, [r3, #0]
 8005c9c:	4798      	blx	r3
  
  USBD_LL_FlushEP(pdev, MSC_EPOUT_ADDR);
 8005c9e:	2101      	movs	r1, #1
 8005ca0:	4620      	mov	r0, r4
 8005ca2:	f7fa fdfe 	bl	80008a2 <USBD_LL_FlushEP>
  USBD_LL_FlushEP(pdev, MSC_EPIN_ADDR);
 8005ca6:	2181      	movs	r1, #129	; 0x81
 8005ca8:	4620      	mov	r0, r4
 8005caa:	f7fa fdfa 	bl	80008a2 <USBD_LL_FlushEP>
  
  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005cae:	f505 7203 	add.w	r2, r5, #524	; 0x20c
 8005cb2:	4620      	mov	r0, r4
 8005cb4:	231f      	movs	r3, #31
 8005cb6:	2101      	movs	r1, #1
                          MSC_EPOUT_ADDR,
                          (uint8_t *)&hmsc->cbw,
                          USBD_BOT_CBW_LENGTH);    
}
 8005cb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  
  USBD_LL_FlushEP(pdev, MSC_EPOUT_ADDR);
  USBD_LL_FlushEP(pdev, MSC_EPIN_ADDR);
  
  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005cbc:	f7fa be27 	b.w	800090e <USBD_LL_PrepareReceive>

08005cc0 <MSC_BOT_Reset>:
* @param  pdev: device instance
* @retval  None
*/
void MSC_BOT_Reset (USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 8005cc0:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
    
  hmsc->bot_state  = USBD_BOT_IDLE;
 8005cc4:	2300      	movs	r3, #0
  hmsc->bot_status = USBD_BOT_STATUS_RECOVERY;  
 8005cc6:	2101      	movs	r1, #1
*/
void MSC_BOT_Reset (USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
    
  hmsc->bot_state  = USBD_BOT_IDLE;
 8005cc8:	7213      	strb	r3, [r2, #8]
  hmsc->bot_status = USBD_BOT_STATUS_RECOVERY;  
 8005cca:	7251      	strb	r1, [r2, #9]
  
  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005ccc:	231f      	movs	r3, #31
 8005cce:	f502 7203 	add.w	r2, r2, #524	; 0x20c
 8005cd2:	f7fa be1c 	b.w	800090e <USBD_LL_PrepareReceive>

08005cd6 <MSC_BOT_DeInit>:
* @param  pdev: device instance
* @retval None
*/
void MSC_BOT_DeInit (USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 8005cd6:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  hmsc->bot_state  = USBD_BOT_IDLE;
 8005cda:	2200      	movs	r2, #0
 8005cdc:	721a      	strb	r2, [r3, #8]
 8005cde:	4770      	bx	lr

08005ce0 <MSC_BOT_SendCSW>:
* @param  status : CSW status
* @retval None
*/
void  MSC_BOT_SendCSW (USBD_HandleTypeDef  *pdev,
                              uint8_t CSW_Status)
{
 8005ce0:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005ce2:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 8005ce6:	4b0b      	ldr	r3, [pc, #44]	; (8005d14 <MSC_BOT_SendCSW+0x34>)
 8005ce8:	f8c4 322c 	str.w	r3, [r4, #556]	; 0x22c
  hmsc->csw.bStatus = CSW_Status;
  hmsc->bot_state = USBD_BOT_IDLE;
 8005cec:	2300      	movs	r3, #0
* @param  status : CSW status
* @retval None
*/
void  MSC_BOT_SendCSW (USBD_HandleTypeDef  *pdev,
                              uint8_t CSW_Status)
{
 8005cee:	4605      	mov	r5, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
  hmsc->csw.bStatus = CSW_Status;
 8005cf0:	f884 1238 	strb.w	r1, [r4, #568]	; 0x238
  hmsc->bot_state = USBD_BOT_IDLE;
 8005cf4:	7223      	strb	r3, [r4, #8]
  
  USBD_LL_Transmit (pdev, 
 8005cf6:	f504 720b 	add.w	r2, r4, #556	; 0x22c
 8005cfa:	230d      	movs	r3, #13
 8005cfc:	2181      	movs	r1, #129	; 0x81
 8005cfe:	f7fa fdff 	bl	8000900 <USBD_LL_Transmit>
             MSC_EPIN_ADDR, 
             (uint8_t *)&hmsc->csw, 
             USBD_BOT_CSW_LENGTH);
  
  /* Prepare EP to Receive next Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005d02:	f504 7203 	add.w	r2, r4, #524	; 0x20c
 8005d06:	4628      	mov	r0, r5
 8005d08:	231f      	movs	r3, #31
 8005d0a:	2101      	movs	r1, #1
                    MSC_EPOUT_ADDR,
                    (uint8_t *)&hmsc->cbw, 
                    USBD_BOT_CBW_LENGTH);  
  
}
 8005d0c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             MSC_EPIN_ADDR, 
             (uint8_t *)&hmsc->csw, 
             USBD_BOT_CSW_LENGTH);
  
  /* Prepare EP to Receive next Cmd */
  USBD_LL_PrepareReceive (pdev,
 8005d10:	f7fa bdfd 	b.w	800090e <USBD_LL_PrepareReceive>
 8005d14:	53425355 	.word	0x53425355

08005d18 <MSC_BOT_DataIn>:
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataIn (USBD_HandleTypeDef  *pdev, 
                     uint8_t epnum)
{
 8005d18:	b510      	push	{r4, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 8005d1a:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  switch (hmsc->bot_state)
 8005d1e:	7a1a      	ldrb	r2, [r3, #8]
 8005d20:	2a02      	cmp	r2, #2
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataIn (USBD_HandleTypeDef  *pdev, 
                     uint8_t epnum)
{
 8005d22:	4604      	mov	r4, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
  
  switch (hmsc->bot_state)
 8005d24:	d003      	beq.n	8005d2e <MSC_BOT_DataIn+0x16>
 8005d26:	d312      	bcc.n	8005d4e <MSC_BOT_DataIn+0x36>
 8005d28:	2a04      	cmp	r2, #4
 8005d2a:	d90b      	bls.n	8005d44 <MSC_BOT_DataIn+0x2c>
 8005d2c:	bd10      	pop	{r4, pc}
  {
  case USBD_BOT_DATA_IN:
    if(SCSI_ProcessCmd(pdev,
 8005d2e:	f203 221b 	addw	r2, r3, #539	; 0x21b
 8005d32:	f893 1219 	ldrb.w	r1, [r3, #537]	; 0x219
 8005d36:	f000 f8a5 	bl	8005e84 <SCSI_ProcessCmd>
 8005d3a:	2800      	cmp	r0, #0
 8005d3c:	da07      	bge.n	8005d4e <MSC_BOT_DataIn+0x36>
                        hmsc->cbw.bLUN,
                        &hmsc->cbw.CB[0]) < 0)
    {
      MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
 8005d3e:	2101      	movs	r1, #1
 8005d40:	4620      	mov	r0, r4
 8005d42:	e000      	b.n	8005d46 <MSC_BOT_DataIn+0x2e>
    }
    break;
    
  case USBD_BOT_SEND_DATA:
  case USBD_BOT_LAST_DATA_IN:
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED);
 8005d44:	2100      	movs	r1, #0
    break;
    
  default:
    break;
  }
}
 8005d46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    }
    break;
    
  case USBD_BOT_SEND_DATA:
  case USBD_BOT_LAST_DATA_IN:
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED);
 8005d4a:	f7ff bfc9 	b.w	8005ce0 <MSC_BOT_SendCSW>
 8005d4e:	bd10      	pop	{r4, pc}

08005d50 <MSC_BOT_DataOut>:
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataOut (USBD_HandleTypeDef  *pdev, 
                      uint8_t epnum)
{
 8005d50:	b570      	push	{r4, r5, r6, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 8005d52:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  switch (hmsc->bot_state)
 8005d56:	7a26      	ldrb	r6, [r4, #8]
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataOut (USBD_HandleTypeDef  *pdev, 
                      uint8_t epnum)
{
 8005d58:	4605      	mov	r5, r0
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
  
  switch (hmsc->bot_state)
 8005d5a:	b116      	cbz	r6, 8005d62 <MSC_BOT_DataOut+0x12>
 8005d5c:	2e01      	cmp	r6, #1
 8005d5e:	d057      	beq.n	8005e10 <MSC_BOT_DataOut+0xc0>
 8005d60:	bd70      	pop	{r4, r5, r6, pc}
*/
static void  MSC_BOT_CBW_Decode (USBD_HandleTypeDef  *pdev)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
  
  hmsc->csw.dTag = hmsc->cbw.dTag;
 8005d62:	f8d4 3210 	ldr.w	r3, [r4, #528]	; 0x210
 8005d66:	f8c4 3230 	str.w	r3, [r4, #560]	; 0x230
  hmsc->csw.dDataResidue = hmsc->cbw.dDataLength;
 8005d6a:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8005d6e:	f8c4 3234 	str.w	r3, [r4, #564]	; 0x234
  
  if ((USBD_LL_GetRxDataSize (pdev ,MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 8005d72:	2101      	movs	r1, #1
 8005d74:	f7fa fdd2 	bl	800091c <USBD_LL_GetRxDataSize>
 8005d78:	281f      	cmp	r0, #31
 8005d7a:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
 8005d7e:	d10b      	bne.n	8005d98 <MSC_BOT_DataOut+0x48>
 8005d80:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
 8005d84:	4b27      	ldr	r3, [pc, #156]	; (8005e24 <MSC_BOT_DataOut+0xd4>)
 8005d86:	429a      	cmp	r2, r3
 8005d88:	d106      	bne.n	8005d98 <MSC_BOT_DataOut+0x48>
      (hmsc->cbw.dSignature != USBD_BOT_CBW_SIGNATURE)||
 8005d8a:	2901      	cmp	r1, #1
 8005d8c:	d804      	bhi.n	8005d98 <MSC_BOT_DataOut+0x48>
        (hmsc->cbw.bLUN > 1) || 
 8005d8e:	f894 321a 	ldrb.w	r3, [r4, #538]	; 0x21a
 8005d92:	3b01      	subs	r3, #1
 8005d94:	2b0f      	cmp	r3, #15
 8005d96:	d907      	bls.n	8005da8 <MSC_BOT_DataOut+0x58>
          (hmsc->cbw.bCBLength < 1) || 
            (hmsc->cbw.bCBLength > 16))
  {
    
    SCSI_SenseCode(pdev,
 8005d98:	2320      	movs	r3, #32
 8005d9a:	2205      	movs	r2, #5
 8005d9c:	4628      	mov	r0, r5
 8005d9e:	f000 f859 	bl	8005e54 <SCSI_SenseCode>
                   hmsc->cbw.bLUN, 
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);
    
    hmsc->bot_status = USBD_BOT_STATUS_ERROR;   
 8005da2:	2302      	movs	r3, #2
 8005da4:	7263      	strb	r3, [r4, #9]
 8005da6:	e00b      	b.n	8005dc0 <MSC_BOT_DataOut+0x70>
    MSC_BOT_Abort(pdev);
 
  }
  else
  {
    if(SCSI_ProcessCmd(pdev,
 8005da8:	f204 221b 	addw	r2, r4, #539	; 0x21b
 8005dac:	4628      	mov	r0, r5
 8005dae:	f000 f869 	bl	8005e84 <SCSI_ProcessCmd>
 8005db2:	2800      	cmp	r0, #0
 8005db4:	7a23      	ldrb	r3, [r4, #8]
 8005db6:	da08      	bge.n	8005dca <MSC_BOT_DataOut+0x7a>
                       hmsc->cbw.bLUN,
                       &hmsc->cbw.CB[0]) < 0)
    {
      if(hmsc->bot_state == USBD_BOT_NO_DATA)
 8005db8:	2b05      	cmp	r3, #5
 8005dba:	d101      	bne.n	8005dc0 <MSC_BOT_DataOut+0x70>
      {
       MSC_BOT_SendCSW (pdev,
 8005dbc:	2101      	movs	r1, #1
 8005dbe:	e022      	b.n	8005e06 <MSC_BOT_DataOut+0xb6>
                         USBD_CSW_CMD_FAILED); 
      }
      else
      {
        MSC_BOT_Abort(pdev);
 8005dc0:	4628      	mov	r0, r5
    break;
    
  default:
    break;
  }
}
 8005dc2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
       MSC_BOT_SendCSW (pdev,
                         USBD_CSW_CMD_FAILED); 
      }
      else
      {
        MSC_BOT_Abort(pdev);
 8005dc6:	f7ff bf3b 	b.w	8005c40 <MSC_BOT_Abort>
      }
    }
    /*Burst xfer handled internally*/
    else if ((hmsc->bot_state != USBD_BOT_DATA_IN) && 
 8005dca:	3b01      	subs	r3, #1
 8005dcc:	2b02      	cmp	r3, #2
 8005dce:	d927      	bls.n	8005e20 <MSC_BOT_DataOut+0xd0>
             (hmsc->bot_state != USBD_BOT_DATA_OUT) &&
             (hmsc->bot_state != USBD_BOT_LAST_DATA_IN)) 
    {
      if (hmsc->bot_data_length > 0)
 8005dd0:	8961      	ldrh	r1, [r4, #10]
 8005dd2:	b1c1      	cbz	r1, 8005e06 <MSC_BOT_DataOut+0xb6>
*/
static void  MSC_BOT_SendData(USBD_HandleTypeDef  *pdev,
                              uint8_t* buf, 
                              uint16_t len)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005dd4:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
  
  len = MIN (hmsc->cbw.dDataLength, len);
 8005dd8:	f8d2 3214 	ldr.w	r3, [r2, #532]	; 0x214
  hmsc->csw.dDataResidue -= len;
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
 8005ddc:	f882 6238 	strb.w	r6, [r2, #568]	; 0x238
                              uint8_t* buf, 
                              uint16_t len)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  len = MIN (hmsc->cbw.dDataLength, len);
 8005de0:	4299      	cmp	r1, r3
 8005de2:	bf28      	it	cs
 8005de4:	4619      	movcs	r1, r3
  hmsc->csw.dDataResidue -= len;
 8005de6:	f8d2 3234 	ldr.w	r3, [r2, #564]	; 0x234
 8005dea:	1a5b      	subs	r3, r3, r1
 8005dec:	f8c2 3234 	str.w	r3, [r2, #564]	; 0x234
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
  hmsc->bot_state = USBD_BOT_SEND_DATA;
 8005df0:	2304      	movs	r3, #4
 8005df2:	7213      	strb	r3, [r2, #8]
  
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, buf, len);  
 8005df4:	4628      	mov	r0, r5
 8005df6:	b28b      	uxth	r3, r1
 8005df8:	f104 020c 	add.w	r2, r4, #12
 8005dfc:	2181      	movs	r1, #129	; 0x81
    break;
    
  default:
    break;
  }
}
 8005dfe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  len = MIN (hmsc->cbw.dDataLength, len);
  hmsc->csw.dDataResidue -= len;
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
  hmsc->bot_state = USBD_BOT_SEND_DATA;
  
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, buf, len);  
 8005e02:	f7fa bd7d 	b.w	8000900 <USBD_LL_Transmit>
                         hmsc->bot_data, 
                         hmsc->bot_data_length);
      }
      else if (hmsc->bot_data_length == 0) 
      {
        MSC_BOT_SendCSW (pdev,
 8005e06:	4628      	mov	r0, r5
    break;
    
  default:
    break;
  }
}
 8005e08:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                         hmsc->bot_data, 
                         hmsc->bot_data_length);
      }
      else if (hmsc->bot_data_length == 0) 
      {
        MSC_BOT_SendCSW (pdev,
 8005e0c:	f7ff bf68 	b.w	8005ce0 <MSC_BOT_SendCSW>
    MSC_BOT_CBW_Decode(pdev);
    break;
    
  case USBD_BOT_DATA_OUT:
    
    if(SCSI_ProcessCmd(pdev,
 8005e10:	f204 221b 	addw	r2, r4, #539	; 0x21b
 8005e14:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
 8005e18:	f000 f834 	bl	8005e84 <SCSI_ProcessCmd>
 8005e1c:	2800      	cmp	r0, #0
 8005e1e:	dbcd      	blt.n	8005dbc <MSC_BOT_DataOut+0x6c>
 8005e20:	bd70      	pop	{r4, r5, r6, pc}
 8005e22:	bf00      	nop
 8005e24:	43425355 	.word	0x43425355

08005e28 <MSC_BOT_CplClrFeature>:
* @param  epnum: endpoint index
* @retval None
*/

void  MSC_BOT_CplClrFeature (USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
 8005e28:	b510      	push	{r4, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005e2a:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR )/* Bad CBW Signature */
 8005e2e:	7a63      	ldrb	r3, [r4, #9]
 8005e30:	2b02      	cmp	r3, #2
 8005e32:	d105      	bne.n	8005e40 <MSC_BOT_CplClrFeature+0x18>
  {
    USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 8005e34:	2181      	movs	r1, #129	; 0x81
 8005e36:	f7fa fd3b 	bl	80008b0 <USBD_LL_StallEP>
    hmsc->bot_status = USBD_BOT_STATUS_NORMAL;    
 8005e3a:	2300      	movs	r3, #0
 8005e3c:	7263      	strb	r3, [r4, #9]
 8005e3e:	bd10      	pop	{r4, pc}
  }
  else if(((epnum & 0x80) == 0x80) && ( hmsc->bot_status != USBD_BOT_STATUS_RECOVERY))
 8005e40:	060a      	lsls	r2, r1, #24
 8005e42:	d506      	bpl.n	8005e52 <MSC_BOT_CplClrFeature+0x2a>
 8005e44:	2b01      	cmp	r3, #1
 8005e46:	d004      	beq.n	8005e52 <MSC_BOT_CplClrFeature+0x2a>
  {
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
 8005e48:	2101      	movs	r1, #1
  }
  
}
 8005e4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
    hmsc->bot_status = USBD_BOT_STATUS_NORMAL;    
  }
  else if(((epnum & 0x80) == 0x80) && ( hmsc->bot_status != USBD_BOT_STATUS_RECOVERY))
  {
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
 8005e4e:	f7ff bf47 	b.w	8005ce0 <MSC_BOT_SendCSW>
 8005e52:	bd10      	pop	{r4, pc}

08005e54 <SCSI_SenseCode>:
* @param  ASC: Additional Sense Key
* @retval none

*/
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
 8005e54:	b510      	push	{r4, lr}
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005e56:	f8d0 0218 	ldr.w	r0, [r0, #536]	; 0x218
  
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8005e5a:	f890 125d 	ldrb.w	r1, [r0, #605]	; 0x25d
 8005e5e:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
  hmsc->scsi_sense_tail++;
 8005e62:	3101      	adds	r1, #1
 8005e64:	b2c9      	uxtb	r1, r1
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8005e66:	021b      	lsls	r3, r3, #8
  hmsc->scsi_sense_tail++;
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 8005e68:	2904      	cmp	r1, #4
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 8005e6a:	f8c4 3240 	str.w	r3, [r4, #576]	; 0x240
  hmsc->scsi_sense_tail++;
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
  {
    hmsc->scsi_sense_tail = 0;
 8005e6e:	bf08      	it	eq
 8005e70:	2300      	moveq	r3, #0
*/
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 8005e72:	f884 223c 	strb.w	r2, [r4, #572]	; 0x23c
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
  hmsc->scsi_sense_tail++;
 8005e76:	bf14      	ite	ne
 8005e78:	f880 125d 	strbne.w	r1, [r0, #605]	; 0x25d
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
  {
    hmsc->scsi_sense_tail = 0;
 8005e7c:	f880 325d 	strbeq.w	r3, [r0, #605]	; 0x25d
 8005e80:	bd10      	pop	{r4, pc}
	...

08005e84 <SCSI_ProcessCmd>:
* @retval status
*/
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef  *pdev,
                           uint8_t lun, 
                           uint8_t *params)
{
 8005e84:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  
  switch (params[0])
 8005e88:	7813      	ldrb	r3, [r2, #0]
 8005e8a:	2b1e      	cmp	r3, #30
* @retval status
*/
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef  *pdev,
                           uint8_t lun, 
                           uint8_t *params)
{
 8005e8c:	4605      	mov	r5, r0
 8005e8e:	460f      	mov	r7, r1
 8005e90:	4690      	mov	r8, r2
  
  switch (params[0])
 8005e92:	f000 8089 	beq.w	8005fa8 <SCSI_ProcessCmd+0x124>
 8005e96:	d813      	bhi.n	8005ec0 <SCSI_ProcessCmd+0x3c>
 8005e98:	2b12      	cmp	r3, #18
 8005e9a:	d066      	beq.n	8005f6a <SCSI_ProcessCmd+0xe6>
 8005e9c:	d80b      	bhi.n	8005eb6 <SCSI_ProcessCmd+0x32>
 8005e9e:	b31b      	cbz	r3, 8005ee8 <SCSI_ProcessCmd+0x64>
 8005ea0:	2b03      	cmp	r3, #3
 8005ea2:	f040 81f8 	bne.w	8006296 <SCSI_ProcessCmd+0x412>
 8005ea6:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  uint8_t i;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  for(i=0 ; i < REQUEST_SENSE_DATA_LEN ; i++) 
  {
    hmsc->bot_data[i] = 0;
 8005eaa:	2000      	movs	r0, #0
 8005eac:	f103 020b 	add.w	r2, r3, #11
 8005eb0:	f103 011d 	add.w	r1, r3, #29
 8005eb4:	e031      	b.n	8005f1a <SCSI_ProcessCmd+0x96>
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef  *pdev,
                           uint8_t lun, 
                           uint8_t *params)
{
  
  switch (params[0])
 8005eb6:	2b1a      	cmp	r3, #26
 8005eb8:	d07a      	beq.n	8005fb0 <SCSI_ProcessCmd+0x12c>
 8005eba:	2b1b      	cmp	r3, #27
 8005ebc:	d074      	beq.n	8005fa8 <SCSI_ProcessCmd+0x124>
 8005ebe:	e1ea      	b.n	8006296 <SCSI_ProcessCmd+0x412>
 8005ec0:	2b28      	cmp	r3, #40	; 0x28
 8005ec2:	f000 80dc 	beq.w	800607e <SCSI_ProcessCmd+0x1fa>
 8005ec6:	d806      	bhi.n	8005ed6 <SCSI_ProcessCmd+0x52>
 8005ec8:	2b23      	cmp	r3, #35	; 0x23
 8005eca:	f000 808b 	beq.w	8005fe4 <SCSI_ProcessCmd+0x160>
 8005ece:	2b25      	cmp	r3, #37	; 0x25
 8005ed0:	f000 80b2 	beq.w	8006038 <SCSI_ProcessCmd+0x1b4>
 8005ed4:	e1df      	b.n	8006296 <SCSI_ProcessCmd+0x412>
 8005ed6:	2b2f      	cmp	r3, #47	; 0x2f
 8005ed8:	f000 81c8 	beq.w	800626c <SCSI_ProcessCmd+0x3e8>
 8005edc:	2b5a      	cmp	r3, #90	; 0x5a
 8005ede:	d074      	beq.n	8005fca <SCSI_ProcessCmd+0x146>
 8005ee0:	2b2a      	cmp	r3, #42	; 0x2a
 8005ee2:	f040 81d8 	bne.w	8006296 <SCSI_ProcessCmd+0x412>
 8005ee6:	e141      	b.n	800616c <SCSI_ProcessCmd+0x2e8>
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_TestUnitReady(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 8005ee8:	f8d0 6218 	ldr.w	r6, [r0, #536]	; 0x218
    
  /* case 9 : Hi > D0 */
  if (hmsc->cbw.dDataLength != 0)
 8005eec:	f8d6 3214 	ldr.w	r3, [r6, #532]	; 0x214
 8005ef0:	2b00      	cmp	r3, #0
 8005ef2:	f040 8144 	bne.w	800617e <SCSI_ProcessCmd+0x2fa>
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);
    return -1;
  }  
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) !=0 )
 8005ef6:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8005efa:	4608      	mov	r0, r1
 8005efc:	689b      	ldr	r3, [r3, #8]
 8005efe:	4798      	blx	r3
 8005f00:	4604      	mov	r4, r0
 8005f02:	b140      	cbz	r0, 8005f16 <SCSI_ProcessCmd+0x92>
  {
    SCSI_SenseCode(pdev,
 8005f04:	233a      	movs	r3, #58	; 0x3a
 8005f06:	2202      	movs	r2, #2
 8005f08:	4639      	mov	r1, r7
 8005f0a:	4628      	mov	r0, r5
 8005f0c:	f7ff ffa2 	bl	8005e54 <SCSI_SenseCode>
                   lun,
                   NOT_READY, 
                   MEDIUM_NOT_PRESENT);
    
    hmsc->bot_state = USBD_BOT_NO_DATA;
 8005f10:	2305      	movs	r3, #5
 8005f12:	7233      	strb	r3, [r6, #8]
 8005f14:	e1c5      	b.n	80062a2 <SCSI_ProcessCmd+0x41e>
    return -1;
  } 
  hmsc->bot_data_length = 0;
 8005f16:	8170      	strh	r0, [r6, #10]
 8005f18:	e203      	b.n	8006322 <SCSI_ProcessCmd+0x49e>
  uint8_t i;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  for(i=0 ; i < REQUEST_SENSE_DATA_LEN ; i++) 
  {
    hmsc->bot_data[i] = 0;
 8005f1a:	f802 0f01 	strb.w	r0, [r2, #1]!
static int8_t SCSI_RequestSense (USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  uint8_t i;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  for(i=0 ; i < REQUEST_SENSE_DATA_LEN ; i++) 
 8005f1e:	4291      	cmp	r1, r2
 8005f20:	d1fb      	bne.n	8005f1a <SCSI_ProcessCmd+0x96>
  {
    hmsc->bot_data[i] = 0;
  }
  
  hmsc->bot_data[0]	= 0x70;		
 8005f22:	2270      	movs	r2, #112	; 0x70
 8005f24:	731a      	strb	r2, [r3, #12]
  hmsc->bot_data[7]	= REQUEST_SENSE_DATA_LEN - 6;	
 8005f26:	220c      	movs	r2, #12
 8005f28:	74da      	strb	r2, [r3, #19]
  
  if((hmsc->scsi_sense_head != hmsc->scsi_sense_tail)) {
 8005f2a:	f893 125d 	ldrb.w	r1, [r3, #605]	; 0x25d
 8005f2e:	f893 225c 	ldrb.w	r2, [r3, #604]	; 0x25c
 8005f32:	4291      	cmp	r1, r2
 8005f34:	d011      	beq.n	8005f5a <SCSI_ProcessCmd+0xd6>
 8005f36:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
    
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;		
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;	
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;	
    hmsc->scsi_sense_head++;
 8005f3a:	3201      	adds	r2, #1
  hmsc->bot_data[0]	= 0x70;		
  hmsc->bot_data[7]	= REQUEST_SENSE_DATA_LEN - 6;	
  
  if((hmsc->scsi_sense_head != hmsc->scsi_sense_tail)) {
    
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;		
 8005f3c:	f891 023c 	ldrb.w	r0, [r1, #572]	; 0x23c
 8005f40:	7398      	strb	r0, [r3, #14]
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;	
 8005f42:	f891 0241 	ldrb.w	r0, [r1, #577]	; 0x241
 8005f46:	7618      	strb	r0, [r3, #24]
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;	
    hmsc->scsi_sense_head++;
 8005f48:	b2d2      	uxtb	r2, r2
    
    if (hmsc->scsi_sense_head == SENSE_LIST_DEEPTH)
 8005f4a:	2a04      	cmp	r2, #4
  
  if((hmsc->scsi_sense_head != hmsc->scsi_sense_tail)) {
    
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;		
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;	
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;	
 8005f4c:	f891 1240 	ldrb.w	r1, [r1, #576]	; 0x240
 8005f50:	7659      	strb	r1, [r3, #25]
    hmsc->scsi_sense_head++;
    
    if (hmsc->scsi_sense_head == SENSE_LIST_DEEPTH)
    {
      hmsc->scsi_sense_head = 0;
 8005f52:	bf08      	it	eq
 8005f54:	2200      	moveq	r2, #0
 8005f56:	f883 225c 	strb.w	r2, [r3, #604]	; 0x25c
    }
  }
  hmsc->bot_data_length = REQUEST_SENSE_DATA_LEN;  
 8005f5a:	2212      	movs	r2, #18
 8005f5c:	815a      	strh	r2, [r3, #10]
  
  if (params[4] <= REQUEST_SENSE_DATA_LEN)
 8005f5e:	f898 2004 	ldrb.w	r2, [r8, #4]
 8005f62:	2a12      	cmp	r2, #18
  {
    hmsc->bot_data_length = params[4];
 8005f64:	bf98      	it	ls
 8005f66:	815a      	strhls	r2, [r3, #10]
 8005f68:	e17e      	b.n	8006268 <SCSI_ProcessCmd+0x3e4>
{
  uint8_t* pPage;
  uint16_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  if (params[1] & 0x01)/*Evpd is set*/
 8005f6a:	7853      	ldrb	r3, [r2, #1]
*/
static int8_t  SCSI_Inquiry(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  uint8_t* pPage;
  uint16_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005f6c:	f8d0 1218 	ldr.w	r1, [r0, #536]	; 0x218
  
  if (params[1] & 0x01)/*Evpd is set*/
 8005f70:	07db      	lsls	r3, r3, #31
 8005f72:	d40d      	bmi.n	8005f90 <SCSI_ProcessCmd+0x10c>
    len = LENGTH_INQUIRY_PAGE00;
  }
  else
  {
    
    pPage = (uint8_t *)&((USBD_StorageTypeDef *)pdev->pUserData)->pInquiry[lun * STANDARD_INQUIRY_DATA_LEN];
 8005f74:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
    len = pPage[4] + 5;
    
    if (params[4] <= len)
 8005f78:	7912      	ldrb	r2, [r2, #4]
    len = LENGTH_INQUIRY_PAGE00;
  }
  else
  {
    
    pPage = (uint8_t *)&((USBD_StorageTypeDef *)pdev->pUserData)->pInquiry[lun * STANDARD_INQUIRY_DATA_LEN];
 8005f7a:	69db      	ldr	r3, [r3, #28]
 8005f7c:	eb07 07c7 	add.w	r7, r7, r7, lsl #3
 8005f80:	eb03 0787 	add.w	r7, r3, r7, lsl #2
    len = pPage[4] + 5;
 8005f84:	793b      	ldrb	r3, [r7, #4]
 8005f86:	3305      	adds	r3, #5
 8005f88:	4293      	cmp	r3, r2
 8005f8a:	bf28      	it	cs
 8005f8c:	4613      	movcs	r3, r2
 8005f8e:	e001      	b.n	8005f94 <SCSI_ProcessCmd+0x110>
  uint16_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  if (params[1] & 0x01)/*Evpd is set*/
  {
    pPage = (uint8_t *)MSC_Page00_Inquiry_Data;
 8005f90:	4fd0      	ldr	r7, [pc, #832]	; (80062d4 <SCSI_ProcessCmd+0x450>)
    len = LENGTH_INQUIRY_PAGE00;
 8005f92:	2307      	movs	r3, #7
    if (params[4] <= len)
    {
      len = params[4];
    }
  }
  hmsc->bot_data_length = len;
 8005f94:	814b      	strh	r3, [r1, #10]
  
  while (len) 
 8005f96:	2b00      	cmp	r3, #0
 8005f98:	f000 8166 	beq.w	8006268 <SCSI_ProcessCmd+0x3e4>
  {
    len--;
 8005f9c:	3b01      	subs	r3, #1
 8005f9e:	b29b      	uxth	r3, r3
    hmsc->bot_data[len] = pPage[len];
 8005fa0:	18ca      	adds	r2, r1, r3
 8005fa2:	5cf8      	ldrb	r0, [r7, r3]
 8005fa4:	7310      	strb	r0, [r2, #12]
 8005fa6:	e7f6      	b.n	8005f96 <SCSI_ProcessCmd+0x112>
* @retval status
*/
static int8_t SCSI_StartStopUnit(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;   
  hmsc->bot_data_length = 0;
 8005fa8:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
 8005fac:	2400      	movs	r4, #0
 8005fae:	e1b7      	b.n	8006320 <SCSI_ProcessCmd+0x49c>
 8005fb0:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
  hmsc->bot_data_length = len;
  
  while (len) 
  {
    len--;
    hmsc->bot_data[len] = MSC_Mode_Sense6_data[len];
 8005fb4:	4cc8      	ldr	r4, [pc, #800]	; (80062d8 <SCSI_ProcessCmd+0x454>)
*/
static int8_t SCSI_ModeSense6 (USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  uint16_t len = 8 ;
  hmsc->bot_data_length = len;
 8005fb6:	2308      	movs	r3, #8
 8005fb8:	8153      	strh	r3, [r2, #10]
  
  while (len) 
  {
    len--;
 8005fba:	3b01      	subs	r3, #1
 8005fbc:	b29b      	uxth	r3, r3
    hmsc->bot_data[len] = MSC_Mode_Sense6_data[len];
 8005fbe:	18d1      	adds	r1, r2, r3
 8005fc0:	5ce0      	ldrb	r0, [r4, r3]
 8005fc2:	7308      	strb	r0, [r1, #12]
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  uint16_t len = 8 ;
  hmsc->bot_data_length = len;
  
  while (len) 
 8005fc4:	2b00      	cmp	r3, #0
 8005fc6:	d1f8      	bne.n	8005fba <SCSI_ProcessCmd+0x136>
 8005fc8:	e14e      	b.n	8006268 <SCSI_ProcessCmd+0x3e4>
 8005fca:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
  hmsc->bot_data_length = len;

  while (len) 
  {
    len--;
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 8005fce:	4cc3      	ldr	r4, [pc, #780]	; (80062dc <SCSI_ProcessCmd+0x458>)
static int8_t SCSI_ModeSense10 (USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  uint16_t len = 8;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->bot_data_length = len;
 8005fd0:	2308      	movs	r3, #8
 8005fd2:	8153      	strh	r3, [r2, #10]

  while (len) 
  {
    len--;
 8005fd4:	3b01      	subs	r3, #1
 8005fd6:	b29b      	uxth	r3, r3
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 8005fd8:	18d1      	adds	r1, r2, r3
 8005fda:	5ce0      	ldrb	r0, [r4, r3]
 8005fdc:	7308      	strb	r0, [r1, #12]
  uint16_t len = 8;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
  
  hmsc->bot_data_length = len;

  while (len) 
 8005fde:	2b00      	cmp	r3, #0
 8005fe0:	d1f8      	bne.n	8005fd4 <SCSI_ProcessCmd+0x150>
 8005fe2:	e141      	b.n	8006268 <SCSI_ProcessCmd+0x3e4>
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_ReadFormatCapacity(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8005fe4:	f8d0 6218 	ldr.w	r6, [r0, #536]	; 0x218
  uint32_t blk_nbr;
  uint16_t i;
  
  for(i=0 ; i < 12 ; i++) 
  {
    hmsc->bot_data[i] = 0;
 8005fe8:	2100      	movs	r1, #0
 8005fea:	f106 030b 	add.w	r3, r6, #11
 8005fee:	f106 0217 	add.w	r2, r6, #23
 8005ff2:	f803 1f01 	strb.w	r1, [r3, #1]!
  
  uint16_t blk_size;
  uint32_t blk_nbr;
  uint16_t i;
  
  for(i=0 ; i < 12 ; i++) 
 8005ff6:	429a      	cmp	r2, r3
 8005ff8:	d1fb      	bne.n	8005ff2 <SCSI_ProcessCmd+0x16e>
  {
    hmsc->bot_data[i] = 0;
  }
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &blk_nbr, &blk_size) != 0)
 8005ffa:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
 8005ffe:	f10d 0202 	add.w	r2, sp, #2
 8006002:	685b      	ldr	r3, [r3, #4]
 8006004:	a901      	add	r1, sp, #4
 8006006:	4638      	mov	r0, r7
 8006008:	4798      	blx	r3
 800600a:	4604      	mov	r4, r0
 800600c:	bb08      	cbnz	r0, 8006052 <SCSI_ProcessCmd+0x1ce>
                   MEDIUM_NOT_PRESENT);
    return -1;
  } 
  else
  {
    hmsc->bot_data[3] = 0x08;
 800600e:	2308      	movs	r3, #8
 8006010:	73f3      	strb	r3, [r6, #15]
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1) >> 24);
 8006012:	9b01      	ldr	r3, [sp, #4]
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1) >> 16);
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
    
    hmsc->bot_data[8] = 0x02;
    hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
 8006014:	7570      	strb	r0, [r6, #21]
    return -1;
  } 
  else
  {
    hmsc->bot_data[3] = 0x08;
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1) >> 24);
 8006016:	3b01      	subs	r3, #1
 8006018:	0e1a      	lsrs	r2, r3, #24
 800601a:	7432      	strb	r2, [r6, #16]
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1) >> 16);
 800601c:	0c1a      	lsrs	r2, r3, #16
 800601e:	7472      	strb	r2, [r6, #17]
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
 8006020:	74f3      	strb	r3, [r6, #19]
  else
  {
    hmsc->bot_data[3] = 0x08;
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1) >> 24);
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1) >> 16);
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
 8006022:	0a1a      	lsrs	r2, r3, #8
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
    
    hmsc->bot_data[8] = 0x02;
 8006024:	2302      	movs	r3, #2
 8006026:	7533      	strb	r3, [r6, #20]
    hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
 8006028:	f8bd 3002 	ldrh.w	r3, [sp, #2]
  else
  {
    hmsc->bot_data[3] = 0x08;
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1) >> 24);
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1) >> 16);
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
 800602c:	74b2      	strb	r2, [r6, #18]
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
    
    hmsc->bot_data[8] = 0x02;
    hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
    hmsc->bot_data[10] = (uint8_t)(blk_size >>  8);
 800602e:	0a1a      	lsrs	r2, r3, #8
    hmsc->bot_data[11] = (uint8_t)(blk_size);
 8006030:	75f3      	strb	r3, [r6, #23]
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
    
    hmsc->bot_data[8] = 0x02;
    hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
    hmsc->bot_data[10] = (uint8_t)(blk_size >>  8);
 8006032:	75b2      	strb	r2, [r6, #22]
    hmsc->bot_data[11] = (uint8_t)(blk_size);
    
    hmsc->bot_data_length = 12;
 8006034:	230c      	movs	r3, #12
 8006036:	e020      	b.n	800607a <SCSI_ProcessCmd+0x1f6>
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_ReadCapacity10(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8006038:	f8d0 6218 	ldr.w	r6, [r0, #536]	; 0x218
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &hmsc->scsi_blk_nbr, &hmsc->scsi_blk_size) != 0)
 800603c:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8006040:	f206 225e 	addw	r2, r6, #606	; 0x25e
 8006044:	685b      	ldr	r3, [r3, #4]
 8006046:	f506 7118 	add.w	r1, r6, #608	; 0x260
 800604a:	4638      	mov	r0, r7
 800604c:	4798      	blx	r3
 800604e:	4604      	mov	r4, r0
 8006050:	b108      	cbz	r0, 8006056 <SCSI_ProcessCmd+0x1d2>
  {
    SCSI_SenseCode(pdev,
 8006052:	233a      	movs	r3, #58	; 0x3a
 8006054:	e0a8      	b.n	80061a8 <SCSI_ProcessCmd+0x324>
    return -1;
  } 
  else
  {
    
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 24);
 8006056:	f8d6 3260 	ldr.w	r3, [r6, #608]	; 0x260
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
    
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
 800605a:	7430      	strb	r0, [r6, #16]
    return -1;
  } 
  else
  {
    
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 24);
 800605c:	3b01      	subs	r3, #1
 800605e:	0e1a      	lsrs	r2, r3, #24
 8006060:	7332      	strb	r2, [r6, #12]
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
 8006062:	0c1a      	lsrs	r2, r3, #16
 8006064:	7372      	strb	r2, [r6, #13]
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
 8006066:	73f3      	strb	r3, [r6, #15]
  else
  {
    
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 24);
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
 8006068:	0a1a      	lsrs	r2, r3, #8
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
    
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
 800606a:	f8b6 325e 	ldrh.w	r3, [r6, #606]	; 0x25e
  else
  {
    
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 24);
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
 800606e:	73b2      	strb	r2, [r6, #14]
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
    
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
    hmsc->bot_data[5] = (uint8_t)(hmsc->scsi_blk_size >>  16);
    hmsc->bot_data[6] = (uint8_t)(hmsc->scsi_blk_size >>  8);
 8006070:	0a1a      	lsrs	r2, r3, #8
    hmsc->bot_data[7] = (uint8_t)(hmsc->scsi_blk_size);
 8006072:	74f3      	strb	r3, [r6, #19]
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
    
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
    hmsc->bot_data[5] = (uint8_t)(hmsc->scsi_blk_size >>  16);
 8006074:	7470      	strb	r0, [r6, #17]
    hmsc->bot_data[6] = (uint8_t)(hmsc->scsi_blk_size >>  8);
 8006076:	74b2      	strb	r2, [r6, #18]
    hmsc->bot_data[7] = (uint8_t)(hmsc->scsi_blk_size);
    
    hmsc->bot_data_length = 8;
 8006078:	2308      	movs	r3, #8
 800607a:	8173      	strh	r3, [r6, #10]
 800607c:	e151      	b.n	8006322 <SCSI_ProcessCmd+0x49e>
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_Read10(USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 800607e:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if(hmsc->bot_state == USBD_BOT_IDLE)  /* Idle */
 8006082:	7a23      	ldrb	r3, [r4, #8]
 8006084:	bb8b      	cbnz	r3, 80060ea <SCSI_ProcessCmd+0x266>
  {
    
    /* case 10 : Ho <> Di */
    
    if ((hmsc->cbw.bmFlags & 0x80) != 0x80)
 8006086:	f994 3218 	ldrsb.w	r3, [r4, #536]	; 0x218
 800608a:	2b00      	cmp	r3, #0
 800608c:	db04      	blt.n	8006098 <SCSI_ProcessCmd+0x214>
    {
      SCSI_SenseCode(pdev,
 800608e:	2320      	movs	r3, #32
 8006090:	2205      	movs	r2, #5
 8006092:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
 8006096:	e102      	b.n	800629e <SCSI_ProcessCmd+0x41a>
                     ILLEGAL_REQUEST, 
                     INVALID_CDB);
      return -1;
    }    
    
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) !=0 )
 8006098:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 800609c:	4608      	mov	r0, r1
 800609e:	689b      	ldr	r3, [r3, #8]
 80060a0:	4798      	blx	r3
 80060a2:	2800      	cmp	r0, #0
 80060a4:	d1d5      	bne.n	8006052 <SCSI_ProcessCmd+0x1ce>
                     NOT_READY, 
                     MEDIUM_NOT_PRESENT);
      return -1;
    } 
    
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 80060a6:	f898 3003 	ldrb.w	r3, [r8, #3]
 80060aa:	f898 2002 	ldrb.w	r2, [r8, #2]
 80060ae:	041b      	lsls	r3, r3, #16
 80060b0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80060b4:	f898 2005 	ldrb.w	r2, [r8, #5]
 80060b8:	4313      	orrs	r3, r2
 80060ba:	f898 2004 	ldrb.w	r2, [r8, #4]
 80060be:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80060c2:	f8c4 3264 	str.w	r3, [r4, #612]	; 0x264
      (params[3] << 16) | \
        (params[4] <<  8) | \
          params[5];
    
    hmsc->scsi_blk_len =  (params[7] <<  8) | \
 80060c6:	f898 2008 	ldrb.w	r2, [r8, #8]
 80060ca:	f898 1007 	ldrb.w	r1, [r8, #7]
 80060ce:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 80060d2:	f8d5 2218 	ldr.w	r2, [r5, #536]	; 0x218
    hmsc->scsi_blk_addr = (params[2] << 24) | \
      (params[3] << 16) | \
        (params[4] <<  8) | \
          params[5];
    
    hmsc->scsi_blk_len =  (params[7] <<  8) | \
 80060d6:	f8c4 1268 	str.w	r1, [r4, #616]	; 0x268
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 80060da:	f8d2 2260 	ldr.w	r2, [r2, #608]	; 0x260
 80060de:	1858      	adds	r0, r3, r1
 80060e0:	4290      	cmp	r0, r2
 80060e2:	f240 80e1 	bls.w	80062a8 <SCSI_ProcessCmd+0x424>
  {
    SCSI_SenseCode(pdev,
 80060e6:	2321      	movs	r3, #33	; 0x21
 80060e8:	e0d6      	b.n	8006298 <SCSI_ProcessCmd+0x414>
* @param  lun: Logical unit number
* @retval status
*/
static int8_t SCSI_ProcessRead (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;   
 80060ea:	f8d5 6218 	ldr.w	r6, [r5, #536]	; 0x218
  uint32_t len;
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
  
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun ,
 80060ee:	f8d5 021c 	ldr.w	r0, [r5, #540]	; 0x21c
 80060f2:	f8b6 225e 	ldrh.w	r2, [r6, #606]	; 0x25e
 80060f6:	f8d6 1264 	ldr.w	r1, [r6, #612]	; 0x264
 80060fa:	f8d0 9010 	ldr.w	r9, [r0, #16]
                     ILLEGAL_REQUEST, 
                     INVALID_CDB);
      return -1;
    }
  }
  hmsc->bot_data_length = MSC_MEDIA_PACKET;  
 80060fe:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006102:	8163      	strh	r3, [r4, #10]
static int8_t SCSI_ProcessRead (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;   
  uint32_t len;
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 8006104:	f8d6 3268 	ldr.w	r3, [r6, #616]	; 0x268
 8006108:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800610c:	bf28      	it	cs
 800610e:	f44f 7300 	movcs.w	r3, #512	; 0x200
  
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun ,
                              hmsc->bot_data, 
 8006112:	f106 040c 	add.w	r4, r6, #12
static int8_t SCSI_ProcessRead (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;   
  uint32_t len;
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 8006116:	4698      	mov	r8, r3
  
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun ,
 8006118:	4638      	mov	r0, r7
 800611a:	fbb3 f3f2 	udiv	r3, r3, r2
 800611e:	fbb1 f2f2 	udiv	r2, r1, r2
 8006122:	b29b      	uxth	r3, r3
 8006124:	4621      	mov	r1, r4
 8006126:	47c8      	blx	r9
 8006128:	2800      	cmp	r0, #0
 800612a:	da01      	bge.n	8006130 <SCSI_ProcessCmd+0x2ac>
                              hmsc->bot_data, 
                              hmsc->scsi_blk_addr / hmsc->scsi_blk_size, 
                              len / hmsc->scsi_blk_size) < 0)
  {
    
    SCSI_SenseCode(pdev,
 800612c:	2311      	movs	r3, #17
 800612e:	e079      	b.n	8006224 <SCSI_ProcessCmd+0x3a0>
                   UNRECOVERED_READ_ERROR);
    return -1; 
  }
  
  
  USBD_LL_Transmit (pdev, 
 8006130:	fa1f f388 	uxth.w	r3, r8
 8006134:	4622      	mov	r2, r4
 8006136:	2181      	movs	r1, #129	; 0x81
 8006138:	4628      	mov	r0, r5
 800613a:	f7fa fbe1 	bl	8000900 <USBD_LL_Transmit>
             MSC_EPIN_ADDR,
             hmsc->bot_data,
             len);
  
  
  hmsc->scsi_blk_addr   += len; 
 800613e:	f8d6 3264 	ldr.w	r3, [r6, #612]	; 0x264
  hmsc->scsi_blk_len    -= len;  
 8006142:	f8d6 4268 	ldr.w	r4, [r6, #616]	; 0x268
             MSC_EPIN_ADDR,
             hmsc->bot_data,
             len);
  
  
  hmsc->scsi_blk_addr   += len; 
 8006146:	4443      	add	r3, r8
 8006148:	f8c6 3264 	str.w	r3, [r6, #612]	; 0x264
  hmsc->scsi_blk_len    -= len;  
  
  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
 800614c:	f8d6 3234 	ldr.w	r3, [r6, #564]	; 0x234
             hmsc->bot_data,
             len);
  
  
  hmsc->scsi_blk_addr   += len; 
  hmsc->scsi_blk_len    -= len;  
 8006150:	ebc8 0404 	rsb	r4, r8, r4
  
  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
 8006154:	ebc8 0303 	rsb	r3, r8, r3
             hmsc->bot_data,
             len);
  
  
  hmsc->scsi_blk_addr   += len; 
  hmsc->scsi_blk_len    -= len;  
 8006158:	f8c6 4268 	str.w	r4, [r6, #616]	; 0x268
  
  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
 800615c:	f8c6 3234 	str.w	r3, [r6, #564]	; 0x234
  
  if (hmsc->scsi_blk_len == 0)
 8006160:	2c00      	cmp	r4, #0
 8006162:	f040 8081 	bne.w	8006268 <SCSI_ProcessCmd+0x3e4>
  {
    hmsc->bot_state = USBD_BOT_LAST_DATA_IN;
 8006166:	2303      	movs	r3, #3
 8006168:	7233      	strb	r3, [r6, #8]
 800616a:	e0da      	b.n	8006322 <SCSI_ProcessCmd+0x49e>
* @retval status
*/

static int8_t SCSI_Write10 (USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 800616c:	f8d0 6218 	ldr.w	r6, [r0, #536]	; 0x218
  
  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
 8006170:	7a33      	ldrb	r3, [r6, #8]
 8006172:	2b00      	cmp	r3, #0
 8006174:	d13a      	bne.n	80061ec <SCSI_ProcessCmd+0x368>
  {
    
    /* case 8 : Hi <> Do */
    
    if ((hmsc->cbw.bmFlags & 0x80) == 0x80)
 8006176:	f996 3218 	ldrsb.w	r3, [r6, #536]	; 0x218
 800617a:	2b00      	cmp	r3, #0
 800617c:	da04      	bge.n	8006188 <SCSI_ProcessCmd+0x304>
    {
      SCSI_SenseCode(pdev,
 800617e:	2320      	movs	r3, #32
 8006180:	2205      	movs	r2, #5
 8006182:	f896 1219 	ldrb.w	r1, [r6, #537]	; 0x219
 8006186:	e08a      	b.n	800629e <SCSI_ProcessCmd+0x41a>
                     INVALID_CDB);
      return -1;
    }
    
    /* Check whether Media is ready */
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) !=0 )
 8006188:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 800618c:	4608      	mov	r0, r1
 800618e:	689b      	ldr	r3, [r3, #8]
 8006190:	4798      	blx	r3
 8006192:	2800      	cmp	r0, #0
 8006194:	f47f af5d 	bne.w	8006052 <SCSI_ProcessCmd+0x1ce>
                     MEDIUM_NOT_PRESENT);
      return -1;
    } 
    
    /* Check If media is write-protected */
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsWriteProtected(lun) !=0 )
 8006198:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
 800619c:	4638      	mov	r0, r7
 800619e:	68db      	ldr	r3, [r3, #12]
 80061a0:	4798      	blx	r3
 80061a2:	4604      	mov	r4, r0
 80061a4:	b110      	cbz	r0, 80061ac <SCSI_ProcessCmd+0x328>
    {
      SCSI_SenseCode(pdev,
 80061a6:	2327      	movs	r3, #39	; 0x27
 80061a8:	2202      	movs	r2, #2
 80061aa:	e076      	b.n	800629a <SCSI_ProcessCmd+0x416>
                     WRITE_PROTECTED);
      return -1;
    } 
    
    
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 80061ac:	f898 3003 	ldrb.w	r3, [r8, #3]
 80061b0:	f898 2002 	ldrb.w	r2, [r8, #2]
 80061b4:	041b      	lsls	r3, r3, #16
 80061b6:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
 80061ba:	f898 3005 	ldrb.w	r3, [r8, #5]
 80061be:	4313      	orrs	r3, r2
 80061c0:	f898 2004 	ldrb.w	r2, [r8, #4]
 80061c4:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 80061c8:	f8c6 2264 	str.w	r2, [r6, #612]	; 0x264
      (params[3] << 16) | \
        (params[4] <<  8) | \
          params[5];
    hmsc->scsi_blk_len = (params[7] <<  8) | \
 80061cc:	f898 1007 	ldrb.w	r1, [r8, #7]
 80061d0:	f898 3008 	ldrb.w	r3, [r8, #8]
 80061d4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 80061d8:	f8d5 1218 	ldr.w	r1, [r5, #536]	; 0x218
    
    hmsc->scsi_blk_addr = (params[2] << 24) | \
      (params[3] << 16) | \
        (params[4] <<  8) | \
          params[5];
    hmsc->scsi_blk_len = (params[7] <<  8) | \
 80061dc:	f8c6 3268 	str.w	r3, [r6, #616]	; 0x268
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 80061e0:	f8d1 1260 	ldr.w	r1, [r1, #608]	; 0x260
 80061e4:	18d0      	adds	r0, r2, r3
 80061e6:	4288      	cmp	r0, r1
 80061e8:	d97a      	bls.n	80062e0 <SCSI_ProcessCmd+0x45c>
 80061ea:	e77c      	b.n	80060e6 <SCSI_ProcessCmd+0x262>
static int8_t SCSI_ProcessWrite (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  uint32_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 80061ec:	f8d6 4268 	ldr.w	r4, [r6, #616]	; 0x268
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun ,
 80061f0:	f8d0 021c 	ldr.w	r0, [r0, #540]	; 0x21c
 80061f4:	f8b6 225e 	ldrh.w	r2, [r6, #606]	; 0x25e
 80061f8:	f8d6 1264 	ldr.w	r1, [r6, #612]	; 0x264
 80061fc:	f8d0 9014 	ldr.w	r9, [r0, #20]
static int8_t SCSI_ProcessWrite (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  uint32_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 8006200:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun ,
                              hmsc->bot_data, 
 8006204:	f106 080c 	add.w	r8, r6, #12
static int8_t SCSI_ProcessWrite (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
  uint32_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 8006208:	bf28      	it	cs
 800620a:	f44f 7400 	movcs.w	r4, #512	; 0x200
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun ,
 800620e:	4638      	mov	r0, r7
 8006210:	fbb4 f3f2 	udiv	r3, r4, r2
 8006214:	fbb1 f2f2 	udiv	r2, r1, r2
 8006218:	b29b      	uxth	r3, r3
 800621a:	4641      	mov	r1, r8
 800621c:	47c8      	blx	r9
 800621e:	2800      	cmp	r0, #0
 8006220:	da02      	bge.n	8006228 <SCSI_ProcessCmd+0x3a4>
                              hmsc->bot_data, 
                              hmsc->scsi_blk_addr / hmsc->scsi_blk_size, 
                              len / hmsc->scsi_blk_size) < 0)
  {
    SCSI_SenseCode(pdev,
 8006222:	2303      	movs	r3, #3
 8006224:	2204      	movs	r2, #4
 8006226:	e038      	b.n	800629a <SCSI_ProcessCmd+0x416>
                   WRITE_FAULT);     
    return -1; 
  }
  
  
  hmsc->scsi_blk_addr  += len; 
 8006228:	f8d6 3264 	ldr.w	r3, [r6, #612]	; 0x264
  hmsc->scsi_blk_len   -= len; 
  
  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
 800622c:	f8d6 2234 	ldr.w	r2, [r6, #564]	; 0x234
                   WRITE_FAULT);     
    return -1; 
  }
  
  
  hmsc->scsi_blk_addr  += len; 
 8006230:	4423      	add	r3, r4
 8006232:	f8c6 3264 	str.w	r3, [r6, #612]	; 0x264
  hmsc->scsi_blk_len   -= len; 
 8006236:	f8d6 3268 	ldr.w	r3, [r6, #616]	; 0x268
 800623a:	1b1b      	subs	r3, r3, r4
  
  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
 800623c:	1b14      	subs	r4, r2, r4
    return -1; 
  }
  
  
  hmsc->scsi_blk_addr  += len; 
  hmsc->scsi_blk_len   -= len; 
 800623e:	f8c6 3268 	str.w	r3, [r6, #616]	; 0x268
  
  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
 8006242:	f8c6 4234 	str.w	r4, [r6, #564]	; 0x234
  
  if (hmsc->scsi_blk_len == 0)
 8006246:	b923      	cbnz	r3, 8006252 <SCSI_ProcessCmd+0x3ce>
  {
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED);
 8006248:	2100      	movs	r1, #0
 800624a:	4628      	mov	r0, r5
 800624c:	f7ff fd48 	bl	8005ce0 <MSC_BOT_SendCSW>
 8006250:	e00a      	b.n	8006268 <SCSI_ProcessCmd+0x3e4>
  }
  else
  {
    /* Prepare EP to Receive next packet */
    USBD_LL_PrepareReceive (pdev,
 8006252:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006256:	bf28      	it	cs
 8006258:	f44f 7300 	movcs.w	r3, #512	; 0x200
 800625c:	b29b      	uxth	r3, r3
 800625e:	4642      	mov	r2, r8
 8006260:	2101      	movs	r1, #1
 8006262:	4628      	mov	r0, r5
 8006264:	f7fa fb53 	bl	800090e <USBD_LL_PrepareReceive>
                            MSC_EPOUT_ADDR,
                            hmsc->bot_data, 
                            MIN (hmsc->scsi_blk_len, MSC_MEDIA_PACKET)); 
  }
  
  return 0;
 8006268:	2400      	movs	r4, #0
 800626a:	e05a      	b.n	8006322 <SCSI_ProcessCmd+0x49e>

static int8_t SCSI_Verify10(USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((params[1]& 0x02) == 0x02) 
 800626c:	7852      	ldrb	r2, [r2, #1]
* @retval status
*/

static int8_t SCSI_Verify10(USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 800626e:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  if ((params[1]& 0x02) == 0x02) 
 8006272:	f002 0202 	and.w	r2, r2, #2
 8006276:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800627a:	b112      	cbz	r2, 8006282 <SCSI_ProcessCmd+0x3fe>
  {
    SCSI_SenseCode (pdev,
 800627c:	2324      	movs	r3, #36	; 0x24
 800627e:	2205      	movs	r2, #5
 8006280:	e00d      	b.n	800629e <SCSI_ProcessCmd+0x41a>
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 8006282:	f8b3 1268 	ldrh.w	r1, [r3, #616]	; 0x268
 8006286:	f8d3 2264 	ldr.w	r2, [r3, #612]	; 0x264
 800628a:	440a      	add	r2, r1
 800628c:	f8d3 1260 	ldr.w	r1, [r3, #608]	; 0x260
 8006290:	428a      	cmp	r2, r1
 8006292:	d945      	bls.n	8006320 <SCSI_ProcessCmd+0x49c>
 8006294:	e727      	b.n	80060e6 <SCSI_ProcessCmd+0x262>
    
  case SCSI_VERIFY10:
    return SCSI_Verify10(pdev, lun, params);
    
  default:
    SCSI_SenseCode(pdev, 
 8006296:	2320      	movs	r3, #32
 8006298:	2205      	movs	r2, #5
 800629a:	4639      	mov	r1, r7
 800629c:	4628      	mov	r0, r5
 800629e:	f7ff fdd9 	bl	8005e54 <SCSI_SenseCode>
                   lun,
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);    
    return -1;
 80062a2:	f04f 34ff 	mov.w	r4, #4294967295
 80062a6:	e03c      	b.n	8006322 <SCSI_ProcessCmd+0x49e>
    if( SCSI_CheckAddressRange(pdev, lun, hmsc->scsi_blk_addr, hmsc->scsi_blk_len) < 0)
    {
      return -1; /* error */
    }
    
    hmsc->bot_state = USBD_BOT_DATA_IN;
 80062a8:	2202      	movs	r2, #2
 80062aa:	7222      	strb	r2, [r4, #8]
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
 80062ac:	f8b4 225e 	ldrh.w	r2, [r4, #606]	; 0x25e
 80062b0:	4353      	muls	r3, r2
 80062b2:	f8c4 3264 	str.w	r3, [r4, #612]	; 0x264
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 80062b6:	fb02 f301 	mul.w	r3, r2, r1
    
    /* cases 4,5 : Hi <> Dn */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 80062ba:	f8d4 2214 	ldr.w	r2, [r4, #532]	; 0x214
      return -1; /* error */
    }
    
    hmsc->bot_state = USBD_BOT_DATA_IN;
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 80062be:	f8c4 3268 	str.w	r3, [r4, #616]	; 0x268
    
    /* cases 4,5 : Hi <> Dn */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 80062c2:	4293      	cmp	r3, r2
 80062c4:	f43f af11 	beq.w	80060ea <SCSI_ProcessCmd+0x266>
    {
      SCSI_SenseCode(pdev,
 80062c8:	2320      	movs	r3, #32
 80062ca:	2205      	movs	r2, #5
 80062cc:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
 80062d0:	e7e4      	b.n	800629c <SCSI_ProcessCmd+0x418>
 80062d2:	bf00      	nop
 80062d4:	0800775c 	.word	0x0800775c
 80062d8:	0800776b 	.word	0x0800776b
 80062dc:	08007763 	.word	0x08007763
                              hmsc->scsi_blk_len) < 0)
    {
      return -1; /* error */      
    }
    
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
 80062e0:	f8b6 125e 	ldrh.w	r1, [r6, #606]	; 0x25e
 80062e4:	434a      	muls	r2, r1
 80062e6:	f8c6 2264 	str.w	r2, [r6, #612]	; 0x264
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
    
    /* cases 3,11,13 : Hn,Ho <> D0 */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 80062ea:	f8d6 2214 	ldr.w	r2, [r6, #532]	; 0x214
    {
      return -1; /* error */      
    }
    
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 80062ee:	434b      	muls	r3, r1
    
    /* cases 3,11,13 : Hn,Ho <> D0 */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 80062f0:	4293      	cmp	r3, r2
    {
      return -1; /* error */      
    }
    
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 80062f2:	f8c6 3268 	str.w	r3, [r6, #616]	; 0x268
    
    /* cases 3,11,13 : Hn,Ho <> D0 */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 80062f6:	d004      	beq.n	8006302 <SCSI_ProcessCmd+0x47e>
    {
      SCSI_SenseCode(pdev,
 80062f8:	2320      	movs	r3, #32
 80062fa:	2205      	movs	r2, #5
 80062fc:	f896 1219 	ldrb.w	r1, [r6, #537]	; 0x219
 8006300:	e7cc      	b.n	800629c <SCSI_ProcessCmd+0x418>
      return -1;
    }
    
    /* Prepare EP to receive first data packet */
    hmsc->bot_state = USBD_BOT_DATA_OUT;  
    USBD_LL_PrepareReceive (pdev,
 8006302:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
                     INVALID_CDB);
      return -1;
    }
    
    /* Prepare EP to receive first data packet */
    hmsc->bot_state = USBD_BOT_DATA_OUT;  
 8006306:	f04f 0101 	mov.w	r1, #1
    USBD_LL_PrepareReceive (pdev,
 800630a:	bf28      	it	cs
 800630c:	f44f 7300 	movcs.w	r3, #512	; 0x200
                     INVALID_CDB);
      return -1;
    }
    
    /* Prepare EP to receive first data packet */
    hmsc->bot_state = USBD_BOT_DATA_OUT;  
 8006310:	7231      	strb	r1, [r6, #8]
    USBD_LL_PrepareReceive (pdev,
 8006312:	b29b      	uxth	r3, r3
 8006314:	f106 020c 	add.w	r2, r6, #12
 8006318:	4628      	mov	r0, r5
 800631a:	f7fa faf8 	bl	800090e <USBD_LL_PrepareReceive>
 800631e:	e000      	b.n	8006322 <SCSI_ProcessCmd+0x49e>
                            hmsc->scsi_blk_addr, 
                            hmsc->scsi_blk_len) < 0)
  {
    return -1; /* error */      
  }
  hmsc->bot_data_length = 0;
 8006320:	815c      	strh	r4, [r3, #10]
                   lun,
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);    
    return -1;
  }
}
 8006322:	4620      	mov	r0, r4
 8006324:	b003      	add	sp, #12
 8006326:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800632a:	bf00      	nop

0800632c <ControlNull>:
	  UART_RX();
  }
}*/
//==============================================================================
void ControlNull()
{
 800632c:	b508      	push	{r3, lr}

   if(strstr(Buf,"PacketPath"))
 800632e:	490a      	ldr	r1, [pc, #40]	; (8006358 <ControlNull+0x2c>)
 8006330:	480a      	ldr	r0, [pc, #40]	; (800635c <ControlNull+0x30>)
 8006332:	f000 fdb7 	bl	8006ea4 <strstr>
 8006336:	b128      	cbz	r0, 8006344 <ControlNull+0x18>
     {
        state_t = control_packet_path;
 8006338:	4b09      	ldr	r3, [pc, #36]	; (8006360 <ControlNull+0x34>)
        USBD_Stop(&hUsbDeviceFS);
 800633a:	480a      	ldr	r0, [pc, #40]	; (8006364 <ControlNull+0x38>)
void ControlNull()
{

   if(strstr(Buf,"PacketPath"))
     {
        state_t = control_packet_path;
 800633c:	2205      	movs	r2, #5
 800633e:	601a      	str	r2, [r3, #0]
        USBD_Stop(&hUsbDeviceFS);
 8006340:	f7ff f89d 	bl	800547e <USBD_Stop>
     }
   if(strstr(Buf,"FileTransfer"))
 8006344:	4908      	ldr	r1, [pc, #32]	; (8006368 <ControlNull+0x3c>)
 8006346:	4805      	ldr	r0, [pc, #20]	; (800635c <ControlNull+0x30>)
 8006348:	f000 fdac 	bl	8006ea4 <strstr>
 800634c:	b110      	cbz	r0, 8006354 <ControlNull+0x28>
     {
        state_t = control_packet_file;
 800634e:	4b04      	ldr	r3, [pc, #16]	; (8006360 <ControlNull+0x34>)
 8006350:	2206      	movs	r2, #6
 8006352:	601a      	str	r2, [r3, #0]
 8006354:	bd08      	pop	{r3, pc}
 8006356:	bf00      	nop
 8006358:	08007773 	.word	0x08007773
 800635c:	20001844 	.word	0x20001844
 8006360:	20001c60 	.word	0x20001c60
 8006364:	200007d0 	.word	0x200007d0
 8006368:	0800777e 	.word	0x0800777e

0800636c <seek>:
         res++;
       }
 }
//==============================================================================
char seek(unsigned char* Buf, unsigned char* Text,char lenword,unsigned int array_size)
{
 800636c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800636e:	4d0e      	ldr	r5, [pc, #56]	; (80063a8 <seek+0x3c>)
 8006370:	782c      	ldrb	r4, [r5, #0]
 8006372:	4403      	add	r3, r0
  unsigned char* pBuf   = Buf;
  unsigned char* pText  = Text;
  static char size_b = 0;
  unsigned int size = 0;
  for(size=0;size<array_size;size++)
 8006374:	2600      	movs	r6, #0
 8006376:	4298      	cmp	r0, r3
 8006378:	d012      	beq.n	80063a0 <seek+0x34>
   {
     if((*pBuf)==(*pText))
 800637a:	f810 6b01 	ldrb.w	r6, [r0], #1
 800637e:	780f      	ldrb	r7, [r1, #0]
 8006380:	42b7      	cmp	r7, r6
 8006382:	d108      	bne.n	8006396 <seek+0x2a>
       {
         pText++;
         size_b++;
 8006384:	3401      	adds	r4, #1
 8006386:	b2e4      	uxtb	r4, r4
         if(size_b>=lenword)
 8006388:	4294      	cmp	r4, r2
  unsigned int size = 0;
  for(size=0;size<array_size;size++)
   {
     if((*pBuf)==(*pText))
       {
         pText++;
 800638a:	f101 0101 	add.w	r1, r1, #1
         size_b++;
         if(size_b>=lenword)
 800638e:	d305      	bcc.n	800639c <seek+0x30>
 8006390:	702c      	strb	r4, [r5, #0]
          {
            return 1;
 8006392:	2001      	movs	r0, #1
 8006394:	bdf0      	pop	{r4, r5, r6, r7, pc}
          }
       }
        else
         {
           if(size_b>0)
 8006396:	b104      	cbz	r4, 800639a <seek+0x2e>
            {
              pText--;
 8006398:	3901      	subs	r1, #1
            }
           size_b = 0;
 800639a:	2400      	movs	r4, #0
 800639c:	2601      	movs	r6, #1
 800639e:	e7ea      	b.n	8006376 <seek+0xa>
 80063a0:	b106      	cbz	r6, 80063a4 <seek+0x38>
 80063a2:	702c      	strb	r4, [r5, #0]

         }
     pBuf++;

   }
  return 0;
 80063a4:	2000      	movs	r0, #0
}
 80063a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80063a8:	20000651 	.word	0x20000651

080063ac <resetBuffer>:

      }
}
//==============================================================================
void resetBuffer(unsigned char* Buf,unsigned int len )
{
 80063ac:	4401      	add	r1, r0
  unsigned int i = 0;
  for(i = 0;i < len;i++)
   {
      Buf[i] = 0;
 80063ae:	2300      	movs	r3, #0
}
//==============================================================================
void resetBuffer(unsigned char* Buf,unsigned int len )
{
  unsigned int i = 0;
  for(i = 0;i < len;i++)
 80063b0:	4288      	cmp	r0, r1
 80063b2:	d002      	beq.n	80063ba <resetBuffer+0xe>
   {
      Buf[i] = 0;
 80063b4:	f800 3b01 	strb.w	r3, [r0], #1
 80063b8:	e7fa      	b.n	80063b0 <resetBuffer+0x4>
   }
}
 80063ba:	4770      	bx	lr

080063bc <decoder>:


}
//==============================================================================
void decoder(char* Buf,const unsigned char len)
{
 80063bc:	b570      	push	{r4, r5, r6, lr}
 static char str_len = 0;
 static char count = 0;
 static char sub_dir_created= 0;
 //-----------------------------------------------------------------------------
      temp_buf = Buf;
      resetBuffer(DirName,LOCAL_BUF_SIZE);
 80063be:	211e      	movs	r1, #30


}
//==============================================================================
void decoder(char* Buf,const unsigned char len)
{
 80063c0:	4605      	mov	r5, r0
 static char str_len = 0;
 static char count = 0;
 static char sub_dir_created= 0;
 //-----------------------------------------------------------------------------
      temp_buf = Buf;
      resetBuffer(DirName,LOCAL_BUF_SIZE);
 80063c2:	4822      	ldr	r0, [pc, #136]	; (800644c <decoder+0x90>)
      resetBuffer(FileName,LOCAL_BUF_SIZE);
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "DirName");
      str_len = strlen("DirName");
      res+=str_len;
      count = 0;
 80063c4:	4c22      	ldr	r4, [pc, #136]	; (8006450 <decoder+0x94>)
      while((*res)!=STAR)
       {
         DirName[count++]  = (*res);
 80063c6:	4e21      	ldr	r6, [pc, #132]	; (800644c <decoder+0x90>)
 static char str_len = 0;
 static char count = 0;
 static char sub_dir_created= 0;
 //-----------------------------------------------------------------------------
      temp_buf = Buf;
      resetBuffer(DirName,LOCAL_BUF_SIZE);
 80063c8:	f7ff fff0 	bl	80063ac <resetBuffer>
      resetBuffer(SubDirName,LOCAL_BUF_SIZE);
 80063cc:	211e      	movs	r1, #30
 80063ce:	4821      	ldr	r0, [pc, #132]	; (8006454 <decoder+0x98>)
 80063d0:	f7ff ffec 	bl	80063ac <resetBuffer>
      resetBuffer(FileName,LOCAL_BUF_SIZE);
 80063d4:	211e      	movs	r1, #30
 80063d6:	4820      	ldr	r0, [pc, #128]	; (8006458 <decoder+0x9c>)
 80063d8:	f7ff ffe8 	bl	80063ac <resetBuffer>
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "DirName");
 80063dc:	491f      	ldr	r1, [pc, #124]	; (800645c <decoder+0xa0>)
 80063de:	4628      	mov	r0, r5
 80063e0:	f000 fd60 	bl	8006ea4 <strstr>
      str_len = strlen("DirName");
      res+=str_len;
      count = 0;
 80063e4:	2300      	movs	r3, #0
 80063e6:	7023      	strb	r3, [r4, #0]
 80063e8:	3006      	adds	r0, #6
      while((*res)!=STAR)
 80063ea:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 80063ee:	1c5a      	adds	r2, r3, #1
 80063f0:	292a      	cmp	r1, #42	; 0x2a
 80063f2:	b2d2      	uxtb	r2, r2
 80063f4:	d002      	beq.n	80063fc <decoder+0x40>
       {
         DirName[count++]  = (*res);
 80063f6:	54f1      	strb	r1, [r6, r3]
 80063f8:	4613      	mov	r3, r2
 80063fa:	e7f6      	b.n	80063ea <decoder+0x2e>
         res++;
       }
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "SubDirName");
 80063fc:	4918      	ldr	r1, [pc, #96]	; (8006460 <decoder+0xa4>)
      str_len = strlen("SubDirName");
      res+=str_len;
      count = 0;
       while((*res)!=STAR)
       {
         SubDirName[count++] = (*res);
 80063fe:	4e15      	ldr	r6, [pc, #84]	; (8006454 <decoder+0x98>)
       {
         DirName[count++]  = (*res);
         res++;
       }
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "SubDirName");
 8006400:	4628      	mov	r0, r5
 8006402:	f000 fd4f 	bl	8006ea4 <strstr>
      str_len = strlen("SubDirName");
      res+=str_len;
      count = 0;
 8006406:	2300      	movs	r3, #0
 8006408:	7023      	strb	r3, [r4, #0]
 800640a:	3009      	adds	r0, #9
       while((*res)!=STAR)
 800640c:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 8006410:	1c5a      	adds	r2, r3, #1
 8006412:	292a      	cmp	r1, #42	; 0x2a
 8006414:	b2d2      	uxtb	r2, r2
 8006416:	d002      	beq.n	800641e <decoder+0x62>
       {
         SubDirName[count++] = (*res);
 8006418:	54f1      	strb	r1, [r6, r3]
 800641a:	4613      	mov	r3, r2
 800641c:	e7f6      	b.n	800640c <decoder+0x50>
         res++;
       }
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "FileName");
 800641e:	4911      	ldr	r1, [pc, #68]	; (8006464 <decoder+0xa8>)
      str_len = strlen("FileName");
      res+=str_len;
      count = 0;
       while((*res)!=STAR)
       {
         FileName[count++] = (*res);
 8006420:	4e0d      	ldr	r6, [pc, #52]	; (8006458 <decoder+0x9c>)
       {
         SubDirName[count++] = (*res);
         res++;
       }
//------------------------------------------------------------------------------
      res = strstr(temp_buf, "FileName");
 8006422:	4628      	mov	r0, r5
 8006424:	f000 fd3e 	bl	8006ea4 <strstr>
      str_len = strlen("FileName");
      res+=str_len;
      count = 0;
 8006428:	2300      	movs	r3, #0
 800642a:	7023      	strb	r3, [r4, #0]
 800642c:	3007      	adds	r0, #7
       while((*res)!=STAR)
 800642e:	4619      	mov	r1, r3
 8006430:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8006434:	1c5a      	adds	r2, r3, #1
 8006436:	2d2a      	cmp	r5, #42	; 0x2a
 8006438:	b2d2      	uxtb	r2, r2
 800643a:	d003      	beq.n	8006444 <decoder+0x88>
       {
         FileName[count++] = (*res);
 800643c:	54f5      	strb	r5, [r6, r3]
 800643e:	2101      	movs	r1, #1
 8006440:	4613      	mov	r3, r2
 8006442:	e7f5      	b.n	8006430 <decoder+0x74>
 8006444:	b101      	cbz	r1, 8006448 <decoder+0x8c>
 8006446:	7023      	strb	r3, [r4, #0]
 8006448:	bd70      	pop	{r4, r5, r6, pc}
 800644a:	bf00      	nop
 800644c:	200015f4 	.word	0x200015f4
 8006450:	20000652 	.word	0x20000652
 8006454:	20001e9c 	.word	0x20001e9c
 8006458:	200020f0 	.word	0x200020f0
 800645c:	080077a5 	.word	0x080077a5
 8006460:	080077a2 	.word	0x080077a2
 8006464:	0800778b 	.word	0x0800778b

08006468 <controlPacketFile>:
      Buf[i] = 0;
   }
}
//==============================================================================
void controlPacketFile()
{
 8006468:	b508      	push	{r3, lr}
  if(seek(Buf,"End",3,GLOBAL_BUFFER_SIZE))
 800646a:	2203      	movs	r2, #3
 800646c:	f44f 6383 	mov.w	r3, #1048	; 0x418
 8006470:	4909      	ldr	r1, [pc, #36]	; (8006498 <controlPacketFile+0x30>)
 8006472:	480a      	ldr	r0, [pc, #40]	; (800649c <controlPacketFile+0x34>)
 8006474:	f7ff ff7a 	bl	800636c <seek>
 8006478:	b110      	cbz	r0, 8006480 <controlPacketFile+0x18>
    {
       state_t = file_packet_full;
 800647a:	4b09      	ldr	r3, [pc, #36]	; (80064a0 <controlPacketFile+0x38>)
 800647c:	2204      	movs	r2, #4
 800647e:	601a      	str	r2, [r3, #0]
    }
  if(seek(Buf,"Stop",4,GLOBAL_BUFFER_SIZE))
 8006480:	f44f 6383 	mov.w	r3, #1048	; 0x418
 8006484:	2204      	movs	r2, #4
 8006486:	4907      	ldr	r1, [pc, #28]	; (80064a4 <controlPacketFile+0x3c>)
 8006488:	4804      	ldr	r0, [pc, #16]	; (800649c <controlPacketFile+0x34>)
 800648a:	f7ff ff6f 	bl	800636c <seek>
 800648e:	b110      	cbz	r0, 8006496 <controlPacketFile+0x2e>
    {
       state_t =  end_file_packet;
 8006490:	4b03      	ldr	r3, [pc, #12]	; (80064a0 <controlPacketFile+0x38>)
 8006492:	2203      	movs	r2, #3
 8006494:	601a      	str	r2, [r3, #0]
 8006496:	bd08      	pop	{r3, pc}
 8006498:	080077d8 	.word	0x080077d8
 800649c:	20001844 	.word	0x20001844
 80064a0:	20001c60 	.word	0x20001c60
 80064a4:	08007794 	.word	0x08007794

080064a8 <send_to_uart>:
  UART3_Write_Text("ACK");
  state_t = null;
}
//==============================================================================
void send_to_uart(uint8_t data)  {
while(!(USART3->SR & USART_SR_TC));
 80064a8:	4a03      	ldr	r2, [pc, #12]	; (80064b8 <send_to_uart+0x10>)
 80064aa:	6813      	ldr	r3, [r2, #0]
 80064ac:	065b      	lsls	r3, r3, #25
 80064ae:	d5fc      	bpl.n	80064aa <send_to_uart+0x2>
USART3->DR=data;
 80064b0:	4b01      	ldr	r3, [pc, #4]	; (80064b8 <send_to_uart+0x10>)
 80064b2:	6058      	str	r0, [r3, #4]
 80064b4:	4770      	bx	lr
 80064b6:	bf00      	nop
 80064b8:	40004800 	.word	0x40004800

080064bc <UART3_Write_Text>:
}
//==============================================================================
void UART3_Write_Text(char * text)
{
 80064bc:	b510      	push	{r4, lr}
	uint8_t i = 0;
	while(text[i])
 80064be:	2100      	movs	r1, #0
while(!(USART3->SR & USART_SR_TC));
USART3->DR=data;
}
//==============================================================================
void UART3_Write_Text(char * text)
{
 80064c0:	4604      	mov	r4, r0
	uint8_t i = 0;
	while(text[i])
 80064c2:	b2cb      	uxtb	r3, r1
 80064c4:	3101      	adds	r1, #1
 80064c6:	5ce0      	ldrb	r0, [r4, r3]
 80064c8:	b110      	cbz	r0, 80064d0 <UART3_Write_Text+0x14>
	{
		send_to_uart(text[i]);
 80064ca:	f7ff ffed 	bl	80064a8 <send_to_uart>
 80064ce:	e7f8      	b.n	80064c2 <UART3_Write_Text+0x6>
		i++;
		//HAL_Delay(100);
	}
	//send_to_uart('\0');
}
 80064d0:	bd10      	pop	{r4, pc}
	...

080064d4 <UART2_Write_Text>:
void UART2_Write_Text(char * text)
{
	uint8_t i = 0;
	while(text[i])
	{
		while(!(USART2->SR & USART_SR_TC));
 80064d4:	490a      	ldr	r1, [pc, #40]	; (8006500 <UART2_Write_Text+0x2c>)
	}
	//send_to_uart('\0');
}
//==============================================================================
void UART2_Write_Text(char * text)
{
 80064d6:	b538      	push	{r3, r4, r5, lr}
	uint8_t i = 0;
	while(text[i])
 80064d8:	2300      	movs	r3, #0
	{
		while(!(USART2->SR & USART_SR_TC));
 80064da:	460c      	mov	r4, r1
}
//==============================================================================
void UART2_Write_Text(char * text)
{
	uint8_t i = 0;
	while(text[i])
 80064dc:	b2da      	uxtb	r2, r3
 80064de:	5c82      	ldrb	r2, [r0, r2]
 80064e0:	b12a      	cbz	r2, 80064ee <UART2_Write_Text+0x1a>
	{
		while(!(USART2->SR & USART_SR_TC));
 80064e2:	680d      	ldr	r5, [r1, #0]
 80064e4:	066d      	lsls	r5, r5, #25
 80064e6:	d5fc      	bpl.n	80064e2 <UART2_Write_Text+0xe>
		USART2->DR=text[i];
 80064e8:	6062      	str	r2, [r4, #4]
 80064ea:	3301      	adds	r3, #1
 80064ec:	e7f6      	b.n	80064dc <UART2_Write_Text+0x8>
		i++;

	}
	send_to_uart('\r');
 80064ee:	200d      	movs	r0, #13
 80064f0:	f7ff ffda 	bl	80064a8 <send_to_uart>
	send_to_uart('\n');
 80064f4:	200a      	movs	r0, #10
}
 80064f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		USART2->DR=text[i];
		i++;

	}
	send_to_uart('\r');
	send_to_uart('\n');
 80064fa:	f7ff bfd5 	b.w	80064a8 <send_to_uart>
 80064fe:	bf00      	nop
 8006500:	40004400 	.word	0x40004400

08006504 <createDir>:
        state_t = control_packet_file;
     }
}
//==============================================================================
void createDir()
{
 8006504:	b538      	push	{r3, r4, r5, lr}
	res = FR_OK;
 8006506:	4c1f      	ldr	r4, [pc, #124]	; (8006584 <createDir+0x80>)
	res = f_mkdir (DirName);
 8006508:	481f      	ldr	r0, [pc, #124]	; (8006588 <createDir+0x84>)
     }
}
//==============================================================================
void createDir()
{
	res = FR_OK;
 800650a:	2300      	movs	r3, #0
 800650c:	7023      	strb	r3, [r4, #0]
	res = f_mkdir (DirName);
 800650e:	f7fe fe03 	bl	8005118 <f_mkdir>
 8006512:	4605      	mov	r5, r0
 8006514:	7020      	strb	r0, [r4, #0]
		if(res==FR_OK)
 8006516:	b9b0      	cbnz	r0, 8006546 <createDir+0x42>
				  {
					res=f_chdir(DirName);
 8006518:	481b      	ldr	r0, [pc, #108]	; (8006588 <createDir+0x84>)
 800651a:	f7fe fcd9 	bl	8004ed0 <f_chdir>
 800651e:	7020      	strb	r0, [r4, #0]
					if(res==FR_OK)
 8006520:	b930      	cbnz	r0, 8006530 <createDir+0x2c>
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_SET);
 8006522:	2201      	movs	r2, #1
 8006524:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8006528:	4818      	ldr	r0, [pc, #96]	; (800658c <createDir+0x88>)
 800652a:	f7fa fc73 	bl	8000e14 <HAL_GPIO_WritePin>
 800652e:	e00a      	b.n	8006546 <createDir+0x42>
					 }
					 else
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
 8006530:	462a      	mov	r2, r5
 8006532:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8006536:	4815      	ldr	r0, [pc, #84]	; (800658c <createDir+0x88>)
 8006538:	f7fa fc6c 	bl	8000e14 <HAL_GPIO_WritePin>
						 UART2_Write_Text("Error in SubDirName");
 800653c:	4814      	ldr	r0, [pc, #80]	; (8006590 <createDir+0x8c>)
 800653e:	f7ff ffc9 	bl	80064d4 <UART2_Write_Text>
						 Error_Handler();
 8006542:	f7f9 febf 	bl	80002c4 <Error_Handler>
					 }
				  }
		if(res==FR_EXIST)
 8006546:	7823      	ldrb	r3, [r4, #0]
 8006548:	2b08      	cmp	r3, #8
 800654a:	d11a      	bne.n	8006582 <createDir+0x7e>
		  {
			res=f_chdir(DirName);
 800654c:	480e      	ldr	r0, [pc, #56]	; (8006588 <createDir+0x84>)
 800654e:	f7fe fcbf 	bl	8004ed0 <f_chdir>
 8006552:	4b0c      	ldr	r3, [pc, #48]	; (8006584 <createDir+0x80>)
 8006554:	7018      	strb	r0, [r3, #0]
					if(res==FR_OK)
 8006556:	b938      	cbnz	r0, 8006568 <createDir+0x64>
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_SET);
 8006558:	2201      	movs	r2, #1
 800655a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800655e:	480b      	ldr	r0, [pc, #44]	; (800658c <createDir+0x88>)
						 UART2_Write_Text("Error in SubDirName");
						 Error_Handler();
					 }
		  }

}
 8006560:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if(res==FR_EXIST)
		  {
			res=f_chdir(DirName);
					if(res==FR_OK)
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_SET);
 8006564:	f7fa bc56 	b.w	8000e14 <HAL_GPIO_WritePin>
					 }
					 else
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
 8006568:	2200      	movs	r2, #0
 800656a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800656e:	4807      	ldr	r0, [pc, #28]	; (800658c <createDir+0x88>)
 8006570:	f7fa fc50 	bl	8000e14 <HAL_GPIO_WritePin>
						 UART2_Write_Text("Error in SubDirName");
 8006574:	4806      	ldr	r0, [pc, #24]	; (8006590 <createDir+0x8c>)
 8006576:	f7ff ffad 	bl	80064d4 <UART2_Write_Text>
						 Error_Handler();
					 }
		  }

}
 800657a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
					 }
					 else
					 {
						 HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
						 UART2_Write_Text("Error in SubDirName");
						 Error_Handler();
 800657e:	f7f9 bea1 	b.w	80002c4 <Error_Handler>
 8006582:	bd38      	pop	{r3, r4, r5, pc}
 8006584:	200020ee 	.word	0x200020ee
 8006588:	200015f4 	.word	0x200015f4
 800658c:	40020c00 	.word	0x40020c00
 8006590:	08007799 	.word	0x08007799

08006594 <createSubDir>:
}
  //«десь далее пишу любую другую операцию
  //FATFS_UnLinkDriver(SD_Path);
//==============================================================================
void createSubDir()
{
 8006594:	b538      	push	{r3, r4, r5, lr}
	res = FR_OK;
 8006596:	4c1f      	ldr	r4, [pc, #124]	; (8006614 <createSubDir+0x80>)
	res = f_mkdir (SubDirName);
 8006598:	481f      	ldr	r0, [pc, #124]	; (8006618 <createSubDir+0x84>)
  //«десь далее пишу любую другую операцию
  //FATFS_UnLinkDriver(SD_Path);
//==============================================================================
void createSubDir()
{
	res = FR_OK;
 800659a:	2300      	movs	r3, #0
 800659c:	7023      	strb	r3, [r4, #0]
	res = f_mkdir (SubDirName);
 800659e:	f7fe fdbb 	bl	8005118 <f_mkdir>
 80065a2:	4605      	mov	r5, r0
 80065a4:	7020      	strb	r0, [r4, #0]
	if(res==FR_OK)
 80065a6:	b9b0      	cbnz	r0, 80065d6 <createSubDir+0x42>
			  {
				res=f_chdir(SubDirName);
 80065a8:	481b      	ldr	r0, [pc, #108]	; (8006618 <createSubDir+0x84>)
 80065aa:	f7fe fc91 	bl	8004ed0 <f_chdir>
 80065ae:	7020      	strb	r0, [r4, #0]
				if(res==FR_OK)
 80065b0:	b930      	cbnz	r0, 80065c0 <createSubDir+0x2c>
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_SET);
 80065b2:	2201      	movs	r2, #1
 80065b4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80065b8:	4818      	ldr	r0, [pc, #96]	; (800661c <createSubDir+0x88>)
 80065ba:	f7fa fc2b 	bl	8000e14 <HAL_GPIO_WritePin>
 80065be:	e00a      	b.n	80065d6 <createSubDir+0x42>
				 }
				 else
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
 80065c0:	462a      	mov	r2, r5
 80065c2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80065c6:	4815      	ldr	r0, [pc, #84]	; (800661c <createSubDir+0x88>)
 80065c8:	f7fa fc24 	bl	8000e14 <HAL_GPIO_WritePin>
					 UART2_Write_Text("Error in SubDirName");
 80065cc:	4814      	ldr	r0, [pc, #80]	; (8006620 <createSubDir+0x8c>)
 80065ce:	f7ff ff81 	bl	80064d4 <UART2_Write_Text>
					 Error_Handler();
 80065d2:	f7f9 fe77 	bl	80002c4 <Error_Handler>
				 }
			  }
	if(res==FR_EXIST)
 80065d6:	7823      	ldrb	r3, [r4, #0]
 80065d8:	2b08      	cmp	r3, #8
 80065da:	d11a      	bne.n	8006612 <createSubDir+0x7e>
	  {
		res=f_chdir(SubDirName);
 80065dc:	480e      	ldr	r0, [pc, #56]	; (8006618 <createSubDir+0x84>)
 80065de:	f7fe fc77 	bl	8004ed0 <f_chdir>
 80065e2:	4b0c      	ldr	r3, [pc, #48]	; (8006614 <createSubDir+0x80>)
 80065e4:	7018      	strb	r0, [r3, #0]
				if(res==FR_OK)
 80065e6:	b938      	cbnz	r0, 80065f8 <createSubDir+0x64>
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_SET);
 80065e8:	2201      	movs	r2, #1
 80065ea:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80065ee:	480b      	ldr	r0, [pc, #44]	; (800661c <createSubDir+0x88>)
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
					 UART2_Write_Text("Error in SubDirName");
					 Error_Handler();
				 }
	  }
}
 80065f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	if(res==FR_EXIST)
	  {
		res=f_chdir(SubDirName);
				if(res==FR_OK)
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_SET);
 80065f4:	f7fa bc0e 	b.w	8000e14 <HAL_GPIO_WritePin>
				 }
				 else
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
 80065f8:	2200      	movs	r2, #0
 80065fa:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80065fe:	4807      	ldr	r0, [pc, #28]	; (800661c <createSubDir+0x88>)
 8006600:	f7fa fc08 	bl	8000e14 <HAL_GPIO_WritePin>
					 UART2_Write_Text("Error in SubDirName");
 8006604:	4806      	ldr	r0, [pc, #24]	; (8006620 <createSubDir+0x8c>)
 8006606:	f7ff ff65 	bl	80064d4 <UART2_Write_Text>
					 Error_Handler();
				 }
	  }
}
 800660a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				 }
				 else
				 {
					 HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
					 UART2_Write_Text("Error in SubDirName");
					 Error_Handler();
 800660e:	f7f9 be59 	b.w	80002c4 <Error_Handler>
 8006612:	bd38      	pop	{r3, r4, r5, pc}
 8006614:	200020ee 	.word	0x200020ee
 8006618:	20001e9c 	.word	0x20001e9c
 800661c:	40020c00 	.word	0x40020c00
 8006620:	08007799 	.word	0x08007799

08006624 <openFile>:
				 }
	  }
}
//==============================================================================
void openFile()
{
 8006624:	b508      	push	{r3, lr}

 res = f_open(&fdst, FileName, FA_CREATE_ALWAYS | FA_WRITE);
 8006626:	220a      	movs	r2, #10
 8006628:	490d      	ldr	r1, [pc, #52]	; (8006660 <openFile+0x3c>)
 800662a:	480e      	ldr	r0, [pc, #56]	; (8006664 <openFile+0x40>)
 800662c:	f7fe fc8c 	bl	8004f48 <f_open>
 8006630:	4b0d      	ldr	r3, [pc, #52]	; (8006668 <openFile+0x44>)
 8006632:	7018      	strb	r0, [r3, #0]
 if(res==FR_OK)
 8006634:	b938      	cbnz	r0, 8006646 <openFile+0x22>
 {
	 HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_SET);
 8006636:	2201      	movs	r2, #1
 8006638:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800663c:	480b      	ldr	r0, [pc, #44]	; (800666c <openFile+0x48>)
	 UART2_Write_Text("Error open file");
	 Error_Handler();
 }


}
 800663e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{

 res = f_open(&fdst, FileName, FA_CREATE_ALWAYS | FA_WRITE);
 if(res==FR_OK)
 {
	 HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_SET);
 8006642:	f7fa bbe7 	b.w	8000e14 <HAL_GPIO_WritePin>
 }
 else
 {
	 HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_RESET);
 8006646:	2200      	movs	r2, #0
 8006648:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800664c:	4807      	ldr	r0, [pc, #28]	; (800666c <openFile+0x48>)
 800664e:	f7fa fbe1 	bl	8000e14 <HAL_GPIO_WritePin>
	 UART2_Write_Text("Error open file");
 8006652:	4807      	ldr	r0, [pc, #28]	; (8006670 <openFile+0x4c>)
 8006654:	f7ff ff3e 	bl	80064d4 <UART2_Write_Text>
	 Error_Handler();
 }


}
 8006658:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 }
 else
 {
	 HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_RESET);
	 UART2_Write_Text("Error open file");
	 Error_Handler();
 800665c:	f7f9 be32 	b.w	80002c4 <Error_Handler>
 8006660:	200020f0 	.word	0x200020f0
 8006664:	200013c8 	.word	0x200013c8
 8006668:	200020ee 	.word	0x200020ee
 800666c:	40020c00 	.word	0x40020c00
 8006670:	080077ad 	.word	0x080077ad

08006674 <Disk_Init>:
   }
  return 0;
}
//==============================================================================
void Disk_Init()
{
 8006674:	b508      	push	{r3, lr}
	if( disk_initialize(0)==RES_OK)
 8006676:	2000      	movs	r0, #0
 8006678:	f7fd f954 	bl	8003924 <disk_initialize>
 800667c:	b970      	cbnz	r0, 800669c <Disk_Init+0x28>
	  {
		res = f_mount(&SDFatFs, (TCHAR const*)SDPath, 1);
 800667e:	2201      	movs	r2, #1
 8006680:	4907      	ldr	r1, [pc, #28]	; (80066a0 <Disk_Init+0x2c>)
 8006682:	4808      	ldr	r0, [pc, #32]	; (80066a4 <Disk_Init+0x30>)
 8006684:	f7fd ff18 	bl	80044b8 <f_mount>
 8006688:	4b07      	ldr	r3, [pc, #28]	; (80066a8 <Disk_Init+0x34>)
 800668a:	7018      	strb	r0, [r3, #0]
		if( res!= FR_OK)
 800668c:	b130      	cbz	r0, 800669c <Disk_Init+0x28>
		  	      {
		  	         //FatFs Initialization Error
				   UART2_Write_Text("Error mount disk");
 800668e:	4807      	ldr	r0, [pc, #28]	; (80066ac <Disk_Init+0x38>)
 8006690:	f7ff ff20 	bl	80064d4 <UART2_Write_Text>
				  else
				  {
					  //HAL_GPIO_WritePin(GPIOD, LD4_Pin, GPIO_PIN_SET);
				  }
	  }
}
 8006694:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		res = f_mount(&SDFatFs, (TCHAR const*)SDPath, 1);
		if( res!= FR_OK)
		  	      {
		  	         //FatFs Initialization Error
				   UART2_Write_Text("Error mount disk");
				   Error_Handler();
 8006698:	f7f9 be14 	b.w	80002c4 <Error_Handler>
 800669c:	bd08      	pop	{r3, pc}
 800669e:	bf00      	nop
 80066a0:	20001c5c 	.word	0x20001c5c
 80066a4:	20001c64 	.word	0x20001c64
 80066a8:	200020ee 	.word	0x200020ee
 80066ac:	080077bd 	.word	0x080077bd

080066b0 <resetLeds>:

  //SystemReset();
}
//==============================================================================
void resetLeds()
{
 80066b0:	b510      	push	{r4, lr}
	HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_RESET);
 80066b2:	4c0d      	ldr	r4, [pc, #52]	; (80066e8 <resetLeds+0x38>)
 80066b4:	2200      	movs	r2, #0
 80066b6:	4620      	mov	r0, r4
 80066b8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80066bc:	f7fa fbaa 	bl	8000e14 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOD, LD4_Pin, GPIO_PIN_RESET);
 80066c0:	4620      	mov	r0, r4
 80066c2:	2200      	movs	r2, #0
 80066c4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80066c8:	f7fa fba4 	bl	8000e14 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
 80066cc:	4620      	mov	r0, r4
 80066ce:	2200      	movs	r2, #0
 80066d0:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80066d4:	f7fa fb9e 	bl	8000e14 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
 80066d8:	4620      	mov	r0, r4
 80066da:	2200      	movs	r2, #0
 80066dc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
}
 80066e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void resetLeds()
{
	HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOD, LD4_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET);
 80066e4:	f7fa bb96 	b.w	8000e14 <HAL_GPIO_WritePin>
 80066e8:	40020c00 	.word	0x40020c00

080066ec <controlPacketPath>:
}
//==============================================================================
void controlPacketPath()
{
 80066ec:	b508      	push	{r3, lr}
  if(strstr(Buf,"PacketPathEnd"))
 80066ee:	4904      	ldr	r1, [pc, #16]	; (8006700 <controlPacketPath+0x14>)
 80066f0:	4804      	ldr	r0, [pc, #16]	; (8006704 <controlPacketPath+0x18>)
 80066f2:	f000 fbd7 	bl	8006ea4 <strstr>
 80066f6:	b110      	cbz	r0, 80066fe <controlPacketPath+0x12>
     {
       state_t = path_packet_full;
 80066f8:	4b03      	ldr	r3, [pc, #12]	; (8006708 <controlPacketPath+0x1c>)
 80066fa:	2201      	movs	r2, #1
 80066fc:	601a      	str	r2, [r3, #0]
 80066fe:	bd08      	pop	{r3, pc}
 8006700:	080077ce 	.word	0x080077ce
 8006704:	20001844 	.word	0x20001844
 8006708:	20001c60 	.word	0x20001c60

0800670c <clearBuf>:
 }
//==============================================================================
void clearBuf()
{
   unsigned int i = 0;
   count_buf = 0;
 800670c:	4a05      	ldr	r2, [pc, #20]	; (8006724 <clearBuf+0x18>)
 800670e:	2300      	movs	r3, #0
 8006710:	6013      	str	r3, [r2, #0]
   for(i = 0;i<GLOBAL_BUFFER_SIZE;i++)
    {
      Buf[i] = 0;
 8006712:	4a05      	ldr	r2, [pc, #20]	; (8006728 <clearBuf+0x1c>)
 8006714:	4619      	mov	r1, r3
 8006716:	5499      	strb	r1, [r3, r2]
//==============================================================================
void clearBuf()
{
   unsigned int i = 0;
   count_buf = 0;
   for(i = 0;i<GLOBAL_BUFFER_SIZE;i++)
 8006718:	3301      	adds	r3, #1
 800671a:	f5b3 6f83 	cmp.w	r3, #1048	; 0x418
 800671e:	d1fa      	bne.n	8006716 <clearBuf+0xa>
    {
      Buf[i] = 0;
    }
}
 8006720:	4770      	bx	lr
 8006722:	bf00      	nop
 8006724:	20000654 	.word	0x20000654
 8006728:	20001844 	.word	0x20001844

0800672c <readFilePacket>:
       state_t =  end_file_packet;
    }
}
//==============================================================================
void readFilePacket()
{
 800672c:	b570      	push	{r4, r5, r6, lr}
 unsigned int str_len = 0,length = 0;
 unsigned char* res;
 unsigned int size_array = 0;

  resetBuffer(writeBuffer,GLOBAL_BUFFER_SIZE);
 800672e:	f44f 6183 	mov.w	r1, #1048	; 0x418
 8006732:	4818      	ldr	r0, [pc, #96]	; (8006794 <readFilePacket+0x68>)
  res = strstr(Buf, "FileTransfer");
  str_len = strlen("FileTransfer");
  res+=str_len;
     while(TRUE)
      {
         if(seek(writeBuffer,"End",3,GLOBAL_BUFFER_SIZE))
 8006734:	4e17      	ldr	r6, [pc, #92]	; (8006794 <readFilePacket+0x68>)
{
 unsigned int str_len = 0,length = 0;
 unsigned char* res;
 unsigned int size_array = 0;

  resetBuffer(writeBuffer,GLOBAL_BUFFER_SIZE);
 8006736:	f7ff fe39 	bl	80063ac <resetBuffer>
  //resetBuffer(readBuffer,GLOBAL_BUFFER_SIZE);
  res = strstr(Buf, "FileTransfer");
 800673a:	4917      	ldr	r1, [pc, #92]	; (8006798 <readFilePacket+0x6c>)
 800673c:	4817      	ldr	r0, [pc, #92]	; (800679c <readFilePacket+0x70>)
 800673e:	f000 fbb1 	bl	8006ea4 <strstr>
    }
}
//==============================================================================
void readFilePacket()
{
 unsigned int str_len = 0,length = 0;
 8006742:	2400      	movs	r4, #0
 8006744:	f100 050b 	add.w	r5, r0, #11
  res = strstr(Buf, "FileTransfer");
  str_len = strlen("FileTransfer");
  res+=str_len;
     while(TRUE)
      {
         if(seek(writeBuffer,"End",3,GLOBAL_BUFFER_SIZE))
 8006748:	f44f 6383 	mov.w	r3, #1048	; 0x418
 800674c:	2203      	movs	r2, #3
 800674e:	4914      	ldr	r1, [pc, #80]	; (80067a0 <readFilePacket+0x74>)
 8006750:	4810      	ldr	r0, [pc, #64]	; (8006794 <readFilePacket+0x68>)
 8006752:	f7ff fe0b 	bl	800636c <seek>
 8006756:	b920      	cbnz	r0, 8006762 <readFilePacket+0x36>
          {
            break;
          }
          else
           {
             writeBuffer[length] = *res;
 8006758:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 800675c:	55a3      	strb	r3, [r4, r6]
             length++;
 800675e:	3401      	adds	r4, #1
             res++;
           }
      }
 8006760:	e7f2      	b.n	8006748 <readFilePacket+0x1c>
  size_array = length -  strlen("End");
  //uint8_t * buffer = (uint8_t*) malloc(size_array);
  //memcpy (buffer, writeBuffer,size_array);

  fileRes = FR_OK;
 8006762:	4d10      	ldr	r5, [pc, #64]	; (80067a4 <readFilePacket+0x78>)
  fileRes = f_write(&fdst, writeBuffer, size_array, &bw);
 8006764:	490b      	ldr	r1, [pc, #44]	; (8006794 <readFilePacket+0x68>)
 8006766:	4810      	ldr	r0, [pc, #64]	; (80067a8 <readFilePacket+0x7c>)
      }
  size_array = length -  strlen("End");
  //uint8_t * buffer = (uint8_t*) malloc(size_array);
  //memcpy (buffer, writeBuffer,size_array);

  fileRes = FR_OK;
 8006768:	2300      	movs	r3, #0
 800676a:	702b      	strb	r3, [r5, #0]
  fileRes = f_write(&fdst, writeBuffer, size_array, &bw);
 800676c:	1ee2      	subs	r2, r4, #3
 800676e:	4b0f      	ldr	r3, [pc, #60]	; (80067ac <readFilePacket+0x80>)
 8006770:	f7fd fedc 	bl	800452c <f_write>
 8006774:	7028      	strb	r0, [r5, #0]
  if(fileRes!=FR_OK)
 8006776:	b120      	cbz	r0, 8006782 <readFilePacket+0x56>
  {
	  UART2_Write_Text("Error write file");
 8006778:	480d      	ldr	r0, [pc, #52]	; (80067b0 <readFilePacket+0x84>)
 800677a:	f7ff feab 	bl	80064d4 <UART2_Write_Text>
	  Error_Handler();
 800677e:	f7f9 fda1 	bl	80002c4 <Error_Handler>
  }
  //free(buffer);
  clearBuf();
 8006782:	f7ff ffc3 	bl	800670c <clearBuf>
  UART3_Write_Text("ACK");
 8006786:	480b      	ldr	r0, [pc, #44]	; (80067b4 <readFilePacket+0x88>)
 8006788:	f7ff fe98 	bl	80064bc <UART3_Write_Text>
  state_t = null;
 800678c:	4b0a      	ldr	r3, [pc, #40]	; (80067b8 <readFilePacket+0x8c>)
 800678e:	2200      	movs	r2, #0
 8006790:	601a      	str	r2, [r3, #0]
 8006792:	bd70      	pop	{r4, r5, r6, pc}
 8006794:	20000fb0 	.word	0x20000fb0
 8006798:	0800777e 	.word	0x0800777e
 800679c:	20001844 	.word	0x20001844
 80067a0:	080077d8 	.word	0x080077d8
 80067a4:	200020ec 	.word	0x200020ec
 80067a8:	200013c8 	.word	0x200013c8
 80067ac:	20001ebc 	.word	0x20001ebc
 80067b0:	080077dc 	.word	0x080077dc
 80067b4:	080077ed 	.word	0x080077ed
 80067b8:	20001c60 	.word	0x20001c60

080067bc <readFilePacketEnd>:
	send_to_uart('\r');
	send_to_uart('\n');
}
//==============================================================================
void readFilePacketEnd()
{
 80067bc:	b570      	push	{r4, r5, r6, lr}
 unsigned int str_len = 0,length = 0;
 unsigned char* res;
 unsigned int size_array = 0;

  resetBuffer(writeBuffer,GLOBAL_BUFFER_SIZE);
 80067be:	f44f 6183 	mov.w	r1, #1048	; 0x418
 80067c2:	4828      	ldr	r0, [pc, #160]	; (8006864 <readFilePacketEnd+0xa8>)
  res = strstr(Buf, "FileTransfer");
  str_len = strlen("FileTransfer");
  res+=str_len;
     while(TRUE)
      {
         if(seek(writeBuffer,"Stop",4,GLOBAL_BUFFER_SIZE))
 80067c4:	4e27      	ldr	r6, [pc, #156]	; (8006864 <readFilePacketEnd+0xa8>)
{
 unsigned int str_len = 0,length = 0;
 unsigned char* res;
 unsigned int size_array = 0;

  resetBuffer(writeBuffer,GLOBAL_BUFFER_SIZE);
 80067c6:	f7ff fdf1 	bl	80063ac <resetBuffer>
  res = strstr(Buf, "FileTransfer");
 80067ca:	4927      	ldr	r1, [pc, #156]	; (8006868 <readFilePacketEnd+0xac>)
 80067cc:	4827      	ldr	r0, [pc, #156]	; (800686c <readFilePacketEnd+0xb0>)
 80067ce:	f000 fb69 	bl	8006ea4 <strstr>
	send_to_uart('\n');
}
//==============================================================================
void readFilePacketEnd()
{
 unsigned int str_len = 0,length = 0;
 80067d2:	2500      	movs	r5, #0
 80067d4:	f100 040b 	add.w	r4, r0, #11
  res = strstr(Buf, "FileTransfer");
  str_len = strlen("FileTransfer");
  res+=str_len;
     while(TRUE)
      {
         if(seek(writeBuffer,"Stop",4,GLOBAL_BUFFER_SIZE))
 80067d8:	f44f 6383 	mov.w	r3, #1048	; 0x418
 80067dc:	2204      	movs	r2, #4
 80067de:	4924      	ldr	r1, [pc, #144]	; (8006870 <readFilePacketEnd+0xb4>)
 80067e0:	4820      	ldr	r0, [pc, #128]	; (8006864 <readFilePacketEnd+0xa8>)
 80067e2:	f7ff fdc3 	bl	800636c <seek>
 80067e6:	b920      	cbnz	r0, 80067f2 <readFilePacketEnd+0x36>
          {
            break;
          }
          else
           {
             writeBuffer[length] = *res;
 80067e8:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 80067ec:	55ab      	strb	r3, [r5, r6]
             length++;
 80067ee:	3501      	adds	r5, #1
             res++;
           }
      }
 80067f0:	e7f2      	b.n	80067d8 <readFilePacketEnd+0x1c>
  size_array = length -  strlen("Stop");
  //uint8_t * buffer = (uint8_t*) malloc(size_array);
  //memcpy (buffer, writeBuffer,size_array+1);
  fileRes = FR_OK;
 80067f2:	4c20      	ldr	r4, [pc, #128]	; (8006874 <readFilePacketEnd+0xb8>)
  fileRes = f_write(&fdst, writeBuffer, size_array, &bw);
 80067f4:	491b      	ldr	r1, [pc, #108]	; (8006864 <readFilePacketEnd+0xa8>)
 80067f6:	4820      	ldr	r0, [pc, #128]	; (8006878 <readFilePacketEnd+0xbc>)
           }
      }
  size_array = length -  strlen("Stop");
  //uint8_t * buffer = (uint8_t*) malloc(size_array);
  //memcpy (buffer, writeBuffer,size_array+1);
  fileRes = FR_OK;
 80067f8:	2300      	movs	r3, #0
 80067fa:	7023      	strb	r3, [r4, #0]
  fileRes = f_write(&fdst, writeBuffer, size_array, &bw);
 80067fc:	1f2a      	subs	r2, r5, #4
 80067fe:	4b1f      	ldr	r3, [pc, #124]	; (800687c <readFilePacketEnd+0xc0>)
 8006800:	f7fd fe94 	bl	800452c <f_write>
 8006804:	7020      	strb	r0, [r4, #0]
  if(fileRes!=FR_OK)
 8006806:	b120      	cbz	r0, 8006812 <readFilePacketEnd+0x56>
    {
	  UART2_Write_Text("Error last write file");
 8006808:	481d      	ldr	r0, [pc, #116]	; (8006880 <readFilePacketEnd+0xc4>)
 800680a:	f7ff fe63 	bl	80064d4 <UART2_Write_Text>
	  Error_Handler();
 800680e:	f7f9 fd59 	bl	80002c4 <Error_Handler>
    }

  fileRes = f_close(&fdst);
 8006812:	4819      	ldr	r0, [pc, #100]	; (8006878 <readFilePacketEnd+0xbc>)
 8006814:	f7fd ffdc 	bl	80047d0 <f_close>
 8006818:	7020      	strb	r0, [r4, #0]
  if(fileRes!=FR_OK)
 800681a:	b120      	cbz	r0, 8006826 <readFilePacketEnd+0x6a>
  {
	   UART2_Write_Text("Error close file");
 800681c:	4819      	ldr	r0, [pc, #100]	; (8006884 <readFilePacketEnd+0xc8>)
 800681e:	f7ff fe59 	bl	80064d4 <UART2_Write_Text>
	  Error_Handler();
 8006822:	f7f9 fd4f 	bl	80002c4 <Error_Handler>
  }
  //free(buffer);
  clearBuf();
 8006826:	f7ff ff71 	bl	800670c <clearBuf>
  fileRes=FR_OK;
 800682a:	2300      	movs	r3, #0
  fileRes = f_chdir("..");
 800682c:	4816      	ldr	r0, [pc, #88]	; (8006888 <readFilePacketEnd+0xcc>)
	   UART2_Write_Text("Error close file");
	  Error_Handler();
  }
  //free(buffer);
  clearBuf();
  fileRes=FR_OK;
 800682e:	7023      	strb	r3, [r4, #0]
  fileRes = f_chdir("..");
 8006830:	f7fe fb4e 	bl	8004ed0 <f_chdir>
 8006834:	7020      	strb	r0, [r4, #0]
  if(fileRes==FR_OK)
 8006836:	b928      	cbnz	r0, 8006844 <readFilePacketEnd+0x88>
	  {
	  fileRes = f_chdir("..");
 8006838:	4813      	ldr	r0, [pc, #76]	; (8006888 <readFilePacketEnd+0xcc>)
 800683a:	f7fe fb49 	bl	8004ed0 <f_chdir>
 800683e:	4b0d      	ldr	r3, [pc, #52]	; (8006874 <readFilePacketEnd+0xb8>)
 8006840:	7018      	strb	r0, [r3, #0]
	  if(fileRes==FR_OK)
 8006842:	b120      	cbz	r0, 800684e <readFilePacketEnd+0x92>
			  {

			  }
		  else
		  {
			   UART2_Write_Text("Error go to root dir");
 8006844:	4811      	ldr	r0, [pc, #68]	; (800688c <readFilePacketEnd+0xd0>)
 8006846:	f7ff fe45 	bl	80064d4 <UART2_Write_Text>
			  Error_Handler();
 800684a:	f7f9 fd3b 	bl	80002c4 <Error_Handler>
	  {
		  UART2_Write_Text("Error go to root dir");
		  Error_Handler();
	  }

  clearBuf();
 800684e:	f7ff ff5d 	bl	800670c <clearBuf>
  resetLeds();
 8006852:	f7ff ff2d 	bl	80066b0 <resetLeds>
  UART3_Write_Text("ACK");
 8006856:	480e      	ldr	r0, [pc, #56]	; (8006890 <readFilePacketEnd+0xd4>)
 8006858:	f7ff fe30 	bl	80064bc <UART3_Write_Text>
  //UART3_Write_Text("ACK");
  state_t = null;
 800685c:	4b0d      	ldr	r3, [pc, #52]	; (8006894 <readFilePacketEnd+0xd8>)
 800685e:	2200      	movs	r2, #0
 8006860:	601a      	str	r2, [r3, #0]
 8006862:	bd70      	pop	{r4, r5, r6, pc}
 8006864:	20000fb0 	.word	0x20000fb0
 8006868:	0800777e 	.word	0x0800777e
 800686c:	20001844 	.word	0x20001844
 8006870:	08007794 	.word	0x08007794
 8006874:	200020ec 	.word	0x200020ec
 8006878:	200013c8 	.word	0x200013c8
 800687c:	20001ebc 	.word	0x20001ebc
 8006880:	080077f1 	.word	0x080077f1
 8006884:	08007807 	.word	0x08007807
 8006888:	08007818 	.word	0x08007818
 800688c:	0800781b 	.word	0x0800781b
 8006890:	080077ed 	.word	0x080077ed
 8006894:	20001c60 	.word	0x20001c60

08006898 <readRXbuffer>:
     }
}
//==============================================================================
void readRXbuffer()
{
 Buf[count_buf] =  UART_Data;
 8006898:	4a07      	ldr	r2, [pc, #28]	; (80068b8 <readRXbuffer+0x20>)
 800689a:	4908      	ldr	r1, [pc, #32]	; (80068bc <readRXbuffer+0x24>)
 800689c:	6813      	ldr	r3, [r2, #0]
 800689e:	7808      	ldrb	r0, [r1, #0]
 80068a0:	4907      	ldr	r1, [pc, #28]	; (80068c0 <readRXbuffer+0x28>)
 80068a2:	54c8      	strb	r0, [r1, r3]
   count_buf++;
 80068a4:	3301      	adds	r3, #1
 80068a6:	6013      	str	r3, [r2, #0]
    if(count_buf>=(GLOBAL_BUFFER_SIZE-1))
 80068a8:	f240 4216 	movw	r2, #1046	; 0x416
 80068ac:	4293      	cmp	r3, r2
 80068ae:	d901      	bls.n	80068b4 <readRXbuffer+0x1c>
      {
       clearBuf();
 80068b0:	f7ff bf2c 	b.w	800670c <clearBuf>
 80068b4:	4770      	bx	lr
 80068b6:	bf00      	nop
 80068b8:	20000654 	.word	0x20000654
 80068bc:	200020ed 	.word	0x200020ed
 80068c0:	20001844 	.word	0x20001844

080068c4 <control_in_buf>:
      }
}
//==============================================================================
void control_in_buf()
 {
 80068c4:	b508      	push	{r3, lr}
     if(seek(Buf,"RST",3,GLOBAL_BUFFER_SIZE))
 80068c6:	2203      	movs	r2, #3
 80068c8:	f44f 6383 	mov.w	r3, #1048	; 0x418
 80068cc:	490f      	ldr	r1, [pc, #60]	; (800690c <control_in_buf+0x48>)
 80068ce:	4810      	ldr	r0, [pc, #64]	; (8006910 <control_in_buf+0x4c>)
 80068d0:	f7ff fd4c 	bl	800636c <seek>
 80068d4:	b160      	cbz	r0, 80068f0 <control_in_buf+0x2c>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80068d6:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80068da:	490e      	ldr	r1, [pc, #56]	; (8006914 <control_in_buf+0x50>)
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80068dc:	4b0e      	ldr	r3, [pc, #56]	; (8006918 <control_in_buf+0x54>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80068de:	68ca      	ldr	r2, [r1, #12]
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80068e0:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80068e4:	4313      	orrs	r3, r2
 80068e6:	60cb      	str	r3, [r1, #12]
 80068e8:	f3bf 8f4f 	dsb	sy
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80068ec:	bf00      	nop
 80068ee:	e7fd      	b.n	80068ec <control_in_buf+0x28>
     {
    	 NVIC_SystemReset();
     }
    if(seek(Buf,"CONNECT",7,GLOBAL_BUFFER_SIZE))
 80068f0:	f44f 6383 	mov.w	r3, #1048	; 0x418
 80068f4:	2207      	movs	r2, #7
 80068f6:	4909      	ldr	r1, [pc, #36]	; (800691c <control_in_buf+0x58>)
 80068f8:	4805      	ldr	r0, [pc, #20]	; (8006910 <control_in_buf+0x4c>)
 80068fa:	f7ff fd37 	bl	800636c <seek>
 80068fe:	b118      	cbz	r0, 8006908 <control_in_buf+0x44>
     {
       clearBuf();
     }

 }
 8006900:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     {
    	 NVIC_SystemReset();
     }
    if(seek(Buf,"CONNECT",7,GLOBAL_BUFFER_SIZE))
     {
       clearBuf();
 8006904:	f7ff bf02 	b.w	800670c <clearBuf>
 8006908:	bd08      	pop	{r3, pc}
 800690a:	bf00      	nop
 800690c:	08007830 	.word	0x08007830
 8006910:	20001844 	.word	0x20001844
 8006914:	e000ed00 	.word	0xe000ed00
 8006918:	05fa0004 	.word	0x05fa0004
 800691c:	08007834 	.word	0x08007834

08006920 <createPath>:
      Buf[i] = 0;
    }
}
//==============================================================================
void createPath()
{
 8006920:	b510      	push	{r4, lr}
 switch(path_state_t)
 8006922:	4c0c      	ldr	r4, [pc, #48]	; (8006954 <createPath+0x34>)
 8006924:	6823      	ldr	r3, [r4, #0]
 8006926:	2b01      	cmp	r3, #1
 8006928:	d007      	beq.n	800693a <createPath+0x1a>
 800692a:	d302      	bcc.n	8006932 <createPath+0x12>
 800692c:	2b02      	cmp	r3, #2
 800692e:	d009      	beq.n	8006944 <createPath+0x24>
 8006930:	bd10      	pop	{r4, pc}
 {
    case dir:
         createDir();
 8006932:	f7ff fde7 	bl	8006504 <createDir>
         path_state_t = sub_dir;
 8006936:	2301      	movs	r3, #1
 8006938:	e002      	b.n	8006940 <createPath+0x20>
    break;

    case sub_dir:
         createSubDir();
 800693a:	f7ff fe2b 	bl	8006594 <createSubDir>
         path_state_t = open_file;
 800693e:	2302      	movs	r3, #2
 8006940:	6023      	str	r3, [r4, #0]
    break;
 8006942:	bd10      	pop	{r4, pc}

    case open_file:
         openFile();
 8006944:	f7ff fe6e 	bl	8006624 <openFile>
         clearBuf();
 8006948:	f7ff fee0 	bl	800670c <clearBuf>
         state_t = null;
 800694c:	4b02      	ldr	r3, [pc, #8]	; (8006958 <createPath+0x38>)
 800694e:	2200      	movs	r2, #0
 8006950:	601a      	str	r2, [r3, #0]
 8006952:	bd10      	pop	{r4, pc}
 8006954:	20001e98 	.word	0x20001e98
 8006958:	20001c60 	.word	0x20001c60

0800695c <stateMashin>:
	  }
}
//==============================================================================
void stateMashin()
{
   switch(state_t)
 800695c:	4b17      	ldr	r3, [pc, #92]	; (80069bc <stateMashin+0x60>)
 800695e:	681a      	ldr	r2, [r3, #0]
				  }
	  }
}
//==============================================================================
void stateMashin()
{
 8006960:	b510      	push	{r4, lr}
 8006962:	461c      	mov	r4, r3
   switch(state_t)
 8006964:	2a06      	cmp	r2, #6
 8006966:	d827      	bhi.n	80069b8 <stateMashin+0x5c>
 8006968:	e8df f002 	tbb	[pc, r2]
 800696c:	22160c04 	.word	0x22160c04
 8006970:	081e      	.short	0x081e
 8006972:	1a          	.byte	0x1a
 8006973:	00          	.byte	0x00
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 8006974:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
   switch(state_t)
      {
//------------------------------------------------------------------------------
        case null:
             ControlNull();
 8006978:	f7ff bcd8 	b.w	800632c <ControlNull>
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 800697c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        case null:
             ControlNull();
        break;
//------------------------------------------------------------------------------
        case control_packet_path:
             controlPacketPath();
 8006980:	f7ff beb4 	b.w	80066ec <controlPacketPath>
        break;
//------------------------------------------------------------------------------
        case path_packet_full:
             decoder(Buf,GLOBAL_BUFFER_SIZE);
 8006984:	2118      	movs	r1, #24
 8006986:	480e      	ldr	r0, [pc, #56]	; (80069c0 <stateMashin+0x64>)
 8006988:	f7ff fd18 	bl	80063bc <decoder>
             state_t = create_path;
 800698c:	2302      	movs	r3, #2
 800698e:	6023      	str	r3, [r4, #0]
             path_state_t = dir;
 8006990:	4b0c      	ldr	r3, [pc, #48]	; (80069c4 <stateMashin+0x68>)
 8006992:	2200      	movs	r2, #0
 8006994:	601a      	str	r2, [r3, #0]
        break;
 8006996:	bd10      	pop	{r4, pc}
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 8006998:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
             state_t = create_path;
             path_state_t = dir;
        break;
//------------------------------------------------------------------------------
        case create_path:
             createPath();
 800699c:	f7ff bfc0 	b.w	8006920 <createPath>
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 80069a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        case create_path:
             createPath();
        break;
//------------------------------------------------------------------------------
        case control_packet_file:
             controlPacketFile();
 80069a4:	f7ff bd60 	b.w	8006468 <controlPacketFile>
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 80069a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        case control_packet_file:
             controlPacketFile();
        break;
//------------------------------------------------------------------------------
        case file_packet_full:
             readFilePacket();
 80069ac:	f7ff bebe 	b.w	800672c <readFilePacket>
        case end_file_packet:
             readFilePacketEnd();
        break;

      }
}
 80069b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        case file_packet_full:
             readFilePacket();
        break;
//------------------------------------------------------------------------------
        case end_file_packet:
             readFilePacketEnd();
 80069b4:	f7ff bf02 	b.w	80067bc <readFilePacketEnd>
 80069b8:	bd10      	pop	{r4, pc}
 80069ba:	bf00      	nop
 80069bc:	20001c60 	.word	0x20001c60
 80069c0:	20001844 	.word	0x20001844
 80069c4:	20001e98 	.word	0x20001e98

080069c8 <InitStateMashine>:
}
//==============================================================================

void InitStateMashine()
{
   state_t = null;
 80069c8:	4b01      	ldr	r3, [pc, #4]	; (80069d0 <InitStateMashine+0x8>)
 80069ca:	2200      	movs	r2, #0
 80069cc:	601a      	str	r2, [r3, #0]
 80069ce:	4770      	bx	lr
 80069d0:	20001c60 	.word	0x20001c60

080069d4 <__libc_init_array>:
 80069d4:	b570      	push	{r4, r5, r6, lr}
 80069d6:	4b0e      	ldr	r3, [pc, #56]	; (8006a10 <__libc_init_array+0x3c>)
 80069d8:	4c0e      	ldr	r4, [pc, #56]	; (8006a14 <__libc_init_array+0x40>)
 80069da:	1ae4      	subs	r4, r4, r3
 80069dc:	10a4      	asrs	r4, r4, #2
 80069de:	2500      	movs	r5, #0
 80069e0:	461e      	mov	r6, r3
 80069e2:	42a5      	cmp	r5, r4
 80069e4:	d004      	beq.n	80069f0 <__libc_init_array+0x1c>
 80069e6:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80069ea:	4798      	blx	r3
 80069ec:	3501      	adds	r5, #1
 80069ee:	e7f8      	b.n	80069e2 <__libc_init_array+0xe>
 80069f0:	f000 fb94 	bl	800711c <_init>
 80069f4:	4c08      	ldr	r4, [pc, #32]	; (8006a18 <__libc_init_array+0x44>)
 80069f6:	4b09      	ldr	r3, [pc, #36]	; (8006a1c <__libc_init_array+0x48>)
 80069f8:	1ae4      	subs	r4, r4, r3
 80069fa:	10a4      	asrs	r4, r4, #2
 80069fc:	2500      	movs	r5, #0
 80069fe:	461e      	mov	r6, r3
 8006a00:	42a5      	cmp	r5, r4
 8006a02:	d004      	beq.n	8006a0e <__libc_init_array+0x3a>
 8006a04:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8006a08:	4798      	blx	r3
 8006a0a:	3501      	adds	r5, #1
 8006a0c:	e7f8      	b.n	8006a00 <__libc_init_array+0x2c>
 8006a0e:	bd70      	pop	{r4, r5, r6, pc}
 8006a10:	08007840 	.word	0x08007840
 8006a14:	08007840 	.word	0x08007840
 8006a18:	08007844 	.word	0x08007844
 8006a1c:	08007840 	.word	0x08007840

08006a20 <malloc>:
 8006a20:	4b02      	ldr	r3, [pc, #8]	; (8006a2c <malloc+0xc>)
 8006a22:	4601      	mov	r1, r0
 8006a24:	6818      	ldr	r0, [r3, #0]
 8006a26:	f000 b80b 	b.w	8006a40 <_malloc_r>
 8006a2a:	bf00      	nop
 8006a2c:	20000604 	.word	0x20000604

08006a30 <free>:
 8006a30:	4b02      	ldr	r3, [pc, #8]	; (8006a3c <free+0xc>)
 8006a32:	4601      	mov	r1, r0
 8006a34:	6818      	ldr	r0, [r3, #0]
 8006a36:	f000 baa5 	b.w	8006f84 <_free_r>
 8006a3a:	bf00      	nop
 8006a3c:	20000604 	.word	0x20000604

08006a40 <_malloc_r>:
 8006a40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006a44:	f101 040b 	add.w	r4, r1, #11
 8006a48:	2c16      	cmp	r4, #22
 8006a4a:	b085      	sub	sp, #20
 8006a4c:	4681      	mov	r9, r0
 8006a4e:	d903      	bls.n	8006a58 <_malloc_r+0x18>
 8006a50:	f034 0407 	bics.w	r4, r4, #7
 8006a54:	d501      	bpl.n	8006a5a <_malloc_r+0x1a>
 8006a56:	e002      	b.n	8006a5e <_malloc_r+0x1e>
 8006a58:	2410      	movs	r4, #16
 8006a5a:	428c      	cmp	r4, r1
 8006a5c:	d203      	bcs.n	8006a66 <_malloc_r+0x26>
 8006a5e:	230c      	movs	r3, #12
 8006a60:	f8c9 3000 	str.w	r3, [r9]
 8006a64:	e1ea      	b.n	8006e3c <_malloc_r+0x3fc>
 8006a66:	4648      	mov	r0, r9
 8006a68:	f000 fa0a 	bl	8006e80 <__malloc_lock>
 8006a6c:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 8006a70:	4d9e      	ldr	r5, [pc, #632]	; (8006cec <_malloc_r+0x2ac>)
 8006a72:	d217      	bcs.n	8006aa4 <_malloc_r+0x64>
 8006a74:	f104 0208 	add.w	r2, r4, #8
 8006a78:	442a      	add	r2, r5
 8006a7a:	f1a2 0108 	sub.w	r1, r2, #8
 8006a7e:	6856      	ldr	r6, [r2, #4]
 8006a80:	428e      	cmp	r6, r1
 8006a82:	ea4f 03d4 	mov.w	r3, r4, lsr #3
 8006a86:	d102      	bne.n	8006a8e <_malloc_r+0x4e>
 8006a88:	68d6      	ldr	r6, [r2, #12]
 8006a8a:	42b2      	cmp	r2, r6
 8006a8c:	d008      	beq.n	8006aa0 <_malloc_r+0x60>
 8006a8e:	6873      	ldr	r3, [r6, #4]
 8006a90:	68f2      	ldr	r2, [r6, #12]
 8006a92:	68b1      	ldr	r1, [r6, #8]
 8006a94:	f023 0303 	bic.w	r3, r3, #3
 8006a98:	60ca      	str	r2, [r1, #12]
 8006a9a:	4433      	add	r3, r6
 8006a9c:	6091      	str	r1, [r2, #8]
 8006a9e:	e02f      	b.n	8006b00 <_malloc_r+0xc0>
 8006aa0:	3302      	adds	r3, #2
 8006aa2:	e03d      	b.n	8006b20 <_malloc_r+0xe0>
 8006aa4:	0a63      	lsrs	r3, r4, #9
 8006aa6:	d01a      	beq.n	8006ade <_malloc_r+0x9e>
 8006aa8:	2b04      	cmp	r3, #4
 8006aaa:	d802      	bhi.n	8006ab2 <_malloc_r+0x72>
 8006aac:	09a3      	lsrs	r3, r4, #6
 8006aae:	3338      	adds	r3, #56	; 0x38
 8006ab0:	e018      	b.n	8006ae4 <_malloc_r+0xa4>
 8006ab2:	2b14      	cmp	r3, #20
 8006ab4:	d801      	bhi.n	8006aba <_malloc_r+0x7a>
 8006ab6:	335b      	adds	r3, #91	; 0x5b
 8006ab8:	e014      	b.n	8006ae4 <_malloc_r+0xa4>
 8006aba:	2b54      	cmp	r3, #84	; 0x54
 8006abc:	d802      	bhi.n	8006ac4 <_malloc_r+0x84>
 8006abe:	0b23      	lsrs	r3, r4, #12
 8006ac0:	336e      	adds	r3, #110	; 0x6e
 8006ac2:	e00f      	b.n	8006ae4 <_malloc_r+0xa4>
 8006ac4:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8006ac8:	d802      	bhi.n	8006ad0 <_malloc_r+0x90>
 8006aca:	0be3      	lsrs	r3, r4, #15
 8006acc:	3377      	adds	r3, #119	; 0x77
 8006ace:	e009      	b.n	8006ae4 <_malloc_r+0xa4>
 8006ad0:	f240 5254 	movw	r2, #1364	; 0x554
 8006ad4:	4293      	cmp	r3, r2
 8006ad6:	d804      	bhi.n	8006ae2 <_malloc_r+0xa2>
 8006ad8:	0ca3      	lsrs	r3, r4, #18
 8006ada:	337c      	adds	r3, #124	; 0x7c
 8006adc:	e002      	b.n	8006ae4 <_malloc_r+0xa4>
 8006ade:	233f      	movs	r3, #63	; 0x3f
 8006ae0:	e000      	b.n	8006ae4 <_malloc_r+0xa4>
 8006ae2:	237e      	movs	r3, #126	; 0x7e
 8006ae4:	1c5a      	adds	r2, r3, #1
 8006ae6:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
 8006aea:	f1a2 0008 	sub.w	r0, r2, #8
 8006aee:	6856      	ldr	r6, [r2, #4]
 8006af0:	e00c      	b.n	8006b0c <_malloc_r+0xcc>
 8006af2:	2900      	cmp	r1, #0
 8006af4:	68f1      	ldr	r1, [r6, #12]
 8006af6:	db08      	blt.n	8006b0a <_malloc_r+0xca>
 8006af8:	68b3      	ldr	r3, [r6, #8]
 8006afa:	60d9      	str	r1, [r3, #12]
 8006afc:	608b      	str	r3, [r1, #8]
 8006afe:	18b3      	adds	r3, r6, r2
 8006b00:	685a      	ldr	r2, [r3, #4]
 8006b02:	f042 0201 	orr.w	r2, r2, #1
 8006b06:	605a      	str	r2, [r3, #4]
 8006b08:	e1a3      	b.n	8006e52 <_malloc_r+0x412>
 8006b0a:	460e      	mov	r6, r1
 8006b0c:	4286      	cmp	r6, r0
 8006b0e:	d006      	beq.n	8006b1e <_malloc_r+0xde>
 8006b10:	6872      	ldr	r2, [r6, #4]
 8006b12:	f022 0203 	bic.w	r2, r2, #3
 8006b16:	1b11      	subs	r1, r2, r4
 8006b18:	290f      	cmp	r1, #15
 8006b1a:	ddea      	ble.n	8006af2 <_malloc_r+0xb2>
 8006b1c:	3b01      	subs	r3, #1
 8006b1e:	3301      	adds	r3, #1
 8006b20:	4a72      	ldr	r2, [pc, #456]	; (8006cec <_malloc_r+0x2ac>)
 8006b22:	692e      	ldr	r6, [r5, #16]
 8006b24:	f102 0708 	add.w	r7, r2, #8
 8006b28:	42be      	cmp	r6, r7
 8006b2a:	4639      	mov	r1, r7
 8006b2c:	d079      	beq.n	8006c22 <_malloc_r+0x1e2>
 8006b2e:	6870      	ldr	r0, [r6, #4]
 8006b30:	f020 0003 	bic.w	r0, r0, #3
 8006b34:	ebc4 0e00 	rsb	lr, r4, r0
 8006b38:	f1be 0f0f 	cmp.w	lr, #15
 8006b3c:	dd0d      	ble.n	8006b5a <_malloc_r+0x11a>
 8006b3e:	1933      	adds	r3, r6, r4
 8006b40:	f044 0401 	orr.w	r4, r4, #1
 8006b44:	6074      	str	r4, [r6, #4]
 8006b46:	6153      	str	r3, [r2, #20]
 8006b48:	6113      	str	r3, [r2, #16]
 8006b4a:	f04e 0201 	orr.w	r2, lr, #1
 8006b4e:	60df      	str	r7, [r3, #12]
 8006b50:	609f      	str	r7, [r3, #8]
 8006b52:	605a      	str	r2, [r3, #4]
 8006b54:	f843 e00e 	str.w	lr, [r3, lr]
 8006b58:	e17b      	b.n	8006e52 <_malloc_r+0x412>
 8006b5a:	f1be 0f00 	cmp.w	lr, #0
 8006b5e:	6157      	str	r7, [r2, #20]
 8006b60:	6117      	str	r7, [r2, #16]
 8006b62:	db05      	blt.n	8006b70 <_malloc_r+0x130>
 8006b64:	4430      	add	r0, r6
 8006b66:	6843      	ldr	r3, [r0, #4]
 8006b68:	f043 0301 	orr.w	r3, r3, #1
 8006b6c:	6043      	str	r3, [r0, #4]
 8006b6e:	e170      	b.n	8006e52 <_malloc_r+0x412>
 8006b70:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8006b74:	d215      	bcs.n	8006ba2 <_malloc_r+0x162>
 8006b76:	08c0      	lsrs	r0, r0, #3
 8006b78:	ea4f 0ea0 	mov.w	lr, r0, asr #2
 8006b7c:	2701      	movs	r7, #1
 8006b7e:	fa07 fe0e 	lsl.w	lr, r7, lr
 8006b82:	6857      	ldr	r7, [r2, #4]
 8006b84:	3001      	adds	r0, #1
 8006b86:	ea4e 0707 	orr.w	r7, lr, r7
 8006b8a:	6057      	str	r7, [r2, #4]
 8006b8c:	eb02 07c0 	add.w	r7, r2, r0, lsl #3
 8006b90:	f852 e030 	ldr.w	lr, [r2, r0, lsl #3]
 8006b94:	f8c6 e008 	str.w	lr, [r6, #8]
 8006b98:	3f08      	subs	r7, #8
 8006b9a:	60f7      	str	r7, [r6, #12]
 8006b9c:	f842 6030 	str.w	r6, [r2, r0, lsl #3]
 8006ba0:	e03d      	b.n	8006c1e <_malloc_r+0x1de>
 8006ba2:	0a42      	lsrs	r2, r0, #9
 8006ba4:	2a04      	cmp	r2, #4
 8006ba6:	d802      	bhi.n	8006bae <_malloc_r+0x16e>
 8006ba8:	0982      	lsrs	r2, r0, #6
 8006baa:	3238      	adds	r2, #56	; 0x38
 8006bac:	e015      	b.n	8006bda <_malloc_r+0x19a>
 8006bae:	2a14      	cmp	r2, #20
 8006bb0:	d801      	bhi.n	8006bb6 <_malloc_r+0x176>
 8006bb2:	325b      	adds	r2, #91	; 0x5b
 8006bb4:	e011      	b.n	8006bda <_malloc_r+0x19a>
 8006bb6:	2a54      	cmp	r2, #84	; 0x54
 8006bb8:	d802      	bhi.n	8006bc0 <_malloc_r+0x180>
 8006bba:	0b02      	lsrs	r2, r0, #12
 8006bbc:	326e      	adds	r2, #110	; 0x6e
 8006bbe:	e00c      	b.n	8006bda <_malloc_r+0x19a>
 8006bc0:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8006bc4:	d802      	bhi.n	8006bcc <_malloc_r+0x18c>
 8006bc6:	0bc2      	lsrs	r2, r0, #15
 8006bc8:	3277      	adds	r2, #119	; 0x77
 8006bca:	e006      	b.n	8006bda <_malloc_r+0x19a>
 8006bcc:	f240 5754 	movw	r7, #1364	; 0x554
 8006bd0:	42ba      	cmp	r2, r7
 8006bd2:	bf9a      	itte	ls
 8006bd4:	0c82      	lsrls	r2, r0, #18
 8006bd6:	327c      	addls	r2, #124	; 0x7c
 8006bd8:	227e      	movhi	r2, #126	; 0x7e
 8006bda:	1c57      	adds	r7, r2, #1
 8006bdc:	eb05 0ec2 	add.w	lr, r5, r2, lsl #3
 8006be0:	f855 7037 	ldr.w	r7, [r5, r7, lsl #3]
 8006be4:	f8df c104 	ldr.w	ip, [pc, #260]	; 8006cec <_malloc_r+0x2ac>
 8006be8:	45be      	cmp	lr, r7
 8006bea:	d10d      	bne.n	8006c08 <_malloc_r+0x1c8>
 8006bec:	2001      	movs	r0, #1
 8006bee:	1092      	asrs	r2, r2, #2
 8006bf0:	fa00 f202 	lsl.w	r2, r0, r2
 8006bf4:	f8dc 0004 	ldr.w	r0, [ip, #4]
 8006bf8:	4310      	orrs	r0, r2
 8006bfa:	f8cc 0004 	str.w	r0, [ip, #4]
 8006bfe:	4672      	mov	r2, lr
 8006c00:	e009      	b.n	8006c16 <_malloc_r+0x1d6>
 8006c02:	68bf      	ldr	r7, [r7, #8]
 8006c04:	45be      	cmp	lr, r7
 8006c06:	d004      	beq.n	8006c12 <_malloc_r+0x1d2>
 8006c08:	687a      	ldr	r2, [r7, #4]
 8006c0a:	f022 0203 	bic.w	r2, r2, #3
 8006c0e:	4290      	cmp	r0, r2
 8006c10:	d3f7      	bcc.n	8006c02 <_malloc_r+0x1c2>
 8006c12:	68fa      	ldr	r2, [r7, #12]
 8006c14:	46be      	mov	lr, r7
 8006c16:	60f2      	str	r2, [r6, #12]
 8006c18:	f8c6 e008 	str.w	lr, [r6, #8]
 8006c1c:	6096      	str	r6, [r2, #8]
 8006c1e:	f8ce 600c 	str.w	r6, [lr, #12]
 8006c22:	2001      	movs	r0, #1
 8006c24:	109a      	asrs	r2, r3, #2
 8006c26:	fa00 f202 	lsl.w	r2, r0, r2
 8006c2a:	6868      	ldr	r0, [r5, #4]
 8006c2c:	4282      	cmp	r2, r0
 8006c2e:	d85f      	bhi.n	8006cf0 <_malloc_r+0x2b0>
 8006c30:	4202      	tst	r2, r0
 8006c32:	d106      	bne.n	8006c42 <_malloc_r+0x202>
 8006c34:	f023 0303 	bic.w	r3, r3, #3
 8006c38:	0052      	lsls	r2, r2, #1
 8006c3a:	4202      	tst	r2, r0
 8006c3c:	f103 0304 	add.w	r3, r3, #4
 8006c40:	d0fa      	beq.n	8006c38 <_malloc_r+0x1f8>
 8006c42:	eb05 08c3 	add.w	r8, r5, r3, lsl #3
 8006c46:	46c2      	mov	sl, r8
 8006c48:	469c      	mov	ip, r3
 8006c4a:	f8da 600c 	ldr.w	r6, [sl, #12]
 8006c4e:	4556      	cmp	r6, sl
 8006c50:	d02c      	beq.n	8006cac <_malloc_r+0x26c>
 8006c52:	6870      	ldr	r0, [r6, #4]
 8006c54:	68f7      	ldr	r7, [r6, #12]
 8006c56:	f020 0003 	bic.w	r0, r0, #3
 8006c5a:	ebc4 0e00 	rsb	lr, r4, r0
 8006c5e:	f1be 0f0f 	cmp.w	lr, #15
 8006c62:	dd11      	ble.n	8006c88 <_malloc_r+0x248>
 8006c64:	1933      	adds	r3, r6, r4
 8006c66:	f044 0401 	orr.w	r4, r4, #1
 8006c6a:	6074      	str	r4, [r6, #4]
 8006c6c:	f856 2f08 	ldr.w	r2, [r6, #8]!
 8006c70:	60d7      	str	r7, [r2, #12]
 8006c72:	60ba      	str	r2, [r7, #8]
 8006c74:	f04e 0201 	orr.w	r2, lr, #1
 8006c78:	616b      	str	r3, [r5, #20]
 8006c7a:	612b      	str	r3, [r5, #16]
 8006c7c:	60d9      	str	r1, [r3, #12]
 8006c7e:	6099      	str	r1, [r3, #8]
 8006c80:	605a      	str	r2, [r3, #4]
 8006c82:	f843 e00e 	str.w	lr, [r3, lr]
 8006c86:	e00b      	b.n	8006ca0 <_malloc_r+0x260>
 8006c88:	f1be 0f00 	cmp.w	lr, #0
 8006c8c:	db0c      	blt.n	8006ca8 <_malloc_r+0x268>
 8006c8e:	1833      	adds	r3, r6, r0
 8006c90:	685a      	ldr	r2, [r3, #4]
 8006c92:	f042 0201 	orr.w	r2, r2, #1
 8006c96:	605a      	str	r2, [r3, #4]
 8006c98:	f856 3f08 	ldr.w	r3, [r6, #8]!
 8006c9c:	60df      	str	r7, [r3, #12]
 8006c9e:	60bb      	str	r3, [r7, #8]
 8006ca0:	4648      	mov	r0, r9
 8006ca2:	f000 f8ee 	bl	8006e82 <__malloc_unlock>
 8006ca6:	e0d8      	b.n	8006e5a <_malloc_r+0x41a>
 8006ca8:	463e      	mov	r6, r7
 8006caa:	e7d0      	b.n	8006c4e <_malloc_r+0x20e>
 8006cac:	f10c 0c01 	add.w	ip, ip, #1
 8006cb0:	f01c 0f03 	tst.w	ip, #3
 8006cb4:	f10a 0a08 	add.w	sl, sl, #8
 8006cb8:	d1c7      	bne.n	8006c4a <_malloc_r+0x20a>
 8006cba:	0798      	lsls	r0, r3, #30
 8006cbc:	d104      	bne.n	8006cc8 <_malloc_r+0x288>
 8006cbe:	686b      	ldr	r3, [r5, #4]
 8006cc0:	ea23 0302 	bic.w	r3, r3, r2
 8006cc4:	606b      	str	r3, [r5, #4]
 8006cc6:	e005      	b.n	8006cd4 <_malloc_r+0x294>
 8006cc8:	f858 0908 	ldr.w	r0, [r8], #-8
 8006ccc:	4580      	cmp	r8, r0
 8006cce:	f103 33ff 	add.w	r3, r3, #4294967295
 8006cd2:	d0f2      	beq.n	8006cba <_malloc_r+0x27a>
 8006cd4:	6868      	ldr	r0, [r5, #4]
 8006cd6:	0052      	lsls	r2, r2, #1
 8006cd8:	4282      	cmp	r2, r0
 8006cda:	d809      	bhi.n	8006cf0 <_malloc_r+0x2b0>
 8006cdc:	b142      	cbz	r2, 8006cf0 <_malloc_r+0x2b0>
 8006cde:	4663      	mov	r3, ip
 8006ce0:	4202      	tst	r2, r0
 8006ce2:	d1ae      	bne.n	8006c42 <_malloc_r+0x202>
 8006ce4:	3304      	adds	r3, #4
 8006ce6:	0052      	lsls	r2, r2, #1
 8006ce8:	e7fa      	b.n	8006ce0 <_malloc_r+0x2a0>
 8006cea:	bf00      	nop
 8006cec:	20000104 	.word	0x20000104
 8006cf0:	f8d5 b008 	ldr.w	fp, [r5, #8]
 8006cf4:	f8db 6004 	ldr.w	r6, [fp, #4]
 8006cf8:	f026 0603 	bic.w	r6, r6, #3
 8006cfc:	42b4      	cmp	r4, r6
 8006cfe:	d803      	bhi.n	8006d08 <_malloc_r+0x2c8>
 8006d00:	1b33      	subs	r3, r6, r4
 8006d02:	2b0f      	cmp	r3, #15
 8006d04:	f300 809c 	bgt.w	8006e40 <_malloc_r+0x400>
 8006d08:	4a56      	ldr	r2, [pc, #344]	; (8006e64 <_malloc_r+0x424>)
 8006d0a:	4957      	ldr	r1, [pc, #348]	; (8006e68 <_malloc_r+0x428>)
 8006d0c:	6812      	ldr	r2, [r2, #0]
 8006d0e:	6808      	ldr	r0, [r1, #0]
 8006d10:	9101      	str	r1, [sp, #4]
 8006d12:	f102 0810 	add.w	r8, r2, #16
 8006d16:	4a55      	ldr	r2, [pc, #340]	; (8006e6c <_malloc_r+0x42c>)
 8006d18:	9203      	str	r2, [sp, #12]
 8006d1a:	3001      	adds	r0, #1
 8006d1c:	bf18      	it	ne
 8006d1e:	f102 31ff 	addne.w	r1, r2, #4294967295
 8006d22:	44a0      	add	r8, r4
 8006d24:	bf1e      	ittt	ne
 8006d26:	4488      	addne	r8, r1
 8006d28:	4251      	negne	r1, r2
 8006d2a:	ea01 0808 	andne.w	r8, r1, r8
 8006d2e:	eb0b 0306 	add.w	r3, fp, r6
 8006d32:	4641      	mov	r1, r8
 8006d34:	4648      	mov	r0, r9
 8006d36:	9302      	str	r3, [sp, #8]
 8006d38:	f000 f8a4 	bl	8006e84 <_sbrk_r>
 8006d3c:	1c42      	adds	r2, r0, #1
 8006d3e:	4607      	mov	r7, r0
 8006d40:	d06f      	beq.n	8006e22 <_malloc_r+0x3e2>
 8006d42:	9b02      	ldr	r3, [sp, #8]
 8006d44:	9a03      	ldr	r2, [sp, #12]
 8006d46:	4283      	cmp	r3, r0
 8006d48:	d901      	bls.n	8006d4e <_malloc_r+0x30e>
 8006d4a:	45ab      	cmp	fp, r5
 8006d4c:	d169      	bne.n	8006e22 <_malloc_r+0x3e2>
 8006d4e:	f8df a128 	ldr.w	sl, [pc, #296]	; 8006e78 <_malloc_r+0x438>
 8006d52:	f8df c128 	ldr.w	ip, [pc, #296]	; 8006e7c <_malloc_r+0x43c>
 8006d56:	f8da 0000 	ldr.w	r0, [sl]
 8006d5a:	42bb      	cmp	r3, r7
 8006d5c:	4440      	add	r0, r8
 8006d5e:	f8ca 0000 	str.w	r0, [sl]
 8006d62:	d108      	bne.n	8006d76 <_malloc_r+0x336>
 8006d64:	ea13 0f0c 	tst.w	r3, ip
 8006d68:	d105      	bne.n	8006d76 <_malloc_r+0x336>
 8006d6a:	68ab      	ldr	r3, [r5, #8]
 8006d6c:	4446      	add	r6, r8
 8006d6e:	f046 0601 	orr.w	r6, r6, #1
 8006d72:	605e      	str	r6, [r3, #4]
 8006d74:	e049      	b.n	8006e0a <_malloc_r+0x3ca>
 8006d76:	9901      	ldr	r1, [sp, #4]
 8006d78:	f8d1 e000 	ldr.w	lr, [r1]
 8006d7c:	f1be 3fff 	cmp.w	lr, #4294967295
 8006d80:	bf15      	itete	ne
 8006d82:	1afb      	subne	r3, r7, r3
 8006d84:	4b38      	ldreq	r3, [pc, #224]	; (8006e68 <_malloc_r+0x428>)
 8006d86:	181b      	addne	r3, r3, r0
 8006d88:	601f      	streq	r7, [r3, #0]
 8006d8a:	bf18      	it	ne
 8006d8c:	f8ca 3000 	strne.w	r3, [sl]
 8006d90:	f017 0307 	ands.w	r3, r7, #7
 8006d94:	bf1c      	itt	ne
 8006d96:	f1c3 0308 	rsbne	r3, r3, #8
 8006d9a:	18ff      	addne	r7, r7, r3
 8006d9c:	44b8      	add	r8, r7
 8006d9e:	441a      	add	r2, r3
 8006da0:	ea08 080c 	and.w	r8, r8, ip
 8006da4:	ebc8 0802 	rsb	r8, r8, r2
 8006da8:	4641      	mov	r1, r8
 8006daa:	4648      	mov	r0, r9
 8006dac:	f000 f86a 	bl	8006e84 <_sbrk_r>
 8006db0:	1c43      	adds	r3, r0, #1
 8006db2:	bf04      	itt	eq
 8006db4:	4638      	moveq	r0, r7
 8006db6:	f04f 0800 	moveq.w	r8, #0
 8006dba:	f8da 3000 	ldr.w	r3, [sl]
 8006dbe:	60af      	str	r7, [r5, #8]
 8006dc0:	1bc2      	subs	r2, r0, r7
 8006dc2:	4442      	add	r2, r8
 8006dc4:	4443      	add	r3, r8
 8006dc6:	f042 0201 	orr.w	r2, r2, #1
 8006dca:	45ab      	cmp	fp, r5
 8006dcc:	f8ca 3000 	str.w	r3, [sl]
 8006dd0:	607a      	str	r2, [r7, #4]
 8006dd2:	d01a      	beq.n	8006e0a <_malloc_r+0x3ca>
 8006dd4:	2e0f      	cmp	r6, #15
 8006dd6:	d802      	bhi.n	8006dde <_malloc_r+0x39e>
 8006dd8:	2301      	movs	r3, #1
 8006dda:	607b      	str	r3, [r7, #4]
 8006ddc:	e021      	b.n	8006e22 <_malloc_r+0x3e2>
 8006dde:	f8db 3004 	ldr.w	r3, [fp, #4]
 8006de2:	3e0c      	subs	r6, #12
 8006de4:	f026 0607 	bic.w	r6, r6, #7
 8006de8:	f003 0301 	and.w	r3, r3, #1
 8006dec:	4333      	orrs	r3, r6
 8006dee:	f8cb 3004 	str.w	r3, [fp, #4]
 8006df2:	eb0b 0306 	add.w	r3, fp, r6
 8006df6:	2205      	movs	r2, #5
 8006df8:	2e0f      	cmp	r6, #15
 8006dfa:	605a      	str	r2, [r3, #4]
 8006dfc:	609a      	str	r2, [r3, #8]
 8006dfe:	d904      	bls.n	8006e0a <_malloc_r+0x3ca>
 8006e00:	f10b 0108 	add.w	r1, fp, #8
 8006e04:	4648      	mov	r0, r9
 8006e06:	f000 f8bd 	bl	8006f84 <_free_r>
 8006e0a:	4a19      	ldr	r2, [pc, #100]	; (8006e70 <_malloc_r+0x430>)
 8006e0c:	f8da 3000 	ldr.w	r3, [sl]
 8006e10:	6811      	ldr	r1, [r2, #0]
 8006e12:	428b      	cmp	r3, r1
 8006e14:	bf88      	it	hi
 8006e16:	6013      	strhi	r3, [r2, #0]
 8006e18:	4a16      	ldr	r2, [pc, #88]	; (8006e74 <_malloc_r+0x434>)
 8006e1a:	6811      	ldr	r1, [r2, #0]
 8006e1c:	428b      	cmp	r3, r1
 8006e1e:	bf88      	it	hi
 8006e20:	6013      	strhi	r3, [r2, #0]
 8006e22:	68ab      	ldr	r3, [r5, #8]
 8006e24:	685a      	ldr	r2, [r3, #4]
 8006e26:	f022 0203 	bic.w	r2, r2, #3
 8006e2a:	4294      	cmp	r4, r2
 8006e2c:	eba2 0304 	sub.w	r3, r2, r4
 8006e30:	d801      	bhi.n	8006e36 <_malloc_r+0x3f6>
 8006e32:	2b0f      	cmp	r3, #15
 8006e34:	dc04      	bgt.n	8006e40 <_malloc_r+0x400>
 8006e36:	4648      	mov	r0, r9
 8006e38:	f000 f823 	bl	8006e82 <__malloc_unlock>
 8006e3c:	2600      	movs	r6, #0
 8006e3e:	e00c      	b.n	8006e5a <_malloc_r+0x41a>
 8006e40:	68ae      	ldr	r6, [r5, #8]
 8006e42:	f044 0201 	orr.w	r2, r4, #1
 8006e46:	4434      	add	r4, r6
 8006e48:	f043 0301 	orr.w	r3, r3, #1
 8006e4c:	6072      	str	r2, [r6, #4]
 8006e4e:	60ac      	str	r4, [r5, #8]
 8006e50:	6063      	str	r3, [r4, #4]
 8006e52:	4648      	mov	r0, r9
 8006e54:	f000 f815 	bl	8006e82 <__malloc_unlock>
 8006e58:	3608      	adds	r6, #8
 8006e5a:	4630      	mov	r0, r6
 8006e5c:	b005      	add	sp, #20
 8006e5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006e62:	bf00      	nop
 8006e64:	20000660 	.word	0x20000660
 8006e68:	20000510 	.word	0x20000510
 8006e6c:	00000080 	.word	0x00000080
 8006e70:	2000065c 	.word	0x2000065c
 8006e74:	20000658 	.word	0x20000658
 8006e78:	20000664 	.word	0x20000664
 8006e7c:	0000007f 	.word	0x0000007f

08006e80 <__malloc_lock>:
 8006e80:	4770      	bx	lr

08006e82 <__malloc_unlock>:
 8006e82:	4770      	bx	lr

08006e84 <_sbrk_r>:
 8006e84:	b538      	push	{r3, r4, r5, lr}
 8006e86:	4c06      	ldr	r4, [pc, #24]	; (8006ea0 <_sbrk_r+0x1c>)
 8006e88:	2300      	movs	r3, #0
 8006e8a:	4605      	mov	r5, r0
 8006e8c:	4608      	mov	r0, r1
 8006e8e:	6023      	str	r3, [r4, #0]
 8006e90:	f000 f936 	bl	8007100 <_sbrk>
 8006e94:	1c43      	adds	r3, r0, #1
 8006e96:	d102      	bne.n	8006e9e <_sbrk_r+0x1a>
 8006e98:	6823      	ldr	r3, [r4, #0]
 8006e9a:	b103      	cbz	r3, 8006e9e <_sbrk_r+0x1a>
 8006e9c:	602b      	str	r3, [r5, #0]
 8006e9e:	bd38      	pop	{r3, r4, r5, pc}
 8006ea0:	20002110 	.word	0x20002110

08006ea4 <strstr>:
 8006ea4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006ea6:	7803      	ldrb	r3, [r0, #0]
 8006ea8:	b963      	cbnz	r3, 8006ec4 <strstr+0x20>
 8006eaa:	780b      	ldrb	r3, [r1, #0]
 8006eac:	2b00      	cmp	r3, #0
 8006eae:	bf18      	it	ne
 8006eb0:	2000      	movne	r0, #0
 8006eb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006eb4:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 8006eb8:	b162      	cbz	r2, 8006ed4 <strstr+0x30>
 8006eba:	f814 7f01 	ldrb.w	r7, [r4, #1]!
 8006ebe:	4297      	cmp	r7, r2
 8006ec0:	4630      	mov	r0, r6
 8006ec2:	d0f7      	beq.n	8006eb4 <strstr+0x10>
 8006ec4:	4603      	mov	r3, r0
 8006ec6:	1c46      	adds	r6, r0, #1
 8006ec8:	7800      	ldrb	r0, [r0, #0]
 8006eca:	b110      	cbz	r0, 8006ed2 <strstr+0x2e>
 8006ecc:	1e4d      	subs	r5, r1, #1
 8006ece:	1e5c      	subs	r4, r3, #1
 8006ed0:	e7f0      	b.n	8006eb4 <strstr+0x10>
 8006ed2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006ed4:	4618      	mov	r0, r3
 8006ed6:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006ed8 <_malloc_trim_r>:
 8006ed8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006edc:	4f25      	ldr	r7, [pc, #148]	; (8006f74 <_malloc_trim_r+0x9c>)
 8006ede:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 8006f80 <_malloc_trim_r+0xa8>
 8006ee2:	4689      	mov	r9, r1
 8006ee4:	4606      	mov	r6, r0
 8006ee6:	f7ff ffcb 	bl	8006e80 <__malloc_lock>
 8006eea:	68bb      	ldr	r3, [r7, #8]
 8006eec:	685d      	ldr	r5, [r3, #4]
 8006eee:	f1a8 0411 	sub.w	r4, r8, #17
 8006ef2:	f025 0503 	bic.w	r5, r5, #3
 8006ef6:	442c      	add	r4, r5
 8006ef8:	ebc9 0404 	rsb	r4, r9, r4
 8006efc:	fbb4 f4f8 	udiv	r4, r4, r8
 8006f00:	3c01      	subs	r4, #1
 8006f02:	fb08 f404 	mul.w	r4, r8, r4
 8006f06:	4544      	cmp	r4, r8
 8006f08:	da05      	bge.n	8006f16 <_malloc_trim_r+0x3e>
 8006f0a:	4630      	mov	r0, r6
 8006f0c:	f7ff ffb9 	bl	8006e82 <__malloc_unlock>
 8006f10:	2000      	movs	r0, #0
 8006f12:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006f16:	2100      	movs	r1, #0
 8006f18:	4630      	mov	r0, r6
 8006f1a:	f7ff ffb3 	bl	8006e84 <_sbrk_r>
 8006f1e:	68bb      	ldr	r3, [r7, #8]
 8006f20:	442b      	add	r3, r5
 8006f22:	4298      	cmp	r0, r3
 8006f24:	d1f1      	bne.n	8006f0a <_malloc_trim_r+0x32>
 8006f26:	4261      	negs	r1, r4
 8006f28:	4630      	mov	r0, r6
 8006f2a:	f7ff ffab 	bl	8006e84 <_sbrk_r>
 8006f2e:	3001      	adds	r0, #1
 8006f30:	d110      	bne.n	8006f54 <_malloc_trim_r+0x7c>
 8006f32:	2100      	movs	r1, #0
 8006f34:	4630      	mov	r0, r6
 8006f36:	f7ff ffa5 	bl	8006e84 <_sbrk_r>
 8006f3a:	68ba      	ldr	r2, [r7, #8]
 8006f3c:	1a83      	subs	r3, r0, r2
 8006f3e:	2b0f      	cmp	r3, #15
 8006f40:	dde3      	ble.n	8006f0a <_malloc_trim_r+0x32>
 8006f42:	490d      	ldr	r1, [pc, #52]	; (8006f78 <_malloc_trim_r+0xa0>)
 8006f44:	6809      	ldr	r1, [r1, #0]
 8006f46:	1a40      	subs	r0, r0, r1
 8006f48:	490c      	ldr	r1, [pc, #48]	; (8006f7c <_malloc_trim_r+0xa4>)
 8006f4a:	f043 0301 	orr.w	r3, r3, #1
 8006f4e:	6008      	str	r0, [r1, #0]
 8006f50:	6053      	str	r3, [r2, #4]
 8006f52:	e7da      	b.n	8006f0a <_malloc_trim_r+0x32>
 8006f54:	68bb      	ldr	r3, [r7, #8]
 8006f56:	4a09      	ldr	r2, [pc, #36]	; (8006f7c <_malloc_trim_r+0xa4>)
 8006f58:	1b2d      	subs	r5, r5, r4
 8006f5a:	f045 0501 	orr.w	r5, r5, #1
 8006f5e:	605d      	str	r5, [r3, #4]
 8006f60:	6813      	ldr	r3, [r2, #0]
 8006f62:	4630      	mov	r0, r6
 8006f64:	1b1c      	subs	r4, r3, r4
 8006f66:	6014      	str	r4, [r2, #0]
 8006f68:	f7ff ff8b 	bl	8006e82 <__malloc_unlock>
 8006f6c:	2001      	movs	r0, #1
 8006f6e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006f72:	bf00      	nop
 8006f74:	20000104 	.word	0x20000104
 8006f78:	20000510 	.word	0x20000510
 8006f7c:	20000664 	.word	0x20000664
 8006f80:	00000080 	.word	0x00000080

08006f84 <_free_r>:
 8006f84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006f88:	4604      	mov	r4, r0
 8006f8a:	4688      	mov	r8, r1
 8006f8c:	2900      	cmp	r1, #0
 8006f8e:	f000 80ad 	beq.w	80070ec <_free_r+0x168>
 8006f92:	f7ff ff75 	bl	8006e80 <__malloc_lock>
 8006f96:	f858 2c04 	ldr.w	r2, [r8, #-4]
 8006f9a:	4d55      	ldr	r5, [pc, #340]	; (80070f0 <_free_r+0x16c>)
 8006f9c:	f022 0001 	bic.w	r0, r2, #1
 8006fa0:	f1a8 0308 	sub.w	r3, r8, #8
 8006fa4:	181f      	adds	r7, r3, r0
 8006fa6:	68a9      	ldr	r1, [r5, #8]
 8006fa8:	687e      	ldr	r6, [r7, #4]
 8006faa:	428f      	cmp	r7, r1
 8006fac:	f026 0603 	bic.w	r6, r6, #3
 8006fb0:	f002 0201 	and.w	r2, r2, #1
 8006fb4:	d11b      	bne.n	8006fee <_free_r+0x6a>
 8006fb6:	4430      	add	r0, r6
 8006fb8:	b93a      	cbnz	r2, 8006fca <_free_r+0x46>
 8006fba:	f858 2c08 	ldr.w	r2, [r8, #-8]
 8006fbe:	1a9b      	subs	r3, r3, r2
 8006fc0:	4410      	add	r0, r2
 8006fc2:	6899      	ldr	r1, [r3, #8]
 8006fc4:	68da      	ldr	r2, [r3, #12]
 8006fc6:	60ca      	str	r2, [r1, #12]
 8006fc8:	6091      	str	r1, [r2, #8]
 8006fca:	f040 0201 	orr.w	r2, r0, #1
 8006fce:	605a      	str	r2, [r3, #4]
 8006fd0:	60ab      	str	r3, [r5, #8]
 8006fd2:	4b48      	ldr	r3, [pc, #288]	; (80070f4 <_free_r+0x170>)
 8006fd4:	681b      	ldr	r3, [r3, #0]
 8006fd6:	4298      	cmp	r0, r3
 8006fd8:	d304      	bcc.n	8006fe4 <_free_r+0x60>
 8006fda:	4b47      	ldr	r3, [pc, #284]	; (80070f8 <_free_r+0x174>)
 8006fdc:	4620      	mov	r0, r4
 8006fde:	6819      	ldr	r1, [r3, #0]
 8006fe0:	f7ff ff7a 	bl	8006ed8 <_malloc_trim_r>
 8006fe4:	4620      	mov	r0, r4
 8006fe6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8006fea:	f7ff bf4a 	b.w	8006e82 <__malloc_unlock>
 8006fee:	607e      	str	r6, [r7, #4]
 8006ff0:	b97a      	cbnz	r2, 8007012 <_free_r+0x8e>
 8006ff2:	f858 1c08 	ldr.w	r1, [r8, #-8]
 8006ff6:	1a5b      	subs	r3, r3, r1
 8006ff8:	4408      	add	r0, r1
 8006ffa:	6899      	ldr	r1, [r3, #8]
 8006ffc:	f105 0e08 	add.w	lr, r5, #8
 8007000:	4571      	cmp	r1, lr
 8007002:	d008      	beq.n	8007016 <_free_r+0x92>
 8007004:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 8007008:	f8c1 e00c 	str.w	lr, [r1, #12]
 800700c:	f8ce 1008 	str.w	r1, [lr, #8]
 8007010:	e002      	b.n	8007018 <_free_r+0x94>
 8007012:	2200      	movs	r2, #0
 8007014:	e000      	b.n	8007018 <_free_r+0x94>
 8007016:	2201      	movs	r2, #1
 8007018:	19b9      	adds	r1, r7, r6
 800701a:	6849      	ldr	r1, [r1, #4]
 800701c:	07c9      	lsls	r1, r1, #31
 800701e:	d40e      	bmi.n	800703e <_free_r+0xba>
 8007020:	4430      	add	r0, r6
 8007022:	68b9      	ldr	r1, [r7, #8]
 8007024:	b942      	cbnz	r2, 8007038 <_free_r+0xb4>
 8007026:	4e35      	ldr	r6, [pc, #212]	; (80070fc <_free_r+0x178>)
 8007028:	42b1      	cmp	r1, r6
 800702a:	d105      	bne.n	8007038 <_free_r+0xb4>
 800702c:	616b      	str	r3, [r5, #20]
 800702e:	612b      	str	r3, [r5, #16]
 8007030:	2201      	movs	r2, #1
 8007032:	60d9      	str	r1, [r3, #12]
 8007034:	6099      	str	r1, [r3, #8]
 8007036:	e002      	b.n	800703e <_free_r+0xba>
 8007038:	68fe      	ldr	r6, [r7, #12]
 800703a:	60ce      	str	r6, [r1, #12]
 800703c:	60b1      	str	r1, [r6, #8]
 800703e:	f040 0101 	orr.w	r1, r0, #1
 8007042:	6059      	str	r1, [r3, #4]
 8007044:	5018      	str	r0, [r3, r0]
 8007046:	2a00      	cmp	r2, #0
 8007048:	d1cc      	bne.n	8006fe4 <_free_r+0x60>
 800704a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800704e:	d212      	bcs.n	8007076 <_free_r+0xf2>
 8007050:	08c0      	lsrs	r0, r0, #3
 8007052:	1081      	asrs	r1, r0, #2
 8007054:	2201      	movs	r2, #1
 8007056:	fa02 f101 	lsl.w	r1, r2, r1
 800705a:	686a      	ldr	r2, [r5, #4]
 800705c:	3001      	adds	r0, #1
 800705e:	430a      	orrs	r2, r1
 8007060:	606a      	str	r2, [r5, #4]
 8007062:	eb05 02c0 	add.w	r2, r5, r0, lsl #3
 8007066:	f855 1030 	ldr.w	r1, [r5, r0, lsl #3]
 800706a:	6099      	str	r1, [r3, #8]
 800706c:	3a08      	subs	r2, #8
 800706e:	60da      	str	r2, [r3, #12]
 8007070:	f845 3030 	str.w	r3, [r5, r0, lsl #3]
 8007074:	e038      	b.n	80070e8 <_free_r+0x164>
 8007076:	0a42      	lsrs	r2, r0, #9
 8007078:	2a04      	cmp	r2, #4
 800707a:	d802      	bhi.n	8007082 <_free_r+0xfe>
 800707c:	0982      	lsrs	r2, r0, #6
 800707e:	3238      	adds	r2, #56	; 0x38
 8007080:	e015      	b.n	80070ae <_free_r+0x12a>
 8007082:	2a14      	cmp	r2, #20
 8007084:	d801      	bhi.n	800708a <_free_r+0x106>
 8007086:	325b      	adds	r2, #91	; 0x5b
 8007088:	e011      	b.n	80070ae <_free_r+0x12a>
 800708a:	2a54      	cmp	r2, #84	; 0x54
 800708c:	d802      	bhi.n	8007094 <_free_r+0x110>
 800708e:	0b02      	lsrs	r2, r0, #12
 8007090:	326e      	adds	r2, #110	; 0x6e
 8007092:	e00c      	b.n	80070ae <_free_r+0x12a>
 8007094:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8007098:	d802      	bhi.n	80070a0 <_free_r+0x11c>
 800709a:	0bc2      	lsrs	r2, r0, #15
 800709c:	3277      	adds	r2, #119	; 0x77
 800709e:	e006      	b.n	80070ae <_free_r+0x12a>
 80070a0:	f240 5154 	movw	r1, #1364	; 0x554
 80070a4:	428a      	cmp	r2, r1
 80070a6:	bf9a      	itte	ls
 80070a8:	0c82      	lsrls	r2, r0, #18
 80070aa:	327c      	addls	r2, #124	; 0x7c
 80070ac:	227e      	movhi	r2, #126	; 0x7e
 80070ae:	1c51      	adds	r1, r2, #1
 80070b0:	eb05 06c2 	add.w	r6, r5, r2, lsl #3
 80070b4:	f855 1031 	ldr.w	r1, [r5, r1, lsl #3]
 80070b8:	4f0d      	ldr	r7, [pc, #52]	; (80070f0 <_free_r+0x16c>)
 80070ba:	428e      	cmp	r6, r1
 80070bc:	d10b      	bne.n	80070d6 <_free_r+0x152>
 80070be:	2101      	movs	r1, #1
 80070c0:	1092      	asrs	r2, r2, #2
 80070c2:	fa01 f202 	lsl.w	r2, r1, r2
 80070c6:	6879      	ldr	r1, [r7, #4]
 80070c8:	4311      	orrs	r1, r2
 80070ca:	6079      	str	r1, [r7, #4]
 80070cc:	4631      	mov	r1, r6
 80070ce:	e008      	b.n	80070e2 <_free_r+0x15e>
 80070d0:	6889      	ldr	r1, [r1, #8]
 80070d2:	428e      	cmp	r6, r1
 80070d4:	d004      	beq.n	80070e0 <_free_r+0x15c>
 80070d6:	684a      	ldr	r2, [r1, #4]
 80070d8:	f022 0203 	bic.w	r2, r2, #3
 80070dc:	4290      	cmp	r0, r2
 80070de:	d3f7      	bcc.n	80070d0 <_free_r+0x14c>
 80070e0:	68ce      	ldr	r6, [r1, #12]
 80070e2:	60de      	str	r6, [r3, #12]
 80070e4:	6099      	str	r1, [r3, #8]
 80070e6:	60b3      	str	r3, [r6, #8]
 80070e8:	60cb      	str	r3, [r1, #12]
 80070ea:	e77b      	b.n	8006fe4 <_free_r+0x60>
 80070ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80070f0:	20000104 	.word	0x20000104
 80070f4:	2000050c 	.word	0x2000050c
 80070f8:	20000660 	.word	0x20000660
 80070fc:	2000010c 	.word	0x2000010c

08007100 <_sbrk>:
 8007100:	4b04      	ldr	r3, [pc, #16]	; (8007114 <_sbrk+0x14>)
 8007102:	6819      	ldr	r1, [r3, #0]
 8007104:	4602      	mov	r2, r0
 8007106:	b909      	cbnz	r1, 800710c <_sbrk+0xc>
 8007108:	4903      	ldr	r1, [pc, #12]	; (8007118 <_sbrk+0x18>)
 800710a:	6019      	str	r1, [r3, #0]
 800710c:	6818      	ldr	r0, [r3, #0]
 800710e:	4402      	add	r2, r0
 8007110:	601a      	str	r2, [r3, #0]
 8007112:	4770      	bx	lr
 8007114:	2000068c 	.word	0x2000068c
 8007118:	20002114 	.word	0x20002114

0800711c <_init>:
 800711c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800711e:	bf00      	nop
 8007120:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8007122:	bc08      	pop	{r3}
 8007124:	469e      	mov	lr, r3
 8007126:	4770      	bx	lr

08007128 <_fini>:
 8007128:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800712a:	bf00      	nop
 800712c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800712e:	bc08      	pop	{r3}
 8007130:	469e      	mov	lr, r3
 8007132:	4770      	bx	lr
